
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000096  00800200  00003b5c  00003bf0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003b5c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007f7  00800296  00800296  00003c86  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003c86  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000718  00000000  00000000  00003cb8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000f4f0  00000000  00000000  000043d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002c3b  00000000  00000000  000138c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000516e  00000000  00000000  000164fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000014f4  00000000  00000000  0001b66c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000366b  00000000  00000000  0001cb60  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00007617  00000000  00000000  000201cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000006e8  00000000  00000000  000277e2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f6 c1       	rjmp	.+1004   	; 0x3ee <__ctors_end>
       2:	00 00       	nop
       4:	25 c2       	rjmp	.+1098   	; 0x450 <__bad_interrupt>
       6:	00 00       	nop
       8:	23 c2       	rjmp	.+1094   	; 0x450 <__bad_interrupt>
       a:	00 00       	nop
       c:	21 c2       	rjmp	.+1090   	; 0x450 <__bad_interrupt>
       e:	00 00       	nop
      10:	1f c2       	rjmp	.+1086   	; 0x450 <__bad_interrupt>
      12:	00 00       	nop
      14:	1d c2       	rjmp	.+1082   	; 0x450 <__bad_interrupt>
      16:	00 00       	nop
      18:	1b c2       	rjmp	.+1078   	; 0x450 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	19 c2       	rjmp	.+1074   	; 0x450 <__bad_interrupt>
      1e:	00 00       	nop
      20:	17 c2       	rjmp	.+1070   	; 0x450 <__bad_interrupt>
      22:	00 00       	nop
      24:	15 c2       	rjmp	.+1066   	; 0x450 <__bad_interrupt>
      26:	00 00       	nop
      28:	13 c2       	rjmp	.+1062   	; 0x450 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	11 c2       	rjmp	.+1058   	; 0x450 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0f c2       	rjmp	.+1054   	; 0x450 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 3c 0c 	jmp	0x1878	; 0x1878 <__vector_13>
      38:	0b c2       	rjmp	.+1046   	; 0x450 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	09 c2       	rjmp	.+1042   	; 0x450 <__bad_interrupt>
      3e:	00 00       	nop
      40:	07 c2       	rjmp	.+1038   	; 0x450 <__bad_interrupt>
      42:	00 00       	nop
      44:	05 c2       	rjmp	.+1034   	; 0x450 <__bad_interrupt>
      46:	00 00       	nop
      48:	03 c2       	rjmp	.+1030   	; 0x450 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	01 c2       	rjmp	.+1026   	; 0x450 <__bad_interrupt>
      4e:	00 00       	nop
      50:	ff c1       	rjmp	.+1022   	; 0x450 <__bad_interrupt>
      52:	00 00       	nop
      54:	fd c1       	rjmp	.+1018   	; 0x450 <__bad_interrupt>
      56:	00 00       	nop
      58:	fb c1       	rjmp	.+1014   	; 0x450 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 68 1b 	jmp	0x36d0	; 0x36d0 <__vector_23>
      60:	f7 c1       	rjmp	.+1006   	; 0x450 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 cd 19 	jmp	0x339a	; 0x339a <__vector_25>
      68:	0c 94 0c 1a 	jmp	0x3418	; 0x3418 <__vector_26>
      6c:	f1 c1       	rjmp	.+994    	; 0x450 <__bad_interrupt>
      6e:	00 00       	nop
      70:	ef c1       	rjmp	.+990    	; 0x450 <__bad_interrupt>
      72:	00 00       	nop
      74:	ed c1       	rjmp	.+986    	; 0x450 <__bad_interrupt>
      76:	00 00       	nop
      78:	eb c1       	rjmp	.+982    	; 0x450 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e9 c1       	rjmp	.+978    	; 0x450 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e7 c1       	rjmp	.+974    	; 0x450 <__bad_interrupt>
      82:	00 00       	nop
      84:	e5 c1       	rjmp	.+970    	; 0x450 <__bad_interrupt>
      86:	00 00       	nop
      88:	e3 c1       	rjmp	.+966    	; 0x450 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e1 c1       	rjmp	.+962    	; 0x450 <__bad_interrupt>
      8e:	00 00       	nop
      90:	df c1       	rjmp	.+958    	; 0x450 <__bad_interrupt>
      92:	00 00       	nop
      94:	dd c1       	rjmp	.+954    	; 0x450 <__bad_interrupt>
      96:	00 00       	nop
      98:	db c1       	rjmp	.+950    	; 0x450 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 c3 13 	jmp	0x2786	; 0x2786 <__vector_39>
      a0:	d7 c1       	rjmp	.+942    	; 0x450 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	d5 c1       	rjmp	.+938    	; 0x450 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	d3 c1       	rjmp	.+934    	; 0x450 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	d1 c1       	rjmp	.+930    	; 0x450 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	cf c1       	rjmp	.+926    	; 0x450 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	cd c1       	rjmp	.+922    	; 0x450 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	cb c1       	rjmp	.+918    	; 0x450 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	c9 c1       	rjmp	.+914    	; 0x450 <__bad_interrupt>
      be:	00 00       	nop
      c0:	c7 c1       	rjmp	.+910    	; 0x450 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	c5 c1       	rjmp	.+906    	; 0x450 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	c3 c1       	rjmp	.+902    	; 0x450 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	c1 c1       	rjmp	.+898    	; 0x450 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	bf c1       	rjmp	.+894    	; 0x450 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	bd c1       	rjmp	.+890    	; 0x450 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	bb c1       	rjmp	.+886    	; 0x450 <__bad_interrupt>
      da:	00 00       	nop
      dc:	b9 c1       	rjmp	.+882    	; 0x450 <__bad_interrupt>
      de:	00 00       	nop
      e0:	b7 c1       	rjmp	.+878    	; 0x450 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	c9 14       	cp	r12, r9
      e6:	cc 14       	cp	r12, r12
      e8:	cc 14       	cp	r12, r12
      ea:	cc 14       	cp	r12, r12
      ec:	cc 14       	cp	r12, r12
      ee:	cc 14       	cp	r12, r12
      f0:	cc 14       	cp	r12, r12
      f2:	cc 14       	cp	r12, r12
      f4:	e3 13       	cpse	r30, r19
      f6:	cc 14       	cp	r12, r12
      f8:	cc 14       	cp	r12, r12
      fa:	cc 14       	cp	r12, r12
      fc:	cc 14       	cp	r12, r12
      fe:	cc 14       	cp	r12, r12
     100:	cc 14       	cp	r12, r12
     102:	cc 14       	cp	r12, r12
     104:	e3 13       	cpse	r30, r19
     106:	cc 14       	cp	r12, r12
     108:	cc 14       	cp	r12, r12
     10a:	cc 14       	cp	r12, r12
     10c:	cc 14       	cp	r12, r12
     10e:	cc 14       	cp	r12, r12
     110:	cc 14       	cp	r12, r12
     112:	cc 14       	cp	r12, r12
     114:	eb 13       	cpse	r30, r27
     116:	cc 14       	cp	r12, r12
     118:	cc 14       	cp	r12, r12
     11a:	cc 14       	cp	r12, r12
     11c:	cc 14       	cp	r12, r12
     11e:	cc 14       	cp	r12, r12
     120:	cc 14       	cp	r12, r12
     122:	cc 14       	cp	r12, r12
     124:	10 14       	cp	r1, r0
     126:	cc 14       	cp	r12, r12
     128:	cc 14       	cp	r12, r12
     12a:	cc 14       	cp	r12, r12
     12c:	cc 14       	cp	r12, r12
     12e:	cc 14       	cp	r12, r12
     130:	cc 14       	cp	r12, r12
     132:	cc 14       	cp	r12, r12
     134:	eb 13       	cpse	r30, r27
     136:	cc 14       	cp	r12, r12
     138:	cc 14       	cp	r12, r12
     13a:	cc 14       	cp	r12, r12
     13c:	cc 14       	cp	r12, r12
     13e:	cc 14       	cp	r12, r12
     140:	cc 14       	cp	r12, r12
     142:	cc 14       	cp	r12, r12
     144:	15 14       	cp	r1, r5
     146:	cc 14       	cp	r12, r12
     148:	cc 14       	cp	r12, r12
     14a:	cc 14       	cp	r12, r12
     14c:	cc 14       	cp	r12, r12
     14e:	cc 14       	cp	r12, r12
     150:	cc 14       	cp	r12, r12
     152:	cc 14       	cp	r12, r12
     154:	1a 14       	cp	r1, r10
     156:	cc 14       	cp	r12, r12
     158:	cc 14       	cp	r12, r12
     15a:	cc 14       	cp	r12, r12
     15c:	cc 14       	cp	r12, r12
     15e:	cc 14       	cp	r12, r12
     160:	cc 14       	cp	r12, r12
     162:	cc 14       	cp	r12, r12
     164:	2b 14       	cp	r2, r11
     166:	cc 14       	cp	r12, r12
     168:	cc 14       	cp	r12, r12
     16a:	cc 14       	cp	r12, r12
     16c:	cc 14       	cp	r12, r12
     16e:	cc 14       	cp	r12, r12
     170:	cc 14       	cp	r12, r12
     172:	cc 14       	cp	r12, r12
     174:	54 14       	cp	r5, r4
     176:	cc 14       	cp	r12, r12
     178:	cc 14       	cp	r12, r12
     17a:	cc 14       	cp	r12, r12
     17c:	cc 14       	cp	r12, r12
     17e:	cc 14       	cp	r12, r12
     180:	cc 14       	cp	r12, r12
     182:	cc 14       	cp	r12, r12
     184:	1f 14       	cp	r1, r15
     186:	cc 14       	cp	r12, r12
     188:	cc 14       	cp	r12, r12
     18a:	cc 14       	cp	r12, r12
     18c:	cc 14       	cp	r12, r12
     18e:	cc 14       	cp	r12, r12
     190:	cc 14       	cp	r12, r12
     192:	cc 14       	cp	r12, r12
     194:	39 14       	cp	r3, r9
     196:	cc 14       	cp	r12, r12
     198:	cc 14       	cp	r12, r12
     19a:	cc 14       	cp	r12, r12
     19c:	cc 14       	cp	r12, r12
     19e:	cc 14       	cp	r12, r12
     1a0:	cc 14       	cp	r12, r12
     1a2:	cc 14       	cp	r12, r12
     1a4:	56 14       	cp	r5, r6
     1a6:	cc 14       	cp	r12, r12
     1a8:	cc 14       	cp	r12, r12
     1aa:	cc 14       	cp	r12, r12
     1ac:	cc 14       	cp	r12, r12
     1ae:	cc 14       	cp	r12, r12
     1b0:	cc 14       	cp	r12, r12
     1b2:	cc 14       	cp	r12, r12
     1b4:	56 14       	cp	r5, r6
     1b6:	cc 14       	cp	r12, r12
     1b8:	cc 14       	cp	r12, r12
     1ba:	cc 14       	cp	r12, r12
     1bc:	cc 14       	cp	r12, r12
     1be:	cc 14       	cp	r12, r12
     1c0:	cc 14       	cp	r12, r12
     1c2:	cc 14       	cp	r12, r12
     1c4:	56 14       	cp	r5, r6
     1c6:	cc 14       	cp	r12, r12
     1c8:	cc 14       	cp	r12, r12
     1ca:	cc 14       	cp	r12, r12
     1cc:	cc 14       	cp	r12, r12
     1ce:	cc 14       	cp	r12, r12
     1d0:	cc 14       	cp	r12, r12
     1d2:	cc 14       	cp	r12, r12
     1d4:	56 14       	cp	r5, r6
     1d6:	cc 14       	cp	r12, r12
     1d8:	cc 14       	cp	r12, r12
     1da:	cc 14       	cp	r12, r12
     1dc:	cc 14       	cp	r12, r12
     1de:	cc 14       	cp	r12, r12
     1e0:	cc 14       	cp	r12, r12
     1e2:	cc 14       	cp	r12, r12
     1e4:	5f 14       	cp	r5, r15
     1e6:	cc 14       	cp	r12, r12
     1e8:	cc 14       	cp	r12, r12
     1ea:	cc 14       	cp	r12, r12
     1ec:	cc 14       	cp	r12, r12
     1ee:	cc 14       	cp	r12, r12
     1f0:	cc 14       	cp	r12, r12
     1f2:	cc 14       	cp	r12, r12
     1f4:	90 14       	cp	r9, r0
     1f6:	cc 14       	cp	r12, r12
     1f8:	cc 14       	cp	r12, r12
     1fa:	cc 14       	cp	r12, r12
     1fc:	cc 14       	cp	r12, r12
     1fe:	cc 14       	cp	r12, r12
     200:	cc 14       	cp	r12, r12
     202:	cc 14       	cp	r12, r12
     204:	5f 14       	cp	r5, r15
     206:	cc 14       	cp	r12, r12
     208:	cc 14       	cp	r12, r12
     20a:	cc 14       	cp	r12, r12
     20c:	cc 14       	cp	r12, r12
     20e:	cc 14       	cp	r12, r12
     210:	cc 14       	cp	r12, r12
     212:	cc 14       	cp	r12, r12
     214:	90 14       	cp	r9, r0
     216:	cc 14       	cp	r12, r12
     218:	cc 14       	cp	r12, r12
     21a:	cc 14       	cp	r12, r12
     21c:	cc 14       	cp	r12, r12
     21e:	cc 14       	cp	r12, r12
     220:	cc 14       	cp	r12, r12
     222:	cc 14       	cp	r12, r12
     224:	77 14       	cp	r7, r7
     226:	cc 14       	cp	r12, r12
     228:	cc 14       	cp	r12, r12
     22a:	cc 14       	cp	r12, r12
     22c:	cc 14       	cp	r12, r12
     22e:	cc 14       	cp	r12, r12
     230:	cc 14       	cp	r12, r12
     232:	cc 14       	cp	r12, r12
     234:	94 14       	cp	r9, r4
     236:	cc 14       	cp	r12, r12
     238:	cc 14       	cp	r12, r12
     23a:	cc 14       	cp	r12, r12
     23c:	cc 14       	cp	r12, r12
     23e:	cc 14       	cp	r12, r12
     240:	cc 14       	cp	r12, r12
     242:	cc 14       	cp	r12, r12
     244:	94 14       	cp	r9, r4
     246:	cc 14       	cp	r12, r12
     248:	cc 14       	cp	r12, r12
     24a:	cc 14       	cp	r12, r12
     24c:	cc 14       	cp	r12, r12
     24e:	cc 14       	cp	r12, r12
     250:	cc 14       	cp	r12, r12
     252:	cc 14       	cp	r12, r12
     254:	a9 14       	cp	r10, r9
     256:	cc 14       	cp	r12, r12
     258:	cc 14       	cp	r12, r12
     25a:	cc 14       	cp	r12, r12
     25c:	cc 14       	cp	r12, r12
     25e:	cc 14       	cp	r12, r12
     260:	cc 14       	cp	r12, r12
     262:	cc 14       	cp	r12, r12
     264:	c3 14       	cp	r12, r3
     266:	cc 14       	cp	r12, r12
     268:	cc 14       	cp	r12, r12
     26a:	cc 14       	cp	r12, r12
     26c:	cc 14       	cp	r12, r12
     26e:	cc 14       	cp	r12, r12
     270:	cc 14       	cp	r12, r12
     272:	cc 14       	cp	r12, r12
     274:	c3 14       	cp	r12, r3
     276:	08 4a       	sbci	r16, 0xA8	; 168
     278:	d7 3b       	cpi	r29, 0xB7	; 183
     27a:	3b ce       	rjmp	.-906    	; 0xfffffef2 <__eeprom_end+0xff7efef2>
     27c:	01 6e       	ori	r16, 0xE1	; 225
     27e:	84 bc       	out	0x24, r8	; 36
     280:	bf fd       	.word	0xfdbf	; ????
     282:	c1 2f       	mov	r28, r17
     284:	3d 6c       	ori	r19, 0xCD	; 205
     286:	74 31       	cpi	r23, 0x14	; 20
     288:	9a bd       	out	0x2a, r25	; 42
     28a:	56 83       	std	Z+6, r21	; 0x06
     28c:	3d da       	rcall	.-2950   	; 0xfffff708 <__eeprom_end+0xff7ef708>
     28e:	3d 00       	.word	0x003d	; ????
     290:	c7 7f       	andi	r28, 0xF7	; 247
     292:	11 be       	out	0x31, r1	; 49
     294:	d9 e4       	ldi	r29, 0x49	; 73
     296:	bb 4c       	sbci	r27, 0xCB	; 203
     298:	3e 91       	ld	r19, -X
     29a:	6b aa       	std	Y+51, r6	; 0x33
     29c:	aa be       	out	0x3a, r10	; 58
     29e:	00 00       	nop
     2a0:	00 80       	ld	r0, Z
     2a2:	3f 00       	.word	0x003f	; ????
     2a4:	4a 1c       	adc	r4, r10
     2a6:	4e 1c       	adc	r4, r14
     2a8:	38 1c       	adc	r3, r8
     2aa:	3e 1c       	adc	r3, r14
     2ac:	44 1c       	adc	r4, r4
     2ae:	93 1c       	adc	r9, r3
     2b0:	52 1c       	adc	r5, r2
     2b2:	58 1c       	adc	r5, r8
     2b4:	5e 1c       	adc	r5, r14
     2b6:	64 1c       	adc	r6, r4
     2b8:	6a 1c       	adc	r6, r10
     2ba:	70 1c       	adc	r7, r0
     2bc:	76 1c       	adc	r7, r6
     2be:	7c 1c       	adc	r7, r12
     2c0:	93 1c       	adc	r9, r3
     2c2:	82 1c       	adc	r8, r2
     2c4:	88 1c       	adc	r8, r8
     2c6:	8e 1c       	adc	r8, r14

000002c8 <__trampolines_end>:
     2c8:	00 00       	nop
     2ca:	0a 0b       	sbc	r16, r26
     2cc:	02 09       	sbc	r16, r2
     2ce:	0c 0d       	add	r16, r12
     2d0:	0e 08       	sbc	r0, r14
     2d2:	07 03       	mulsu	r16, r23
     2d4:	04 01       	movw	r0, r8
	...
     2f2:	00 00       	nop
     2f4:	12 11       	cpse	r17, r2
     2f6:	10 00       	.word	0x0010	; ????
	...

0000030e <digital_pin_to_bit_mask_PGM>:
     30e:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     31e:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     32e:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     33e:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     34e:	04 08 10 20 40 80                                   ... @.

00000354 <digital_pin_to_port_PGM>:
     354:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     364:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     374:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     384:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     394:	0b 0b 0b 0b 0b 0b                                   ......

0000039a <port_to_input_PGM>:
     39a:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     3aa:	00 01 00 00 03 01 06 01 09 01                       ..........

000003b4 <port_to_output_PGM>:
     3b4:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     3c4:	02 01 00 00 05 01 08 01 0b 01                       ..........

000003ce <port_to_mode_PGM>:
     3ce:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     3de:	01 01 00 00 04 01 07 01 0a 01                       ..........

000003e8 <__ctors_start>:
     3e8:	e2 0e       	add	r14, r18
     3ea:	b1 15       	cp	r27, r1
     3ec:	35 1a       	sub	r3, r21

000003ee <__ctors_end>:
     3ee:	11 24       	eor	r1, r1
     3f0:	1f be       	out	0x3f, r1	; 63
     3f2:	cf ef       	ldi	r28, 0xFF	; 255
     3f4:	d1 e2       	ldi	r29, 0x21	; 33
     3f6:	de bf       	out	0x3e, r29	; 62
     3f8:	cd bf       	out	0x3d, r28	; 61
     3fa:	00 e0       	ldi	r16, 0x00	; 0
     3fc:	0c bf       	out	0x3c, r16	; 60

000003fe <__do_copy_data>:
     3fe:	12 e0       	ldi	r17, 0x02	; 2
     400:	a0 e0       	ldi	r26, 0x00	; 0
     402:	b2 e0       	ldi	r27, 0x02	; 2
     404:	ec e5       	ldi	r30, 0x5C	; 92
     406:	fb e3       	ldi	r31, 0x3B	; 59
     408:	00 e0       	ldi	r16, 0x00	; 0
     40a:	0b bf       	out	0x3b, r16	; 59
     40c:	02 c0       	rjmp	.+4      	; 0x412 <__do_copy_data+0x14>
     40e:	07 90       	elpm	r0, Z+
     410:	0d 92       	st	X+, r0
     412:	a6 39       	cpi	r26, 0x96	; 150
     414:	b1 07       	cpc	r27, r17
     416:	d9 f7       	brne	.-10     	; 0x40e <__do_copy_data+0x10>

00000418 <__do_clear_bss>:
     418:	2a e0       	ldi	r18, 0x0A	; 10
     41a:	a6 e9       	ldi	r26, 0x96	; 150
     41c:	b2 e0       	ldi	r27, 0x02	; 2
     41e:	01 c0       	rjmp	.+2      	; 0x422 <.do_clear_bss_start>

00000420 <.do_clear_bss_loop>:
     420:	1d 92       	st	X+, r1

00000422 <.do_clear_bss_start>:
     422:	ad 38       	cpi	r26, 0x8D	; 141
     424:	b2 07       	cpc	r27, r18
     426:	e1 f7       	brne	.-8      	; 0x420 <.do_clear_bss_loop>

00000428 <__do_global_ctors>:
     428:	13 e0       	ldi	r17, 0x03	; 3
     42a:	ce ee       	ldi	r28, 0xEE	; 238
     42c:	d3 e0       	ldi	r29, 0x03	; 3
     42e:	00 e0       	ldi	r16, 0x00	; 0
     430:	06 c0       	rjmp	.+12     	; 0x43e <__do_global_ctors+0x16>
     432:	22 97       	sbiw	r28, 0x02	; 2
     434:	01 09       	sbc	r16, r1
     436:	fe 01       	movw	r30, r28
     438:	0b bf       	out	0x3b, r16	; 59
     43a:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <__tablejump_elpm__>
     43e:	c8 3e       	cpi	r28, 0xE8	; 232
     440:	d1 07       	cpc	r29, r17
     442:	80 e0       	ldi	r24, 0x00	; 0
     444:	08 07       	cpc	r16, r24
     446:	a9 f7       	brne	.-22     	; 0x432 <__do_global_ctors+0xa>
     448:	0e 94 76 0e 	call	0x1cec	; 0x1cec <main>
     44c:	0c 94 ac 1d 	jmp	0x3b58	; 0x3b58 <_exit>

00000450 <__bad_interrupt>:
     450:	d7 cd       	rjmp	.-1106   	; 0x0 <__vectors>

00000452 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     452:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     454:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     456:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     458:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     45a:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     45c:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     45e:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     460:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     462:	05 c0       	rjmp	.+10     	; 0x46e <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     464:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     466:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     468:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     46a:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     46c:	61 f1       	breq	.+88     	; 0x4c6 <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     46e:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     470:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     472:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     474:	b9 f3       	breq	.-18     	; 0x464 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     476:	05 c0       	rjmp	.+10     	; 0x482 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     478:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     47a:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     47c:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     47e:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     480:	11 f1       	breq	.+68     	; 0x4c6 <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     482:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     484:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     486:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     488:	f7 cf       	rjmp	.-18     	; 0x478 <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     48a:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     48c:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     48e:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     490:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     492:	0a c0       	rjmp	.+20     	; 0x4a8 <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     494:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     496:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     498:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     49a:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     49c:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     49e:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     4a0:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     4a2:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     4a4:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     4a6:	79 f0       	breq	.+30     	; 0x4c6 <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     4a8:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     4aa:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     4ac:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     4ae:	91 f3       	breq	.-28     	; 0x494 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     4b0:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     4b2:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     4b4:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     4b6:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     4b8:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     4ba:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     4bc:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     4be:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     4c0:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     4c2:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     4c4:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     4c6:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     4c8:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     4ca:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     4cc:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     4ce:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     4d0:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     4d2:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     4d4:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     4d6:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     4d8:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     4da:	08 95       	ret

000004dc <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4dc:	cf 93       	push	r28
     4de:	df 93       	push	r29
     4e0:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4e2:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     4e6:	80 91 96 02 	lds	r24, 0x0296
     4ea:	90 91 97 02 	lds	r25, 0x0297
     4ee:	89 2b       	or	r24, r25
     4f0:	31 f4       	brne	.+12     	; 0x4fe <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     4f2:	8b e9       	ldi	r24, 0x9B	; 155
     4f4:	92 e0       	ldi	r25, 0x02	; 2
     4f6:	90 93 97 02 	sts	0x0297, r25
     4fa:	80 93 96 02 	sts	0x0296, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     4fe:	40 91 98 02 	lds	r20, 0x0298
     502:	50 91 99 02 	lds	r21, 0x0299
     506:	9e 01       	movw	r18, r28
     508:	24 0f       	add	r18, r20
     50a:	35 1f       	adc	r19, r21
     50c:	2b 3d       	cpi	r18, 0xDB	; 219
     50e:	85 e0       	ldi	r24, 0x05	; 5
     510:	38 07       	cpc	r19, r24
     512:	70 f4       	brcc	.+28     	; 0x530 <pvPortMalloc+0x54>
     514:	42 17       	cp	r20, r18
     516:	53 07       	cpc	r21, r19
     518:	70 f4       	brcc	.+28     	; 0x536 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     51a:	c0 91 96 02 	lds	r28, 0x0296
     51e:	d0 91 97 02 	lds	r29, 0x0297
     522:	c4 0f       	add	r28, r20
     524:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     526:	30 93 99 02 	sts	0x0299, r19
     52a:	20 93 98 02 	sts	0x0298, r18
     52e:	05 c0       	rjmp	.+10     	; 0x53a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     530:	c0 e0       	ldi	r28, 0x00	; 0
     532:	d0 e0       	ldi	r29, 0x00	; 0
     534:	02 c0       	rjmp	.+4      	; 0x53a <pvPortMalloc+0x5e>
     536:	c0 e0       	ldi	r28, 0x00	; 0
     538:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     53a:	0e 94 96 11 	call	0x232c	; 0x232c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     53e:	ce 01       	movw	r24, r28
     540:	df 91       	pop	r29
     542:	cf 91       	pop	r28
     544:	08 95       	ret

00000546 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     546:	08 95       	ret

00000548 <_ZN3L3GC1Ev>:
  Wire.requestFrom(address, (byte)1);
  value = Wire.read();
  Wire.endTransmission();

  return value;
}
     548:	fc 01       	movw	r30, r24
     54a:	83 e0       	ldi	r24, 0x03	; 3
     54c:	87 83       	std	Z+7, r24	; 0x07
     54e:	12 86       	std	Z+10, r1	; 0x0a
     550:	11 86       	std	Z+9, r1	; 0x09
     552:	13 86       	std	Z+11, r1	; 0x0b
     554:	08 95       	ret

00000556 <_ZN3L3G8writeRegEhh>:
     556:	0f 93       	push	r16
     558:	1f 93       	push	r17
     55a:	cf 93       	push	r28
     55c:	df 93       	push	r29
     55e:	ec 01       	movw	r28, r24
     560:	06 2f       	mov	r16, r22
     562:	14 2f       	mov	r17, r20
     564:	68 85       	ldd	r22, Y+8	; 0x08
     566:	85 e9       	ldi	r24, 0x95	; 149
     568:	99 e0       	ldi	r25, 0x09	; 9
     56a:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
     56e:	60 2f       	mov	r22, r16
     570:	85 e9       	ldi	r24, 0x95	; 149
     572:	99 e0       	ldi	r25, 0x09	; 9
     574:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
     578:	61 2f       	mov	r22, r17
     57a:	85 e9       	ldi	r24, 0x95	; 149
     57c:	99 e0       	ldi	r25, 0x09	; 9
     57e:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
     582:	85 e9       	ldi	r24, 0x95	; 149
     584:	99 e0       	ldi	r25, 0x09	; 9
     586:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
     58a:	8e 83       	std	Y+6, r24	; 0x06
     58c:	df 91       	pop	r29
     58e:	cf 91       	pop	r28
     590:	1f 91       	pop	r17
     592:	0f 91       	pop	r16
     594:	08 95       	ret

00000596 <_ZN3L3G13enableDefaultEv>:
     596:	cf 93       	push	r28
     598:	df 93       	push	r29
     59a:	ec 01       	movw	r28, r24
     59c:	8f 81       	ldd	r24, Y+7	; 0x07
     59e:	82 30       	cpi	r24, 0x02	; 2
     5a0:	21 f4       	brne	.+8      	; 0x5aa <_ZN3L3G13enableDefaultEv+0x14>
     5a2:	40 e0       	ldi	r20, 0x00	; 0
     5a4:	69 e3       	ldi	r22, 0x39	; 57
     5a6:	ce 01       	movw	r24, r28
     5a8:	d6 df       	rcall	.-84     	; 0x556 <_ZN3L3G8writeRegEhh>
     5aa:	40 e0       	ldi	r20, 0x00	; 0
     5ac:	63 e2       	ldi	r22, 0x23	; 35
     5ae:	ce 01       	movw	r24, r28
     5b0:	d2 df       	rcall	.-92     	; 0x556 <_ZN3L3G8writeRegEhh>
     5b2:	4f e6       	ldi	r20, 0x6F	; 111
     5b4:	60 e2       	ldi	r22, 0x20	; 32
     5b6:	ce 01       	movw	r24, r28
     5b8:	ce df       	rcall	.-100    	; 0x556 <_ZN3L3G8writeRegEhh>
     5ba:	df 91       	pop	r29
     5bc:	cf 91       	pop	r28
     5be:	08 95       	ret

000005c0 <_ZN3L3G4readEv>:

// Reads the 3 gyro channels and stores them in vector g
void L3G::read()
{
     5c0:	9f 92       	push	r9
     5c2:	af 92       	push	r10
     5c4:	bf 92       	push	r11
     5c6:	cf 92       	push	r12
     5c8:	df 92       	push	r13
     5ca:	ef 92       	push	r14
     5cc:	ff 92       	push	r15
     5ce:	0f 93       	push	r16
     5d0:	1f 93       	push	r17
     5d2:	cf 93       	push	r28
     5d4:	df 93       	push	r29
     5d6:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     5d8:	68 85       	ldd	r22, Y+8	; 0x08
     5da:	85 e9       	ldi	r24, 0x95	; 149
     5dc:	99 e0       	ldi	r25, 0x09	; 9
     5de:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     5e2:	e0 91 95 09 	lds	r30, 0x0995
     5e6:	f0 91 96 09 	lds	r31, 0x0996
     5ea:	01 90       	ld	r0, Z+
     5ec:	f0 81       	ld	r31, Z
     5ee:	e0 2d       	mov	r30, r0
     5f0:	68 ea       	ldi	r22, 0xA8	; 168
     5f2:	85 e9       	ldi	r24, 0x95	; 149
     5f4:	99 e0       	ldi	r25, 0x09	; 9
     5f6:	19 95       	eicall
  // assert the MSB of the address to get the gyro
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
     5f8:	85 e9       	ldi	r24, 0x95	; 149
     5fa:	99 e0       	ldi	r25, 0x09	; 9
     5fc:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)6);
     600:	46 e0       	ldi	r20, 0x06	; 6
     602:	68 85       	ldd	r22, Y+8	; 0x08
     604:	85 e9       	ldi	r24, 0x95	; 149
     606:	99 e0       	ldi	r25, 0x09	; 9
     608:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <_ZN7TwoWire11requestFromEhh>
  
  unsigned int millis_start = millis();
     60c:	0e 94 b2 1b 	call	0x3764	; 0x3764 <millis>
     610:	8b 01       	movw	r16, r22
  while (Wire.available() < 6)
     612:	10 c0       	rjmp	.+32     	; 0x634 <_ZN3L3G4readEv+0x74>
  {
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     614:	89 85       	ldd	r24, Y+9	; 0x09
     616:	9a 85       	ldd	r25, Y+10	; 0x0a
     618:	89 2b       	or	r24, r25
     61a:	61 f0       	breq	.+24     	; 0x634 <_ZN3L3G4readEv+0x74>
     61c:	0e 94 b2 1b 	call	0x3764	; 0x3764 <millis>
     620:	60 1b       	sub	r22, r16
     622:	71 0b       	sbc	r23, r17
     624:	89 85       	ldd	r24, Y+9	; 0x09
     626:	9a 85       	ldd	r25, Y+10	; 0x0a
     628:	86 17       	cp	r24, r22
     62a:	97 07       	cpc	r25, r23
     62c:	18 f4       	brcc	.+6      	; 0x634 <_ZN3L3G4readEv+0x74>
    {
      did_timeout = true;
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	8b 87       	std	Y+11, r24	; 0x0b
      return;
     632:	32 c0       	rjmp	.+100    	; 0x698 <_ZN3L3G4readEv+0xd8>
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
  Wire.requestFrom(address, (byte)6);
  
  unsigned int millis_start = millis();
  while (Wire.available() < 6)
     634:	85 e9       	ldi	r24, 0x95	; 149
     636:	99 e0       	ldi	r25, 0x09	; 9
     638:	0e 94 df 14 	call	0x29be	; 0x29be <_ZN7TwoWire9availableEv>
     63c:	06 97       	sbiw	r24, 0x06	; 6
     63e:	54 f3       	brlt	.-44     	; 0x614 <_ZN3L3G4readEv+0x54>
      did_timeout = true;
      return;
    }
  }

  uint8_t xlg = Wire.read();
     640:	85 e9       	ldi	r24, 0x95	; 149
     642:	99 e0       	ldi	r25, 0x09	; 9
     644:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
     648:	a8 2e       	mov	r10, r24
  uint8_t xhg = Wire.read();
     64a:	85 e9       	ldi	r24, 0x95	; 149
     64c:	99 e0       	ldi	r25, 0x09	; 9
     64e:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
     652:	98 2e       	mov	r9, r24
  uint8_t ylg = Wire.read();
     654:	85 e9       	ldi	r24, 0x95	; 149
     656:	99 e0       	ldi	r25, 0x09	; 9
     658:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
     65c:	08 2f       	mov	r16, r24
  uint8_t yhg = Wire.read();
     65e:	85 e9       	ldi	r24, 0x95	; 149
     660:	99 e0       	ldi	r25, 0x09	; 9
     662:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
     666:	b8 2e       	mov	r11, r24
  uint8_t zlg = Wire.read();
     668:	85 e9       	ldi	r24, 0x95	; 149
     66a:	99 e0       	ldi	r25, 0x09	; 9
     66c:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
     670:	18 2f       	mov	r17, r24
  uint8_t zhg = Wire.read();
     672:	85 e9       	ldi	r24, 0x95	; 149
     674:	99 e0       	ldi	r25, 0x09	; 9
     676:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
     67a:	d9 2c       	mov	r13, r9
     67c:	c1 2c       	mov	r12, r1
     67e:	ca 28       	or	r12, r10
     680:	d9 82       	std	Y+1, r13	; 0x01
     682:	c8 82       	st	Y, r12
  g.y = (int16_t)(yhg << 8 | ylg);
     684:	fb 2c       	mov	r15, r11
     686:	e1 2c       	mov	r14, r1
     688:	e0 2a       	or	r14, r16
     68a:	fb 82       	std	Y+3, r15	; 0x03
     68c:	ea 82       	std	Y+2, r14	; 0x02
  g.z = (int16_t)(zhg << 8 | zlg);
     68e:	98 2f       	mov	r25, r24
     690:	88 27       	eor	r24, r24
     692:	81 2b       	or	r24, r17
     694:	9d 83       	std	Y+5, r25	; 0x05
     696:	8c 83       	std	Y+4, r24	; 0x04
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	1f 91       	pop	r17
     69e:	0f 91       	pop	r16
     6a0:	ff 90       	pop	r15
     6a2:	ef 90       	pop	r14
     6a4:	df 90       	pop	r13
     6a6:	cf 90       	pop	r12
     6a8:	bf 90       	pop	r11
     6aa:	af 90       	pop	r10
     6ac:	9f 90       	pop	r9
     6ae:	08 95       	ret

000006b0 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     6b0:	cf 93       	push	r28
     6b2:	df 93       	push	r29
     6b4:	c6 2f       	mov	r28, r22
     6b6:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     6b8:	85 e9       	ldi	r24, 0x95	; 149
     6ba:	99 e0       	ldi	r25, 0x09	; 9
     6bc:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     6c0:	6d 2f       	mov	r22, r29
     6c2:	85 e9       	ldi	r24, 0x95	; 149
     6c4:	99 e0       	ldi	r25, 0x09	; 9
     6c6:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     6ca:	85 e9       	ldi	r24, 0x95	; 149
     6cc:	99 e0       	ldi	r25, 0x09	; 9
     6ce:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
     6d2:	81 11       	cpse	r24, r1
     6d4:	11 c0       	rjmp	.+34     	; 0x6f8 <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     6d6:	41 e0       	ldi	r20, 0x01	; 1
     6d8:	6c 2f       	mov	r22, r28
     6da:	85 e9       	ldi	r24, 0x95	; 149
     6dc:	99 e0       	ldi	r25, 0x09	; 9
     6de:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     6e2:	85 e9       	ldi	r24, 0x95	; 149
     6e4:	99 e0       	ldi	r25, 0x09	; 9
     6e6:	0e 94 df 14 	call	0x29be	; 0x29be <_ZN7TwoWire9availableEv>
     6ea:	89 2b       	or	r24, r25
     6ec:	41 f0       	breq	.+16     	; 0x6fe <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     6ee:	85 e9       	ldi	r24, 0x95	; 149
     6f0:	99 e0       	ldi	r25, 0x09	; 9
     6f2:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
     6f6:	05 c0       	rjmp	.+10     	; 0x702 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     6f8:	8f ef       	ldi	r24, 0xFF	; 255
     6fa:	9f ef       	ldi	r25, 0xFF	; 255
     6fc:	02 c0       	rjmp	.+4      	; 0x702 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     6fe:	8f ef       	ldi	r24, 0xFF	; 255
     700:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	08 95       	ret

00000708 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     708:	0f 93       	push	r16
     70a:	1f 93       	push	r17
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	ec 01       	movw	r28, r24
     712:	16 2f       	mov	r17, r22
     714:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     716:	63 30       	cpi	r22, 0x03	; 3
     718:	09 f4       	brne	.+2      	; 0x71c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     71a:	56 c0       	rjmp	.+172    	; 0x7c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     71c:	42 30       	cpi	r20, 0x02	; 2
     71e:	c9 f5       	brne	.+114    	; 0x792 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     720:	56 c0       	rjmp	.+172    	; 0x7ce <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     722:	13 30       	cpi	r17, 0x03	; 3
     724:	09 f0       	breq	.+2      	; 0x728 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     726:	58 c0       	rjmp	.+176    	; 0x7d8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     728:	87 3d       	cpi	r24, 0xD7	; 215
     72a:	91 05       	cpc	r25, r1
     72c:	09 f4       	brne	.+2      	; 0x730 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     72e:	58 c0       	rjmp	.+176    	; 0x7e0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     730:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     732:	11 e0       	ldi	r17, 0x01	; 1
     734:	2c c0       	rjmp	.+88     	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     736:	01 30       	cpi	r16, 0x01	; 1
     738:	91 f0       	breq	.+36     	; 0x75e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     73a:	4f e0       	ldi	r20, 0x0F	; 15
     73c:	6a e6       	ldi	r22, 0x6A	; 106
     73e:	ce 01       	movw	r24, r28
     740:	b7 df       	rcall	.-146    	; 0x6b0 <_ZN3L3G7testRegEhNS_7regAddrE>
     742:	8f 3f       	cpi	r24, 0xFF	; 255
     744:	2f ef       	ldi	r18, 0xFF	; 255
     746:	92 07       	cpc	r25, r18
     748:	51 f0       	breq	.+20     	; 0x75e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     74a:	13 30       	cpi	r17, 0x03	; 3
     74c:	09 f0       	breq	.+2      	; 0x750 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     74e:	46 c0       	rjmp	.+140    	; 0x7dc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     750:	87 3d       	cpi	r24, 0xD7	; 215
     752:	91 05       	cpc	r25, r1
     754:	09 f0       	breq	.+2      	; 0x758 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     756:	47 c0       	rjmp	.+142    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     758:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     75a:	12 e0       	ldi	r17, 0x02	; 2
     75c:	18 c0       	rjmp	.+48     	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     75e:	13 30       	cpi	r17, 0x03	; 3
     760:	11 f0       	breq	.+4      	; 0x766 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     762:	11 11       	cpse	r17, r1
     764:	14 c0       	rjmp	.+40     	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     766:	00 23       	and	r16, r16
     768:	49 f0       	breq	.+18     	; 0x77c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     76a:	4f e0       	ldi	r20, 0x0F	; 15
     76c:	69 e6       	ldi	r22, 0x69	; 105
     76e:	ce 01       	movw	r24, r28
     770:	9f df       	rcall	.-194    	; 0x6b0 <_ZN3L3G7testRegEhNS_7regAddrE>
     772:	83 3d       	cpi	r24, 0xD3	; 211
     774:	91 05       	cpc	r25, r1
     776:	d1 f1       	breq	.+116    	; 0x7ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     778:	01 30       	cpi	r16, 0x01	; 1
     77a:	39 f0       	breq	.+14     	; 0x78a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     77c:	4f e0       	ldi	r20, 0x0F	; 15
     77e:	68 e6       	ldi	r22, 0x68	; 104
     780:	ce 01       	movw	r24, r28
     782:	96 df       	rcall	.-212    	; 0x6b0 <_ZN3L3G7testRegEhNS_7regAddrE>
     784:	83 3d       	cpi	r24, 0xD3	; 211
     786:	91 05       	cpc	r25, r1
     788:	99 f1       	breq	.+102    	; 0x7f0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     78a:	13 30       	cpi	r17, 0x03	; 3
     78c:	b9 f0       	breq	.+46     	; 0x7bc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     78e:	02 30       	cpi	r16, 0x02	; 2
     790:	b9 f0       	breq	.+46     	; 0x7c0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     792:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     794:	11 23       	and	r17, r17
     796:	51 f0       	breq	.+20     	; 0x7ac <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     798:	13 30       	cpi	r17, 0x03	; 3
     79a:	a0 f4       	brcc	.+40     	; 0x7c4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     79c:	01 30       	cpi	r16, 0x01	; 1
     79e:	11 f4       	brne	.+4      	; 0x7a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     7a0:	8b e6       	ldi	r24, 0x6B	; 107
     7a2:	01 c0       	rjmp	.+2      	; 0x7a6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     7a4:	8a e6       	ldi	r24, 0x6A	; 106
     7a6:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     7a8:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     7aa:	41 c0       	rjmp	.+130    	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     7ac:	01 30       	cpi	r16, 0x01	; 1
     7ae:	11 f4       	brne	.+4      	; 0x7b4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     7b0:	89 e6       	ldi	r24, 0x69	; 105
     7b2:	01 c0       	rjmp	.+2      	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     7b4:	88 e6       	ldi	r24, 0x68	; 104
     7b6:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     7b8:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     7ba:	39 c0       	rjmp	.+114    	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     7bc:	80 e0       	ldi	r24, 0x00	; 0
     7be:	37 c0       	rjmp	.+110    	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	35 c0       	rjmp	.+106    	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	33 c0       	rjmp	.+102    	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7c8:	44 23       	and	r20, r20
     7ca:	41 f1       	breq	.+80     	; 0x81c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     7cc:	1e c0       	rjmp	.+60     	; 0x80a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     7ce:	8f ef       	ldi	r24, 0xFF	; 255
     7d0:	86 0f       	add	r24, r22
     7d2:	83 30       	cpi	r24, 0x03	; 3
     7d4:	30 f6       	brcc	.-116    	; 0x762 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     7d6:	0f c0       	rjmp	.+30     	; 0x7f6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7d8:	01 e0       	ldi	r16, 0x01	; 1
     7da:	c3 cf       	rjmp	.-122    	; 0x762 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7dc:	00 e0       	ldi	r16, 0x00	; 0
     7de:	c1 cf       	rjmp	.-126    	; 0x762 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7e0:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7e2:	12 e0       	ldi	r17, 0x02	; 2
     7e4:	d4 cf       	rjmp	.-88     	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7e6:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7e8:	11 e0       	ldi	r17, 0x01	; 1
     7ea:	d1 cf       	rjmp	.-94     	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     7ec:	01 e0       	ldi	r16, 0x01	; 1
     7ee:	01 c0       	rjmp	.+2      	; 0x7f2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     7f0:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     7f2:	1f 82       	std	Y+7, r1	; 0x07
     7f4:	db cf       	rjmp	.-74     	; 0x7ac <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7f6:	4f e0       	ldi	r20, 0x0F	; 15
     7f8:	6b e6       	ldi	r22, 0x6B	; 107
     7fa:	ce 01       	movw	r24, r28
     7fc:	59 df       	rcall	.-334    	; 0x6b0 <_ZN3L3G7testRegEhNS_7regAddrE>
     7fe:	8f 3f       	cpi	r24, 0xFF	; 255
     800:	2f ef       	ldi	r18, 0xFF	; 255
     802:	92 07       	cpc	r25, r18
     804:	09 f0       	breq	.+2      	; 0x808 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     806:	8d cf       	rjmp	.-230    	; 0x722 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     808:	98 cf       	rjmp	.-208    	; 0x73a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     80a:	4f e0       	ldi	r20, 0x0F	; 15
     80c:	6b e6       	ldi	r22, 0x6B	; 107
     80e:	50 df       	rcall	.-352    	; 0x6b0 <_ZN3L3G7testRegEhNS_7regAddrE>
     810:	8f 3f       	cpi	r24, 0xFF	; 255
     812:	2f ef       	ldi	r18, 0xFF	; 255
     814:	92 07       	cpc	r25, r18
     816:	09 f0       	breq	.+2      	; 0x81a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     818:	87 cf       	rjmp	.-242    	; 0x728 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     81a:	8d cf       	rjmp	.-230    	; 0x736 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     81c:	4f e0       	ldi	r20, 0x0F	; 15
     81e:	6a e6       	ldi	r22, 0x6A	; 106
     820:	47 df       	rcall	.-370    	; 0x6b0 <_ZN3L3G7testRegEhNS_7regAddrE>
     822:	8f 3f       	cpi	r24, 0xFF	; 255
     824:	2f ef       	ldi	r18, 0xFF	; 255
     826:	92 07       	cpc	r25, r18
     828:	09 f0       	breq	.+2      	; 0x82c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     82a:	92 cf       	rjmp	.-220    	; 0x750 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     82c:	98 cf       	rjmp	.-208    	; 0x75e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     82e:	df 91       	pop	r29
     830:	cf 91       	pop	r28
     832:	1f 91       	pop	r17
     834:	0f 91       	pop	r16
     836:	08 95       	ret

00000838 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     838:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     83a:	03 96       	adiw	r24, 0x03	; 3
     83c:	92 83       	std	Z+2, r25	; 0x02
     83e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     840:	2f ef       	ldi	r18, 0xFF	; 255
     842:	3f ef       	ldi	r19, 0xFF	; 255
     844:	34 83       	std	Z+4, r19	; 0x04
     846:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     848:	96 83       	std	Z+6, r25	; 0x06
     84a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     84c:	90 87       	std	Z+8, r25	; 0x08
     84e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     850:	10 82       	st	Z, r1
     852:	08 95       	ret

00000854 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     854:	fc 01       	movw	r30, r24
     856:	11 86       	std	Z+9, r1	; 0x09
     858:	10 86       	std	Z+8, r1	; 0x08
     85a:	08 95       	ret

0000085c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     85c:	cf 93       	push	r28
     85e:	df 93       	push	r29
     860:	9c 01       	movw	r18, r24
     862:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     864:	dc 01       	movw	r26, r24
     866:	11 96       	adiw	r26, 0x01	; 1
     868:	cd 91       	ld	r28, X+
     86a:	dc 91       	ld	r29, X
     86c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     86e:	d3 83       	std	Z+3, r29	; 0x03
     870:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     872:	8c 81       	ldd	r24, Y+4	; 0x04
     874:	9d 81       	ldd	r25, Y+5	; 0x05
     876:	95 83       	std	Z+5, r25	; 0x05
     878:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     87a:	8c 81       	ldd	r24, Y+4	; 0x04
     87c:	9d 81       	ldd	r25, Y+5	; 0x05
     87e:	dc 01       	movw	r26, r24
     880:	13 96       	adiw	r26, 0x03	; 3
     882:	7c 93       	st	X, r23
     884:	6e 93       	st	-X, r22
     886:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     888:	7d 83       	std	Y+5, r23	; 0x05
     88a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     88c:	31 87       	std	Z+9, r19	; 0x09
     88e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     890:	f9 01       	movw	r30, r18
     892:	80 81       	ld	r24, Z
     894:	8f 5f       	subi	r24, 0xFF	; 255
     896:	80 83       	st	Z, r24
}
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	08 95       	ret

0000089e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     89e:	cf 93       	push	r28
     8a0:	df 93       	push	r29
     8a2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     8a4:	48 81       	ld	r20, Y
     8a6:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     8a8:	4f 3f       	cpi	r20, 0xFF	; 255
     8aa:	2f ef       	ldi	r18, 0xFF	; 255
     8ac:	52 07       	cpc	r21, r18
     8ae:	21 f4       	brne	.+8      	; 0x8b8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     8b0:	fc 01       	movw	r30, r24
     8b2:	a7 81       	ldd	r26, Z+7	; 0x07
     8b4:	b0 85       	ldd	r27, Z+8	; 0x08
     8b6:	0d c0       	rjmp	.+26     	; 0x8d2 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8b8:	dc 01       	movw	r26, r24
     8ba:	13 96       	adiw	r26, 0x03	; 3
     8bc:	12 96       	adiw	r26, 0x02	; 2
     8be:	ed 91       	ld	r30, X+
     8c0:	fc 91       	ld	r31, X
     8c2:	13 97       	sbiw	r26, 0x03	; 3
     8c4:	20 81       	ld	r18, Z
     8c6:	31 81       	ldd	r19, Z+1	; 0x01
     8c8:	42 17       	cp	r20, r18
     8ca:	53 07       	cpc	r21, r19
     8cc:	10 f0       	brcs	.+4      	; 0x8d2 <vListInsert+0x34>
     8ce:	df 01       	movw	r26, r30
     8d0:	f5 cf       	rjmp	.-22     	; 0x8bc <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8d2:	12 96       	adiw	r26, 0x02	; 2
     8d4:	ed 91       	ld	r30, X+
     8d6:	fc 91       	ld	r31, X
     8d8:	13 97       	sbiw	r26, 0x03	; 3
     8da:	fb 83       	std	Y+3, r31	; 0x03
     8dc:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8de:	d5 83       	std	Z+5, r29	; 0x05
     8e0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8e2:	bd 83       	std	Y+5, r27	; 0x05
     8e4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8e6:	13 96       	adiw	r26, 0x03	; 3
     8e8:	dc 93       	st	X, r29
     8ea:	ce 93       	st	-X, r28
     8ec:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8ee:	99 87       	std	Y+9, r25	; 0x09
     8f0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8f2:	fc 01       	movw	r30, r24
     8f4:	20 81       	ld	r18, Z
     8f6:	2f 5f       	subi	r18, 0xFF	; 255
     8f8:	20 83       	st	Z, r18
}
     8fa:	df 91       	pop	r29
     8fc:	cf 91       	pop	r28
     8fe:	08 95       	ret

00000900 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     906:	a0 85       	ldd	r26, Z+8	; 0x08
     908:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     90a:	c2 81       	ldd	r28, Z+2	; 0x02
     90c:	d3 81       	ldd	r29, Z+3	; 0x03
     90e:	84 81       	ldd	r24, Z+4	; 0x04
     910:	95 81       	ldd	r25, Z+5	; 0x05
     912:	9d 83       	std	Y+5, r25	; 0x05
     914:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     916:	c4 81       	ldd	r28, Z+4	; 0x04
     918:	d5 81       	ldd	r29, Z+5	; 0x05
     91a:	82 81       	ldd	r24, Z+2	; 0x02
     91c:	93 81       	ldd	r25, Z+3	; 0x03
     91e:	9b 83       	std	Y+3, r25	; 0x03
     920:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     922:	11 96       	adiw	r26, 0x01	; 1
     924:	cd 91       	ld	r28, X+
     926:	dc 91       	ld	r29, X
     928:	12 97       	sbiw	r26, 0x02	; 2
     92a:	ce 17       	cp	r28, r30
     92c:	df 07       	cpc	r29, r31
     92e:	31 f4       	brne	.+12     	; 0x93c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     930:	8c 81       	ldd	r24, Y+4	; 0x04
     932:	9d 81       	ldd	r25, Y+5	; 0x05
     934:	12 96       	adiw	r26, 0x02	; 2
     936:	9c 93       	st	X, r25
     938:	8e 93       	st	-X, r24
     93a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     93c:	11 86       	std	Z+9, r1	; 0x09
     93e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     940:	8c 91       	ld	r24, X
     942:	81 50       	subi	r24, 0x01	; 1
     944:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     946:	df 91       	pop	r29
     948:	cf 91       	pop	r28
     94a:	08 95       	ret

0000094c <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	ec 01       	movw	r28, r24
     952:	86 e0       	ldi	r24, 0x06	; 6
     954:	e3 e1       	ldi	r30, 0x13	; 19
     956:	f2 e0       	ldi	r31, 0x02	; 2
     958:	de 01       	movw	r26, r28
     95a:	52 96       	adiw	r26, 0x12	; 18
     95c:	01 90       	ld	r0, Z+
     95e:	0d 92       	st	X+, r0
     960:	8a 95       	dec	r24
     962:	e1 f7       	brne	.-8      	; 0x95c <_ZN6LSM303C1Ev+0x10>
     964:	86 e0       	ldi	r24, 0x06	; 6
     966:	e9 e1       	ldi	r30, 0x19	; 25
     968:	f2 e0       	ldi	r31, 0x02	; 2
     96a:	de 01       	movw	r26, r28
     96c:	1c 96       	adiw	r26, 0x0c	; 12
     96e:	01 90       	ld	r0, Z+
     970:	0d 92       	st	X+, r0
     972:	8a 95       	dec	r24
     974:	e1 f7       	brne	.-8      	; 0x96e <_ZN6LSM303C1Ev+0x22>
     976:	84 e0       	ldi	r24, 0x04	; 4
     978:	89 8f       	std	Y+25, r24	; 0x19
     97a:	1c a2       	std	Y+36, r1	; 0x24
     97c:	1b a2       	std	Y+35, r1	; 0x23
     97e:	1d a2       	std	Y+37, r1	; 0x25
     980:	df 91       	pop	r29
     982:	cf 91       	pop	r28
     984:	08 95       	ret

00000986 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>:
     986:	4f 92       	push	r4
     988:	5f 92       	push	r5
     98a:	6f 92       	push	r6
     98c:	7f 92       	push	r7
     98e:	8f 92       	push	r8
     990:	9f 92       	push	r9
     992:	af 92       	push	r10
     994:	bf 92       	push	r11
     996:	cf 92       	push	r12
     998:	df 92       	push	r13
     99a:	ef 92       	push	r14
     99c:	ff 92       	push	r15
     99e:	0f 93       	push	r16
     9a0:	1f 93       	push	r17
     9a2:	cf 93       	push	r28
     9a4:	df 93       	push	r29
     9a6:	00 d0       	rcall	.+0      	; 0x9a8 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE+0x22>
     9a8:	1f 92       	push	r1
     9aa:	cd b7       	in	r28, 0x3d	; 61
     9ac:	de b7       	in	r29, 0x3e	; 62
     9ae:	8c 01       	movw	r16, r24
     9b0:	dc 01       	movw	r26, r24
     9b2:	4d 90       	ld	r4, X+
     9b4:	5d 90       	ld	r5, X+
     9b6:	6d 90       	ld	r6, X+
     9b8:	7c 90       	ld	r7, X
     9ba:	13 97       	sbiw	r26, 0x03	; 3
     9bc:	14 96       	adiw	r26, 0x04	; 4
     9be:	8d 90       	ld	r8, X+
     9c0:	9d 90       	ld	r9, X+
     9c2:	ad 90       	ld	r10, X+
     9c4:	bc 90       	ld	r11, X
     9c6:	17 97       	sbiw	r26, 0x07	; 7
     9c8:	18 96       	adiw	r26, 0x08	; 8
     9ca:	8d 91       	ld	r24, X+
     9cc:	9d 91       	ld	r25, X+
     9ce:	0d 90       	ld	r0, X+
     9d0:	bc 91       	ld	r27, X
     9d2:	a0 2d       	mov	r26, r0
     9d4:	89 83       	std	Y+1, r24	; 0x01
     9d6:	9a 83       	std	Y+2, r25	; 0x02
     9d8:	ab 83       	std	Y+3, r26	; 0x03
     9da:	bc 83       	std	Y+4, r27	; 0x04
     9dc:	a3 01       	movw	r20, r6
     9de:	92 01       	movw	r18, r4
     9e0:	c3 01       	movw	r24, r6
     9e2:	b2 01       	movw	r22, r4
     9e4:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     9e8:	6b 01       	movw	r12, r22
     9ea:	7c 01       	movw	r14, r24
     9ec:	a5 01       	movw	r20, r10
     9ee:	94 01       	movw	r18, r8
     9f0:	c5 01       	movw	r24, r10
     9f2:	b4 01       	movw	r22, r8
     9f4:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     9f8:	9b 01       	movw	r18, r22
     9fa:	ac 01       	movw	r20, r24
     9fc:	c7 01       	movw	r24, r14
     9fe:	b6 01       	movw	r22, r12
     a00:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     a04:	6b 01       	movw	r12, r22
     a06:	7c 01       	movw	r14, r24
     a08:	29 81       	ldd	r18, Y+1	; 0x01
     a0a:	3a 81       	ldd	r19, Y+2	; 0x02
     a0c:	4b 81       	ldd	r20, Y+3	; 0x03
     a0e:	5c 81       	ldd	r21, Y+4	; 0x04
     a10:	ca 01       	movw	r24, r20
     a12:	b9 01       	movw	r22, r18
     a14:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     a18:	9b 01       	movw	r18, r22
     a1a:	ac 01       	movw	r20, r24
     a1c:	c7 01       	movw	r24, r14
     a1e:	b6 01       	movw	r22, r12
     a20:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     a24:	0e 94 5e 18 	call	0x30bc	; 0x30bc <sqrt>
     a28:	6b 01       	movw	r12, r22
     a2a:	7c 01       	movw	r14, r24
     a2c:	9b 01       	movw	r18, r22
     a2e:	ac 01       	movw	r20, r24
     a30:	c3 01       	movw	r24, r6
     a32:	b2 01       	movw	r22, r4
     a34:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
     a38:	f8 01       	movw	r30, r16
     a3a:	60 83       	st	Z, r22
     a3c:	71 83       	std	Z+1, r23	; 0x01
     a3e:	82 83       	std	Z+2, r24	; 0x02
     a40:	93 83       	std	Z+3, r25	; 0x03
     a42:	a7 01       	movw	r20, r14
     a44:	96 01       	movw	r18, r12
     a46:	c5 01       	movw	r24, r10
     a48:	b4 01       	movw	r22, r8
     a4a:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
     a4e:	d8 01       	movw	r26, r16
     a50:	14 96       	adiw	r26, 0x04	; 4
     a52:	6d 93       	st	X+, r22
     a54:	7d 93       	st	X+, r23
     a56:	8d 93       	st	X+, r24
     a58:	9c 93       	st	X, r25
     a5a:	17 97       	sbiw	r26, 0x07	; 7
     a5c:	a7 01       	movw	r20, r14
     a5e:	96 01       	movw	r18, r12
     a60:	69 81       	ldd	r22, Y+1	; 0x01
     a62:	7a 81       	ldd	r23, Y+2	; 0x02
     a64:	8b 81       	ldd	r24, Y+3	; 0x03
     a66:	9c 81       	ldd	r25, Y+4	; 0x04
     a68:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
     a6c:	f8 01       	movw	r30, r16
     a6e:	60 87       	std	Z+8, r22	; 0x08
     a70:	71 87       	std	Z+9, r23	; 0x09
     a72:	82 87       	std	Z+10, r24	; 0x0a
     a74:	93 87       	std	Z+11, r25	; 0x0b
     a76:	0f 90       	pop	r0
     a78:	0f 90       	pop	r0
     a7a:	0f 90       	pop	r0
     a7c:	0f 90       	pop	r0
     a7e:	df 91       	pop	r29
     a80:	cf 91       	pop	r28
     a82:	1f 91       	pop	r17
     a84:	0f 91       	pop	r16
     a86:	ff 90       	pop	r15
     a88:	ef 90       	pop	r14
     a8a:	df 90       	pop	r13
     a8c:	cf 90       	pop	r12
     a8e:	bf 90       	pop	r11
     a90:	af 90       	pop	r10
     a92:	9f 90       	pop	r9
     a94:	8f 90       	pop	r8
     a96:	7f 90       	pop	r7
     a98:	6f 90       	pop	r6
     a9a:	5f 90       	pop	r5
     a9c:	4f 90       	pop	r4
     a9e:	08 95       	ret

00000aa0 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>:
     aa0:	4f 92       	push	r4
     aa2:	5f 92       	push	r5
     aa4:	6f 92       	push	r6
     aa6:	7f 92       	push	r7
     aa8:	8f 92       	push	r8
     aaa:	9f 92       	push	r9
     aac:	af 92       	push	r10
     aae:	bf 92       	push	r11
     ab0:	cf 92       	push	r12
     ab2:	df 92       	push	r13
     ab4:	ef 92       	push	r14
     ab6:	ff 92       	push	r15
     ab8:	0f 93       	push	r16
     aba:	1f 93       	push	r17
     abc:	cf 93       	push	r28
     abe:	df 93       	push	r29
     ac0:	cd b7       	in	r28, 0x3d	; 61
     ac2:	de b7       	in	r29, 0x3e	; 62
     ac4:	aa 97       	sbiw	r28, 0x2a	; 42
     ac6:	0f b6       	in	r0, 0x3f	; 63
     ac8:	f8 94       	cli
     aca:	de bf       	out	0x3e, r29	; 62
     acc:	0f be       	out	0x3f, r0	; 63
     ace:	cd bf       	out	0x3d, r28	; 61
     ad0:	8c 01       	movw	r16, r24
     ad2:	29 8f       	std	Y+25, r18	; 0x19
     ad4:	3a 8f       	std	Y+26, r19	; 0x1a
     ad6:	4b 8f       	std	Y+27, r20	; 0x1b
     ad8:	5c 8f       	std	Y+28, r21	; 0x1c
     ada:	6d 8f       	std	Y+29, r22	; 0x1d
     adc:	7e 8f       	std	Y+30, r23	; 0x1e
     ade:	dc 01       	movw	r26, r24
     ae0:	16 96       	adiw	r26, 0x06	; 6
     ae2:	cd 90       	ld	r12, X+
     ae4:	dc 90       	ld	r13, X
     ae6:	17 97       	sbiw	r26, 0x07	; 7
     ae8:	ee 24       	eor	r14, r14
     aea:	d7 fc       	sbrc	r13, 7
     aec:	e0 94       	com	r14
     aee:	fe 2c       	mov	r15, r14
     af0:	52 96       	adiw	r26, 0x12	; 18
     af2:	4d 91       	ld	r20, X+
     af4:	5c 91       	ld	r21, X
     af6:	53 97       	sbiw	r26, 0x13	; 19
     af8:	66 27       	eor	r22, r22
     afa:	57 fd       	sbrc	r21, 7
     afc:	60 95       	com	r22
     afe:	76 2f       	mov	r23, r22
     b00:	1c 96       	adiw	r26, 0x0c	; 12
     b02:	8d 91       	ld	r24, X+
     b04:	9c 91       	ld	r25, X
     b06:	1d 97       	sbiw	r26, 0x0d	; 13
     b08:	aa 27       	eor	r26, r26
     b0a:	97 fd       	sbrc	r25, 7
     b0c:	a0 95       	com	r26
     b0e:	ba 2f       	mov	r27, r26
     b10:	48 0f       	add	r20, r24
     b12:	59 1f       	adc	r21, r25
     b14:	6a 1f       	adc	r22, r26
     b16:	7b 1f       	adc	r23, r27
     b18:	db 01       	movw	r26, r22
     b1a:	ca 01       	movw	r24, r20
     b1c:	77 23       	and	r23, r23
     b1e:	1c f4       	brge	.+6      	; 0xb26 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x86>
     b20:	01 96       	adiw	r24, 0x01	; 1
     b22:	a1 1d       	adc	r26, r1
     b24:	b1 1d       	adc	r27, r1
     b26:	b5 95       	asr	r27
     b28:	a7 95       	ror	r26
     b2a:	97 95       	ror	r25
     b2c:	87 95       	ror	r24
     b2e:	a7 01       	movw	r20, r14
     b30:	96 01       	movw	r18, r12
     b32:	28 1b       	sub	r18, r24
     b34:	39 0b       	sbc	r19, r25
     b36:	4a 0b       	sbc	r20, r26
     b38:	5b 0b       	sbc	r21, r27
     b3a:	2f 8f       	std	Y+31, r18	; 0x1f
     b3c:	38 a3       	std	Y+32, r19	; 0x20
     b3e:	49 a3       	std	Y+33, r20	; 0x21
     b40:	5a a3       	std	Y+34, r21	; 0x22
     b42:	d8 01       	movw	r26, r16
     b44:	18 96       	adiw	r26, 0x08	; 8
     b46:	cd 90       	ld	r12, X+
     b48:	dc 90       	ld	r13, X
     b4a:	19 97       	sbiw	r26, 0x09	; 9
     b4c:	ee 24       	eor	r14, r14
     b4e:	d7 fc       	sbrc	r13, 7
     b50:	e0 94       	com	r14
     b52:	fe 2c       	mov	r15, r14
     b54:	54 96       	adiw	r26, 0x14	; 20
     b56:	4d 91       	ld	r20, X+
     b58:	5c 91       	ld	r21, X
     b5a:	55 97       	sbiw	r26, 0x15	; 21
     b5c:	66 27       	eor	r22, r22
     b5e:	57 fd       	sbrc	r21, 7
     b60:	60 95       	com	r22
     b62:	76 2f       	mov	r23, r22
     b64:	1e 96       	adiw	r26, 0x0e	; 14
     b66:	8d 91       	ld	r24, X+
     b68:	9c 91       	ld	r25, X
     b6a:	1f 97       	sbiw	r26, 0x0f	; 15
     b6c:	aa 27       	eor	r26, r26
     b6e:	97 fd       	sbrc	r25, 7
     b70:	a0 95       	com	r26
     b72:	ba 2f       	mov	r27, r26
     b74:	48 0f       	add	r20, r24
     b76:	59 1f       	adc	r21, r25
     b78:	6a 1f       	adc	r22, r26
     b7a:	7b 1f       	adc	r23, r27
     b7c:	db 01       	movw	r26, r22
     b7e:	ca 01       	movw	r24, r20
     b80:	77 23       	and	r23, r23
     b82:	1c f4       	brge	.+6      	; 0xb8a <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0xea>
     b84:	01 96       	adiw	r24, 0x01	; 1
     b86:	a1 1d       	adc	r26, r1
     b88:	b1 1d       	adc	r27, r1
     b8a:	b5 95       	asr	r27
     b8c:	a7 95       	ror	r26
     b8e:	97 95       	ror	r25
     b90:	87 95       	ror	r24
     b92:	a7 01       	movw	r20, r14
     b94:	96 01       	movw	r18, r12
     b96:	28 1b       	sub	r18, r24
     b98:	39 0b       	sbc	r19, r25
     b9a:	4a 0b       	sbc	r20, r26
     b9c:	5b 0b       	sbc	r21, r27
     b9e:	2b a3       	std	Y+35, r18	; 0x23
     ba0:	3c a3       	std	Y+36, r19	; 0x24
     ba2:	4d a3       	std	Y+37, r20	; 0x25
     ba4:	5e a3       	std	Y+38, r21	; 0x26
     ba6:	d8 01       	movw	r26, r16
     ba8:	1a 96       	adiw	r26, 0x0a	; 10
     baa:	4d 90       	ld	r4, X+
     bac:	5c 90       	ld	r5, X
     bae:	1b 97       	sbiw	r26, 0x0b	; 11
     bb0:	66 24       	eor	r6, r6
     bb2:	57 fc       	sbrc	r5, 7
     bb4:	60 94       	com	r6
     bb6:	76 2c       	mov	r7, r6
     bb8:	56 96       	adiw	r26, 0x16	; 22
     bba:	4d 91       	ld	r20, X+
     bbc:	5c 91       	ld	r21, X
     bbe:	57 97       	sbiw	r26, 0x17	; 23
     bc0:	66 27       	eor	r22, r22
     bc2:	57 fd       	sbrc	r21, 7
     bc4:	60 95       	com	r22
     bc6:	76 2f       	mov	r23, r22
     bc8:	50 96       	adiw	r26, 0x10	; 16
     bca:	8d 91       	ld	r24, X+
     bcc:	9c 91       	ld	r25, X
     bce:	51 97       	sbiw	r26, 0x11	; 17
     bd0:	aa 27       	eor	r26, r26
     bd2:	97 fd       	sbrc	r25, 7
     bd4:	a0 95       	com	r26
     bd6:	ba 2f       	mov	r27, r26
     bd8:	48 0f       	add	r20, r24
     bda:	59 1f       	adc	r21, r25
     bdc:	6a 1f       	adc	r22, r26
     bde:	7b 1f       	adc	r23, r27
     be0:	db 01       	movw	r26, r22
     be2:	ca 01       	movw	r24, r20
     be4:	77 23       	and	r23, r23
     be6:	1c f4       	brge	.+6      	; 0xbee <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x14e>
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	a1 1d       	adc	r26, r1
     bec:	b1 1d       	adc	r27, r1
     bee:	b5 95       	asr	r27
     bf0:	a7 95       	ror	r26
     bf2:	97 95       	ror	r25
     bf4:	87 95       	ror	r24
     bf6:	48 1a       	sub	r4, r24
     bf8:	59 0a       	sbc	r5, r25
     bfa:	6a 0a       	sbc	r6, r26
     bfc:	7b 0a       	sbc	r7, r27
     bfe:	f8 01       	movw	r30, r16
     c00:	84 80       	ldd	r8, Z+4	; 0x04
     c02:	95 80       	ldd	r9, Z+5	; 0x05
     c04:	aa 24       	eor	r10, r10
     c06:	97 fc       	sbrc	r9, 7
     c08:	a0 94       	com	r10
     c0a:	ba 2c       	mov	r11, r10
     c0c:	82 81       	ldd	r24, Z+2	; 0x02
     c0e:	93 81       	ldd	r25, Z+3	; 0x03
     c10:	9c 01       	movw	r18, r24
     c12:	44 27       	eor	r20, r20
     c14:	37 fd       	sbrc	r19, 7
     c16:	40 95       	com	r20
     c18:	54 2f       	mov	r21, r20
     c1a:	2f a3       	std	Y+39, r18	; 0x27
     c1c:	38 a7       	std	Y+40, r19	; 0x28
     c1e:	49 a7       	std	Y+41, r20	; 0x29
     c20:	5a a7       	std	Y+42, r21	; 0x2a
     c22:	2b a1       	ldd	r18, Y+35	; 0x23
     c24:	3c a1       	ldd	r19, Y+36	; 0x24
     c26:	4d a1       	ldd	r20, Y+37	; 0x25
     c28:	5e a1       	ldd	r21, Y+38	; 0x26
     c2a:	c5 01       	movw	r24, r10
     c2c:	b4 01       	movw	r22, r8
     c2e:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__mulsi3>
     c32:	6b 01       	movw	r12, r22
     c34:	7c 01       	movw	r14, r24
     c36:	a3 01       	movw	r20, r6
     c38:	92 01       	movw	r18, r4
     c3a:	6f a1       	ldd	r22, Y+39	; 0x27
     c3c:	78 a5       	ldd	r23, Y+40	; 0x28
     c3e:	89 a5       	ldd	r24, Y+41	; 0x29
     c40:	9a a5       	ldd	r25, Y+42	; 0x2a
     c42:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__mulsi3>
     c46:	a7 01       	movw	r20, r14
     c48:	96 01       	movw	r18, r12
     c4a:	26 1b       	sub	r18, r22
     c4c:	37 0b       	sbc	r19, r23
     c4e:	48 0b       	sbc	r20, r24
     c50:	59 0b       	sbc	r21, r25
     c52:	ca 01       	movw	r24, r20
     c54:	b9 01       	movw	r22, r18
     c56:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     c5a:	6d 87       	std	Y+13, r22	; 0x0d
     c5c:	7e 87       	std	Y+14, r23	; 0x0e
     c5e:	8f 87       	std	Y+15, r24	; 0x0f
     c60:	98 8b       	std	Y+16, r25	; 0x10
     c62:	d8 01       	movw	r26, r16
     c64:	cd 90       	ld	r12, X+
     c66:	dc 90       	ld	r13, X
     c68:	ee 24       	eor	r14, r14
     c6a:	d7 fc       	sbrc	r13, 7
     c6c:	e0 94       	com	r14
     c6e:	fe 2c       	mov	r15, r14
     c70:	a3 01       	movw	r20, r6
     c72:	92 01       	movw	r18, r4
     c74:	c7 01       	movw	r24, r14
     c76:	b6 01       	movw	r22, r12
     c78:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__mulsi3>
     c7c:	2b 01       	movw	r4, r22
     c7e:	3c 01       	movw	r6, r24
     c80:	2f 8d       	ldd	r18, Y+31	; 0x1f
     c82:	38 a1       	ldd	r19, Y+32	; 0x20
     c84:	49 a1       	ldd	r20, Y+33	; 0x21
     c86:	5a a1       	ldd	r21, Y+34	; 0x22
     c88:	c5 01       	movw	r24, r10
     c8a:	b4 01       	movw	r22, r8
     c8c:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__mulsi3>
     c90:	a3 01       	movw	r20, r6
     c92:	92 01       	movw	r18, r4
     c94:	26 1b       	sub	r18, r22
     c96:	37 0b       	sbc	r19, r23
     c98:	48 0b       	sbc	r20, r24
     c9a:	59 0b       	sbc	r21, r25
     c9c:	ca 01       	movw	r24, r20
     c9e:	b9 01       	movw	r22, r18
     ca0:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     ca4:	69 8b       	std	Y+17, r22	; 0x11
     ca6:	7a 8b       	std	Y+18, r23	; 0x12
     ca8:	8b 8b       	std	Y+19, r24	; 0x13
     caa:	9c 8b       	std	Y+20, r25	; 0x14
     cac:	2f 8d       	ldd	r18, Y+31	; 0x1f
     cae:	38 a1       	ldd	r19, Y+32	; 0x20
     cb0:	49 a1       	ldd	r20, Y+33	; 0x21
     cb2:	5a a1       	ldd	r21, Y+34	; 0x22
     cb4:	6f a1       	ldd	r22, Y+39	; 0x27
     cb6:	78 a5       	ldd	r23, Y+40	; 0x28
     cb8:	89 a5       	ldd	r24, Y+41	; 0x29
     cba:	9a a5       	ldd	r25, Y+42	; 0x2a
     cbc:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__mulsi3>
     cc0:	4b 01       	movw	r8, r22
     cc2:	5c 01       	movw	r10, r24
     cc4:	2b a1       	ldd	r18, Y+35	; 0x23
     cc6:	3c a1       	ldd	r19, Y+36	; 0x24
     cc8:	4d a1       	ldd	r20, Y+37	; 0x25
     cca:	5e a1       	ldd	r21, Y+38	; 0x26
     ccc:	c7 01       	movw	r24, r14
     cce:	b6 01       	movw	r22, r12
     cd0:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__mulsi3>
     cd4:	a5 01       	movw	r20, r10
     cd6:	94 01       	movw	r18, r8
     cd8:	26 1b       	sub	r18, r22
     cda:	37 0b       	sbc	r19, r23
     cdc:	48 0b       	sbc	r20, r24
     cde:	59 0b       	sbc	r21, r25
     ce0:	ca 01       	movw	r24, r20
     ce2:	b9 01       	movw	r22, r18
     ce4:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     ce8:	6d 8b       	std	Y+21, r22	; 0x15
     cea:	7e 8b       	std	Y+22, r23	; 0x16
     cec:	8f 8b       	std	Y+23, r24	; 0x17
     cee:	98 8f       	std	Y+24, r25	; 0x18
     cf0:	ce 01       	movw	r24, r28
     cf2:	0d 96       	adiw	r24, 0x0d	; 13
     cf4:	48 de       	rcall	.-880    	; 0x986 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     cf6:	d8 01       	movw	r26, r16
     cf8:	12 96       	adiw	r26, 0x02	; 2
     cfa:	6d 91       	ld	r22, X+
     cfc:	7c 91       	ld	r23, X
     cfe:	13 97       	sbiw	r26, 0x03	; 3
     d00:	88 27       	eor	r24, r24
     d02:	77 fd       	sbrc	r23, 7
     d04:	80 95       	com	r24
     d06:	98 2f       	mov	r25, r24
     d08:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     d0c:	6b 01       	movw	r12, r22
     d0e:	7c 01       	movw	r14, r24
     d10:	2d 89       	ldd	r18, Y+21	; 0x15
     d12:	3e 89       	ldd	r19, Y+22	; 0x16
     d14:	4f 89       	ldd	r20, Y+23	; 0x17
     d16:	58 8d       	ldd	r21, Y+24	; 0x18
     d18:	2f 8f       	std	Y+31, r18	; 0x1f
     d1a:	38 a3       	std	Y+32, r19	; 0x20
     d1c:	49 a3       	std	Y+33, r20	; 0x21
     d1e:	5a a3       	std	Y+34, r21	; 0x22
     d20:	d8 01       	movw	r26, r16
     d22:	14 96       	adiw	r26, 0x04	; 4
     d24:	6d 91       	ld	r22, X+
     d26:	7c 91       	ld	r23, X
     d28:	15 97       	sbiw	r26, 0x05	; 5
     d2a:	88 27       	eor	r24, r24
     d2c:	77 fd       	sbrc	r23, 7
     d2e:	80 95       	com	r24
     d30:	98 2f       	mov	r25, r24
     d32:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     d36:	2b 01       	movw	r4, r22
     d38:	3c 01       	movw	r6, r24
     d3a:	29 89       	ldd	r18, Y+17	; 0x11
     d3c:	3a 89       	ldd	r19, Y+18	; 0x12
     d3e:	4b 89       	ldd	r20, Y+19	; 0x13
     d40:	5c 89       	ldd	r21, Y+20	; 0x14
     d42:	2b a3       	std	Y+35, r18	; 0x23
     d44:	3c a3       	std	Y+36, r19	; 0x24
     d46:	4d a3       	std	Y+37, r20	; 0x25
     d48:	5e a3       	std	Y+38, r21	; 0x26
     d4a:	2f 8d       	ldd	r18, Y+31	; 0x1f
     d4c:	38 a1       	ldd	r19, Y+32	; 0x20
     d4e:	49 a1       	ldd	r20, Y+33	; 0x21
     d50:	5a a1       	ldd	r21, Y+34	; 0x22
     d52:	c7 01       	movw	r24, r14
     d54:	b6 01       	movw	r22, r12
     d56:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     d5a:	4b 01       	movw	r8, r22
     d5c:	5c 01       	movw	r10, r24
     d5e:	2b a1       	ldd	r18, Y+35	; 0x23
     d60:	3c a1       	ldd	r19, Y+36	; 0x24
     d62:	4d a1       	ldd	r20, Y+37	; 0x25
     d64:	5e a1       	ldd	r21, Y+38	; 0x26
     d66:	c3 01       	movw	r24, r6
     d68:	b2 01       	movw	r22, r4
     d6a:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     d6e:	9b 01       	movw	r18, r22
     d70:	ac 01       	movw	r20, r24
     d72:	c5 01       	movw	r24, r10
     d74:	b4 01       	movw	r22, r8
     d76:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <__subsf3>
     d7a:	69 83       	std	Y+1, r22	; 0x01
     d7c:	7a 83       	std	Y+2, r23	; 0x02
     d7e:	8b 83       	std	Y+3, r24	; 0x03
     d80:	9c 83       	std	Y+4, r25	; 0x04
     d82:	8d 85       	ldd	r24, Y+13	; 0x0d
     d84:	9e 85       	ldd	r25, Y+14	; 0x0e
     d86:	af 85       	ldd	r26, Y+15	; 0x0f
     d88:	b8 89       	ldd	r27, Y+16	; 0x10
     d8a:	8f a3       	std	Y+39, r24	; 0x27
     d8c:	98 a7       	std	Y+40, r25	; 0x28
     d8e:	a9 a7       	std	Y+41, r26	; 0x29
     d90:	ba a7       	std	Y+42, r27	; 0x2a
     d92:	d8 01       	movw	r26, r16
     d94:	6d 91       	ld	r22, X+
     d96:	7c 91       	ld	r23, X
     d98:	88 27       	eor	r24, r24
     d9a:	77 fd       	sbrc	r23, 7
     d9c:	80 95       	com	r24
     d9e:	98 2f       	mov	r25, r24
     da0:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     da4:	4b 01       	movw	r8, r22
     da6:	5c 01       	movw	r10, r24
     da8:	2f a1       	ldd	r18, Y+39	; 0x27
     daa:	38 a5       	ldd	r19, Y+40	; 0x28
     dac:	49 a5       	ldd	r20, Y+41	; 0x29
     dae:	5a a5       	ldd	r21, Y+42	; 0x2a
     db0:	c3 01       	movw	r24, r6
     db2:	b2 01       	movw	r22, r4
     db4:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     db8:	2b 01       	movw	r4, r22
     dba:	3c 01       	movw	r6, r24
     dbc:	a5 01       	movw	r20, r10
     dbe:	94 01       	movw	r18, r8
     dc0:	6f 8d       	ldd	r22, Y+31	; 0x1f
     dc2:	78 a1       	ldd	r23, Y+32	; 0x20
     dc4:	89 a1       	ldd	r24, Y+33	; 0x21
     dc6:	9a a1       	ldd	r25, Y+34	; 0x22
     dc8:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     dcc:	9b 01       	movw	r18, r22
     dce:	ac 01       	movw	r20, r24
     dd0:	c3 01       	movw	r24, r6
     dd2:	b2 01       	movw	r22, r4
     dd4:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <__subsf3>
     dd8:	6d 83       	std	Y+5, r22	; 0x05
     dda:	7e 83       	std	Y+6, r23	; 0x06
     ddc:	8f 83       	std	Y+7, r24	; 0x07
     dde:	98 87       	std	Y+8, r25	; 0x08
     de0:	a5 01       	movw	r20, r10
     de2:	94 01       	movw	r18, r8
     de4:	6b a1       	ldd	r22, Y+35	; 0x23
     de6:	7c a1       	ldd	r23, Y+36	; 0x24
     de8:	8d a1       	ldd	r24, Y+37	; 0x25
     dea:	9e a1       	ldd	r25, Y+38	; 0x26
     dec:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     df0:	4b 01       	movw	r8, r22
     df2:	5c 01       	movw	r10, r24
     df4:	2f a1       	ldd	r18, Y+39	; 0x27
     df6:	38 a5       	ldd	r19, Y+40	; 0x28
     df8:	49 a5       	ldd	r20, Y+41	; 0x29
     dfa:	5a a5       	ldd	r21, Y+42	; 0x2a
     dfc:	c7 01       	movw	r24, r14
     dfe:	b6 01       	movw	r22, r12
     e00:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     e04:	9b 01       	movw	r18, r22
     e06:	ac 01       	movw	r20, r24
     e08:	c5 01       	movw	r24, r10
     e0a:	b4 01       	movw	r22, r8
     e0c:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <__subsf3>
     e10:	69 87       	std	Y+9, r22	; 0x09
     e12:	7a 87       	std	Y+10, r23	; 0x0a
     e14:	8b 87       	std	Y+11, r24	; 0x0b
     e16:	9c 87       	std	Y+12, r25	; 0x0c
     e18:	ce 01       	movw	r24, r28
     e1a:	01 96       	adiw	r24, 0x01	; 1
     e1c:	b4 dd       	rcall	.-1176   	; 0x986 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     e1e:	69 8d       	ldd	r22, Y+25	; 0x19
     e20:	7a 8d       	ldd	r23, Y+26	; 0x1a
     e22:	88 27       	eor	r24, r24
     e24:	77 fd       	sbrc	r23, 7
     e26:	80 95       	com	r24
     e28:	98 2f       	mov	r25, r24
     e2a:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     e2e:	2b 01       	movw	r4, r22
     e30:	3c 01       	movw	r6, r24
     e32:	6b 8d       	ldd	r22, Y+27	; 0x1b
     e34:	7c 8d       	ldd	r23, Y+28	; 0x1c
     e36:	88 27       	eor	r24, r24
     e38:	77 fd       	sbrc	r23, 7
     e3a:	80 95       	com	r24
     e3c:	98 2f       	mov	r25, r24
     e3e:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     e42:	4b 01       	movw	r8, r22
     e44:	5c 01       	movw	r10, r24
     e46:	6d 8d       	ldd	r22, Y+29	; 0x1d
     e48:	7e 8d       	ldd	r23, Y+30	; 0x1e
     e4a:	88 27       	eor	r24, r24
     e4c:	77 fd       	sbrc	r23, 7
     e4e:	80 95       	com	r24
     e50:	98 2f       	mov	r25, r24
     e52:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
     e56:	6b 01       	movw	r12, r22
     e58:	7c 01       	movw	r14, r24
     e5a:	29 81       	ldd	r18, Y+1	; 0x01
     e5c:	3a 81       	ldd	r19, Y+2	; 0x02
     e5e:	4b 81       	ldd	r20, Y+3	; 0x03
     e60:	5c 81       	ldd	r21, Y+4	; 0x04
     e62:	c3 01       	movw	r24, r6
     e64:	b2 01       	movw	r22, r4
     e66:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     e6a:	6f 8f       	std	Y+31, r22	; 0x1f
     e6c:	78 a3       	std	Y+32, r23	; 0x20
     e6e:	89 a3       	std	Y+33, r24	; 0x21
     e70:	9a a3       	std	Y+34, r25	; 0x22
     e72:	2d 81       	ldd	r18, Y+5	; 0x05
     e74:	3e 81       	ldd	r19, Y+6	; 0x06
     e76:	4f 81       	ldd	r20, Y+7	; 0x07
     e78:	58 85       	ldd	r21, Y+8	; 0x08
     e7a:	c5 01       	movw	r24, r10
     e7c:	b4 01       	movw	r22, r8
     e7e:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     e82:	9b 01       	movw	r18, r22
     e84:	ac 01       	movw	r20, r24
     e86:	6f 8d       	ldd	r22, Y+31	; 0x1f
     e88:	78 a1       	ldd	r23, Y+32	; 0x20
     e8a:	89 a1       	ldd	r24, Y+33	; 0x21
     e8c:	9a a1       	ldd	r25, Y+34	; 0x22
     e8e:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     e92:	6f 8f       	std	Y+31, r22	; 0x1f
     e94:	78 a3       	std	Y+32, r23	; 0x20
     e96:	89 a3       	std	Y+33, r24	; 0x21
     e98:	9a a3       	std	Y+34, r25	; 0x22
     e9a:	29 85       	ldd	r18, Y+9	; 0x09
     e9c:	3a 85       	ldd	r19, Y+10	; 0x0a
     e9e:	4b 85       	ldd	r20, Y+11	; 0x0b
     ea0:	5c 85       	ldd	r21, Y+12	; 0x0c
     ea2:	c7 01       	movw	r24, r14
     ea4:	b6 01       	movw	r22, r12
     ea6:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     eaa:	9b 01       	movw	r18, r22
     eac:	ac 01       	movw	r20, r24
     eae:	6f 8d       	ldd	r22, Y+31	; 0x1f
     eb0:	78 a1       	ldd	r23, Y+32	; 0x20
     eb2:	89 a1       	ldd	r24, Y+33	; 0x21
     eb4:	9a a1       	ldd	r25, Y+34	; 0x22
     eb6:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     eba:	6f 8f       	std	Y+31, r22	; 0x1f
     ebc:	78 a3       	std	Y+32, r23	; 0x20
     ebe:	89 a3       	std	Y+33, r24	; 0x21
     ec0:	9a a3       	std	Y+34, r25	; 0x22
     ec2:	2d 85       	ldd	r18, Y+13	; 0x0d
     ec4:	3e 85       	ldd	r19, Y+14	; 0x0e
     ec6:	4f 85       	ldd	r20, Y+15	; 0x0f
     ec8:	58 89       	ldd	r21, Y+16	; 0x10
     eca:	c3 01       	movw	r24, r6
     ecc:	b2 01       	movw	r22, r4
     ece:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     ed2:	2b 01       	movw	r4, r22
     ed4:	3c 01       	movw	r6, r24
     ed6:	29 89       	ldd	r18, Y+17	; 0x11
     ed8:	3a 89       	ldd	r19, Y+18	; 0x12
     eda:	4b 89       	ldd	r20, Y+19	; 0x13
     edc:	5c 89       	ldd	r21, Y+20	; 0x14
     ede:	c5 01       	movw	r24, r10
     ee0:	b4 01       	movw	r22, r8
     ee2:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     ee6:	9b 01       	movw	r18, r22
     ee8:	ac 01       	movw	r20, r24
     eea:	c3 01       	movw	r24, r6
     eec:	b2 01       	movw	r22, r4
     eee:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     ef2:	4b 01       	movw	r8, r22
     ef4:	5c 01       	movw	r10, r24
     ef6:	2d 89       	ldd	r18, Y+21	; 0x15
     ef8:	3e 89       	ldd	r19, Y+22	; 0x16
     efa:	4f 89       	ldd	r20, Y+23	; 0x17
     efc:	58 8d       	ldd	r21, Y+24	; 0x18
     efe:	c7 01       	movw	r24, r14
     f00:	b6 01       	movw	r22, r12
     f02:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     f06:	9b 01       	movw	r18, r22
     f08:	ac 01       	movw	r20, r24
     f0a:	c5 01       	movw	r24, r10
     f0c:	b4 01       	movw	r22, r8
     f0e:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     f12:	2f 8d       	ldd	r18, Y+31	; 0x1f
     f14:	38 a1       	ldd	r19, Y+32	; 0x20
     f16:	49 a1       	ldd	r20, Y+33	; 0x21
     f18:	5a a1       	ldd	r21, Y+34	; 0x22
     f1a:	0e 94 29 16 	call	0x2c52	; 0x2c52 <atan2>
     f1e:	20 e0       	ldi	r18, 0x00	; 0
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	44 e3       	ldi	r20, 0x34	; 52
     f24:	53 e4       	ldi	r21, 0x43	; 67
     f26:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
     f2a:	2b ed       	ldi	r18, 0xDB	; 219
     f2c:	3f e0       	ldi	r19, 0x0F	; 15
     f2e:	49 e4       	ldi	r20, 0x49	; 73
     f30:	50 e4       	ldi	r21, 0x40	; 64
     f32:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
     f36:	6b 01       	movw	r12, r22
     f38:	7c 01       	movw	r14, r24
     f3a:	20 e0       	ldi	r18, 0x00	; 0
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	a9 01       	movw	r20, r18
     f40:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <__cmpsf2>
     f44:	88 23       	and	r24, r24
     f46:	54 f4       	brge	.+20     	; 0xf5c <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x4bc>
     f48:	20 e0       	ldi	r18, 0x00	; 0
     f4a:	30 e0       	ldi	r19, 0x00	; 0
     f4c:	44 eb       	ldi	r20, 0xB4	; 180
     f4e:	53 e4       	ldi	r21, 0x43	; 67
     f50:	c7 01       	movw	r24, r14
     f52:	b6 01       	movw	r22, r12
     f54:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <__addsf3>
     f58:	6b 01       	movw	r12, r22
     f5a:	7c 01       	movw	r14, r24
     f5c:	c7 01       	movw	r24, r14
     f5e:	b6 01       	movw	r22, r12
     f60:	aa 96       	adiw	r28, 0x2a	; 42
     f62:	0f b6       	in	r0, 0x3f	; 63
     f64:	f8 94       	cli
     f66:	de bf       	out	0x3e, r29	; 62
     f68:	0f be       	out	0x3f, r0	; 63
     f6a:	cd bf       	out	0x3d, r28	; 61
     f6c:	df 91       	pop	r29
     f6e:	cf 91       	pop	r28
     f70:	1f 91       	pop	r17
     f72:	0f 91       	pop	r16
     f74:	ff 90       	pop	r15
     f76:	ef 90       	pop	r14
     f78:	df 90       	pop	r13
     f7a:	cf 90       	pop	r12
     f7c:	bf 90       	pop	r11
     f7e:	af 90       	pop	r10
     f80:	9f 90       	pop	r9
     f82:	8f 90       	pop	r8
     f84:	7f 90       	pop	r7
     f86:	6f 90       	pop	r6
     f88:	5f 90       	pop	r5
     f8a:	4f 90       	pop	r4
     f8c:	08 95       	ret

00000f8e <_ZN6LSM3037headingEv>:
     f8e:	cf 93       	push	r28
     f90:	df 93       	push	r29
     f92:	cd b7       	in	r28, 0x3d	; 61
     f94:	de b7       	in	r29, 0x3e	; 62
     f96:	2c 97       	sbiw	r28, 0x0c	; 12
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	f8 94       	cli
     f9c:	de bf       	out	0x3e, r29	; 62
     f9e:	0f be       	out	0x3f, r0	; 63
     fa0:	cd bf       	out	0x3d, r28	; 61
     fa2:	fc 01       	movw	r30, r24
     fa4:	21 8d       	ldd	r18, Z+25	; 0x19
     fa6:	23 30       	cpi	r18, 0x03	; 3
     fa8:	79 f4       	brne	.+30     	; 0xfc8 <_ZN6LSM3037headingEv+0x3a>
     faa:	31 e0       	ldi	r19, 0x01	; 1
     fac:	23 2f       	mov	r18, r19
     fae:	3f 83       	std	Y+7, r19	; 0x07
     fb0:	18 86       	std	Y+8, r1	; 0x08
     fb2:	1a 86       	std	Y+10, r1	; 0x0a
     fb4:	19 86       	std	Y+9, r1	; 0x09
     fb6:	1c 86       	std	Y+12, r1	; 0x0c
     fb8:	1b 86       	std	Y+11, r1	; 0x0b
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	40 e0       	ldi	r20, 0x00	; 0
     fbe:	5a 85       	ldd	r21, Y+10	; 0x0a
     fc0:	60 e0       	ldi	r22, 0x00	; 0
     fc2:	7c 85       	ldd	r23, Y+12	; 0x0c
     fc4:	6d dd       	rcall	.-1318   	; 0xaa0 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
     fc6:	0e c0       	rjmp	.+28     	; 0xfe4 <_ZN6LSM3037headingEv+0x56>
     fc8:	1a 82       	std	Y+2, r1	; 0x02
     fca:	19 82       	std	Y+1, r1	; 0x01
     fcc:	2f ef       	ldi	r18, 0xFF	; 255
     fce:	42 2f       	mov	r20, r18
     fd0:	2b 83       	std	Y+3, r18	; 0x03
     fd2:	2c 83       	std	Y+4, r18	; 0x04
     fd4:	1e 82       	std	Y+6, r1	; 0x06
     fd6:	1d 82       	std	Y+5, r1	; 0x05
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	3a 81       	ldd	r19, Y+2	; 0x02
     fdc:	5f ef       	ldi	r21, 0xFF	; 255
     fde:	60 e0       	ldi	r22, 0x00	; 0
     fe0:	7e 81       	ldd	r23, Y+6	; 0x06
     fe2:	5e dd       	rcall	.-1348   	; 0xaa0 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
     fe4:	2c 96       	adiw	r28, 0x0c	; 12
     fe6:	0f b6       	in	r0, 0x3f	; 63
     fe8:	f8 94       	cli
     fea:	de bf       	out	0x3e, r29	; 62
     fec:	0f be       	out	0x3f, r0	; 63
     fee:	cd bf       	out	0x3d, r28	; 61
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	08 95       	ret

00000ff6 <_ZN6LSM30311writeAccRegEhh>:
     ff6:	0f 93       	push	r16
     ff8:	1f 93       	push	r17
     ffa:	cf 93       	push	r28
     ffc:	df 93       	push	r29
     ffe:	ec 01       	movw	r28, r24
    1000:	06 2f       	mov	r16, r22
    1002:	14 2f       	mov	r17, r20
    1004:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1006:	85 e9       	ldi	r24, 0x95	; 149
    1008:	99 e0       	ldi	r25, 0x09	; 9
    100a:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
    100e:	60 2f       	mov	r22, r16
    1010:	85 e9       	ldi	r24, 0x95	; 149
    1012:	99 e0       	ldi	r25, 0x09	; 9
    1014:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
    1018:	61 2f       	mov	r22, r17
    101a:	85 e9       	ldi	r24, 0x95	; 149
    101c:	99 e0       	ldi	r25, 0x09	; 9
    101e:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
    1022:	85 e9       	ldi	r24, 0x95	; 149
    1024:	99 e0       	ldi	r25, 0x09	; 9
    1026:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
    102a:	88 8f       	std	Y+24, r24	; 0x18
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	1f 91       	pop	r17
    1032:	0f 91       	pop	r16
    1034:	08 95       	ret

00001036 <_ZN6LSM30311writeMagRegEhh>:
    1036:	0f 93       	push	r16
    1038:	1f 93       	push	r17
    103a:	cf 93       	push	r28
    103c:	df 93       	push	r29
    103e:	ec 01       	movw	r28, r24
    1040:	06 2f       	mov	r16, r22
    1042:	14 2f       	mov	r17, r20
    1044:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1046:	85 e9       	ldi	r24, 0x95	; 149
    1048:	99 e0       	ldi	r25, 0x09	; 9
    104a:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
    104e:	60 2f       	mov	r22, r16
    1050:	85 e9       	ldi	r24, 0x95	; 149
    1052:	99 e0       	ldi	r25, 0x09	; 9
    1054:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
    1058:	61 2f       	mov	r22, r17
    105a:	85 e9       	ldi	r24, 0x95	; 149
    105c:	99 e0       	ldi	r25, 0x09	; 9
    105e:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
    1062:	85 e9       	ldi	r24, 0x95	; 149
    1064:	99 e0       	ldi	r25, 0x09	; 9
    1066:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
    106a:	88 8f       	std	Y+24, r24	; 0x18
    106c:	df 91       	pop	r29
    106e:	cf 91       	pop	r28
    1070:	1f 91       	pop	r17
    1072:	0f 91       	pop	r16
    1074:	08 95       	ret

00001076 <_ZN6LSM3038writeRegEhh>:
    1076:	fc 01       	movw	r30, r24
    1078:	21 8d       	ldd	r18, Z+25	; 0x19
    107a:	23 30       	cpi	r18, 0x03	; 3
    107c:	11 f0       	breq	.+4      	; 0x1082 <_ZN6LSM3038writeRegEhh+0xc>
    107e:	60 32       	cpi	r22, 0x20	; 32
    1080:	10 f4       	brcc	.+4      	; 0x1086 <_ZN6LSM3038writeRegEhh+0x10>
    1082:	d9 cf       	rjmp	.-78     	; 0x1036 <_ZN6LSM30311writeMagRegEhh>
    1084:	08 95       	ret
    1086:	b7 cf       	rjmp	.-146    	; 0xff6 <_ZN6LSM30311writeAccRegEhh>
    1088:	08 95       	ret

0000108a <_ZN6LSM30313enableDefaultEv>:
    108a:	cf 93       	push	r28
    108c:	df 93       	push	r29
    108e:	ec 01       	movw	r28, r24
    1090:	89 8d       	ldd	r24, Y+25	; 0x19
    1092:	83 30       	cpi	r24, 0x03	; 3
    1094:	a9 f4       	brne	.+42     	; 0x10c0 <_ZN6LSM30313enableDefaultEv+0x36>
    1096:	40 e0       	ldi	r20, 0x00	; 0
    1098:	61 e2       	ldi	r22, 0x21	; 33
    109a:	ce 01       	movw	r24, r28
    109c:	ec df       	rcall	.-40     	; 0x1076 <_ZN6LSM3038writeRegEhh>
    109e:	47 e5       	ldi	r20, 0x57	; 87
    10a0:	60 e2       	ldi	r22, 0x20	; 32
    10a2:	ce 01       	movw	r24, r28
    10a4:	e8 df       	rcall	.-48     	; 0x1076 <_ZN6LSM3038writeRegEhh>
    10a6:	44 e6       	ldi	r20, 0x64	; 100
    10a8:	64 e2       	ldi	r22, 0x24	; 36
    10aa:	ce 01       	movw	r24, r28
    10ac:	e4 df       	rcall	.-56     	; 0x1076 <_ZN6LSM3038writeRegEhh>
    10ae:	40 e2       	ldi	r20, 0x20	; 32
    10b0:	65 e2       	ldi	r22, 0x25	; 37
    10b2:	ce 01       	movw	r24, r28
    10b4:	e0 df       	rcall	.-64     	; 0x1076 <_ZN6LSM3038writeRegEhh>
    10b6:	40 e0       	ldi	r20, 0x00	; 0
    10b8:	66 e2       	ldi	r22, 0x26	; 38
    10ba:	ce 01       	movw	r24, r28
    10bc:	dc df       	rcall	.-72     	; 0x1076 <_ZN6LSM3038writeRegEhh>
    10be:	1f c0       	rjmp	.+62     	; 0x10fe <_ZN6LSM30313enableDefaultEv+0x74>
    10c0:	82 30       	cpi	r24, 0x02	; 2
    10c2:	49 f4       	brne	.+18     	; 0x10d6 <_ZN6LSM30313enableDefaultEv+0x4c>
    10c4:	48 e0       	ldi	r20, 0x08	; 8
    10c6:	63 e2       	ldi	r22, 0x23	; 35
    10c8:	ce 01       	movw	r24, r28
    10ca:	95 df       	rcall	.-214    	; 0xff6 <_ZN6LSM30311writeAccRegEhh>
    10cc:	47 e4       	ldi	r20, 0x47	; 71
    10ce:	60 e2       	ldi	r22, 0x20	; 32
    10d0:	ce 01       	movw	r24, r28
    10d2:	91 df       	rcall	.-222    	; 0xff6 <_ZN6LSM30311writeAccRegEhh>
    10d4:	08 c0       	rjmp	.+16     	; 0x10e6 <_ZN6LSM30313enableDefaultEv+0x5c>
    10d6:	40 e0       	ldi	r20, 0x00	; 0
    10d8:	63 e2       	ldi	r22, 0x23	; 35
    10da:	ce 01       	movw	r24, r28
    10dc:	8c df       	rcall	.-232    	; 0xff6 <_ZN6LSM30311writeAccRegEhh>
    10de:	47 e2       	ldi	r20, 0x27	; 39
    10e0:	60 e2       	ldi	r22, 0x20	; 32
    10e2:	ce 01       	movw	r24, r28
    10e4:	88 df       	rcall	.-240    	; 0xff6 <_ZN6LSM30311writeAccRegEhh>
    10e6:	4c e0       	ldi	r20, 0x0C	; 12
    10e8:	60 e0       	ldi	r22, 0x00	; 0
    10ea:	ce 01       	movw	r24, r28
    10ec:	a4 df       	rcall	.-184    	; 0x1036 <_ZN6LSM30311writeMagRegEhh>
    10ee:	40 e2       	ldi	r20, 0x20	; 32
    10f0:	61 e0       	ldi	r22, 0x01	; 1
    10f2:	ce 01       	movw	r24, r28
    10f4:	a0 df       	rcall	.-192    	; 0x1036 <_ZN6LSM30311writeMagRegEhh>
    10f6:	40 e0       	ldi	r20, 0x00	; 0
    10f8:	62 e0       	ldi	r22, 0x02	; 2
    10fa:	ce 01       	movw	r24, r28
    10fc:	9c df       	rcall	.-200    	; 0x1036 <_ZN6LSM30311writeMagRegEhh>
    10fe:	df 91       	pop	r29
    1100:	cf 91       	pop	r28
    1102:	08 95       	ret

00001104 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
    1104:	9f 92       	push	r9
    1106:	af 92       	push	r10
    1108:	bf 92       	push	r11
    110a:	cf 92       	push	r12
    110c:	df 92       	push	r13
    110e:	ef 92       	push	r14
    1110:	ff 92       	push	r15
    1112:	0f 93       	push	r16
    1114:	1f 93       	push	r17
    1116:	cf 93       	push	r28
    1118:	df 93       	push	r29
    111a:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
    111c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    111e:	85 e9       	ldi	r24, 0x95	; 149
    1120:	99 e0       	ldi	r25, 0x09	; 9
    1122:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
    1126:	e0 91 95 09 	lds	r30, 0x0995
    112a:	f0 91 96 09 	lds	r31, 0x0996
    112e:	01 90       	ld	r0, Z+
    1130:	f0 81       	ld	r31, Z
    1132:	e0 2d       	mov	r30, r0
    1134:	68 ea       	ldi	r22, 0xA8	; 168
    1136:	85 e9       	ldi	r24, 0x95	; 149
    1138:	99 e0       	ldi	r25, 0x09	; 9
    113a:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
    113c:	85 e9       	ldi	r24, 0x95	; 149
    113e:	99 e0       	ldi	r25, 0x09	; 9
    1140:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
    1144:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
    1146:	46 e0       	ldi	r20, 0x06	; 6
    1148:	6a 8d       	ldd	r22, Y+26	; 0x1a
    114a:	85 e9       	ldi	r24, 0x95	; 149
    114c:	99 e0       	ldi	r25, 0x09	; 9
    114e:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    1152:	0e 94 b2 1b 	call	0x3764	; 0x3764 <millis>
    1156:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    1158:	10 c0       	rjmp	.+32     	; 0x117a <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    115a:	8b a1       	ldd	r24, Y+35	; 0x23
    115c:	9c a1       	ldd	r25, Y+36	; 0x24
    115e:	89 2b       	or	r24, r25
    1160:	61 f0       	breq	.+24     	; 0x117a <_ZN6LSM3037readAccEv+0x76>
    1162:	0e 94 b2 1b 	call	0x3764	; 0x3764 <millis>
    1166:	60 1b       	sub	r22, r16
    1168:	71 0b       	sbc	r23, r17
    116a:	8b a1       	ldd	r24, Y+35	; 0x23
    116c:	9c a1       	ldd	r25, Y+36	; 0x24
    116e:	86 17       	cp	r24, r22
    1170:	97 07       	cpc	r25, r23
    1172:	18 f4       	brcc	.+6      	; 0x117a <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
    1174:	81 e0       	ldi	r24, 0x01	; 1
    1176:	8d a3       	std	Y+37, r24	; 0x25
      return;
    1178:	32 c0       	rjmp	.+100    	; 0x11de <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    117a:	85 e9       	ldi	r24, 0x95	; 149
    117c:	99 e0       	ldi	r25, 0x09	; 9
    117e:	0e 94 df 14 	call	0x29be	; 0x29be <_ZN7TwoWire9availableEv>
    1182:	06 97       	sbiw	r24, 0x06	; 6
    1184:	54 f3       	brlt	.-44     	; 0x115a <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
    1186:	85 e9       	ldi	r24, 0x95	; 149
    1188:	99 e0       	ldi	r25, 0x09	; 9
    118a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    118e:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
    1190:	85 e9       	ldi	r24, 0x95	; 149
    1192:	99 e0       	ldi	r25, 0x09	; 9
    1194:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    1198:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
    119a:	85 e9       	ldi	r24, 0x95	; 149
    119c:	99 e0       	ldi	r25, 0x09	; 9
    119e:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    11a2:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
    11a4:	85 e9       	ldi	r24, 0x95	; 149
    11a6:	99 e0       	ldi	r25, 0x09	; 9
    11a8:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    11ac:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
    11ae:	85 e9       	ldi	r24, 0x95	; 149
    11b0:	99 e0       	ldi	r25, 0x09	; 9
    11b2:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    11b6:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
    11b8:	85 e9       	ldi	r24, 0x95	; 149
    11ba:	99 e0       	ldi	r25, 0x09	; 9
    11bc:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
    11c0:	d9 2c       	mov	r13, r9
    11c2:	c1 2c       	mov	r12, r1
    11c4:	ca 28       	or	r12, r10
    11c6:	d9 82       	std	Y+1, r13	; 0x01
    11c8:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
    11ca:	fb 2c       	mov	r15, r11
    11cc:	e1 2c       	mov	r14, r1
    11ce:	e0 2a       	or	r14, r16
    11d0:	fb 82       	std	Y+3, r15	; 0x03
    11d2:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
    11d4:	98 2f       	mov	r25, r24
    11d6:	88 27       	eor	r24, r24
    11d8:	81 2b       	or	r24, r17
    11da:	9d 83       	std	Y+5, r25	; 0x05
    11dc:	8c 83       	std	Y+4, r24	; 0x04
}
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	1f 91       	pop	r17
    11e4:	0f 91       	pop	r16
    11e6:	ff 90       	pop	r15
    11e8:	ef 90       	pop	r14
    11ea:	df 90       	pop	r13
    11ec:	cf 90       	pop	r12
    11ee:	bf 90       	pop	r11
    11f0:	af 90       	pop	r10
    11f2:	9f 90       	pop	r9
    11f4:	08 95       	ret

000011f6 <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
    11f6:	cf 92       	push	r12
    11f8:	df 92       	push	r13
    11fa:	ef 92       	push	r14
    11fc:	ff 92       	push	r15
    11fe:	0f 93       	push	r16
    1200:	1f 93       	push	r17
    1202:	cf 93       	push	r28
    1204:	df 93       	push	r29
    1206:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
    1208:	6b 8d       	ldd	r22, Y+27	; 0x1b
    120a:	85 e9       	ldi	r24, 0x95	; 149
    120c:	99 e0       	ldi	r25, 0x09	; 9
    120e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
    1212:	89 8d       	ldd	r24, Y+25	; 0x19
    1214:	83 30       	cpi	r24, 0x03	; 3
    1216:	31 f4       	brne	.+12     	; 0x1224 <_ZN6LSM3037readMagEv+0x2e>
    1218:	6e 8d       	ldd	r22, Y+30	; 0x1e
    121a:	77 27       	eor	r23, r23
    121c:	67 fd       	sbrc	r22, 7
    121e:	70 95       	com	r23
    1220:	60 68       	ori	r22, 0x80	; 128
    1222:	04 c0       	rjmp	.+8      	; 0x122c <_ZN6LSM3037readMagEv+0x36>
    1224:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1226:	77 27       	eor	r23, r23
    1228:	67 fd       	sbrc	r22, 7
    122a:	70 95       	com	r23
    122c:	e0 91 95 09 	lds	r30, 0x0995
    1230:	f0 91 96 09 	lds	r31, 0x0996
    1234:	01 90       	ld	r0, Z+
    1236:	f0 81       	ld	r31, Z
    1238:	e0 2d       	mov	r30, r0
    123a:	85 e9       	ldi	r24, 0x95	; 149
    123c:	99 e0       	ldi	r25, 0x09	; 9
    123e:	19 95       	eicall
  last_status = Wire.endTransmission();
    1240:	85 e9       	ldi	r24, 0x95	; 149
    1242:	99 e0       	ldi	r25, 0x09	; 9
    1244:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
    1248:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
    124a:	46 e0       	ldi	r20, 0x06	; 6
    124c:	6b 8d       	ldd	r22, Y+27	; 0x1b
    124e:	85 e9       	ldi	r24, 0x95	; 149
    1250:	99 e0       	ldi	r25, 0x09	; 9
    1252:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    1256:	0e 94 b2 1b 	call	0x3764	; 0x3764 <millis>
    125a:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    125c:	10 c0       	rjmp	.+32     	; 0x127e <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    125e:	8b a1       	ldd	r24, Y+35	; 0x23
    1260:	9c a1       	ldd	r25, Y+36	; 0x24
    1262:	89 2b       	or	r24, r25
    1264:	61 f0       	breq	.+24     	; 0x127e <_ZN6LSM3037readMagEv+0x88>
    1266:	0e 94 b2 1b 	call	0x3764	; 0x3764 <millis>
    126a:	60 1b       	sub	r22, r16
    126c:	71 0b       	sbc	r23, r17
    126e:	8b a1       	ldd	r24, Y+35	; 0x23
    1270:	9c a1       	ldd	r25, Y+36	; 0x24
    1272:	86 17       	cp	r24, r22
    1274:	97 07       	cpc	r25, r23
    1276:	18 f4       	brcc	.+6      	; 0x127e <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	8d a3       	std	Y+37, r24	; 0x25
      return;
    127c:	6e c0       	rjmp	.+220    	; 0x135a <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    127e:	85 e9       	ldi	r24, 0x95	; 149
    1280:	99 e0       	ldi	r25, 0x09	; 9
    1282:	0e 94 df 14 	call	0x29be	; 0x29be <_ZN7TwoWire9availableEv>
    1286:	06 97       	sbiw	r24, 0x06	; 6
    1288:	54 f3       	brlt	.-44     	; 0x125e <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
    128a:	89 8d       	ldd	r24, Y+25	; 0x19
    128c:	83 30       	cpi	r24, 0x03	; 3
    128e:	f9 f4       	brne	.+62     	; 0x12ce <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
    1290:	85 e9       	ldi	r24, 0x95	; 149
    1292:	99 e0       	ldi	r25, 0x09	; 9
    1294:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    1298:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
    129a:	85 e9       	ldi	r24, 0x95	; 149
    129c:	99 e0       	ldi	r25, 0x09	; 9
    129e:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12a2:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
    12a4:	85 e9       	ldi	r24, 0x95	; 149
    12a6:	99 e0       	ldi	r25, 0x09	; 9
    12a8:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12ac:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
    12ae:	85 e9       	ldi	r24, 0x95	; 149
    12b0:	99 e0       	ldi	r25, 0x09	; 9
    12b2:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12b6:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
    12b8:	85 e9       	ldi	r24, 0x95	; 149
    12ba:	99 e0       	ldi	r25, 0x09	; 9
    12bc:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12c0:	08 2f       	mov	r16, r24
    zhm = Wire.read();
    12c2:	85 e9       	ldi	r24, 0x95	; 149
    12c4:	99 e0       	ldi	r25, 0x09	; 9
    12c6:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12ca:	18 2f       	mov	r17, r24
    12cc:	36 c0       	rjmp	.+108    	; 0x133a <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
    12ce:	85 e9       	ldi	r24, 0x95	; 149
    12d0:	99 e0       	ldi	r25, 0x09	; 9
    12d2:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12d6:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
    12d8:	85 e9       	ldi	r24, 0x95	; 149
    12da:	99 e0       	ldi	r25, 0x09	; 9
    12dc:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12e0:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
    12e2:	89 8d       	ldd	r24, Y+25	; 0x19
    12e4:	81 11       	cpse	r24, r1
    12e6:	15 c0       	rjmp	.+42     	; 0x1312 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
    12e8:	85 e9       	ldi	r24, 0x95	; 149
    12ea:	99 e0       	ldi	r25, 0x09	; 9
    12ec:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12f0:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    12f2:	85 e9       	ldi	r24, 0x95	; 149
    12f4:	99 e0       	ldi	r25, 0x09	; 9
    12f6:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    12fa:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
    12fc:	85 e9       	ldi	r24, 0x95	; 149
    12fe:	99 e0       	ldi	r25, 0x09	; 9
    1300:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    1304:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    1306:	85 e9       	ldi	r24, 0x95	; 149
    1308:	99 e0       	ldi	r25, 0x09	; 9
    130a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    130e:	08 2f       	mov	r16, r24
    1310:	14 c0       	rjmp	.+40     	; 0x133a <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
    1312:	85 e9       	ldi	r24, 0x95	; 149
    1314:	99 e0       	ldi	r25, 0x09	; 9
    1316:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    131a:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    131c:	85 e9       	ldi	r24, 0x95	; 149
    131e:	99 e0       	ldi	r25, 0x09	; 9
    1320:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    1324:	08 2f       	mov	r16, r24
      yhm = Wire.read();
    1326:	85 e9       	ldi	r24, 0x95	; 149
    1328:	99 e0       	ldi	r25, 0x09	; 9
    132a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    132e:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    1330:	85 e9       	ldi	r24, 0x95	; 149
    1332:	99 e0       	ldi	r25, 0x09	; 9
    1334:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    1338:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
    133a:	6c 2d       	mov	r22, r12
    133c:	70 e0       	ldi	r23, 0x00	; 0
    133e:	7d 29       	or	r23, r13
    1340:	7f 83       	std	Y+7, r23	; 0x07
    1342:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
    1344:	4e 2d       	mov	r20, r14
    1346:	50 e0       	ldi	r21, 0x00	; 0
    1348:	5f 29       	or	r21, r15
    134a:	59 87       	std	Y+9, r21	; 0x09
    134c:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
    134e:	20 2f       	mov	r18, r16
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	c9 01       	movw	r24, r18
    1354:	91 2b       	or	r25, r17
    1356:	9b 87       	std	Y+11, r25	; 0x0b
    1358:	8a 87       	std	Y+10, r24	; 0x0a
}
    135a:	df 91       	pop	r29
    135c:	cf 91       	pop	r28
    135e:	1f 91       	pop	r17
    1360:	0f 91       	pop	r16
    1362:	ff 90       	pop	r15
    1364:	ef 90       	pop	r14
    1366:	df 90       	pop	r13
    1368:	cf 90       	pop	r12
    136a:	08 95       	ret

0000136c <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
    1370:	ec 01       	movw	r28, r24
  readAcc();
    1372:	c8 de       	rcall	.-624    	; 0x1104 <_ZN6LSM3037readAccEv>
  readMag();
    1374:	ce 01       	movw	r24, r28
    1376:	3f df       	rcall	.-386    	; 0x11f6 <_ZN6LSM3037readMagEv>
}
    1378:	df 91       	pop	r29
    137a:	cf 91       	pop	r28
    137c:	08 95       	ret

0000137e <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
    137e:	cf 93       	push	r28
    1380:	df 93       	push	r29
    1382:	c6 2f       	mov	r28, r22
    1384:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
    1386:	85 e9       	ldi	r24, 0x95	; 149
    1388:	99 e0       	ldi	r25, 0x09	; 9
    138a:	0e 94 92 15 	call	0x2b24	; 0x2b24 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
    138e:	6d 2f       	mov	r22, r29
    1390:	85 e9       	ldi	r24, 0x95	; 149
    1392:	99 e0       	ldi	r25, 0x09	; 9
    1394:	0e 94 39 15 	call	0x2a72	; 0x2a72 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
    1398:	85 e9       	ldi	r24, 0x95	; 149
    139a:	99 e0       	ldi	r25, 0x09	; 9
    139c:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <_ZN7TwoWire15endTransmissionEv>
    13a0:	81 11       	cpse	r24, r1
    13a2:	11 c0       	rjmp	.+34     	; 0x13c6 <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
    13a4:	41 e0       	ldi	r20, 0x01	; 1
    13a6:	6c 2f       	mov	r22, r28
    13a8:	85 e9       	ldi	r24, 0x95	; 149
    13aa:	99 e0       	ldi	r25, 0x09	; 9
    13ac:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
    13b0:	85 e9       	ldi	r24, 0x95	; 149
    13b2:	99 e0       	ldi	r25, 0x09	; 9
    13b4:	0e 94 df 14 	call	0x29be	; 0x29be <_ZN7TwoWire9availableEv>
    13b8:	89 2b       	or	r24, r25
    13ba:	41 f0       	breq	.+16     	; 0x13cc <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
    13bc:	85 e9       	ldi	r24, 0x95	; 149
    13be:	99 e0       	ldi	r25, 0x09	; 9
    13c0:	0e 94 e7 14 	call	0x29ce	; 0x29ce <_ZN7TwoWire4readEv>
    13c4:	05 c0       	rjmp	.+10     	; 0x13d0 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
    13c6:	8f ef       	ldi	r24, 0xFF	; 255
    13c8:	9f ef       	ldi	r25, 0xFF	; 255
    13ca:	02 c0       	rjmp	.+4      	; 0x13d0 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
    13cc:	8f ef       	ldi	r24, 0xFF	; 255
    13ce:	9f ef       	ldi	r25, 0xFF	; 255
  }
    13d0:	df 91       	pop	r29
    13d2:	cf 91       	pop	r28
    13d4:	08 95       	ret

000013d6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
    13d6:	0f 93       	push	r16
    13d8:	1f 93       	push	r17
    13da:	cf 93       	push	r28
    13dc:	df 93       	push	r29
    13de:	ec 01       	movw	r28, r24
    13e0:	16 2f       	mov	r17, r22
    13e2:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
    13e4:	64 30       	cpi	r22, 0x04	; 4
    13e6:	09 f4       	brne	.+2      	; 0x13ea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
    13e8:	ad c0       	rjmp	.+346    	; 0x1544 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
    13ea:	42 30       	cpi	r20, 0x02	; 2
    13ec:	09 f0       	breq	.+2      	; 0x13f0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
    13ee:	47 c0       	rjmp	.+142    	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    13f0:	ad c0       	rjmp	.+346    	; 0x154c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    13f2:	4f e0       	ldi	r20, 0x0F	; 15
    13f4:	6d e1       	ldi	r22, 0x1D	; 29
    13f6:	ce 01       	movw	r24, r28
    13f8:	c2 df       	rcall	.-124    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    13fa:	89 34       	cpi	r24, 0x49	; 73
    13fc:	91 05       	cpc	r25, r1
    13fe:	09 f4       	brne	.+2      	; 0x1402 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
    1400:	ab c0       	rjmp	.+342    	; 0x1558 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1402:	01 30       	cpi	r16, 0x01	; 1
    1404:	41 f0       	breq	.+16     	; 0x1416 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1406:	4f e0       	ldi	r20, 0x0F	; 15
    1408:	6e e1       	ldi	r22, 0x1E	; 30
    140a:	ce 01       	movw	r24, r28
    140c:	b8 df       	rcall	.-144    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    140e:	89 34       	cpi	r24, 0x49	; 73
    1410:	91 05       	cpc	r25, r1
    1412:	09 f4       	brne	.+2      	; 0x1416 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1414:	a3 c0       	rjmp	.+326    	; 0x155c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
    1416:	14 30       	cpi	r17, 0x04	; 4
    1418:	11 f0       	breq	.+4      	; 0x141e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
    141a:	13 30       	cpi	r17, 0x03	; 3
    141c:	68 f5       	brcc	.+90     	; 0x1478 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    141e:	00 23       	and	r16, r16
    1420:	a9 f0       	breq	.+42     	; 0x144c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
    1422:	40 e2       	ldi	r20, 0x20	; 32
    1424:	69 e1       	ldi	r22, 0x19	; 25
    1426:	ce 01       	movw	r24, r28
    1428:	aa df       	rcall	.-172    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    142a:	01 96       	adiw	r24, 0x01	; 1
    142c:	69 f0       	breq	.+26     	; 0x1448 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
    142e:	14 30       	cpi	r17, 0x04	; 4
    1430:	09 f0       	breq	.+2      	; 0x1434 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
    1432:	99 c0       	rjmp	.+306    	; 0x1566 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1434:	4f e0       	ldi	r20, 0x0F	; 15
    1436:	6e e1       	ldi	r22, 0x1E	; 30
    1438:	ce 01       	movw	r24, r28
    143a:	a1 df       	rcall	.-190    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    143c:	cc 97       	sbiw	r24, 0x3c	; 60
    143e:	09 f0       	breq	.+2      	; 0x1442 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
    1440:	94 c0       	rjmp	.+296    	; 0x156a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    1442:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1444:	12 e0       	ldi	r17, 0x02	; 2
    1446:	1b c0       	rjmp	.+54     	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    1448:	01 30       	cpi	r16, 0x01	; 1
    144a:	99 f0       	breq	.+38     	; 0x1472 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
    144c:	40 e2       	ldi	r20, 0x20	; 32
    144e:	68 e1       	ldi	r22, 0x18	; 24
    1450:	ce 01       	movw	r24, r28
    1452:	95 df       	rcall	.-214    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    1454:	01 96       	adiw	r24, 0x01	; 1
    1456:	69 f0       	breq	.+26     	; 0x1472 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
    1458:	14 30       	cpi	r17, 0x04	; 4
    145a:	09 f0       	breq	.+2      	; 0x145e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
    145c:	89 c0       	rjmp	.+274    	; 0x1570 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
    145e:	4f e0       	ldi	r20, 0x0F	; 15
    1460:	6e e1       	ldi	r22, 0x1E	; 30
    1462:	ce 01       	movw	r24, r28
    1464:	8c df       	rcall	.-232    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    1466:	11 e0       	ldi	r17, 0x01	; 1
    1468:	cc 97       	sbiw	r24, 0x3c	; 60
    146a:	09 f0       	breq	.+2      	; 0x146e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
    146c:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    146e:	00 e0       	ldi	r16, 0x00	; 0
    1470:	06 c0       	rjmp	.+12     	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    1472:	14 30       	cpi	r17, 0x04	; 4
    1474:	09 f4       	brne	.+2      	; 0x1478 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    1476:	60 c0       	rjmp	.+192    	; 0x1538 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
    1478:	02 30       	cpi	r16, 0x02	; 2
    147a:	09 f4       	brne	.+2      	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    147c:	5f c0       	rjmp	.+190    	; 0x153c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
    147e:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
    1480:	11 30       	cpi	r17, 0x01	; 1
    1482:	71 f1       	breq	.+92     	; 0x14e0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
    1484:	08 f4       	brcc	.+2      	; 0x1488 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
    1486:	42 c0       	rjmp	.+132    	; 0x150c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
    1488:	12 30       	cpi	r17, 0x02	; 2
    148a:	c1 f0       	breq	.+48     	; 0x14bc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
    148c:	13 30       	cpi	r17, 0x03	; 3
    148e:	09 f0       	breq	.+2      	; 0x1492 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
    1490:	57 c0       	rjmp	.+174    	; 0x1540 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
    1492:	01 30       	cpi	r16, 0x01	; 1
    1494:	11 f4       	brne	.+4      	; 0x149a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
    1496:	8d e1       	ldi	r24, 0x1D	; 29
    1498:	01 c0       	rjmp	.+2      	; 0x149c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
    149a:	8e e1       	ldi	r24, 0x1E	; 30
    149c:	8b 8f       	std	Y+27, r24	; 0x1b
    149e:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
    14a0:	88 e0       	ldi	r24, 0x08	; 8
    14a2:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
    14a4:	89 e0       	ldi	r24, 0x09	; 9
    14a6:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
    14a8:	8a e0       	ldi	r24, 0x0A	; 10
    14aa:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
    14ac:	8b e0       	ldi	r24, 0x0B	; 11
    14ae:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
    14b0:	8c e0       	ldi	r24, 0x0C	; 12
    14b2:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
    14b4:	8d e0       	ldi	r24, 0x0D	; 13
    14b6:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    14b8:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
    14ba:	64 c0       	rjmp	.+200    	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
    14bc:	89 e1       	ldi	r24, 0x19	; 25
    14be:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    14c0:	8e e1       	ldi	r24, 0x1E	; 30
    14c2:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
    14c4:	83 e0       	ldi	r24, 0x03	; 3
    14c6:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
    14c8:	84 e0       	ldi	r24, 0x04	; 4
    14ca:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
    14cc:	87 e0       	ldi	r24, 0x07	; 7
    14ce:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
    14d0:	88 e0       	ldi	r24, 0x08	; 8
    14d2:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
    14d4:	85 e0       	ldi	r24, 0x05	; 5
    14d6:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
    14d8:	86 e0       	ldi	r24, 0x06	; 6
    14da:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    14dc:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
    14de:	52 c0       	rjmp	.+164    	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    14e0:	01 30       	cpi	r16, 0x01	; 1
    14e2:	11 f4       	brne	.+4      	; 0x14e8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
    14e4:	89 e1       	ldi	r24, 0x19	; 25
    14e6:	01 c0       	rjmp	.+2      	; 0x14ea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
    14e8:	88 e1       	ldi	r24, 0x18	; 24
    14ea:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    14ec:	8e e1       	ldi	r24, 0x1E	; 30
    14ee:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
    14f0:	83 e0       	ldi	r24, 0x03	; 3
    14f2:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
    14f4:	84 e0       	ldi	r24, 0x04	; 4
    14f6:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
    14f8:	87 e0       	ldi	r24, 0x07	; 7
    14fa:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
    14fc:	88 e0       	ldi	r24, 0x08	; 8
    14fe:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
    1500:	85 e0       	ldi	r24, 0x05	; 5
    1502:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
    1504:	86 e0       	ldi	r24, 0x06	; 6
    1506:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    1508:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
    150a:	3c c0       	rjmp	.+120    	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    150c:	01 30       	cpi	r16, 0x01	; 1
    150e:	11 f4       	brne	.+4      	; 0x1514 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
    1510:	89 e1       	ldi	r24, 0x19	; 25
    1512:	01 c0       	rjmp	.+2      	; 0x1516 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
    1514:	88 e1       	ldi	r24, 0x18	; 24
    1516:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    1518:	8e e1       	ldi	r24, 0x1E	; 30
    151a:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
    151c:	83 e0       	ldi	r24, 0x03	; 3
    151e:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
    1520:	84 e0       	ldi	r24, 0x04	; 4
    1522:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
    1524:	85 e0       	ldi	r24, 0x05	; 5
    1526:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
    1528:	86 e0       	ldi	r24, 0x06	; 6
    152a:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
    152c:	87 e0       	ldi	r24, 0x07	; 7
    152e:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
    1530:	88 e0       	ldi	r24, 0x08	; 8
    1532:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
    1534:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
    1536:	26 c0       	rjmp	.+76     	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
    1538:	80 e0       	ldi	r24, 0x00	; 0
    153a:	24 c0       	rjmp	.+72     	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	22 c0       	rjmp	.+68     	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	20 c0       	rjmp	.+64     	; 0x1584 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1544:	44 23       	and	r20, r20
    1546:	09 f4       	brne	.+2      	; 0x154a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
    1548:	5e cf       	rjmp	.-324    	; 0x1406 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
    154a:	53 cf       	rjmp	.-346    	; 0x13f2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    154c:	8d ef       	ldi	r24, 0xFD	; 253
    154e:	86 0f       	add	r24, r22
    1550:	82 30       	cpi	r24, 0x02	; 2
    1552:	08 f0       	brcs	.+2      	; 0x1556 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
    1554:	62 cf       	rjmp	.-316    	; 0x141a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
    1556:	0e c0       	rjmp	.+28     	; 0x1574 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    1558:	01 e0       	ldi	r16, 0x01	; 1
    155a:	03 c0       	rjmp	.+6      	; 0x1562 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
    155c:	00 e0       	ldi	r16, 0x00	; 0
    155e:	01 c0       	rjmp	.+2      	; 0x1562 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    1560:	01 e0       	ldi	r16, 0x01	; 1
    1562:	13 e0       	ldi	r17, 0x03	; 3
    1564:	89 cf       	rjmp	.-238    	; 0x1478 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    1566:	01 e0       	ldi	r16, 0x01	; 1
    1568:	8a cf       	rjmp	.-236    	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    156a:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    156c:	10 e0       	ldi	r17, 0x00	; 0
    156e:	87 cf       	rjmp	.-242    	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    1570:	00 e0       	ldi	r16, 0x00	; 0
    1572:	85 cf       	rjmp	.-246    	; 0x147e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1574:	4f e0       	ldi	r20, 0x0F	; 15
    1576:	6d e1       	ldi	r22, 0x1D	; 29
    1578:	ce 01       	movw	r24, r28
    157a:	01 df       	rcall	.-510    	; 0x137e <_ZN6LSM3037testRegEhNS_7regAddrE>
    157c:	89 34       	cpi	r24, 0x49	; 73
    157e:	91 05       	cpc	r25, r1
    1580:	79 f3       	breq	.-34     	; 0x1560 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
    1582:	41 cf       	rjmp	.-382    	; 0x1406 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	1f 91       	pop	r17
    158a:	0f 91       	pop	r16
    158c:	08 95       	ret

0000158e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    158e:	31 e1       	ldi	r19, 0x11	; 17
    1590:	fc 01       	movw	r30, r24
    1592:	30 83       	st	Z, r19
    1594:	31 97       	sbiw	r30, 0x01	; 1
    1596:	22 e2       	ldi	r18, 0x22	; 34
    1598:	20 83       	st	Z, r18
    159a:	31 97       	sbiw	r30, 0x01	; 1
    159c:	a3 e3       	ldi	r26, 0x33	; 51
    159e:	a0 83       	st	Z, r26
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	60 83       	st	Z, r22
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	70 83       	st	Z, r23
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	10 82       	st	Z, r1
    15ac:	31 97       	sbiw	r30, 0x01	; 1
    15ae:	10 82       	st	Z, r1
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	60 e8       	ldi	r22, 0x80	; 128
    15b4:	60 83       	st	Z, r22
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	10 82       	st	Z, r1
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	10 82       	st	Z, r1
    15be:	31 97       	sbiw	r30, 0x01	; 1
    15c0:	10 82       	st	Z, r1
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	62 e0       	ldi	r22, 0x02	; 2
    15c6:	60 83       	st	Z, r22
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	63 e0       	ldi	r22, 0x03	; 3
    15cc:	60 83       	st	Z, r22
    15ce:	31 97       	sbiw	r30, 0x01	; 1
    15d0:	64 e0       	ldi	r22, 0x04	; 4
    15d2:	60 83       	st	Z, r22
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	65 e0       	ldi	r22, 0x05	; 5
    15d8:	60 83       	st	Z, r22
    15da:	31 97       	sbiw	r30, 0x01	; 1
    15dc:	66 e0       	ldi	r22, 0x06	; 6
    15de:	60 83       	st	Z, r22
    15e0:	31 97       	sbiw	r30, 0x01	; 1
    15e2:	67 e0       	ldi	r22, 0x07	; 7
    15e4:	60 83       	st	Z, r22
    15e6:	31 97       	sbiw	r30, 0x01	; 1
    15e8:	68 e0       	ldi	r22, 0x08	; 8
    15ea:	60 83       	st	Z, r22
    15ec:	31 97       	sbiw	r30, 0x01	; 1
    15ee:	69 e0       	ldi	r22, 0x09	; 9
    15f0:	60 83       	st	Z, r22
    15f2:	31 97       	sbiw	r30, 0x01	; 1
    15f4:	60 e1       	ldi	r22, 0x10	; 16
    15f6:	60 83       	st	Z, r22
    15f8:	31 97       	sbiw	r30, 0x01	; 1
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	32 e1       	ldi	r19, 0x12	; 18
    1600:	30 83       	st	Z, r19
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	33 e1       	ldi	r19, 0x13	; 19
    1606:	30 83       	st	Z, r19
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	34 e1       	ldi	r19, 0x14	; 20
    160c:	30 83       	st	Z, r19
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	35 e1       	ldi	r19, 0x15	; 21
    1612:	30 83       	st	Z, r19
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	36 e1       	ldi	r19, 0x16	; 22
    1618:	30 83       	st	Z, r19
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	37 e1       	ldi	r19, 0x17	; 23
    161e:	30 83       	st	Z, r19
    1620:	31 97       	sbiw	r30, 0x01	; 1
    1622:	38 e1       	ldi	r19, 0x18	; 24
    1624:	30 83       	st	Z, r19
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	39 e1       	ldi	r19, 0x19	; 25
    162a:	30 83       	st	Z, r19
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	30 e2       	ldi	r19, 0x20	; 32
    1630:	30 83       	st	Z, r19
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	31 e2       	ldi	r19, 0x21	; 33
    1636:	30 83       	st	Z, r19
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	20 83       	st	Z, r18
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	23 e2       	ldi	r18, 0x23	; 35
    1640:	20 83       	st	Z, r18
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	40 83       	st	Z, r20
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	50 83       	st	Z, r21
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	26 e2       	ldi	r18, 0x26	; 38
    164e:	20 83       	st	Z, r18
    1650:	31 97       	sbiw	r30, 0x01	; 1
    1652:	27 e2       	ldi	r18, 0x27	; 39
    1654:	20 83       	st	Z, r18
    1656:	31 97       	sbiw	r30, 0x01	; 1
    1658:	28 e2       	ldi	r18, 0x28	; 40
    165a:	20 83       	st	Z, r18
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	29 e2       	ldi	r18, 0x29	; 41
    1660:	20 83       	st	Z, r18
    1662:	31 97       	sbiw	r30, 0x01	; 1
    1664:	20 e3       	ldi	r18, 0x30	; 48
    1666:	20 83       	st	Z, r18
    1668:	31 97       	sbiw	r30, 0x01	; 1
    166a:	21 e3       	ldi	r18, 0x31	; 49
    166c:	20 83       	st	Z, r18
    166e:	89 97       	sbiw	r24, 0x29	; 41
    1670:	08 95       	ret

00001672 <xPortStartScheduler>:
    1672:	82 e0       	ldi	r24, 0x02	; 2
    1674:	80 93 b0 00 	sts	0x00B0, r24
    1678:	10 92 b2 00 	sts	0x00B2, r1
    167c:	8a ef       	ldi	r24, 0xFA	; 250
    167e:	80 93 b3 00 	sts	0x00B3, r24
    1682:	e0 e7       	ldi	r30, 0x70	; 112
    1684:	f0 e0       	ldi	r31, 0x00	; 0
    1686:	80 81       	ld	r24, Z
    1688:	82 60       	ori	r24, 0x02	; 2
    168a:	80 83       	st	Z, r24
    168c:	84 e0       	ldi	r24, 0x04	; 4
    168e:	80 93 b1 00 	sts	0x00B1, r24
    1692:	a0 91 25 09 	lds	r26, 0x0925
    1696:	b0 91 26 09 	lds	r27, 0x0926
    169a:	cd 91       	ld	r28, X+
    169c:	cd bf       	out	0x3d, r28	; 61
    169e:	dd 91       	ld	r29, X+
    16a0:	de bf       	out	0x3e, r29	; 62
    16a2:	ff 91       	pop	r31
    16a4:	ef 91       	pop	r30
    16a6:	df 91       	pop	r29
    16a8:	cf 91       	pop	r28
    16aa:	bf 91       	pop	r27
    16ac:	af 91       	pop	r26
    16ae:	9f 91       	pop	r25
    16b0:	8f 91       	pop	r24
    16b2:	7f 91       	pop	r23
    16b4:	6f 91       	pop	r22
    16b6:	5f 91       	pop	r21
    16b8:	4f 91       	pop	r20
    16ba:	3f 91       	pop	r19
    16bc:	2f 91       	pop	r18
    16be:	1f 91       	pop	r17
    16c0:	0f 91       	pop	r16
    16c2:	ff 90       	pop	r15
    16c4:	ef 90       	pop	r14
    16c6:	df 90       	pop	r13
    16c8:	cf 90       	pop	r12
    16ca:	bf 90       	pop	r11
    16cc:	af 90       	pop	r10
    16ce:	9f 90       	pop	r9
    16d0:	8f 90       	pop	r8
    16d2:	7f 90       	pop	r7
    16d4:	6f 90       	pop	r6
    16d6:	5f 90       	pop	r5
    16d8:	4f 90       	pop	r4
    16da:	3f 90       	pop	r3
    16dc:	2f 90       	pop	r2
    16de:	1f 90       	pop	r1
    16e0:	0f 90       	pop	r0
    16e2:	0c be       	out	0x3c, r0	; 60
    16e4:	0f 90       	pop	r0
    16e6:	0b be       	out	0x3b, r0	; 59
    16e8:	0f 90       	pop	r0
    16ea:	0f be       	out	0x3f, r0	; 63
    16ec:	0f 90       	pop	r0
    16ee:	08 95       	ret
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	08 95       	ret

000016f4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16f4:	0f 92       	push	r0
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	f8 94       	cli
    16fa:	0f 92       	push	r0
    16fc:	0c b6       	in	r0, 0x3c	; 60
    16fe:	0f 92       	push	r0
    1700:	0b b6       	in	r0, 0x3b	; 59
    1702:	0f 92       	push	r0
    1704:	1f 92       	push	r1
    1706:	11 24       	eor	r1, r1
    1708:	2f 92       	push	r2
    170a:	3f 92       	push	r3
    170c:	4f 92       	push	r4
    170e:	5f 92       	push	r5
    1710:	6f 92       	push	r6
    1712:	7f 92       	push	r7
    1714:	8f 92       	push	r8
    1716:	9f 92       	push	r9
    1718:	af 92       	push	r10
    171a:	bf 92       	push	r11
    171c:	cf 92       	push	r12
    171e:	df 92       	push	r13
    1720:	ef 92       	push	r14
    1722:	ff 92       	push	r15
    1724:	0f 93       	push	r16
    1726:	1f 93       	push	r17
    1728:	2f 93       	push	r18
    172a:	3f 93       	push	r19
    172c:	4f 93       	push	r20
    172e:	5f 93       	push	r21
    1730:	6f 93       	push	r22
    1732:	7f 93       	push	r23
    1734:	8f 93       	push	r24
    1736:	9f 93       	push	r25
    1738:	af 93       	push	r26
    173a:	bf 93       	push	r27
    173c:	cf 93       	push	r28
    173e:	df 93       	push	r29
    1740:	ef 93       	push	r30
    1742:	ff 93       	push	r31
    1744:	a0 91 25 09 	lds	r26, 0x0925
    1748:	b0 91 26 09 	lds	r27, 0x0926
    174c:	0d b6       	in	r0, 0x3d	; 61
    174e:	0d 92       	st	X+, r0
    1750:	0e b6       	in	r0, 0x3e	; 62
    1752:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1754:	c1 d6       	rcall	.+3458   	; 0x24d8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1756:	a0 91 25 09 	lds	r26, 0x0925
    175a:	b0 91 26 09 	lds	r27, 0x0926
    175e:	cd 91       	ld	r28, X+
    1760:	cd bf       	out	0x3d, r28	; 61
    1762:	dd 91       	ld	r29, X+
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	bf 91       	pop	r27
    1770:	af 91       	pop	r26
    1772:	9f 91       	pop	r25
    1774:	8f 91       	pop	r24
    1776:	7f 91       	pop	r23
    1778:	6f 91       	pop	r22
    177a:	5f 91       	pop	r21
    177c:	4f 91       	pop	r20
    177e:	3f 91       	pop	r19
    1780:	2f 91       	pop	r18
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	ff 90       	pop	r15
    1788:	ef 90       	pop	r14
    178a:	df 90       	pop	r13
    178c:	cf 90       	pop	r12
    178e:	bf 90       	pop	r11
    1790:	af 90       	pop	r10
    1792:	9f 90       	pop	r9
    1794:	8f 90       	pop	r8
    1796:	7f 90       	pop	r7
    1798:	6f 90       	pop	r6
    179a:	5f 90       	pop	r5
    179c:	4f 90       	pop	r4
    179e:	3f 90       	pop	r3
    17a0:	2f 90       	pop	r2
    17a2:	1f 90       	pop	r1
    17a4:	0f 90       	pop	r0
    17a6:	0c be       	out	0x3c, r0	; 60
    17a8:	0f 90       	pop	r0
    17aa:	0b be       	out	0x3b, r0	; 59
    17ac:	0f 90       	pop	r0
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17b2:	08 95       	ret

000017b4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17b4:	0f 92       	push	r0
    17b6:	0f b6       	in	r0, 0x3f	; 63
    17b8:	f8 94       	cli
    17ba:	0f 92       	push	r0
    17bc:	0c b6       	in	r0, 0x3c	; 60
    17be:	0f 92       	push	r0
    17c0:	0b b6       	in	r0, 0x3b	; 59
    17c2:	0f 92       	push	r0
    17c4:	1f 92       	push	r1
    17c6:	11 24       	eor	r1, r1
    17c8:	2f 92       	push	r2
    17ca:	3f 92       	push	r3
    17cc:	4f 92       	push	r4
    17ce:	5f 92       	push	r5
    17d0:	6f 92       	push	r6
    17d2:	7f 92       	push	r7
    17d4:	8f 92       	push	r8
    17d6:	9f 92       	push	r9
    17d8:	af 92       	push	r10
    17da:	bf 92       	push	r11
    17dc:	cf 92       	push	r12
    17de:	df 92       	push	r13
    17e0:	ef 92       	push	r14
    17e2:	ff 92       	push	r15
    17e4:	0f 93       	push	r16
    17e6:	1f 93       	push	r17
    17e8:	2f 93       	push	r18
    17ea:	3f 93       	push	r19
    17ec:	4f 93       	push	r20
    17ee:	5f 93       	push	r21
    17f0:	6f 93       	push	r22
    17f2:	7f 93       	push	r23
    17f4:	8f 93       	push	r24
    17f6:	9f 93       	push	r25
    17f8:	af 93       	push	r26
    17fa:	bf 93       	push	r27
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	ef 93       	push	r30
    1802:	ff 93       	push	r31
    1804:	a0 91 25 09 	lds	r26, 0x0925
    1808:	b0 91 26 09 	lds	r27, 0x0926
    180c:	0d b6       	in	r0, 0x3d	; 61
    180e:	0d 92       	st	X+, r0
    1810:	0e b6       	in	r0, 0x3e	; 62
    1812:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1814:	cd d4       	rcall	.+2458   	; 0x21b0 <xTaskIncrementTick>
    1816:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1818:	5f d6       	rcall	.+3262   	; 0x24d8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    181a:	a0 91 25 09 	lds	r26, 0x0925
    181e:	b0 91 26 09 	lds	r27, 0x0926
    1822:	cd 91       	ld	r28, X+
    1824:	cd bf       	out	0x3d, r28	; 61
    1826:	dd 91       	ld	r29, X+
    1828:	de bf       	out	0x3e, r29	; 62
    182a:	ff 91       	pop	r31
    182c:	ef 91       	pop	r30
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	bf 91       	pop	r27
    1834:	af 91       	pop	r26
    1836:	9f 91       	pop	r25
    1838:	8f 91       	pop	r24
    183a:	7f 91       	pop	r23
    183c:	6f 91       	pop	r22
    183e:	5f 91       	pop	r21
    1840:	4f 91       	pop	r20
    1842:	3f 91       	pop	r19
    1844:	2f 91       	pop	r18
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	df 90       	pop	r13
    1850:	cf 90       	pop	r12
    1852:	bf 90       	pop	r11
    1854:	af 90       	pop	r10
    1856:	9f 90       	pop	r9
    1858:	8f 90       	pop	r8
    185a:	7f 90       	pop	r7
    185c:	6f 90       	pop	r6
    185e:	5f 90       	pop	r5
    1860:	4f 90       	pop	r4
    1862:	3f 90       	pop	r3
    1864:	2f 90       	pop	r2
    1866:	1f 90       	pop	r1
    1868:	0f 90       	pop	r0
    186a:	0c be       	out	0x3c, r0	; 60
    186c:	0f 90       	pop	r0
    186e:	0b be       	out	0x3b, r0	; 59
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63
    1874:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1876:	08 95       	ret

00001878 <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    1878:	9d df       	rcall	.-198    	; 0x17b4 <vPortYieldFromTick>
	asm volatile ( "reti" );
    187a:	18 95       	reti

0000187c <_Z13taskReadSonarPv>:
	while(1) {
		//if(xSemaphoreTake(analogSema, portMAX_DELAY)) {
			distance = sharp.distance();
			data[10] = distance;
			//xSemaphoreGive(gyroSema);
			vTaskDelay(500);
    187c:	0f 2e       	mov	r0, r31
    187e:	fc e0       	ldi	r31, 0x0C	; 12
    1880:	ef 2e       	mov	r14, r31
    1882:	f2 e0       	ldi	r31, 0x02	; 2
    1884:	ff 2e       	mov	r15, r31
    1886:	f0 2d       	mov	r31, r0
    1888:	0f 2e       	mov	r0, r31
    188a:	fe e0       	ldi	r31, 0x0E	; 14
    188c:	cf 2e       	mov	r12, r31
    188e:	f2 e0       	ldi	r31, 0x02	; 2
    1890:	df 2e       	mov	r13, r31
    1892:	f0 2d       	mov	r31, r0
    1894:	0f 2e       	mov	r0, r31
    1896:	f8 e7       	ldi	r31, 0x78	; 120
    1898:	8f 2e       	mov	r8, r31
    189a:	f8 e0       	ldi	r31, 0x08	; 8
    189c:	9f 2e       	mov	r9, r31
    189e:	f0 2d       	mov	r31, r0
    18a0:	08 e0       	ldi	r16, 0x08	; 8
    18a2:	12 e0       	ldi	r17, 0x02	; 2
    18a4:	0f 2e       	mov	r0, r31
    18a6:	fa e0       	ldi	r31, 0x0A	; 10
    18a8:	af 2e       	mov	r10, r31
    18aa:	f2 e0       	ldi	r31, 0x02	; 2
    18ac:	bf 2e       	mov	r11, r31
    18ae:	f0 2d       	mov	r31, r0
    18b0:	0f 2e       	mov	r0, r31
    18b2:	fa e7       	ldi	r31, 0x7A	; 122
    18b4:	6f 2e       	mov	r6, r31
    18b6:	f8 e0       	ldi	r31, 0x08	; 8
    18b8:	7f 2e       	mov	r7, r31
    18ba:	f0 2d       	mov	r31, r0
    18bc:	c4 e0       	ldi	r28, 0x04	; 4
    18be:	d2 e0       	ldi	r29, 0x02	; 2
    18c0:	0f 2e       	mov	r0, r31
    18c2:	f6 e0       	ldi	r31, 0x06	; 6
    18c4:	4f 2e       	mov	r4, r31
    18c6:	f2 e0       	ldi	r31, 0x02	; 2
    18c8:	5f 2e       	mov	r5, r31
    18ca:	f0 2d       	mov	r31, r0
    18cc:	0f 2e       	mov	r0, r31
    18ce:	fc e7       	ldi	r31, 0x7C	; 124
    18d0:	2f 2e       	mov	r2, r31
    18d2:	f8 e0       	ldi	r31, 0x08	; 8
    18d4:	3f 2e       	mov	r3, r31
    18d6:	f0 2d       	mov	r31, r0
    18d8:	65 d4       	rcall	.+2250   	; 0x21a4 <vTaskSuspendAll>
    18da:	60 e0       	ldi	r22, 0x00	; 0
    18dc:	f7 01       	movw	r30, r14
    18de:	80 81       	ld	r24, Z
    18e0:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    18e4:	85 e0       	ldi	r24, 0x05	; 5
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	0e 94 be 1b 	call	0x377c	; 0x377c <delayMicroseconds>
    18ec:	61 e0       	ldi	r22, 0x01	; 1
    18ee:	f7 01       	movw	r30, r14
    18f0:	80 81       	ld	r24, Z
    18f2:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    18f6:	8a e0       	ldi	r24, 0x0A	; 10
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	0e 94 be 1b 	call	0x377c	; 0x377c <delayMicroseconds>
    18fe:	60 e0       	ldi	r22, 0x00	; 0
    1900:	f7 01       	movw	r30, r14
    1902:	80 81       	ld	r24, Z
    1904:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    1908:	60 e0       	ldi	r22, 0x00	; 0
    190a:	f6 01       	movw	r30, r12
    190c:	80 81       	ld	r24, Z
    190e:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
    1912:	20 e4       	ldi	r18, 0x40	; 64
    1914:	32 e4       	ldi	r19, 0x42	; 66
    1916:	4f e0       	ldi	r20, 0x0F	; 15
    1918:	50 e0       	ldi	r21, 0x00	; 0
    191a:	61 e0       	ldi	r22, 0x01	; 1
    191c:	f6 01       	movw	r30, r12
    191e:	80 81       	ld	r24, Z
    1920:	0e 94 02 1d 	call	0x3a04	; 0x3a04 <pulseIn>
    1924:	76 95       	lsr	r23
    1926:	67 95       	ror	r22
    1928:	80 e0       	ldi	r24, 0x00	; 0
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__floatunsisf>
    1930:	2d ec       	ldi	r18, 0xCD	; 205
    1932:	3c ec       	ldi	r19, 0xCC	; 204
    1934:	48 ee       	ldi	r20, 0xE8	; 232
    1936:	51 e4       	ldi	r21, 0x41	; 65
    1938:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    193c:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1940:	f4 01       	movw	r30, r8
    1942:	71 83       	std	Z+1, r23	; 0x01
    1944:	60 83       	st	Z, r22
    1946:	60 e0       	ldi	r22, 0x00	; 0
    1948:	f8 01       	movw	r30, r16
    194a:	80 81       	ld	r24, Z
    194c:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    1950:	85 e0       	ldi	r24, 0x05	; 5
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	0e 94 be 1b 	call	0x377c	; 0x377c <delayMicroseconds>
    1958:	61 e0       	ldi	r22, 0x01	; 1
    195a:	f8 01       	movw	r30, r16
    195c:	80 81       	ld	r24, Z
    195e:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    1962:	8a e0       	ldi	r24, 0x0A	; 10
    1964:	90 e0       	ldi	r25, 0x00	; 0
    1966:	0e 94 be 1b 	call	0x377c	; 0x377c <delayMicroseconds>
    196a:	60 e0       	ldi	r22, 0x00	; 0
    196c:	f8 01       	movw	r30, r16
    196e:	80 81       	ld	r24, Z
    1970:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    1974:	20 e4       	ldi	r18, 0x40	; 64
    1976:	32 e4       	ldi	r19, 0x42	; 66
    1978:	4f e0       	ldi	r20, 0x0F	; 15
    197a:	50 e0       	ldi	r21, 0x00	; 0
    197c:	61 e0       	ldi	r22, 0x01	; 1
    197e:	f5 01       	movw	r30, r10
    1980:	80 81       	ld	r24, Z
    1982:	0e 94 02 1d 	call	0x3a04	; 0x3a04 <pulseIn>
    1986:	76 95       	lsr	r23
    1988:	67 95       	ror	r22
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__floatunsisf>
    1992:	2d ec       	ldi	r18, 0xCD	; 205
    1994:	3c ec       	ldi	r19, 0xCC	; 204
    1996:	48 ee       	ldi	r20, 0xE8	; 232
    1998:	51 e4       	ldi	r21, 0x41	; 65
    199a:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    199e:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    19a2:	f3 01       	movw	r30, r6
    19a4:	71 83       	std	Z+1, r23	; 0x01
    19a6:	60 83       	st	Z, r22
    19a8:	60 e0       	ldi	r22, 0x00	; 0
    19aa:	88 81       	ld	r24, Y
    19ac:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    19b0:	85 e0       	ldi	r24, 0x05	; 5
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	0e 94 be 1b 	call	0x377c	; 0x377c <delayMicroseconds>
    19b8:	61 e0       	ldi	r22, 0x01	; 1
    19ba:	88 81       	ld	r24, Y
    19bc:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    19c0:	8a e0       	ldi	r24, 0x0A	; 10
    19c2:	90 e0       	ldi	r25, 0x00	; 0
    19c4:	0e 94 be 1b 	call	0x377c	; 0x377c <delayMicroseconds>
    19c8:	60 e0       	ldi	r22, 0x00	; 0
    19ca:	88 81       	ld	r24, Y
    19cc:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    19d0:	20 e4       	ldi	r18, 0x40	; 64
    19d2:	32 e4       	ldi	r19, 0x42	; 66
    19d4:	4f e0       	ldi	r20, 0x0F	; 15
    19d6:	50 e0       	ldi	r21, 0x00	; 0
    19d8:	61 e0       	ldi	r22, 0x01	; 1
    19da:	f2 01       	movw	r30, r4
    19dc:	80 81       	ld	r24, Z
    19de:	0e 94 02 1d 	call	0x3a04	; 0x3a04 <pulseIn>
    19e2:	76 95       	lsr	r23
    19e4:	67 95       	ror	r22
    19e6:	80 e0       	ldi	r24, 0x00	; 0
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__floatunsisf>
    19ee:	2d ec       	ldi	r18, 0xCD	; 205
    19f0:	3c ec       	ldi	r19, 0xCC	; 204
    19f2:	48 ee       	ldi	r20, 0xE8	; 232
    19f4:	51 e4       	ldi	r21, 0x41	; 65
    19f6:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    19fa:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    19fe:	f1 01       	movw	r30, r2
    1a00:	71 83       	std	Z+1, r23	; 0x01
    1a02:	60 83       	st	Z, r22
    1a04:	93 d4       	rcall	.+2342   	; 0x232c <xTaskResumeAll>
    1a06:	84 ef       	ldi	r24, 0xF4	; 244
    1a08:	91 e0       	ldi	r25, 0x01	; 1
    1a0a:	11 d5       	rcall	.+2594   	; 0x242e <vTaskDelay>
    1a0c:	65 cf       	rjmp	.-310    	; 0x18d8 <_Z13taskReadSonarPv+0x5c>

00001a0e <_Z11taskReadAccPv>:
    1a0e:	0f 2e       	mov	r0, r31
    1a10:	fa ea       	ldi	r31, 0xAA	; 170
    1a12:	af 2e       	mov	r10, r31
    1a14:	f8 e0       	ldi	r31, 0x08	; 8
    1a16:	bf 2e       	mov	r11, r31
    1a18:	f0 2d       	mov	r31, r0
    1a1a:	0c ea       	ldi	r16, 0xAC	; 172
    1a1c:	18 e0       	ldi	r17, 0x08	; 8
    1a1e:	ce e7       	ldi	r28, 0x7E	; 126
    1a20:	d8 e0       	ldi	r29, 0x08	; 8
    1a22:	0f 2e       	mov	r0, r31
    1a24:	f0 e8       	ldi	r31, 0x80	; 128
    1a26:	8f 2e       	mov	r8, r31
    1a28:	f8 e0       	ldi	r31, 0x08	; 8
    1a2a:	9f 2e       	mov	r9, r31
    1a2c:	f0 2d       	mov	r31, r0
    1a2e:	0f 2e       	mov	r0, r31
    1a30:	f2 e8       	ldi	r31, 0x82	; 130
    1a32:	2f 2e       	mov	r2, r31
    1a34:	f8 e0       	ldi	r31, 0x08	; 8
    1a36:	3f 2e       	mov	r3, r31
    1a38:	f0 2d       	mov	r31, r0
    1a3a:	b4 d3       	rcall	.+1896   	; 0x21a4 <vTaskSuspendAll>
    1a3c:	88 ea       	ldi	r24, 0xA8	; 168
    1a3e:	98 e0       	ldi	r25, 0x08	; 8
    1a40:	95 dc       	rcall	.-1750   	; 0x136c <_ZN6LSM3034readEv>
    1a42:	74 d4       	rcall	.+2280   	; 0x232c <xTaskResumeAll>
    1a44:	f5 01       	movw	r30, r10
    1a46:	60 81       	ld	r22, Z
    1a48:	71 81       	ldd	r23, Z+1	; 0x01
    1a4a:	88 27       	eor	r24, r24
    1a4c:	77 fd       	sbrc	r23, 7
    1a4e:	80 95       	com	r24
    1a50:	98 2f       	mov	r25, r24
    1a52:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
    1a56:	20 e0       	ldi	r18, 0x00	; 0
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	4a e7       	ldi	r20, 0x7A	; 122
    1a5c:	54 e4       	ldi	r21, 0x44	; 68
    1a5e:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    1a62:	20 e0       	ldi	r18, 0x00	; 0
    1a64:	30 e0       	ldi	r19, 0x00	; 0
    1a66:	44 e7       	ldi	r20, 0x74	; 116
    1a68:	52 e4       	ldi	r21, 0x42	; 66
    1a6a:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1a6e:	2f e6       	ldi	r18, 0x6F	; 111
    1a70:	32 e1       	ldi	r19, 0x12	; 18
    1a72:	43 e8       	ldi	r20, 0x83	; 131
    1a74:	5a e3       	ldi	r21, 0x3A	; 58
    1a76:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1a7a:	2d ec       	ldi	r18, 0xCD	; 205
    1a7c:	3c ec       	ldi	r19, 0xCC	; 204
    1a7e:	4c e1       	ldi	r20, 0x1C	; 28
    1a80:	51 e4       	ldi	r21, 0x41	; 65
    1a82:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1a86:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1a8a:	2b 01       	movw	r4, r22
    1a8c:	3c 01       	movw	r6, r24
    1a8e:	f8 01       	movw	r30, r16
    1a90:	60 81       	ld	r22, Z
    1a92:	71 81       	ldd	r23, Z+1	; 0x01
    1a94:	88 27       	eor	r24, r24
    1a96:	77 fd       	sbrc	r23, 7
    1a98:	80 95       	com	r24
    1a9a:	98 2f       	mov	r25, r24
    1a9c:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
    1aa0:	20 e0       	ldi	r18, 0x00	; 0
    1aa2:	30 e0       	ldi	r19, 0x00	; 0
    1aa4:	4a e7       	ldi	r20, 0x7A	; 122
    1aa6:	54 e4       	ldi	r21, 0x44	; 68
    1aa8:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    1aac:	20 e0       	ldi	r18, 0x00	; 0
    1aae:	30 e0       	ldi	r19, 0x00	; 0
    1ab0:	44 e7       	ldi	r20, 0x74	; 116
    1ab2:	52 e4       	ldi	r21, 0x42	; 66
    1ab4:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1ab8:	2f e6       	ldi	r18, 0x6F	; 111
    1aba:	32 e1       	ldi	r19, 0x12	; 18
    1abc:	43 e8       	ldi	r20, 0x83	; 131
    1abe:	5a e3       	ldi	r21, 0x3A	; 58
    1ac0:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1ac4:	2d ec       	ldi	r18, 0xCD	; 205
    1ac6:	3c ec       	ldi	r19, 0xCC	; 204
    1ac8:	4c e1       	ldi	r20, 0x1C	; 28
    1aca:	51 e4       	ldi	r21, 0x41	; 65
    1acc:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1ad0:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1ad4:	6b 01       	movw	r12, r22
    1ad6:	7c 01       	movw	r14, r24
    1ad8:	80 91 a8 08 	lds	r24, 0x08A8
    1adc:	90 91 a9 08 	lds	r25, 0x08A9
    1ae0:	bc 01       	movw	r22, r24
    1ae2:	88 27       	eor	r24, r24
    1ae4:	77 fd       	sbrc	r23, 7
    1ae6:	80 95       	com	r24
    1ae8:	98 2f       	mov	r25, r24
    1aea:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
    1aee:	20 e0       	ldi	r18, 0x00	; 0
    1af0:	30 e0       	ldi	r19, 0x00	; 0
    1af2:	4a e7       	ldi	r20, 0x7A	; 122
    1af4:	54 e4       	ldi	r21, 0x44	; 68
    1af6:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    1afa:	20 e0       	ldi	r18, 0x00	; 0
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	44 e7       	ldi	r20, 0x74	; 116
    1b00:	52 e4       	ldi	r21, 0x42	; 66
    1b02:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1b06:	2f e6       	ldi	r18, 0x6F	; 111
    1b08:	32 e1       	ldi	r19, 0x12	; 18
    1b0a:	43 e8       	ldi	r20, 0x83	; 131
    1b0c:	5a e3       	ldi	r21, 0x3A	; 58
    1b0e:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1b12:	2d ec       	ldi	r18, 0xCD	; 205
    1b14:	3c ec       	ldi	r19, 0xCC	; 204
    1b16:	4c e1       	ldi	r20, 0x1C	; 28
    1b18:	51 e4       	ldi	r21, 0x41	; 65
    1b1a:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1b1e:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1b22:	79 83       	std	Y+1, r23	; 0x01
    1b24:	68 83       	st	Y, r22
    1b26:	f4 01       	movw	r30, r8
    1b28:	51 82       	std	Z+1, r5	; 0x01
    1b2a:	40 82       	st	Z, r4
    1b2c:	f1 01       	movw	r30, r2
    1b2e:	d1 82       	std	Z+1, r13	; 0x01
    1b30:	c0 82       	st	Z, r12
    1b32:	84 ef       	ldi	r24, 0xF4	; 244
    1b34:	91 e0       	ldi	r25, 0x01	; 1
    1b36:	7b d4       	rcall	.+2294   	; 0x242e <vTaskDelay>
    1b38:	80 cf       	rjmp	.-256    	; 0x1a3a <_Z11taskReadAccPv+0x2c>

00001b3a <_Z12taskReadGyroPv>:
    1b3a:	0f 2e       	mov	r0, r31
    1b3c:	fe e9       	ldi	r31, 0x9E	; 158
    1b3e:	af 2e       	mov	r10, r31
    1b40:	f8 e0       	ldi	r31, 0x08	; 8
    1b42:	bf 2e       	mov	r11, r31
    1b44:	f0 2d       	mov	r31, r0
    1b46:	00 ea       	ldi	r16, 0xA0	; 160
    1b48:	18 e0       	ldi	r17, 0x08	; 8
    1b4a:	c4 e8       	ldi	r28, 0x84	; 132
    1b4c:	d8 e0       	ldi	r29, 0x08	; 8
    1b4e:	0f 2e       	mov	r0, r31
    1b50:	f6 e8       	ldi	r31, 0x86	; 134
    1b52:	8f 2e       	mov	r8, r31
    1b54:	f8 e0       	ldi	r31, 0x08	; 8
    1b56:	9f 2e       	mov	r9, r31
    1b58:	f0 2d       	mov	r31, r0
    1b5a:	0f 2e       	mov	r0, r31
    1b5c:	f8 e8       	ldi	r31, 0x88	; 136
    1b5e:	2f 2e       	mov	r2, r31
    1b60:	f8 e0       	ldi	r31, 0x08	; 8
    1b62:	3f 2e       	mov	r3, r31
    1b64:	f0 2d       	mov	r31, r0
    1b66:	1e d3       	rcall	.+1596   	; 0x21a4 <vTaskSuspendAll>
    1b68:	8c e9       	ldi	r24, 0x9C	; 156
    1b6a:	98 e0       	ldi	r25, 0x08	; 8
    1b6c:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <_ZN3L3G4readEv>
    1b70:	dd d3       	rcall	.+1978   	; 0x232c <xTaskResumeAll>
    1b72:	f5 01       	movw	r30, r10
    1b74:	60 81       	ld	r22, Z
    1b76:	71 81       	ldd	r23, Z+1	; 0x01
    1b78:	88 27       	eor	r24, r24
    1b7a:	77 fd       	sbrc	r23, 7
    1b7c:	80 95       	com	r24
    1b7e:	98 2f       	mov	r25, r24
    1b80:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
    1b84:	20 e0       	ldi	r18, 0x00	; 0
    1b86:	30 e0       	ldi	r19, 0x00	; 0
    1b88:	4c e0       	ldi	r20, 0x0C	; 12
    1b8a:	51 e4       	ldi	r21, 0x41	; 65
    1b8c:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1b90:	20 e0       	ldi	r18, 0x00	; 0
    1b92:	30 e0       	ldi	r19, 0x00	; 0
    1b94:	4a e7       	ldi	r20, 0x7A	; 122
    1b96:	54 e4       	ldi	r21, 0x44	; 68
    1b98:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    1b9c:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1ba0:	2b 01       	movw	r4, r22
    1ba2:	3c 01       	movw	r6, r24
    1ba4:	f8 01       	movw	r30, r16
    1ba6:	60 81       	ld	r22, Z
    1ba8:	71 81       	ldd	r23, Z+1	; 0x01
    1baa:	88 27       	eor	r24, r24
    1bac:	77 fd       	sbrc	r23, 7
    1bae:	80 95       	com	r24
    1bb0:	98 2f       	mov	r25, r24
    1bb2:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
    1bb6:	20 e0       	ldi	r18, 0x00	; 0
    1bb8:	30 e0       	ldi	r19, 0x00	; 0
    1bba:	4c e0       	ldi	r20, 0x0C	; 12
    1bbc:	51 e4       	ldi	r21, 0x41	; 65
    1bbe:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1bc2:	20 e0       	ldi	r18, 0x00	; 0
    1bc4:	30 e0       	ldi	r19, 0x00	; 0
    1bc6:	4a e7       	ldi	r20, 0x7A	; 122
    1bc8:	54 e4       	ldi	r21, 0x44	; 68
    1bca:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    1bce:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1bd2:	6b 01       	movw	r12, r22
    1bd4:	7c 01       	movw	r14, r24
    1bd6:	80 91 9c 08 	lds	r24, 0x089C
    1bda:	90 91 9d 08 	lds	r25, 0x089D
    1bde:	bc 01       	movw	r22, r24
    1be0:	88 27       	eor	r24, r24
    1be2:	77 fd       	sbrc	r23, 7
    1be4:	80 95       	com	r24
    1be6:	98 2f       	mov	r25, r24
    1be8:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__floatsisf>
    1bec:	20 e0       	ldi	r18, 0x00	; 0
    1bee:	30 e0       	ldi	r19, 0x00	; 0
    1bf0:	4c e0       	ldi	r20, 0x0C	; 12
    1bf2:	51 e4       	ldi	r21, 0x41	; 65
    1bf4:	0e 94 f7 17 	call	0x2fee	; 0x2fee <__mulsf3>
    1bf8:	20 e0       	ldi	r18, 0x00	; 0
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	4a e7       	ldi	r20, 0x7A	; 122
    1bfe:	54 e4       	ldi	r21, 0x44	; 68
    1c00:	0e 94 80 16 	call	0x2d00	; 0x2d00 <__divsf3>
    1c04:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1c08:	79 83       	std	Y+1, r23	; 0x01
    1c0a:	68 83       	st	Y, r22
    1c0c:	f4 01       	movw	r30, r8
    1c0e:	51 82       	std	Z+1, r5	; 0x01
    1c10:	40 82       	st	Z, r4
    1c12:	f1 01       	movw	r30, r2
    1c14:	d1 82       	std	Z+1, r13	; 0x01
    1c16:	c0 82       	st	Z, r12
    1c18:	84 ef       	ldi	r24, 0xF4	; 244
    1c1a:	91 e0       	ldi	r25, 0x01	; 1
    1c1c:	08 d4       	rcall	.+2064   	; 0x242e <vTaskDelay>
    1c1e:	a3 cf       	rjmp	.-186    	; 0x1b66 <_Z12taskReadGyroPv+0x2c>

00001c20 <_Z15taskReadMagnetoPv>:
    1c20:	cc e8       	ldi	r28, 0x8C	; 140
    1c22:	d8 e0       	ldi	r29, 0x08	; 8
    1c24:	bf d2       	rcall	.+1406   	; 0x21a4 <vTaskSuspendAll>
    1c26:	88 ea       	ldi	r24, 0xA8	; 168
    1c28:	98 e0       	ldi	r25, 0x08	; 8
    1c2a:	a0 db       	rcall	.-2240   	; 0x136c <_ZN6LSM3034readEv>
    1c2c:	88 ea       	ldi	r24, 0xA8	; 168
    1c2e:	98 e0       	ldi	r25, 0x08	; 8
    1c30:	ae d9       	rcall	.-3236   	; 0xf8e <_ZN6LSM3037headingEv>
    1c32:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <__fixsfsi>
    1c36:	79 83       	std	Y+1, r23	; 0x01
    1c38:	68 83       	st	Y, r22
    1c3a:	78 d3       	rcall	.+1776   	; 0x232c <xTaskResumeAll>
    1c3c:	84 ef       	ldi	r24, 0xF4	; 244
    1c3e:	91 e0       	ldi	r25, 0x01	; 1
    1c40:	f6 d3       	rcall	.+2028   	; 0x242e <vTaskDelay>
    1c42:	f0 cf       	rjmp	.-32     	; 0x1c24 <_Z15taskReadMagnetoPv+0x4>

00001c44 <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1c44:	26 e0       	ldi	r18, 0x06	; 6
    1c46:	40 e8       	ldi	r20, 0x80	; 128
    1c48:	55 e2       	ldi	r21, 0x25	; 37
    1c4a:	60 e0       	ldi	r22, 0x00	; 0
    1c4c:	70 e0       	ldi	r23, 0x00	; 0
    1c4e:	87 ee       	ldi	r24, 0xE7	; 231
    1c50:	99 e0       	ldi	r25, 0x09	; 9
    1c52:	0e 94 69 19 	call	0x32d2	; 0x32d2 <_ZN14HardwareSerial5beginEmh>
void setup(void) 
{
	// Starting up serial monitor
	Serial.begin(9600);
	// Setting up compass
	Wire.begin();
    1c56:	85 e9       	ldi	r24, 0x95	; 149
    1c58:	99 e0       	ldi	r25, 0x09	; 9
    1c5a:	4b d7       	rcall	.+3734   	; 0x2af2 <_ZN7TwoWire5beginEv>
	compass.init();
    1c5c:	42 e0       	ldi	r20, 0x02	; 2
    1c5e:	64 e0       	ldi	r22, 0x04	; 4
    1c60:	88 ea       	ldi	r24, 0xA8	; 168
    1c62:	98 e0       	ldi	r25, 0x08	; 8
    1c64:	b8 db       	rcall	.-2192   	; 0x13d6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    1c66:	88 ea       	ldi	r24, 0xA8	; 168
    1c68:	98 e0       	ldi	r25, 0x08	; 8
    1c6a:	0f da       	rcall	.-3042   	; 0x108a <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    1c6c:	86 e0       	ldi	r24, 0x06	; 6
    1c6e:	ef e1       	ldi	r30, 0x1F	; 31
    1c70:	f2 e0       	ldi	r31, 0x02	; 2
    1c72:	aa eb       	ldi	r26, 0xBA	; 186
    1c74:	b8 e0       	ldi	r27, 0x08	; 8
    1c76:	01 90       	ld	r0, Z+
    1c78:	0d 92       	st	X+, r0
    1c7a:	8a 95       	dec	r24
    1c7c:	e1 f7       	brne	.-8      	; 0x1c76 <setup+0x32>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    1c7e:	86 e0       	ldi	r24, 0x06	; 6
    1c80:	e5 e2       	ldi	r30, 0x25	; 37
    1c82:	f2 e0       	ldi	r31, 0x02	; 2
    1c84:	a4 eb       	ldi	r26, 0xB4	; 180
    1c86:	b8 e0       	ldi	r27, 0x08	; 8
    1c88:	01 90       	ld	r0, Z+
    1c8a:	0d 92       	st	X+, r0
    1c8c:	8a 95       	dec	r24
    1c8e:	e1 f7       	brne	.-8      	; 0x1c88 <setup+0x44>
	gyro.init();
    1c90:	42 e0       	ldi	r20, 0x02	; 2
    1c92:	63 e0       	ldi	r22, 0x03	; 3
    1c94:	8c e9       	ldi	r24, 0x9C	; 156
    1c96:	98 e0       	ldi	r25, 0x08	; 8
    1c98:	0e 94 84 03 	call	0x708	; 0x708 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
	gyro.enableDefault();
    1c9c:	8c e9       	ldi	r24, 0x9C	; 156
    1c9e:	98 e0       	ldi	r25, 0x08	; 8
    1ca0:	0e 94 cb 02 	call	0x596	; 0x596 <_ZN3L3G13enableDefaultEv>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	80 91 0c 02 	lds	r24, 0x020C
    1caa:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
	pinMode(echo_1, INPUT);
    1cae:	60 e0       	ldi	r22, 0x00	; 0
    1cb0:	80 91 0e 02 	lds	r24, 0x020E
    1cb4:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
	pinMode(echo_2, INPUT);
    1cb8:	60 e0       	ldi	r22, 0x00	; 0
    1cba:	80 91 0a 02 	lds	r24, 0x020A
    1cbe:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
	pinMode(trigger_2, OUTPUT);
    1cc2:	61 e0       	ldi	r22, 0x01	; 1
    1cc4:	80 91 08 02 	lds	r24, 0x0208
    1cc8:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
	pinMode(echo_3, INPUT);
    1ccc:	60 e0       	ldi	r22, 0x00	; 0
    1cce:	80 91 06 02 	lds	r24, 0x0206
    1cd2:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
	pinMode(trigger_3, OUTPUT);
    1cd6:	61 e0       	ldi	r22, 0x01	; 1
    1cd8:	80 91 04 02 	lds	r24, 0x0204
    1cdc:	0e 94 94 1c 	call	0x3928	; 0x3928 <pinMode>
	
	pinMode(analog_1, INPUT);
    1ce0:	60 e0       	ldi	r22, 0x00	; 0
    1ce2:	80 91 02 02 	lds	r24, 0x0202
    1ce6:	0c 94 94 1c 	jmp	0x3928	; 0x3928 <pinMode>
    1cea:	08 95       	ret

00001cec <main>:
}

int main(void)
{
    1cec:	af 92       	push	r10
    1cee:	bf 92       	push	r11
    1cf0:	cf 92       	push	r12
    1cf2:	df 92       	push	r13
    1cf4:	ef 92       	push	r14
    1cf6:	ff 92       	push	r15
    1cf8:	0f 93       	push	r16
    1cfa:	cf 93       	push	r28
    1cfc:	df 93       	push	r29
    1cfe:	cd b7       	in	r28, 0x3d	; 61
    1d00:	de b7       	in	r29, 0x3e	; 62
    1d02:	2a 97       	sbiw	r28, 0x0a	; 10
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	de bf       	out	0x3e, r29	; 62
    1d0a:	0f be       	out	0x3f, r0	; 63
    1d0c:	cd bf       	out	0x3d, r28	; 61
	init();
    1d0e:	0e 94 c9 1b 	call	0x3792	; 0x3792 <init>
	setup();
    1d12:	98 df       	rcall	.-208    	; 0x1c44 <setup>
	TaskHandle_t t1, t2, t3, t4, t5, t6;
	// Create tasks
	xTaskCreate(printArray, "printA", STACK_DEPTH, NULL, 10, &t1);
    1d14:	a1 2c       	mov	r10, r1
    1d16:	b1 2c       	mov	r11, r1
    1d18:	c1 2c       	mov	r12, r1
    1d1a:	d1 2c       	mov	r13, r1
    1d1c:	ce 01       	movw	r24, r28
    1d1e:	09 96       	adiw	r24, 0x09	; 9
    1d20:	7c 01       	movw	r14, r24
    1d22:	0a e0       	ldi	r16, 0x0A	; 10
    1d24:	20 e0       	ldi	r18, 0x00	; 0
    1d26:	30 e0       	ldi	r19, 0x00	; 0
    1d28:	48 ec       	ldi	r20, 0xC8	; 200
    1d2a:	50 e0       	ldi	r21, 0x00	; 0
    1d2c:	6b e2       	ldi	r22, 0x2B	; 43
    1d2e:	72 e0       	ldi	r23, 0x02	; 2
    1d30:	8a ef       	ldi	r24, 0xFA	; 250
    1d32:	9e e0       	ldi	r25, 0x0E	; 14
    1d34:	06 d1       	rcall	.+524    	; 0x1f42 <xTaskGenericCreate>
	xTaskCreate(taskReadGyro, "Read Gyrometer", STACK_DEPTH, NULL, 9, &t2);
    1d36:	ce 01       	movw	r24, r28
    1d38:	07 96       	adiw	r24, 0x07	; 7
    1d3a:	7c 01       	movw	r14, r24
    1d3c:	09 e0       	ldi	r16, 0x09	; 9
    1d3e:	20 e0       	ldi	r18, 0x00	; 0
    1d40:	30 e0       	ldi	r19, 0x00	; 0
    1d42:	48 ec       	ldi	r20, 0xC8	; 200
    1d44:	50 e0       	ldi	r21, 0x00	; 0
    1d46:	62 e3       	ldi	r22, 0x32	; 50
    1d48:	72 e0       	ldi	r23, 0x02	; 2
    1d4a:	8d e9       	ldi	r24, 0x9D	; 157
    1d4c:	9d e0       	ldi	r25, 0x0D	; 13
    1d4e:	f9 d0       	rcall	.+498    	; 0x1f42 <xTaskGenericCreate>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
    1d50:	ce 01       	movw	r24, r28
    1d52:	05 96       	adiw	r24, 0x05	; 5
    1d54:	7c 01       	movw	r14, r24
    1d56:	08 e0       	ldi	r16, 0x08	; 8
    1d58:	20 e0       	ldi	r18, 0x00	; 0
    1d5a:	30 e0       	ldi	r19, 0x00	; 0
    1d5c:	48 ec       	ldi	r20, 0xC8	; 200
    1d5e:	50 e0       	ldi	r21, 0x00	; 0
    1d60:	61 e4       	ldi	r22, 0x41	; 65
    1d62:	72 e0       	ldi	r23, 0x02	; 2
    1d64:	87 e0       	ldi	r24, 0x07	; 7
    1d66:	9d e0       	ldi	r25, 0x0D	; 13
    1d68:	ec d0       	rcall	.+472    	; 0x1f42 <xTaskGenericCreate>
	//xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
    1d6a:	ce 01       	movw	r24, r28
    1d6c:	03 96       	adiw	r24, 0x03	; 3
    1d6e:	7c 01       	movw	r14, r24
    1d70:	06 e0       	ldi	r16, 0x06	; 6
    1d72:	20 e0       	ldi	r18, 0x00	; 0
    1d74:	30 e0       	ldi	r19, 0x00	; 0
    1d76:	48 ec       	ldi	r20, 0xC8	; 200
    1d78:	50 e0       	ldi	r21, 0x00	; 0
    1d7a:	64 e5       	ldi	r22, 0x54	; 84
    1d7c:	72 e0       	ldi	r23, 0x02	; 2
    1d7e:	80 e1       	ldi	r24, 0x10	; 16
    1d80:	9e e0       	ldi	r25, 0x0E	; 14
    1d82:	df d0       	rcall	.+446    	; 0x1f42 <xTaskGenericCreate>
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
    1d84:	ce 01       	movw	r24, r28
    1d86:	01 96       	adiw	r24, 0x01	; 1
    1d88:	7c 01       	movw	r14, r24
    1d8a:	05 e0       	ldi	r16, 0x05	; 5
    1d8c:	20 e0       	ldi	r18, 0x00	; 0
    1d8e:	30 e0       	ldi	r19, 0x00	; 0
    1d90:	48 ec       	ldi	r20, 0xC8	; 200
    1d92:	50 e0       	ldi	r21, 0x00	; 0
    1d94:	61 e6       	ldi	r22, 0x61	; 97
    1d96:	72 e0       	ldi	r23, 0x02	; 2
    1d98:	8e e3       	ldi	r24, 0x3E	; 62
    1d9a:	9c e0       	ldi	r25, 0x0C	; 12
    1d9c:	d2 d0       	rcall	.+420    	; 0x1f42 <xTaskGenericCreate>
	vTaskStartScheduler();
    1d9e:	d9 d1       	rcall	.+946    	; 0x2152 <vTaskStartScheduler>
}
    1da0:	80 e0       	ldi	r24, 0x00	; 0
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	2a 96       	adiw	r28, 0x0a	; 10
    1da6:	0f b6       	in	r0, 0x3f	; 63
    1da8:	f8 94       	cli
    1daa:	de bf       	out	0x3e, r29	; 62
    1dac:	0f be       	out	0x3f, r0	; 63
    1dae:	cd bf       	out	0x3d, r28	; 61
    1db0:	df 91       	pop	r29
    1db2:	cf 91       	pop	r28
    1db4:	0f 91       	pop	r16
    1db6:	ff 90       	pop	r15
    1db8:	ef 90       	pop	r14
    1dba:	df 90       	pop	r13
    1dbc:	cf 90       	pop	r12
    1dbe:	bf 90       	pop	r11
    1dc0:	af 90       	pop	r10
    1dc2:	08 95       	ret

00001dc4 <_GLOBAL__sub_I_echo_1>:
    1dc4:	0f 93       	push	r16
    1dc6:	1f 93       	push	r17
int echo_3 = 7;
int trigger_3 = 8;

int analog_1 = A0; 
int numOfData = 11;
LSM303 compass;
    1dc8:	88 ea       	ldi	r24, 0xA8	; 168
    1dca:	98 e0       	ldi	r25, 0x08	; 8
    1dcc:	0e 94 a6 04 	call	0x94c	; 0x94c <_ZN6LSM303C1Ev>
L3G gyro;
    1dd0:	8c e9       	ldi	r24, 0x9C	; 156
    1dd2:	98 e0       	ldi	r25, 0x08	; 8
    1dd4:	0e 94 a4 02 	call	0x548	; 0x548 <_ZN3L3GC1Ev>
SharpIR sharp(A0, 25, 93, 20150);
    1dd8:	06 eb       	ldi	r16, 0xB6	; 182
    1dda:	1e e4       	ldi	r17, 0x4E	; 78
    1ddc:	2d e5       	ldi	r18, 0x5D	; 93
    1dde:	30 e0       	ldi	r19, 0x00	; 0
    1de0:	49 e1       	ldi	r20, 0x19	; 25
    1de2:	50 e0       	ldi	r21, 0x00	; 0
    1de4:	66 e3       	ldi	r22, 0x36	; 54
    1de6:	70 e0       	ldi	r23, 0x00	; 0
    1de8:	8e e8       	ldi	r24, 0x8E	; 142
    1dea:	98 e0       	ldi	r25, 0x08	; 8
    1dec:	3e d0       	rcall	.+124    	; 0x1e6a <_ZN7SharpIRC1Eiiii>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
	//xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
	vTaskStartScheduler();
}
    1dee:	1f 91       	pop	r17
    1df0:	0f 91       	pop	r16
    1df2:	08 95       	ret

00001df4 <_Z10printArrayPv>:
	return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int)__brkval);
}

void printArray(void *p) {
	int i;
	char canRead = '0';
    1df4:	c0 e3       	ldi	r28, 0x30	; 48
    1df6:	0f 2e       	mov	r0, r31
    1df8:	f8 e7       	ldi	r31, 0x78	; 120
    1dfa:	ef 2e       	mov	r14, r31
    1dfc:	f8 e0       	ldi	r31, 0x08	; 8
    1dfe:	ff 2e       	mov	r15, r31
    1e00:	f0 2d       	mov	r31, r0
    1e02:	0e e8       	ldi	r16, 0x8E	; 142
    1e04:	18 e0       	ldi	r17, 0x08	; 8
	while(1) {
		if(Serial.available()){
    1e06:	87 ee       	ldi	r24, 0xE7	; 231
    1e08:	99 e0       	ldi	r25, 0x09	; 9
    1e0a:	0e 94 b4 18 	call	0x3168	; 0x3168 <_ZN14HardwareSerial9availableEv>
    1e0e:	89 2b       	or	r24, r25
    1e10:	29 f0       	breq	.+10     	; 0x1e1c <_Z10printArrayPv+0x28>
			canRead = Serial.read();
    1e12:	87 ee       	ldi	r24, 0xE7	; 231
    1e14:	99 e0       	ldi	r25, 0x09	; 9
    1e16:	0e 94 cd 18 	call	0x319a	; 0x319a <_ZN14HardwareSerial4readEv>
    1e1a:	c8 2f       	mov	r28, r24
		}
		if(canRead - '0'){
    1e1c:	c0 33       	cpi	r28, 0x30	; 48
    1e1e:	09 f1       	breq	.+66     	; 0x1e62 <_Z10printArrayPv+0x6e>
			Serial.print(numOfData);
    1e20:	60 91 00 02 	lds	r22, 0x0200
    1e24:	70 91 01 02 	lds	r23, 0x0201
    1e28:	4a e0       	ldi	r20, 0x0A	; 10
    1e2a:	50 e0       	ldi	r21, 0x00	; 0
    1e2c:	87 ee       	ldi	r24, 0xE7	; 231
    1e2e:	99 e0       	ldi	r25, 0x09	; 9
    1e30:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <_ZN5Print5printEii>
			Serial.print('\r');
    1e34:	6d e0       	ldi	r22, 0x0D	; 13
    1e36:	87 ee       	ldi	r24, 0xE7	; 231
    1e38:	99 e0       	ldi	r25, 0x09	; 9
    1e3a:	0e 94 a6 1a 	call	0x354c	; 0x354c <_ZN5Print5printEc>
    1e3e:	e7 01       	movw	r28, r14
			for(i = 1; i < 12; i++) {
				Serial.print(data[i]);
    1e40:	69 91       	ld	r22, Y+
    1e42:	79 91       	ld	r23, Y+
    1e44:	4a e0       	ldi	r20, 0x0A	; 10
    1e46:	50 e0       	ldi	r21, 0x00	; 0
    1e48:	87 ee       	ldi	r24, 0xE7	; 231
    1e4a:	99 e0       	ldi	r25, 0x09	; 9
    1e4c:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <_ZN5Print5printEii>
				Serial.print('\r');
    1e50:	6d e0       	ldi	r22, 0x0D	; 13
    1e52:	87 ee       	ldi	r24, 0xE7	; 231
    1e54:	99 e0       	ldi	r25, 0x09	; 9
    1e56:	0e 94 a6 1a 	call	0x354c	; 0x354c <_ZN5Print5printEc>
			canRead = Serial.read();
		}
		if(canRead - '0'){
			Serial.print(numOfData);
			Serial.print('\r');
			for(i = 1; i < 12; i++) {
    1e5a:	c0 17       	cp	r28, r16
    1e5c:	d1 07       	cpc	r29, r17
    1e5e:	81 f7       	brne	.-32     	; 0x1e40 <_Z10printArrayPv+0x4c>
				Serial.print(data[i]);
				Serial.print('\r');
			}
			//Serial.println(freeRAM());
			canRead = '0';	
    1e60:	c0 e3       	ldi	r28, 0x30	; 48
		/*
		for(i = 1; i < 12; i++) {
			Serial.println(data[i]);
			Serial.print('\r');
		}*/
		vTaskDelay(100);
    1e62:	84 e6       	ldi	r24, 0x64	; 100
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	e3 d2       	rcall	.+1478   	; 0x242e <vTaskDelay>
	}
    1e68:	ce cf       	rjmp	.-100    	; 0x1e06 <_Z10printArrayPv+0x12>

00001e6a <_ZN7SharpIRC1Eiiii>:
#include "Arduino.h"
#include "SharpIR.h"



SharpIR::SharpIR(int irPin, int avg, int tolerance, int sensorModel) {
    1e6a:	0f 93       	push	r16
    1e6c:	1f 93       	push	r17
    1e6e:	fc 01       	movw	r30, r24
    1e70:	c9 01       	movw	r24, r18
  
    _irPin=irPin;
    1e72:	71 83       	std	Z+1, r23	; 0x01
    1e74:	60 83       	st	Z, r22
    _avg=avg;
    1e76:	55 83       	std	Z+5, r21	; 0x05
    1e78:	44 83       	std	Z+4, r20	; 0x04
    _tol=tolerance/100;
    1e7a:	64 e6       	ldi	r22, 0x64	; 100
    1e7c:	70 e0       	ldi	r23, 0x00	; 0
    1e7e:	0e 94 40 1d 	call	0x3a80	; 0x3a80 <__divmodhi4>
    1e82:	75 87       	std	Z+13, r23	; 0x0d
    1e84:	64 87       	std	Z+12, r22	; 0x0c
    _model=sensorModel;
    1e86:	13 83       	std	Z+3, r17	; 0x03
    1e88:	02 83       	std	Z+2, r16	; 0x02
    
    analogReference(DEFAULT);
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	0e 94 2b 1c 	call	0x3856	; 0x3856 <analogReference>
 
}
    1e90:	1f 91       	pop	r17
    1e92:	0f 91       	pop	r16
    1e94:	08 95       	ret

00001e96 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1e96:	e0 91 ed 08 	lds	r30, 0x08ED
    1e9a:	f0 91 ee 08 	lds	r31, 0x08EE
    1e9e:	80 81       	ld	r24, Z
    1ea0:	81 11       	cpse	r24, r1
    1ea2:	07 c0       	rjmp	.+14     	; 0x1eb2 <prvResetNextTaskUnblockTime+0x1c>
    1ea4:	8f ef       	ldi	r24, 0xFF	; 255
    1ea6:	9f ef       	ldi	r25, 0xFF	; 255
    1ea8:	90 93 11 02 	sts	0x0211, r25
    1eac:	80 93 10 02 	sts	0x0210, r24
    1eb0:	08 95       	ret
    1eb2:	e0 91 ed 08 	lds	r30, 0x08ED
    1eb6:	f0 91 ee 08 	lds	r31, 0x08EE
    1eba:	05 80       	ldd	r0, Z+5	; 0x05
    1ebc:	f6 81       	ldd	r31, Z+6	; 0x06
    1ebe:	e0 2d       	mov	r30, r0
    1ec0:	06 80       	ldd	r0, Z+6	; 0x06
    1ec2:	f7 81       	ldd	r31, Z+7	; 0x07
    1ec4:	e0 2d       	mov	r30, r0
    1ec6:	82 81       	ldd	r24, Z+2	; 0x02
    1ec8:	93 81       	ldd	r25, Z+3	; 0x03
    1eca:	90 93 11 02 	sts	0x0211, r25
    1ece:	80 93 10 02 	sts	0x0210, r24
    1ed2:	08 95       	ret

00001ed4 <prvAddCurrentTaskToDelayedList>:
    1ed4:	cf 93       	push	r28
    1ed6:	df 93       	push	r29
    1ed8:	ec 01       	movw	r28, r24
    1eda:	e0 91 25 09 	lds	r30, 0x0925
    1ede:	f0 91 26 09 	lds	r31, 0x0926
    1ee2:	93 83       	std	Z+3, r25	; 0x03
    1ee4:	82 83       	std	Z+2, r24	; 0x02
    1ee6:	80 91 d5 08 	lds	r24, 0x08D5
    1eea:	90 91 d6 08 	lds	r25, 0x08D6
    1eee:	c8 17       	cp	r28, r24
    1ef0:	d9 07       	cpc	r29, r25
    1ef2:	68 f4       	brcc	.+26     	; 0x1f0e <prvAddCurrentTaskToDelayedList+0x3a>
    1ef4:	60 91 25 09 	lds	r22, 0x0925
    1ef8:	70 91 26 09 	lds	r23, 0x0926
    1efc:	80 91 eb 08 	lds	r24, 0x08EB
    1f00:	90 91 ec 08 	lds	r25, 0x08EC
    1f04:	6e 5f       	subi	r22, 0xFE	; 254
    1f06:	7f 4f       	sbci	r23, 0xFF	; 255
    1f08:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInsert>
    1f0c:	17 c0       	rjmp	.+46     	; 0x1f3c <prvAddCurrentTaskToDelayedList+0x68>
    1f0e:	60 91 25 09 	lds	r22, 0x0925
    1f12:	70 91 26 09 	lds	r23, 0x0926
    1f16:	80 91 ed 08 	lds	r24, 0x08ED
    1f1a:	90 91 ee 08 	lds	r25, 0x08EE
    1f1e:	6e 5f       	subi	r22, 0xFE	; 254
    1f20:	7f 4f       	sbci	r23, 0xFF	; 255
    1f22:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInsert>
    1f26:	80 91 10 02 	lds	r24, 0x0210
    1f2a:	90 91 11 02 	lds	r25, 0x0211
    1f2e:	c8 17       	cp	r28, r24
    1f30:	d9 07       	cpc	r29, r25
    1f32:	20 f4       	brcc	.+8      	; 0x1f3c <prvAddCurrentTaskToDelayedList+0x68>
    1f34:	d0 93 11 02 	sts	0x0211, r29
    1f38:	c0 93 10 02 	sts	0x0210, r28
    1f3c:	df 91       	pop	r29
    1f3e:	cf 91       	pop	r28
    1f40:	08 95       	ret

00001f42 <xTaskGenericCreate>:
    1f42:	4f 92       	push	r4
    1f44:	5f 92       	push	r5
    1f46:	6f 92       	push	r6
    1f48:	7f 92       	push	r7
    1f4a:	8f 92       	push	r8
    1f4c:	9f 92       	push	r9
    1f4e:	af 92       	push	r10
    1f50:	bf 92       	push	r11
    1f52:	cf 92       	push	r12
    1f54:	df 92       	push	r13
    1f56:	ef 92       	push	r14
    1f58:	ff 92       	push	r15
    1f5a:	0f 93       	push	r16
    1f5c:	1f 93       	push	r17
    1f5e:	cf 93       	push	r28
    1f60:	df 93       	push	r29
    1f62:	4c 01       	movw	r8, r24
    1f64:	5b 01       	movw	r10, r22
    1f66:	2a 01       	movw	r4, r20
    1f68:	39 01       	movw	r6, r18
    1f6a:	81 e2       	ldi	r24, 0x21	; 33
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1f72:	ec 01       	movw	r28, r24
    1f74:	00 97       	sbiw	r24, 0x00	; 0
    1f76:	09 f4       	brne	.+2      	; 0x1f7a <xTaskGenericCreate+0x38>
    1f78:	da c0       	rjmp	.+436    	; 0x212e <xTaskGenericCreate+0x1ec>
    1f7a:	c1 14       	cp	r12, r1
    1f7c:	d1 04       	cpc	r13, r1
    1f7e:	09 f0       	breq	.+2      	; 0x1f82 <xTaskGenericCreate+0x40>
    1f80:	bf c0       	rjmp	.+382    	; 0x2100 <xTaskGenericCreate+0x1be>
    1f82:	c2 01       	movw	r24, r4
    1f84:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1f88:	98 8f       	std	Y+24, r25	; 0x18
    1f8a:	8f 8b       	std	Y+23, r24	; 0x17
    1f8c:	89 2b       	or	r24, r25
    1f8e:	09 f0       	breq	.+2      	; 0x1f92 <xTaskGenericCreate+0x50>
    1f90:	b9 c0       	rjmp	.+370    	; 0x2104 <xTaskGenericCreate+0x1c2>
    1f92:	ce 01       	movw	r24, r28
    1f94:	0e 94 a3 02 	call	0x546	; 0x546 <vPortFree>
    1f98:	ca c0       	rjmp	.+404    	; 0x212e <xTaskGenericCreate+0x1ec>
    1f9a:	cf 01       	movw	r24, r30
    1f9c:	31 91       	ld	r19, Z+
    1f9e:	da 01       	movw	r26, r20
    1fa0:	3d 93       	st	X+, r19
    1fa2:	ad 01       	movw	r20, r26
    1fa4:	dc 01       	movw	r26, r24
    1fa6:	8c 91       	ld	r24, X
    1fa8:	88 23       	and	r24, r24
    1faa:	11 f0       	breq	.+4      	; 0x1fb0 <xTaskGenericCreate+0x6e>
    1fac:	21 50       	subi	r18, 0x01	; 1
    1fae:	a9 f7       	brne	.-22     	; 0x1f9a <xTaskGenericCreate+0x58>
    1fb0:	18 a2       	std	Y+32, r1	; 0x20
    1fb2:	10 2f       	mov	r17, r16
    1fb4:	04 30       	cpi	r16, 0x04	; 4
    1fb6:	08 f0       	brcs	.+2      	; 0x1fba <xTaskGenericCreate+0x78>
    1fb8:	13 e0       	ldi	r17, 0x03	; 3
    1fba:	1e 8b       	std	Y+22, r17	; 0x16
    1fbc:	5e 01       	movw	r10, r28
    1fbe:	b2 e0       	ldi	r27, 0x02	; 2
    1fc0:	ab 0e       	add	r10, r27
    1fc2:	b1 1c       	adc	r11, r1
    1fc4:	c5 01       	movw	r24, r10
    1fc6:	0e 94 2a 04 	call	0x854	; 0x854 <vListInitialiseItem>
    1fca:	ce 01       	movw	r24, r28
    1fcc:	0c 96       	adiw	r24, 0x0c	; 12
    1fce:	0e 94 2a 04 	call	0x854	; 0x854 <vListInitialiseItem>
    1fd2:	d9 87       	std	Y+9, r29	; 0x09
    1fd4:	c8 87       	std	Y+8, r28	; 0x08
    1fd6:	84 e0       	ldi	r24, 0x04	; 4
    1fd8:	90 e0       	ldi	r25, 0x00	; 0
    1fda:	81 1b       	sub	r24, r17
    1fdc:	91 09       	sbc	r25, r1
    1fde:	9d 87       	std	Y+13, r25	; 0x0d
    1fe0:	8c 87       	std	Y+12, r24	; 0x0c
    1fe2:	db 8b       	std	Y+19, r29	; 0x13
    1fe4:	ca 8b       	std	Y+18, r28	; 0x12
    1fe6:	a3 01       	movw	r20, r6
    1fe8:	b4 01       	movw	r22, r8
    1fea:	c6 01       	movw	r24, r12
    1fec:	d0 da       	rcall	.-2656   	; 0x158e <pxPortInitialiseStack>
    1fee:	99 83       	std	Y+1, r25	; 0x01
    1ff0:	88 83       	st	Y, r24
    1ff2:	e1 14       	cp	r14, r1
    1ff4:	f1 04       	cpc	r15, r1
    1ff6:	19 f0       	breq	.+6      	; 0x1ffe <xTaskGenericCreate+0xbc>
    1ff8:	f7 01       	movw	r30, r14
    1ffa:	d1 83       	std	Z+1, r29	; 0x01
    1ffc:	c0 83       	st	Z, r28
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	0f 92       	push	r0
    2004:	80 91 d7 08 	lds	r24, 0x08D7
    2008:	8f 5f       	subi	r24, 0xFF	; 255
    200a:	80 93 d7 08 	sts	0x08D7, r24
    200e:	80 91 25 09 	lds	r24, 0x0925
    2012:	90 91 26 09 	lds	r25, 0x0926
    2016:	89 2b       	or	r24, r25
    2018:	a9 f5       	brne	.+106    	; 0x2084 <xTaskGenericCreate+0x142>
    201a:	d0 93 26 09 	sts	0x0926, r29
    201e:	c0 93 25 09 	sts	0x0925, r28
    2022:	80 91 d7 08 	lds	r24, 0x08D7
    2026:	81 30       	cpi	r24, 0x01	; 1
    2028:	e1 f5       	brne	.+120    	; 0x20a2 <xTaskGenericCreate+0x160>
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	99 e0       	ldi	r25, 0x09	; 9
    202e:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    2032:	8a e0       	ldi	r24, 0x0A	; 10
    2034:	99 e0       	ldi	r25, 0x09	; 9
    2036:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    203a:	83 e1       	ldi	r24, 0x13	; 19
    203c:	99 e0       	ldi	r25, 0x09	; 9
    203e:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    2042:	8c e1       	ldi	r24, 0x1C	; 28
    2044:	99 e0       	ldi	r25, 0x09	; 9
    2046:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    204a:	88 ef       	ldi	r24, 0xF8	; 248
    204c:	98 e0       	ldi	r25, 0x08	; 8
    204e:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    2052:	8f ee       	ldi	r24, 0xEF	; 239
    2054:	98 e0       	ldi	r25, 0x08	; 8
    2056:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    205a:	82 ee       	ldi	r24, 0xE2	; 226
    205c:	98 e0       	ldi	r25, 0x08	; 8
    205e:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    2062:	89 ed       	ldi	r24, 0xD9	; 217
    2064:	98 e0       	ldi	r25, 0x08	; 8
    2066:	0e 94 1c 04 	call	0x838	; 0x838 <vListInitialise>
    206a:	88 ef       	ldi	r24, 0xF8	; 248
    206c:	98 e0       	ldi	r25, 0x08	; 8
    206e:	90 93 ee 08 	sts	0x08EE, r25
    2072:	80 93 ed 08 	sts	0x08ED, r24
    2076:	8f ee       	ldi	r24, 0xEF	; 239
    2078:	98 e0       	ldi	r25, 0x08	; 8
    207a:	90 93 ec 08 	sts	0x08EC, r25
    207e:	80 93 eb 08 	sts	0x08EB, r24
    2082:	0f c0       	rjmp	.+30     	; 0x20a2 <xTaskGenericCreate+0x160>
    2084:	80 91 d3 08 	lds	r24, 0x08D3
    2088:	81 11       	cpse	r24, r1
    208a:	0b c0       	rjmp	.+22     	; 0x20a2 <xTaskGenericCreate+0x160>
    208c:	e0 91 25 09 	lds	r30, 0x0925
    2090:	f0 91 26 09 	lds	r31, 0x0926
    2094:	86 89       	ldd	r24, Z+22	; 0x16
    2096:	08 17       	cp	r16, r24
    2098:	20 f0       	brcs	.+8      	; 0x20a2 <xTaskGenericCreate+0x160>
    209a:	d0 93 26 09 	sts	0x0926, r29
    209e:	c0 93 25 09 	sts	0x0925, r28
    20a2:	80 91 cf 08 	lds	r24, 0x08CF
    20a6:	8f 5f       	subi	r24, 0xFF	; 255
    20a8:	80 93 cf 08 	sts	0x08CF, r24
    20ac:	8e 89       	ldd	r24, Y+22	; 0x16
    20ae:	90 91 d4 08 	lds	r25, 0x08D4
    20b2:	98 17       	cp	r25, r24
    20b4:	10 f4       	brcc	.+4      	; 0x20ba <xTaskGenericCreate+0x178>
    20b6:	80 93 d4 08 	sts	0x08D4, r24
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	9c 01       	movw	r18, r24
    20be:	22 0f       	add	r18, r18
    20c0:	33 1f       	adc	r19, r19
    20c2:	22 0f       	add	r18, r18
    20c4:	33 1f       	adc	r19, r19
    20c6:	22 0f       	add	r18, r18
    20c8:	33 1f       	adc	r19, r19
    20ca:	82 0f       	add	r24, r18
    20cc:	93 1f       	adc	r25, r19
    20ce:	b5 01       	movw	r22, r10
    20d0:	8f 5f       	subi	r24, 0xFF	; 255
    20d2:	96 4f       	sbci	r25, 0xF6	; 246
    20d4:	0e 94 2e 04 	call	0x85c	; 0x85c <vListInsertEnd>
    20d8:	0f 90       	pop	r0
    20da:	0f be       	out	0x3f, r0	; 63
    20dc:	80 91 d3 08 	lds	r24, 0x08D3
    20e0:	88 23       	and	r24, r24
    20e2:	51 f0       	breq	.+20     	; 0x20f8 <xTaskGenericCreate+0x1b6>
    20e4:	e0 91 25 09 	lds	r30, 0x0925
    20e8:	f0 91 26 09 	lds	r31, 0x0926
    20ec:	86 89       	ldd	r24, Z+22	; 0x16
    20ee:	80 17       	cp	r24, r16
    20f0:	28 f4       	brcc	.+10     	; 0x20fc <xTaskGenericCreate+0x1ba>
    20f2:	00 db       	rcall	.-2560   	; 0x16f4 <vPortYield>
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	1c c0       	rjmp	.+56     	; 0x2130 <xTaskGenericCreate+0x1ee>
    20f8:	81 e0       	ldi	r24, 0x01	; 1
    20fa:	1a c0       	rjmp	.+52     	; 0x2130 <xTaskGenericCreate+0x1ee>
    20fc:	81 e0       	ldi	r24, 0x01	; 1
    20fe:	18 c0       	rjmp	.+48     	; 0x2130 <xTaskGenericCreate+0x1ee>
    2100:	d8 8e       	std	Y+24, r13	; 0x18
    2102:	cf 8a       	std	Y+23, r12	; 0x17
    2104:	f1 e0       	ldi	r31, 0x01	; 1
    2106:	4f 1a       	sub	r4, r31
    2108:	51 08       	sbc	r5, r1
    210a:	cf 88       	ldd	r12, Y+23	; 0x17
    210c:	d8 8c       	ldd	r13, Y+24	; 0x18
    210e:	c4 0c       	add	r12, r4
    2110:	d5 1c       	adc	r13, r5
    2112:	d5 01       	movw	r26, r10
    2114:	8c 91       	ld	r24, X
    2116:	89 8f       	std	Y+25, r24	; 0x19
    2118:	8c 91       	ld	r24, X
    211a:	88 23       	and	r24, r24
    211c:	09 f4       	brne	.+2      	; 0x2120 <xTaskGenericCreate+0x1de>
    211e:	48 cf       	rjmp	.-368    	; 0x1fb0 <xTaskGenericCreate+0x6e>
    2120:	ae 01       	movw	r20, r28
    2122:	46 5e       	subi	r20, 0xE6	; 230
    2124:	5f 4f       	sbci	r21, 0xFF	; 255
    2126:	f5 01       	movw	r30, r10
    2128:	31 96       	adiw	r30, 0x01	; 1
    212a:	27 e0       	ldi	r18, 0x07	; 7
    212c:	36 cf       	rjmp	.-404    	; 0x1f9a <xTaskGenericCreate+0x58>
    212e:	8f ef       	ldi	r24, 0xFF	; 255
    2130:	df 91       	pop	r29
    2132:	cf 91       	pop	r28
    2134:	1f 91       	pop	r17
    2136:	0f 91       	pop	r16
    2138:	ff 90       	pop	r15
    213a:	ef 90       	pop	r14
    213c:	df 90       	pop	r13
    213e:	cf 90       	pop	r12
    2140:	bf 90       	pop	r11
    2142:	af 90       	pop	r10
    2144:	9f 90       	pop	r9
    2146:	8f 90       	pop	r8
    2148:	7f 90       	pop	r7
    214a:	6f 90       	pop	r6
    214c:	5f 90       	pop	r5
    214e:	4f 90       	pop	r4
    2150:	08 95       	ret

00002152 <vTaskStartScheduler>:
    2152:	af 92       	push	r10
    2154:	bf 92       	push	r11
    2156:	cf 92       	push	r12
    2158:	df 92       	push	r13
    215a:	ef 92       	push	r14
    215c:	ff 92       	push	r15
    215e:	0f 93       	push	r16
    2160:	a1 2c       	mov	r10, r1
    2162:	b1 2c       	mov	r11, r1
    2164:	c1 2c       	mov	r12, r1
    2166:	d1 2c       	mov	r13, r1
    2168:	e1 2c       	mov	r14, r1
    216a:	f1 2c       	mov	r15, r1
    216c:	00 e0       	ldi	r16, 0x00	; 0
    216e:	20 e0       	ldi	r18, 0x00	; 0
    2170:	30 e0       	ldi	r19, 0x00	; 0
    2172:	45 e5       	ldi	r20, 0x55	; 85
    2174:	50 e0       	ldi	r21, 0x00	; 0
    2176:	61 e7       	ldi	r22, 0x71	; 113
    2178:	72 e0       	ldi	r23, 0x02	; 2
    217a:	83 e3       	ldi	r24, 0x33	; 51
    217c:	92 e1       	ldi	r25, 0x12	; 18
    217e:	e1 de       	rcall	.-574    	; 0x1f42 <xTaskGenericCreate>
    2180:	81 30       	cpi	r24, 0x01	; 1
    2182:	41 f4       	brne	.+16     	; 0x2194 <vTaskStartScheduler+0x42>
    2184:	f8 94       	cli
    2186:	80 93 d3 08 	sts	0x08D3, r24
    218a:	10 92 d6 08 	sts	0x08D6, r1
    218e:	10 92 d5 08 	sts	0x08D5, r1
    2192:	6f da       	rcall	.-2850   	; 0x1672 <xPortStartScheduler>
    2194:	0f 91       	pop	r16
    2196:	ff 90       	pop	r15
    2198:	ef 90       	pop	r14
    219a:	df 90       	pop	r13
    219c:	cf 90       	pop	r12
    219e:	bf 90       	pop	r11
    21a0:	af 90       	pop	r10
    21a2:	08 95       	ret

000021a4 <vTaskSuspendAll>:
    21a4:	80 91 ce 08 	lds	r24, 0x08CE
    21a8:	8f 5f       	subi	r24, 0xFF	; 255
    21aa:	80 93 ce 08 	sts	0x08CE, r24
    21ae:	08 95       	ret

000021b0 <xTaskIncrementTick>:
    21b0:	cf 92       	push	r12
    21b2:	df 92       	push	r13
    21b4:	ef 92       	push	r14
    21b6:	ff 92       	push	r15
    21b8:	0f 93       	push	r16
    21ba:	1f 93       	push	r17
    21bc:	cf 93       	push	r28
    21be:	df 93       	push	r29
    21c0:	80 91 ce 08 	lds	r24, 0x08CE
    21c4:	81 11       	cpse	r24, r1
    21c6:	99 c0       	rjmp	.+306    	; 0x22fa <__stack+0xfb>
    21c8:	80 91 d5 08 	lds	r24, 0x08D5
    21cc:	90 91 d6 08 	lds	r25, 0x08D6
    21d0:	01 96       	adiw	r24, 0x01	; 1
    21d2:	90 93 d6 08 	sts	0x08D6, r25
    21d6:	80 93 d5 08 	sts	0x08D5, r24
    21da:	e0 90 d5 08 	lds	r14, 0x08D5
    21de:	f0 90 d6 08 	lds	r15, 0x08D6
    21e2:	e1 14       	cp	r14, r1
    21e4:	f1 04       	cpc	r15, r1
    21e6:	b1 f4       	brne	.+44     	; 0x2214 <__stack+0x15>
    21e8:	80 91 ed 08 	lds	r24, 0x08ED
    21ec:	90 91 ee 08 	lds	r25, 0x08EE
    21f0:	20 91 eb 08 	lds	r18, 0x08EB
    21f4:	30 91 ec 08 	lds	r19, 0x08EC
    21f8:	30 93 ee 08 	sts	0x08EE, r19
    21fc:	20 93 ed 08 	sts	0x08ED, r18
    2200:	90 93 ec 08 	sts	0x08EC, r25
    2204:	80 93 eb 08 	sts	0x08EB, r24
    2208:	80 91 d0 08 	lds	r24, 0x08D0
    220c:	8f 5f       	subi	r24, 0xFF	; 255
    220e:	80 93 d0 08 	sts	0x08D0, r24
    2212:	41 de       	rcall	.-894    	; 0x1e96 <prvResetNextTaskUnblockTime>
    2214:	80 91 10 02 	lds	r24, 0x0210
    2218:	90 91 11 02 	lds	r25, 0x0211
    221c:	e8 16       	cp	r14, r24
    221e:	f9 06       	cpc	r15, r25
    2220:	08 f4       	brcc	.+2      	; 0x2224 <__stack+0x25>
    2222:	54 c0       	rjmp	.+168    	; 0x22cc <__stack+0xcd>
    2224:	d1 2c       	mov	r13, r1
    2226:	cc 24       	eor	r12, r12
    2228:	c3 94       	inc	r12
    222a:	01 c0       	rjmp	.+2      	; 0x222e <__stack+0x2f>
    222c:	dc 2c       	mov	r13, r12
    222e:	e0 91 ed 08 	lds	r30, 0x08ED
    2232:	f0 91 ee 08 	lds	r31, 0x08EE
    2236:	80 81       	ld	r24, Z
    2238:	81 11       	cpse	r24, r1
    223a:	07 c0       	rjmp	.+14     	; 0x224a <__stack+0x4b>
    223c:	8f ef       	ldi	r24, 0xFF	; 255
    223e:	9f ef       	ldi	r25, 0xFF	; 255
    2240:	90 93 11 02 	sts	0x0211, r25
    2244:	80 93 10 02 	sts	0x0210, r24
    2248:	42 c0       	rjmp	.+132    	; 0x22ce <__stack+0xcf>
    224a:	e0 91 ed 08 	lds	r30, 0x08ED
    224e:	f0 91 ee 08 	lds	r31, 0x08EE
    2252:	05 80       	ldd	r0, Z+5	; 0x05
    2254:	f6 81       	ldd	r31, Z+6	; 0x06
    2256:	e0 2d       	mov	r30, r0
    2258:	c6 81       	ldd	r28, Z+6	; 0x06
    225a:	d7 81       	ldd	r29, Z+7	; 0x07
    225c:	2a 81       	ldd	r18, Y+2	; 0x02
    225e:	3b 81       	ldd	r19, Y+3	; 0x03
    2260:	e2 16       	cp	r14, r18
    2262:	f3 06       	cpc	r15, r19
    2264:	28 f4       	brcc	.+10     	; 0x2270 <__stack+0x71>
    2266:	30 93 11 02 	sts	0x0211, r19
    226a:	20 93 10 02 	sts	0x0210, r18
    226e:	2f c0       	rjmp	.+94     	; 0x22ce <__stack+0xcf>
    2270:	8e 01       	movw	r16, r28
    2272:	0e 5f       	subi	r16, 0xFE	; 254
    2274:	1f 4f       	sbci	r17, 0xFF	; 255
    2276:	c8 01       	movw	r24, r16
    2278:	0e 94 80 04 	call	0x900	; 0x900 <uxListRemove>
    227c:	8c 89       	ldd	r24, Y+20	; 0x14
    227e:	9d 89       	ldd	r25, Y+21	; 0x15
    2280:	89 2b       	or	r24, r25
    2282:	21 f0       	breq	.+8      	; 0x228c <__stack+0x8d>
    2284:	ce 01       	movw	r24, r28
    2286:	0c 96       	adiw	r24, 0x0c	; 12
    2288:	0e 94 80 04 	call	0x900	; 0x900 <uxListRemove>
    228c:	2e 89       	ldd	r18, Y+22	; 0x16
    228e:	80 91 d4 08 	lds	r24, 0x08D4
    2292:	82 17       	cp	r24, r18
    2294:	10 f4       	brcc	.+4      	; 0x229a <__stack+0x9b>
    2296:	20 93 d4 08 	sts	0x08D4, r18
    229a:	30 e0       	ldi	r19, 0x00	; 0
    229c:	c9 01       	movw	r24, r18
    229e:	88 0f       	add	r24, r24
    22a0:	99 1f       	adc	r25, r25
    22a2:	88 0f       	add	r24, r24
    22a4:	99 1f       	adc	r25, r25
    22a6:	88 0f       	add	r24, r24
    22a8:	99 1f       	adc	r25, r25
    22aa:	82 0f       	add	r24, r18
    22ac:	93 1f       	adc	r25, r19
    22ae:	b8 01       	movw	r22, r16
    22b0:	8f 5f       	subi	r24, 0xFF	; 255
    22b2:	96 4f       	sbci	r25, 0xF6	; 246
    22b4:	0e 94 2e 04 	call	0x85c	; 0x85c <vListInsertEnd>
    22b8:	e0 91 25 09 	lds	r30, 0x0925
    22bc:	f0 91 26 09 	lds	r31, 0x0926
    22c0:	9e 89       	ldd	r25, Y+22	; 0x16
    22c2:	86 89       	ldd	r24, Z+22	; 0x16
    22c4:	98 17       	cp	r25, r24
    22c6:	08 f0       	brcs	.+2      	; 0x22ca <__stack+0xcb>
    22c8:	b1 cf       	rjmp	.-158    	; 0x222c <__stack+0x2d>
    22ca:	b1 cf       	rjmp	.-158    	; 0x222e <__stack+0x2f>
    22cc:	d1 2c       	mov	r13, r1
    22ce:	e0 91 25 09 	lds	r30, 0x0925
    22d2:	f0 91 26 09 	lds	r31, 0x0926
    22d6:	86 89       	ldd	r24, Z+22	; 0x16
    22d8:	90 e0       	ldi	r25, 0x00	; 0
    22da:	fc 01       	movw	r30, r24
    22dc:	ee 0f       	add	r30, r30
    22de:	ff 1f       	adc	r31, r31
    22e0:	ee 0f       	add	r30, r30
    22e2:	ff 1f       	adc	r31, r31
    22e4:	ee 0f       	add	r30, r30
    22e6:	ff 1f       	adc	r31, r31
    22e8:	8e 0f       	add	r24, r30
    22ea:	9f 1f       	adc	r25, r31
    22ec:	fc 01       	movw	r30, r24
    22ee:	ef 5f       	subi	r30, 0xFF	; 255
    22f0:	f6 4f       	sbci	r31, 0xF6	; 246
    22f2:	80 81       	ld	r24, Z
    22f4:	82 30       	cpi	r24, 0x02	; 2
    22f6:	40 f4       	brcc	.+16     	; 0x2308 <__stack+0x109>
    22f8:	09 c0       	rjmp	.+18     	; 0x230c <__stack+0x10d>
    22fa:	80 91 d2 08 	lds	r24, 0x08D2
    22fe:	8f 5f       	subi	r24, 0xFF	; 255
    2300:	80 93 d2 08 	sts	0x08D2, r24
    2304:	d1 2c       	mov	r13, r1
    2306:	02 c0       	rjmp	.+4      	; 0x230c <__stack+0x10d>
    2308:	dd 24       	eor	r13, r13
    230a:	d3 94       	inc	r13
    230c:	80 91 d1 08 	lds	r24, 0x08D1
    2310:	88 23       	and	r24, r24
    2312:	11 f0       	breq	.+4      	; 0x2318 <__stack+0x119>
    2314:	dd 24       	eor	r13, r13
    2316:	d3 94       	inc	r13
    2318:	8d 2d       	mov	r24, r13
    231a:	df 91       	pop	r29
    231c:	cf 91       	pop	r28
    231e:	1f 91       	pop	r17
    2320:	0f 91       	pop	r16
    2322:	ff 90       	pop	r15
    2324:	ef 90       	pop	r14
    2326:	df 90       	pop	r13
    2328:	cf 90       	pop	r12
    232a:	08 95       	ret

0000232c <xTaskResumeAll>:
    232c:	df 92       	push	r13
    232e:	ef 92       	push	r14
    2330:	ff 92       	push	r15
    2332:	0f 93       	push	r16
    2334:	1f 93       	push	r17
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	0f 92       	push	r0
    2340:	80 91 ce 08 	lds	r24, 0x08CE
    2344:	81 50       	subi	r24, 0x01	; 1
    2346:	80 93 ce 08 	sts	0x08CE, r24
    234a:	80 91 ce 08 	lds	r24, 0x08CE
    234e:	81 11       	cpse	r24, r1
    2350:	5f c0       	rjmp	.+190    	; 0x2410 <xTaskResumeAll+0xe4>
    2352:	80 91 d7 08 	lds	r24, 0x08D7
    2356:	88 23       	and	r24, r24
    2358:	09 f4       	brne	.+2      	; 0x235c <xTaskResumeAll+0x30>
    235a:	5c c0       	rjmp	.+184    	; 0x2414 <xTaskResumeAll+0xe8>
    235c:	0f 2e       	mov	r0, r31
    235e:	f2 ee       	ldi	r31, 0xE2	; 226
    2360:	ef 2e       	mov	r14, r31
    2362:	f8 e0       	ldi	r31, 0x08	; 8
    2364:	ff 2e       	mov	r15, r31
    2366:	f0 2d       	mov	r31, r0
    2368:	dd 24       	eor	r13, r13
    236a:	d3 94       	inc	r13
    236c:	30 c0       	rjmp	.+96     	; 0x23ce <xTaskResumeAll+0xa2>
    236e:	e0 91 e7 08 	lds	r30, 0x08E7
    2372:	f0 91 e8 08 	lds	r31, 0x08E8
    2376:	c6 81       	ldd	r28, Z+6	; 0x06
    2378:	d7 81       	ldd	r29, Z+7	; 0x07
    237a:	ce 01       	movw	r24, r28
    237c:	0c 96       	adiw	r24, 0x0c	; 12
    237e:	0e 94 80 04 	call	0x900	; 0x900 <uxListRemove>
    2382:	8e 01       	movw	r16, r28
    2384:	0e 5f       	subi	r16, 0xFE	; 254
    2386:	1f 4f       	sbci	r17, 0xFF	; 255
    2388:	c8 01       	movw	r24, r16
    238a:	0e 94 80 04 	call	0x900	; 0x900 <uxListRemove>
    238e:	8e 89       	ldd	r24, Y+22	; 0x16
    2390:	90 91 d4 08 	lds	r25, 0x08D4
    2394:	98 17       	cp	r25, r24
    2396:	10 f4       	brcc	.+4      	; 0x239c <xTaskResumeAll+0x70>
    2398:	80 93 d4 08 	sts	0x08D4, r24
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	9c 01       	movw	r18, r24
    23a0:	22 0f       	add	r18, r18
    23a2:	33 1f       	adc	r19, r19
    23a4:	22 0f       	add	r18, r18
    23a6:	33 1f       	adc	r19, r19
    23a8:	22 0f       	add	r18, r18
    23aa:	33 1f       	adc	r19, r19
    23ac:	82 0f       	add	r24, r18
    23ae:	93 1f       	adc	r25, r19
    23b0:	b8 01       	movw	r22, r16
    23b2:	8f 5f       	subi	r24, 0xFF	; 255
    23b4:	96 4f       	sbci	r25, 0xF6	; 246
    23b6:	0e 94 2e 04 	call	0x85c	; 0x85c <vListInsertEnd>
    23ba:	e0 91 25 09 	lds	r30, 0x0925
    23be:	f0 91 26 09 	lds	r31, 0x0926
    23c2:	9e 89       	ldd	r25, Y+22	; 0x16
    23c4:	86 89       	ldd	r24, Z+22	; 0x16
    23c6:	98 17       	cp	r25, r24
    23c8:	10 f0       	brcs	.+4      	; 0x23ce <xTaskResumeAll+0xa2>
    23ca:	d0 92 d1 08 	sts	0x08D1, r13
    23ce:	f7 01       	movw	r30, r14
    23d0:	80 81       	ld	r24, Z
    23d2:	81 11       	cpse	r24, r1
    23d4:	cc cf       	rjmp	.-104    	; 0x236e <xTaskResumeAll+0x42>
    23d6:	80 91 d2 08 	lds	r24, 0x08D2
    23da:	88 23       	and	r24, r24
    23dc:	91 f0       	breq	.+36     	; 0x2402 <xTaskResumeAll+0xd6>
    23de:	80 91 d2 08 	lds	r24, 0x08D2
    23e2:	88 23       	and	r24, r24
    23e4:	71 f0       	breq	.+28     	; 0x2402 <xTaskResumeAll+0xd6>
    23e6:	c1 e0       	ldi	r28, 0x01	; 1
    23e8:	e3 de       	rcall	.-570    	; 0x21b0 <xTaskIncrementTick>
    23ea:	81 11       	cpse	r24, r1
    23ec:	c0 93 d1 08 	sts	0x08D1, r28
    23f0:	80 91 d2 08 	lds	r24, 0x08D2
    23f4:	81 50       	subi	r24, 0x01	; 1
    23f6:	80 93 d2 08 	sts	0x08D2, r24
    23fa:	80 91 d2 08 	lds	r24, 0x08D2
    23fe:	81 11       	cpse	r24, r1
    2400:	f3 cf       	rjmp	.-26     	; 0x23e8 <xTaskResumeAll+0xbc>
    2402:	80 91 d1 08 	lds	r24, 0x08D1
    2406:	81 30       	cpi	r24, 0x01	; 1
    2408:	39 f4       	brne	.+14     	; 0x2418 <xTaskResumeAll+0xec>
    240a:	74 d9       	rcall	.-3352   	; 0x16f4 <vPortYield>
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	05 c0       	rjmp	.+10     	; 0x241a <xTaskResumeAll+0xee>
    2410:	80 e0       	ldi	r24, 0x00	; 0
    2412:	03 c0       	rjmp	.+6      	; 0x241a <xTaskResumeAll+0xee>
    2414:	80 e0       	ldi	r24, 0x00	; 0
    2416:	01 c0       	rjmp	.+2      	; 0x241a <xTaskResumeAll+0xee>
    2418:	80 e0       	ldi	r24, 0x00	; 0
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63
    241e:	df 91       	pop	r29
    2420:	cf 91       	pop	r28
    2422:	1f 91       	pop	r17
    2424:	0f 91       	pop	r16
    2426:	ff 90       	pop	r15
    2428:	ef 90       	pop	r14
    242a:	df 90       	pop	r13
    242c:	08 95       	ret

0000242e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    242e:	cf 93       	push	r28
    2430:	df 93       	push	r29
    2432:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2434:	00 97       	sbiw	r24, 0x00	; 0
    2436:	99 f0       	breq	.+38     	; 0x245e <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2438:	b5 de       	rcall	.-662    	; 0x21a4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    243a:	80 91 d5 08 	lds	r24, 0x08D5
    243e:	90 91 d6 08 	lds	r25, 0x08D6
    2442:	c8 0f       	add	r28, r24
    2444:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2446:	80 91 25 09 	lds	r24, 0x0925
    244a:	90 91 26 09 	lds	r25, 0x0926
    244e:	02 96       	adiw	r24, 0x02	; 2
    2450:	0e 94 80 04 	call	0x900	; 0x900 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2454:	ce 01       	movw	r24, r28
    2456:	3e dd       	rcall	.-1412   	; 0x1ed4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2458:	69 df       	rcall	.-302    	; 0x232c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    245a:	81 11       	cpse	r24, r1
    245c:	01 c0       	rjmp	.+2      	; 0x2460 <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    245e:	4a d9       	rcall	.-3436   	; 0x16f4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2460:	df 91       	pop	r29
    2462:	cf 91       	pop	r28
    2464:	08 95       	ret

00002466 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2466:	0f 2e       	mov	r0, r31
    2468:	f1 e0       	ldi	r31, 0x01	; 1
    246a:	ef 2e       	mov	r14, r31
    246c:	f9 e0       	ldi	r31, 0x09	; 9
    246e:	ff 2e       	mov	r15, r31
    2470:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2472:	c9 ed       	ldi	r28, 0xD9	; 217
    2474:	d8 e0       	ldi	r29, 0x08	; 8
    2476:	26 c0       	rjmp	.+76     	; 0x24c4 <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2478:	95 de       	rcall	.-726    	; 0x21a4 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    247a:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    247c:	57 df       	rcall	.-338    	; 0x232c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    247e:	11 23       	and	r17, r17
    2480:	09 f1       	breq	.+66     	; 0x24c4 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	f8 94       	cli
    2486:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2488:	e0 91 de 08 	lds	r30, 0x08DE
    248c:	f0 91 df 08 	lds	r31, 0x08DF
    2490:	06 81       	ldd	r16, Z+6	; 0x06
    2492:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2494:	c8 01       	movw	r24, r16
    2496:	02 96       	adiw	r24, 0x02	; 2
    2498:	0e 94 80 04 	call	0x900	; 0x900 <uxListRemove>
					--uxCurrentNumberOfTasks;
    249c:	80 91 d7 08 	lds	r24, 0x08D7
    24a0:	81 50       	subi	r24, 0x01	; 1
    24a2:	80 93 d7 08 	sts	0x08D7, r24
					--uxTasksDeleted;
    24a6:	80 91 d8 08 	lds	r24, 0x08D8
    24aa:	81 50       	subi	r24, 0x01	; 1
    24ac:	80 93 d8 08 	sts	0x08D8, r24
				}
				taskEXIT_CRITICAL();
    24b0:	0f 90       	pop	r0
    24b2:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    24b4:	f8 01       	movw	r30, r16
    24b6:	87 89       	ldd	r24, Z+23	; 0x17
    24b8:	90 8d       	ldd	r25, Z+24	; 0x18
    24ba:	0e 94 a3 02 	call	0x546	; 0x546 <vPortFree>
		vPortFree( pxTCB );
    24be:	c8 01       	movw	r24, r16
    24c0:	0e 94 a3 02 	call	0x546	; 0x546 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    24c4:	80 91 d8 08 	lds	r24, 0x08D8
    24c8:	81 11       	cpse	r24, r1
    24ca:	d6 cf       	rjmp	.-84     	; 0x2478 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    24cc:	f7 01       	movw	r30, r14
    24ce:	80 81       	ld	r24, Z
    24d0:	82 30       	cpi	r24, 0x02	; 2
    24d2:	c0 f3       	brcs	.-16     	; 0x24c4 <prvIdleTask+0x5e>
			{
				taskYIELD();
    24d4:	0f d9       	rcall	.-3554   	; 0x16f4 <vPortYield>
    24d6:	f6 cf       	rjmp	.-20     	; 0x24c4 <prvIdleTask+0x5e>

000024d8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    24d8:	80 91 ce 08 	lds	r24, 0x08CE
    24dc:	88 23       	and	r24, r24
    24de:	21 f0       	breq	.+8      	; 0x24e8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	80 93 d1 08 	sts	0x08D1, r24
    24e6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    24e8:	10 92 d1 08 	sts	0x08D1, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    24ec:	80 91 d4 08 	lds	r24, 0x08D4
    24f0:	90 e0       	ldi	r25, 0x00	; 0
    24f2:	fc 01       	movw	r30, r24
    24f4:	ee 0f       	add	r30, r30
    24f6:	ff 1f       	adc	r31, r31
    24f8:	ee 0f       	add	r30, r30
    24fa:	ff 1f       	adc	r31, r31
    24fc:	ee 0f       	add	r30, r30
    24fe:	ff 1f       	adc	r31, r31
    2500:	8e 0f       	add	r24, r30
    2502:	9f 1f       	adc	r25, r31
    2504:	fc 01       	movw	r30, r24
    2506:	ef 5f       	subi	r30, 0xFF	; 255
    2508:	f6 4f       	sbci	r31, 0xF6	; 246
    250a:	80 81       	ld	r24, Z
    250c:	81 11       	cpse	r24, r1
    250e:	17 c0       	rjmp	.+46     	; 0x253e <vTaskSwitchContext+0x66>
    2510:	80 91 d4 08 	lds	r24, 0x08D4
    2514:	81 50       	subi	r24, 0x01	; 1
    2516:	80 93 d4 08 	sts	0x08D4, r24
    251a:	80 91 d4 08 	lds	r24, 0x08D4
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	fc 01       	movw	r30, r24
    2522:	ee 0f       	add	r30, r30
    2524:	ff 1f       	adc	r31, r31
    2526:	ee 0f       	add	r30, r30
    2528:	ff 1f       	adc	r31, r31
    252a:	ee 0f       	add	r30, r30
    252c:	ff 1f       	adc	r31, r31
    252e:	8e 0f       	add	r24, r30
    2530:	9f 1f       	adc	r25, r31
    2532:	fc 01       	movw	r30, r24
    2534:	ef 5f       	subi	r30, 0xFF	; 255
    2536:	f6 4f       	sbci	r31, 0xF6	; 246
    2538:	80 81       	ld	r24, Z
    253a:	88 23       	and	r24, r24
    253c:	49 f3       	breq	.-46     	; 0x2510 <vTaskSwitchContext+0x38>
    253e:	e0 91 d4 08 	lds	r30, 0x08D4
    2542:	f0 e0       	ldi	r31, 0x00	; 0
    2544:	cf 01       	movw	r24, r30
    2546:	88 0f       	add	r24, r24
    2548:	99 1f       	adc	r25, r25
    254a:	88 0f       	add	r24, r24
    254c:	99 1f       	adc	r25, r25
    254e:	88 0f       	add	r24, r24
    2550:	99 1f       	adc	r25, r25
    2552:	e8 0f       	add	r30, r24
    2554:	f9 1f       	adc	r31, r25
    2556:	ef 5f       	subi	r30, 0xFF	; 255
    2558:	f6 4f       	sbci	r31, 0xF6	; 246
    255a:	a1 81       	ldd	r26, Z+1	; 0x01
    255c:	b2 81       	ldd	r27, Z+2	; 0x02
    255e:	12 96       	adiw	r26, 0x02	; 2
    2560:	0d 90       	ld	r0, X+
    2562:	bc 91       	ld	r27, X
    2564:	a0 2d       	mov	r26, r0
    2566:	b2 83       	std	Z+2, r27	; 0x02
    2568:	a1 83       	std	Z+1, r26	; 0x01
    256a:	cf 01       	movw	r24, r30
    256c:	03 96       	adiw	r24, 0x03	; 3
    256e:	a8 17       	cp	r26, r24
    2570:	b9 07       	cpc	r27, r25
    2572:	31 f4       	brne	.+12     	; 0x2580 <vTaskSwitchContext+0xa8>
    2574:	12 96       	adiw	r26, 0x02	; 2
    2576:	8d 91       	ld	r24, X+
    2578:	9c 91       	ld	r25, X
    257a:	13 97       	sbiw	r26, 0x03	; 3
    257c:	92 83       	std	Z+2, r25	; 0x02
    257e:	81 83       	std	Z+1, r24	; 0x01
    2580:	01 80       	ldd	r0, Z+1	; 0x01
    2582:	f2 81       	ldd	r31, Z+2	; 0x02
    2584:	e0 2d       	mov	r30, r0
    2586:	86 81       	ldd	r24, Z+6	; 0x06
    2588:	97 81       	ldd	r25, Z+7	; 0x07
    258a:	90 93 26 09 	sts	0x0926, r25
    258e:	80 93 25 09 	sts	0x0925, r24
    2592:	08 95       	ret

00002594 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2594:	10 92 94 09 	sts	0x0994, r1
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	80 93 92 09 	sts	0x0992, r24
    259e:	10 92 91 09 	sts	0x0991, r1
    25a2:	61 e0       	ldi	r22, 0x01	; 1
    25a4:	84 e1       	ldi	r24, 0x14	; 20
    25a6:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    25aa:	61 e0       	ldi	r22, 0x01	; 1
    25ac:	85 e1       	ldi	r24, 0x15	; 21
    25ae:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <digitalWrite>
    25b2:	e9 eb       	ldi	r30, 0xB9	; 185
    25b4:	f0 e0       	ldi	r31, 0x00	; 0
    25b6:	80 81       	ld	r24, Z
    25b8:	8e 7f       	andi	r24, 0xFE	; 254
    25ba:	80 83       	st	Z, r24
    25bc:	80 81       	ld	r24, Z
    25be:	8d 7f       	andi	r24, 0xFD	; 253
    25c0:	80 83       	st	Z, r24
    25c2:	8d ef       	ldi	r24, 0xFD	; 253
    25c4:	80 93 b8 00 	sts	0x00B8, r24
    25c8:	85 e4       	ldi	r24, 0x45	; 69
    25ca:	80 93 bc 00 	sts	0x00BC, r24
    25ce:	08 95       	ret

000025d0 <twi_readFrom>:
    25d0:	41 32       	cpi	r20, 0x21	; 33
    25d2:	08 f0       	brcs	.+2      	; 0x25d6 <twi_readFrom+0x6>
    25d4:	45 c0       	rjmp	.+138    	; 0x2660 <twi_readFrom+0x90>
    25d6:	90 91 94 09 	lds	r25, 0x0994
    25da:	91 11       	cpse	r25, r1
    25dc:	fc cf       	rjmp	.-8      	; 0x25d6 <twi_readFrom+0x6>
    25de:	91 e0       	ldi	r25, 0x01	; 1
    25e0:	90 93 94 09 	sts	0x0994, r25
    25e4:	20 93 92 09 	sts	0x0992, r18
    25e8:	2f ef       	ldi	r18, 0xFF	; 255
    25ea:	20 93 27 09 	sts	0x0927, r18
    25ee:	10 92 6c 09 	sts	0x096C, r1
    25f2:	24 0f       	add	r18, r20
    25f4:	20 93 6b 09 	sts	0x096B, r18
    25f8:	90 93 93 09 	sts	0x0993, r25
    25fc:	90 91 93 09 	lds	r25, 0x0993
    2600:	88 0f       	add	r24, r24
    2602:	89 2b       	or	r24, r25
    2604:	80 93 93 09 	sts	0x0993, r24
    2608:	80 91 91 09 	lds	r24, 0x0991
    260c:	81 30       	cpi	r24, 0x01	; 1
    260e:	51 f4       	brne	.+20     	; 0x2624 <twi_readFrom+0x54>
    2610:	10 92 91 09 	sts	0x0991, r1
    2614:	80 91 93 09 	lds	r24, 0x0993
    2618:	80 93 bb 00 	sts	0x00BB, r24
    261c:	85 ec       	ldi	r24, 0xC5	; 197
    261e:	80 93 bc 00 	sts	0x00BC, r24
    2622:	03 c0       	rjmp	.+6      	; 0x262a <twi_readFrom+0x5a>
    2624:	85 ee       	ldi	r24, 0xE5	; 229
    2626:	80 93 bc 00 	sts	0x00BC, r24
    262a:	80 91 94 09 	lds	r24, 0x0994
    262e:	81 30       	cpi	r24, 0x01	; 1
    2630:	e1 f3       	breq	.-8      	; 0x262a <twi_readFrom+0x5a>
    2632:	80 91 6c 09 	lds	r24, 0x096C
    2636:	84 17       	cp	r24, r20
    2638:	10 f4       	brcc	.+4      	; 0x263e <twi_readFrom+0x6e>
    263a:	40 91 6c 09 	lds	r20, 0x096C
    263e:	44 23       	and	r20, r20
    2640:	89 f0       	breq	.+34     	; 0x2664 <twi_readFrom+0x94>
    2642:	ed e6       	ldi	r30, 0x6D	; 109
    2644:	f9 e0       	ldi	r31, 0x09	; 9
    2646:	a6 2f       	mov	r26, r22
    2648:	b7 2f       	mov	r27, r23
    264a:	2f ef       	ldi	r18, 0xFF	; 255
    264c:	24 0f       	add	r18, r20
    264e:	30 e0       	ldi	r19, 0x00	; 0
    2650:	22 59       	subi	r18, 0x92	; 146
    2652:	36 4f       	sbci	r19, 0xF6	; 246
    2654:	91 91       	ld	r25, Z+
    2656:	9d 93       	st	X+, r25
    2658:	e2 17       	cp	r30, r18
    265a:	f3 07       	cpc	r31, r19
    265c:	d9 f7       	brne	.-10     	; 0x2654 <twi_readFrom+0x84>
    265e:	04 c0       	rjmp	.+8      	; 0x2668 <twi_readFrom+0x98>
    2660:	80 e0       	ldi	r24, 0x00	; 0
    2662:	08 95       	ret
    2664:	84 2f       	mov	r24, r20
    2666:	08 95       	ret
    2668:	84 2f       	mov	r24, r20
    266a:	08 95       	ret

0000266c <twi_writeTo>:
    266c:	0f 93       	push	r16
    266e:	41 32       	cpi	r20, 0x21	; 33
    2670:	08 f0       	brcs	.+2      	; 0x2674 <twi_writeTo+0x8>
    2672:	50 c0       	rjmp	.+160    	; 0x2714 <twi_writeTo+0xa8>
    2674:	90 91 94 09 	lds	r25, 0x0994
    2678:	91 11       	cpse	r25, r1
    267a:	fc cf       	rjmp	.-8      	; 0x2674 <twi_writeTo+0x8>
    267c:	92 e0       	ldi	r25, 0x02	; 2
    267e:	90 93 94 09 	sts	0x0994, r25
    2682:	00 93 92 09 	sts	0x0992, r16
    2686:	9f ef       	ldi	r25, 0xFF	; 255
    2688:	90 93 27 09 	sts	0x0927, r25
    268c:	10 92 6c 09 	sts	0x096C, r1
    2690:	40 93 6b 09 	sts	0x096B, r20
    2694:	44 23       	and	r20, r20
    2696:	69 f0       	breq	.+26     	; 0x26b2 <twi_writeTo+0x46>
    2698:	fb 01       	movw	r30, r22
    269a:	ad e6       	ldi	r26, 0x6D	; 109
    269c:	b9 e0       	ldi	r27, 0x09	; 9
    269e:	6f 5f       	subi	r22, 0xFF	; 255
    26a0:	7f 4f       	sbci	r23, 0xFF	; 255
    26a2:	41 50       	subi	r20, 0x01	; 1
    26a4:	64 0f       	add	r22, r20
    26a6:	71 1d       	adc	r23, r1
    26a8:	91 91       	ld	r25, Z+
    26aa:	9d 93       	st	X+, r25
    26ac:	e6 17       	cp	r30, r22
    26ae:	f7 07       	cpc	r31, r23
    26b0:	d9 f7       	brne	.-10     	; 0x26a8 <twi_writeTo+0x3c>
    26b2:	10 92 93 09 	sts	0x0993, r1
    26b6:	90 91 93 09 	lds	r25, 0x0993
    26ba:	88 0f       	add	r24, r24
    26bc:	89 2b       	or	r24, r25
    26be:	80 93 93 09 	sts	0x0993, r24
    26c2:	80 91 91 09 	lds	r24, 0x0991
    26c6:	81 30       	cpi	r24, 0x01	; 1
    26c8:	51 f4       	brne	.+20     	; 0x26de <twi_writeTo+0x72>
    26ca:	10 92 91 09 	sts	0x0991, r1
    26ce:	80 91 93 09 	lds	r24, 0x0993
    26d2:	80 93 bb 00 	sts	0x00BB, r24
    26d6:	85 ec       	ldi	r24, 0xC5	; 197
    26d8:	80 93 bc 00 	sts	0x00BC, r24
    26dc:	03 c0       	rjmp	.+6      	; 0x26e4 <twi_writeTo+0x78>
    26de:	85 ee       	ldi	r24, 0xE5	; 229
    26e0:	80 93 bc 00 	sts	0x00BC, r24
    26e4:	22 23       	and	r18, r18
    26e6:	41 f0       	breq	.+16     	; 0x26f8 <twi_writeTo+0x8c>
    26e8:	80 91 94 09 	lds	r24, 0x0994
    26ec:	82 30       	cpi	r24, 0x02	; 2
    26ee:	21 f4       	brne	.+8      	; 0x26f8 <twi_writeTo+0x8c>
    26f0:	80 91 94 09 	lds	r24, 0x0994
    26f4:	82 30       	cpi	r24, 0x02	; 2
    26f6:	e1 f3       	breq	.-8      	; 0x26f0 <twi_writeTo+0x84>
    26f8:	80 91 27 09 	lds	r24, 0x0927
    26fc:	8f 3f       	cpi	r24, 0xFF	; 255
    26fe:	61 f0       	breq	.+24     	; 0x2718 <twi_writeTo+0xac>
    2700:	80 91 27 09 	lds	r24, 0x0927
    2704:	80 32       	cpi	r24, 0x20	; 32
    2706:	51 f0       	breq	.+20     	; 0x271c <twi_writeTo+0xb0>
    2708:	80 91 27 09 	lds	r24, 0x0927
    270c:	80 33       	cpi	r24, 0x30	; 48
    270e:	41 f4       	brne	.+16     	; 0x2720 <twi_writeTo+0xb4>
    2710:	83 e0       	ldi	r24, 0x03	; 3
    2712:	07 c0       	rjmp	.+14     	; 0x2722 <twi_writeTo+0xb6>
    2714:	81 e0       	ldi	r24, 0x01	; 1
    2716:	05 c0       	rjmp	.+10     	; 0x2722 <twi_writeTo+0xb6>
    2718:	80 e0       	ldi	r24, 0x00	; 0
    271a:	03 c0       	rjmp	.+6      	; 0x2722 <twi_writeTo+0xb6>
    271c:	82 e0       	ldi	r24, 0x02	; 2
    271e:	01 c0       	rjmp	.+2      	; 0x2722 <twi_writeTo+0xb6>
    2720:	84 e0       	ldi	r24, 0x04	; 4
    2722:	0f 91       	pop	r16
    2724:	08 95       	ret

00002726 <twi_transmit>:
    2726:	61 32       	cpi	r22, 0x21	; 33
    2728:	a8 f4       	brcc	.+42     	; 0x2754 <twi_transmit+0x2e>
    272a:	20 91 94 09 	lds	r18, 0x0994
    272e:	24 30       	cpi	r18, 0x04	; 4
    2730:	99 f4       	brne	.+38     	; 0x2758 <twi_transmit+0x32>
    2732:	60 93 49 09 	sts	0x0949, r22
    2736:	66 23       	and	r22, r22
    2738:	89 f0       	breq	.+34     	; 0x275c <twi_transmit+0x36>
    273a:	fc 01       	movw	r30, r24
    273c:	ab e4       	ldi	r26, 0x4B	; 75
    273e:	b9 e0       	ldi	r27, 0x09	; 9
    2740:	01 96       	adiw	r24, 0x01	; 1
    2742:	61 50       	subi	r22, 0x01	; 1
    2744:	86 0f       	add	r24, r22
    2746:	91 1d       	adc	r25, r1
    2748:	21 91       	ld	r18, Z+
    274a:	2d 93       	st	X+, r18
    274c:	e8 17       	cp	r30, r24
    274e:	f9 07       	cpc	r31, r25
    2750:	d9 f7       	brne	.-10     	; 0x2748 <twi_transmit+0x22>
    2752:	06 c0       	rjmp	.+12     	; 0x2760 <twi_transmit+0x3a>
    2754:	81 e0       	ldi	r24, 0x01	; 1
    2756:	08 95       	ret
    2758:	82 e0       	ldi	r24, 0x02	; 2
    275a:	08 95       	ret
    275c:	80 e0       	ldi	r24, 0x00	; 0
    275e:	08 95       	ret
    2760:	80 e0       	ldi	r24, 0x00	; 0
    2762:	08 95       	ret

00002764 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    2764:	85 ed       	ldi	r24, 0xD5	; 213
    2766:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    276a:	ec eb       	ldi	r30, 0xBC	; 188
    276c:	f0 e0       	ldi	r31, 0x00	; 0
    276e:	80 81       	ld	r24, Z
    2770:	84 fd       	sbrc	r24, 4
    2772:	fd cf       	rjmp	.-6      	; 0x276e <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    2774:	10 92 94 09 	sts	0x0994, r1
    2778:	08 95       	ret

0000277a <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    277a:	85 ec       	ldi	r24, 0xC5	; 197
    277c:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2780:	10 92 94 09 	sts	0x0994, r1
    2784:	08 95       	ret

00002786 <__vector_39>:
}

ISR(TWI_vect)
{
    2786:	1f 92       	push	r1
    2788:	0f 92       	push	r0
    278a:	0f b6       	in	r0, 0x3f	; 63
    278c:	0f 92       	push	r0
    278e:	11 24       	eor	r1, r1
    2790:	0b b6       	in	r0, 0x3b	; 59
    2792:	0f 92       	push	r0
    2794:	2f 93       	push	r18
    2796:	3f 93       	push	r19
    2798:	4f 93       	push	r20
    279a:	5f 93       	push	r21
    279c:	6f 93       	push	r22
    279e:	7f 93       	push	r23
    27a0:	8f 93       	push	r24
    27a2:	9f 93       	push	r25
    27a4:	af 93       	push	r26
    27a6:	bf 93       	push	r27
    27a8:	ef 93       	push	r30
    27aa:	ff 93       	push	r31
  switch(TW_STATUS){
    27ac:	80 91 b9 00 	lds	r24, 0x00B9
    27b0:	88 7f       	andi	r24, 0xF8	; 248
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	89 3c       	cpi	r24, 0xC9	; 201
    27b6:	91 05       	cpc	r25, r1
    27b8:	08 f0       	brcs	.+2      	; 0x27bc <__vector_39+0x36>
    27ba:	ee c0       	rjmp	.+476    	; 0x2998 <__vector_39+0x212>
    27bc:	fc 01       	movw	r30, r24
    27be:	ee 58       	subi	r30, 0x8E	; 142
    27c0:	ff 4f       	sbci	r31, 0xFF	; 255
    27c2:	0c 94 75 1d 	jmp	0x3aea	; 0x3aea <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    27c6:	80 91 93 09 	lds	r24, 0x0993
    27ca:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    27ce:	85 ec       	ldi	r24, 0xC5	; 197
    27d0:	80 93 bc 00 	sts	0x00BC, r24
    27d4:	e1 c0       	rjmp	.+450    	; 0x2998 <__vector_39+0x212>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    27d6:	90 91 6c 09 	lds	r25, 0x096C
    27da:	80 91 6b 09 	lds	r24, 0x096B
    27de:	98 17       	cp	r25, r24
    27e0:	80 f4       	brcc	.+32     	; 0x2802 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    27e2:	e0 91 6c 09 	lds	r30, 0x096C
    27e6:	81 e0       	ldi	r24, 0x01	; 1
    27e8:	8e 0f       	add	r24, r30
    27ea:	80 93 6c 09 	sts	0x096C, r24
    27ee:	f0 e0       	ldi	r31, 0x00	; 0
    27f0:	e3 59       	subi	r30, 0x93	; 147
    27f2:	f6 4f       	sbci	r31, 0xF6	; 246
    27f4:	80 81       	ld	r24, Z
    27f6:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    27fa:	85 ec       	ldi	r24, 0xC5	; 197
    27fc:	80 93 bc 00 	sts	0x00BC, r24
    2800:	cb c0       	rjmp	.+406    	; 0x2998 <__vector_39+0x212>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    2802:	80 91 92 09 	lds	r24, 0x0992
    2806:	88 23       	and	r24, r24
    2808:	11 f0       	breq	.+4      	; 0x280e <__vector_39+0x88>
          twi_stop();
    280a:	ac df       	rcall	.-168    	; 0x2764 <twi_stop>
    280c:	c5 c0       	rjmp	.+394    	; 0x2998 <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    280e:	81 e0       	ldi	r24, 0x01	; 1
    2810:	80 93 91 09 	sts	0x0991, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2814:	84 ea       	ldi	r24, 0xA4	; 164
    2816:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    281a:	10 92 94 09 	sts	0x0994, r1
    281e:	bc c0       	rjmp	.+376    	; 0x2998 <__vector_39+0x212>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    2820:	80 e2       	ldi	r24, 0x20	; 32
    2822:	80 93 27 09 	sts	0x0927, r24
      twi_stop();
    2826:	9e df       	rcall	.-196    	; 0x2764 <twi_stop>
      break;
    2828:	b7 c0       	rjmp	.+366    	; 0x2998 <__vector_39+0x212>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    282a:	80 e3       	ldi	r24, 0x30	; 48
    282c:	80 93 27 09 	sts	0x0927, r24
      twi_stop();
    2830:	99 df       	rcall	.-206    	; 0x2764 <twi_stop>
      break;
    2832:	b2 c0       	rjmp	.+356    	; 0x2998 <__vector_39+0x212>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    2834:	88 e3       	ldi	r24, 0x38	; 56
    2836:	80 93 27 09 	sts	0x0927, r24
      twi_releaseBus();
    283a:	9f df       	rcall	.-194    	; 0x277a <twi_releaseBus>
      break;
    283c:	ad c0       	rjmp	.+346    	; 0x2998 <__vector_39+0x212>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    283e:	e0 91 6c 09 	lds	r30, 0x096C
    2842:	81 e0       	ldi	r24, 0x01	; 1
    2844:	8e 0f       	add	r24, r30
    2846:	80 93 6c 09 	sts	0x096C, r24
    284a:	80 91 bb 00 	lds	r24, 0x00BB
    284e:	f0 e0       	ldi	r31, 0x00	; 0
    2850:	e3 59       	subi	r30, 0x93	; 147
    2852:	f6 4f       	sbci	r31, 0xF6	; 246
    2854:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2856:	90 91 6c 09 	lds	r25, 0x096C
    285a:	80 91 6b 09 	lds	r24, 0x096B
    285e:	98 17       	cp	r25, r24
    2860:	20 f4       	brcc	.+8      	; 0x286a <__vector_39+0xe4>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2862:	85 ec       	ldi	r24, 0xC5	; 197
    2864:	80 93 bc 00 	sts	0x00BC, r24
    2868:	97 c0       	rjmp	.+302    	; 0x2998 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    286a:	85 e8       	ldi	r24, 0x85	; 133
    286c:	80 93 bc 00 	sts	0x00BC, r24
    2870:	93 c0       	rjmp	.+294    	; 0x2998 <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2872:	e0 91 6c 09 	lds	r30, 0x096C
    2876:	81 e0       	ldi	r24, 0x01	; 1
    2878:	8e 0f       	add	r24, r30
    287a:	80 93 6c 09 	sts	0x096C, r24
    287e:	80 91 bb 00 	lds	r24, 0x00BB
    2882:	f0 e0       	ldi	r31, 0x00	; 0
    2884:	e3 59       	subi	r30, 0x93	; 147
    2886:	f6 4f       	sbci	r31, 0xF6	; 246
    2888:	80 83       	st	Z, r24
	if (twi_sendStop)
    288a:	80 91 92 09 	lds	r24, 0x0992
    288e:	88 23       	and	r24, r24
    2890:	11 f0       	breq	.+4      	; 0x2896 <__vector_39+0x110>
          twi_stop();
    2892:	68 df       	rcall	.-304    	; 0x2764 <twi_stop>
    2894:	81 c0       	rjmp	.+258    	; 0x2998 <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2896:	81 e0       	ldi	r24, 0x01	; 1
    2898:	80 93 91 09 	sts	0x0991, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    289c:	84 ea       	ldi	r24, 0xA4	; 164
    289e:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    28a2:	10 92 94 09 	sts	0x0994, r1
    28a6:	78 c0       	rjmp	.+240    	; 0x2998 <__vector_39+0x212>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    28a8:	5d df       	rcall	.-326    	; 0x2764 <twi_stop>
      break;
    28aa:	76 c0       	rjmp	.+236    	; 0x2998 <__vector_39+0x212>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    28ac:	83 e0       	ldi	r24, 0x03	; 3
    28ae:	80 93 94 09 	sts	0x0994, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    28b2:	10 92 28 09 	sts	0x0928, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    28b6:	85 ec       	ldi	r24, 0xC5	; 197
    28b8:	80 93 bc 00 	sts	0x00BC, r24
    28bc:	6d c0       	rjmp	.+218    	; 0x2998 <__vector_39+0x212>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    28be:	80 91 28 09 	lds	r24, 0x0928
    28c2:	80 32       	cpi	r24, 0x20	; 32
    28c4:	80 f4       	brcc	.+32     	; 0x28e6 <__vector_39+0x160>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    28c6:	e0 91 28 09 	lds	r30, 0x0928
    28ca:	81 e0       	ldi	r24, 0x01	; 1
    28cc:	8e 0f       	add	r24, r30
    28ce:	80 93 28 09 	sts	0x0928, r24
    28d2:	80 91 bb 00 	lds	r24, 0x00BB
    28d6:	f0 e0       	ldi	r31, 0x00	; 0
    28d8:	e7 5d       	subi	r30, 0xD7	; 215
    28da:	f6 4f       	sbci	r31, 0xF6	; 246
    28dc:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    28de:	85 ec       	ldi	r24, 0xC5	; 197
    28e0:	80 93 bc 00 	sts	0x00BC, r24
    28e4:	59 c0       	rjmp	.+178    	; 0x2998 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    28e6:	85 e8       	ldi	r24, 0x85	; 133
    28e8:	80 93 bc 00 	sts	0x00BC, r24
    28ec:	55 c0       	rjmp	.+170    	; 0x2998 <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    28ee:	80 91 28 09 	lds	r24, 0x0928
    28f2:	80 32       	cpi	r24, 0x20	; 32
    28f4:	30 f4       	brcc	.+12     	; 0x2902 <__vector_39+0x17c>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    28f6:	e0 91 28 09 	lds	r30, 0x0928
    28fa:	f0 e0       	ldi	r31, 0x00	; 0
    28fc:	e7 5d       	subi	r30, 0xD7	; 215
    28fe:	f6 4f       	sbci	r31, 0xF6	; 246
    2900:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    2902:	30 df       	rcall	.-416    	; 0x2764 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    2904:	60 91 28 09 	lds	r22, 0x0928
    2908:	70 e0       	ldi	r23, 0x00	; 0
    290a:	e0 91 8d 09 	lds	r30, 0x098D
    290e:	f0 91 8e 09 	lds	r31, 0x098E
    2912:	89 e2       	ldi	r24, 0x29	; 41
    2914:	99 e0       	ldi	r25, 0x09	; 9
    2916:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    2918:	10 92 28 09 	sts	0x0928, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    291c:	2e df       	rcall	.-420    	; 0x277a <twi_releaseBus>
      break;
    291e:	3c c0       	rjmp	.+120    	; 0x2998 <__vector_39+0x212>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2920:	85 e8       	ldi	r24, 0x85	; 133
    2922:	80 93 bc 00 	sts	0x00BC, r24
    2926:	38 c0       	rjmp	.+112    	; 0x2998 <__vector_39+0x212>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    2928:	84 e0       	ldi	r24, 0x04	; 4
    292a:	80 93 94 09 	sts	0x0994, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    292e:	10 92 4a 09 	sts	0x094A, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2932:	10 92 49 09 	sts	0x0949, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    2936:	e0 91 8f 09 	lds	r30, 0x098F
    293a:	f0 91 90 09 	lds	r31, 0x0990
    293e:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2940:	80 91 49 09 	lds	r24, 0x0949
    2944:	81 11       	cpse	r24, r1
    2946:	05 c0       	rjmp	.+10     	; 0x2952 <__vector_39+0x1cc>
        twi_txBufferLength = 1;
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	80 93 49 09 	sts	0x0949, r24
        twi_txBuffer[0] = 0x00;
    294e:	10 92 4b 09 	sts	0x094B, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2952:	e0 91 4a 09 	lds	r30, 0x094A
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	8e 0f       	add	r24, r30
    295a:	80 93 4a 09 	sts	0x094A, r24
    295e:	f0 e0       	ldi	r31, 0x00	; 0
    2960:	e5 5b       	subi	r30, 0xB5	; 181
    2962:	f6 4f       	sbci	r31, 0xF6	; 246
    2964:	80 81       	ld	r24, Z
    2966:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    296a:	90 91 4a 09 	lds	r25, 0x094A
    296e:	80 91 49 09 	lds	r24, 0x0949
    2972:	98 17       	cp	r25, r24
    2974:	20 f4       	brcc	.+8      	; 0x297e <__vector_39+0x1f8>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2976:	85 ec       	ldi	r24, 0xC5	; 197
    2978:	80 93 bc 00 	sts	0x00BC, r24
    297c:	0d c0       	rjmp	.+26     	; 0x2998 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    297e:	85 e8       	ldi	r24, 0x85	; 133
    2980:	80 93 bc 00 	sts	0x00BC, r24
    2984:	09 c0       	rjmp	.+18     	; 0x2998 <__vector_39+0x212>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2986:	85 ec       	ldi	r24, 0xC5	; 197
    2988:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    298c:	10 92 94 09 	sts	0x0994, r1
      break;
    2990:	03 c0       	rjmp	.+6      	; 0x2998 <__vector_39+0x212>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    2992:	10 92 27 09 	sts	0x0927, r1
      twi_stop();
    2996:	e6 de       	rcall	.-564    	; 0x2764 <twi_stop>
      break;
  }
}
    2998:	ff 91       	pop	r31
    299a:	ef 91       	pop	r30
    299c:	bf 91       	pop	r27
    299e:	af 91       	pop	r26
    29a0:	9f 91       	pop	r25
    29a2:	8f 91       	pop	r24
    29a4:	7f 91       	pop	r23
    29a6:	6f 91       	pop	r22
    29a8:	5f 91       	pop	r21
    29aa:	4f 91       	pop	r20
    29ac:	3f 91       	pop	r19
    29ae:	2f 91       	pop	r18
    29b0:	0f 90       	pop	r0
    29b2:	0b be       	out	0x3b, r0	; 59
    29b4:	0f 90       	pop	r0
    29b6:	0f be       	out	0x3f, r0	; 63
    29b8:	0f 90       	pop	r0
    29ba:	1f 90       	pop	r1
    29bc:	18 95       	reti

000029be <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    29be:	80 91 c5 09 	lds	r24, 0x09C5
    29c2:	90 e0       	ldi	r25, 0x00	; 0
    29c4:	20 91 c6 09 	lds	r18, 0x09C6
    29c8:	82 1b       	sub	r24, r18
    29ca:	91 09       	sbc	r25, r1
    29cc:	08 95       	ret

000029ce <_ZN7TwoWire4readEv>:
    29ce:	20 91 c6 09 	lds	r18, 0x09C6
    29d2:	80 91 c5 09 	lds	r24, 0x09C5
    29d6:	28 17       	cp	r18, r24
    29d8:	50 f4       	brcc	.+20     	; 0x29ee <_ZN7TwoWire4readEv+0x20>
    29da:	e2 2f       	mov	r30, r18
    29dc:	f0 e0       	ldi	r31, 0x00	; 0
    29de:	e9 53       	subi	r30, 0x39	; 57
    29e0:	f6 4f       	sbci	r31, 0xF6	; 246
    29e2:	80 81       	ld	r24, Z
    29e4:	90 e0       	ldi	r25, 0x00	; 0
    29e6:	2f 5f       	subi	r18, 0xFF	; 255
    29e8:	20 93 c6 09 	sts	0x09C6, r18
    29ec:	08 95       	ret
    29ee:	8f ef       	ldi	r24, 0xFF	; 255
    29f0:	9f ef       	ldi	r25, 0xFF	; 255
    29f2:	08 95       	ret

000029f4 <_ZN7TwoWire4peekEv>:
    29f4:	e0 91 c6 09 	lds	r30, 0x09C6
    29f8:	80 91 c5 09 	lds	r24, 0x09C5
    29fc:	e8 17       	cp	r30, r24
    29fe:	30 f4       	brcc	.+12     	; 0x2a0c <_ZN7TwoWire4peekEv+0x18>
    2a00:	f0 e0       	ldi	r31, 0x00	; 0
    2a02:	e9 53       	subi	r30, 0x39	; 57
    2a04:	f6 4f       	sbci	r31, 0xF6	; 246
    2a06:	80 81       	ld	r24, Z
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	08 95       	ret
    2a0c:	8f ef       	ldi	r24, 0xFF	; 255
    2a0e:	9f ef       	ldi	r25, 0xFF	; 255
    2a10:	08 95       	ret

00002a12 <_ZN7TwoWire5flushEv>:
    2a12:	08 95       	ret

00002a14 <_ZN7TwoWire5writeEPKhj>:
    2a14:	cf 92       	push	r12
    2a16:	df 92       	push	r13
    2a18:	ef 92       	push	r14
    2a1a:	ff 92       	push	r15
    2a1c:	0f 93       	push	r16
    2a1e:	1f 93       	push	r17
    2a20:	cf 93       	push	r28
    2a22:	df 93       	push	r29
    2a24:	8c 01       	movw	r16, r24
    2a26:	7b 01       	movw	r14, r22
    2a28:	6a 01       	movw	r12, r20
    2a2a:	80 91 a1 09 	lds	r24, 0x09A1
    2a2e:	88 23       	and	r24, r24
    2a30:	99 f0       	breq	.+38     	; 0x2a58 <_ZN7TwoWire5writeEPKhj+0x44>
    2a32:	41 15       	cp	r20, r1
    2a34:	51 05       	cpc	r21, r1
    2a36:	99 f0       	breq	.+38     	; 0x2a5e <_ZN7TwoWire5writeEPKhj+0x4a>
    2a38:	eb 01       	movw	r28, r22
    2a3a:	e4 0e       	add	r14, r20
    2a3c:	f5 1e       	adc	r15, r21
    2a3e:	69 91       	ld	r22, Y+
    2a40:	d8 01       	movw	r26, r16
    2a42:	ed 91       	ld	r30, X+
    2a44:	fc 91       	ld	r31, X
    2a46:	01 90       	ld	r0, Z+
    2a48:	f0 81       	ld	r31, Z
    2a4a:	e0 2d       	mov	r30, r0
    2a4c:	c8 01       	movw	r24, r16
    2a4e:	19 95       	eicall
    2a50:	ce 15       	cp	r28, r14
    2a52:	df 05       	cpc	r29, r15
    2a54:	a1 f7       	brne	.-24     	; 0x2a3e <_ZN7TwoWire5writeEPKhj+0x2a>
    2a56:	03 c0       	rjmp	.+6      	; 0x2a5e <_ZN7TwoWire5writeEPKhj+0x4a>
    2a58:	64 2f       	mov	r22, r20
    2a5a:	c7 01       	movw	r24, r14
    2a5c:	64 de       	rcall	.-824    	; 0x2726 <twi_transmit>
    2a5e:	c6 01       	movw	r24, r12
    2a60:	df 91       	pop	r29
    2a62:	cf 91       	pop	r28
    2a64:	1f 91       	pop	r17
    2a66:	0f 91       	pop	r16
    2a68:	ff 90       	pop	r15
    2a6a:	ef 90       	pop	r14
    2a6c:	df 90       	pop	r13
    2a6e:	cf 90       	pop	r12
    2a70:	08 95       	ret

00002a72 <_ZN7TwoWire5writeEh>:
    2a72:	cf 93       	push	r28
    2a74:	df 93       	push	r29
    2a76:	1f 92       	push	r1
    2a78:	cd b7       	in	r28, 0x3d	; 61
    2a7a:	de b7       	in	r29, 0x3e	; 62
    2a7c:	69 83       	std	Y+1, r22	; 0x01
    2a7e:	20 91 a1 09 	lds	r18, 0x09A1
    2a82:	22 23       	and	r18, r18
    2a84:	e1 f0       	breq	.+56     	; 0x2abe <_ZN7TwoWire5writeEh+0x4c>
    2a86:	20 91 a2 09 	lds	r18, 0x09A2
    2a8a:	20 32       	cpi	r18, 0x20	; 32
    2a8c:	40 f0       	brcs	.+16     	; 0x2a9e <_ZN7TwoWire5writeEh+0x2c>
    2a8e:	21 e0       	ldi	r18, 0x01	; 1
    2a90:	30 e0       	ldi	r19, 0x00	; 0
    2a92:	fc 01       	movw	r30, r24
    2a94:	33 83       	std	Z+3, r19	; 0x03
    2a96:	22 83       	std	Z+2, r18	; 0x02
    2a98:	80 e0       	ldi	r24, 0x00	; 0
    2a9a:	90 e0       	ldi	r25, 0x00	; 0
    2a9c:	16 c0       	rjmp	.+44     	; 0x2aca <_ZN7TwoWire5writeEh+0x58>
    2a9e:	80 91 a3 09 	lds	r24, 0x09A3
    2aa2:	e8 2f       	mov	r30, r24
    2aa4:	f0 e0       	ldi	r31, 0x00	; 0
    2aa6:	ec 55       	subi	r30, 0x5C	; 92
    2aa8:	f6 4f       	sbci	r31, 0xF6	; 246
    2aaa:	99 81       	ldd	r25, Y+1	; 0x01
    2aac:	90 83       	st	Z, r25
    2aae:	8f 5f       	subi	r24, 0xFF	; 255
    2ab0:	80 93 a3 09 	sts	0x09A3, r24
    2ab4:	80 93 a2 09 	sts	0x09A2, r24
    2ab8:	81 e0       	ldi	r24, 0x01	; 1
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	06 c0       	rjmp	.+12     	; 0x2aca <_ZN7TwoWire5writeEh+0x58>
    2abe:	61 e0       	ldi	r22, 0x01	; 1
    2ac0:	ce 01       	movw	r24, r28
    2ac2:	01 96       	adiw	r24, 0x01	; 1
    2ac4:	30 de       	rcall	.-928    	; 0x2726 <twi_transmit>
    2ac6:	81 e0       	ldi	r24, 0x01	; 1
    2ac8:	90 e0       	ldi	r25, 0x00	; 0
    2aca:	0f 90       	pop	r0
    2acc:	df 91       	pop	r29
    2ace:	cf 91       	pop	r28
    2ad0:	08 95       	ret

00002ad2 <_ZN7TwoWireC1Ev>:
    2ad2:	fc 01       	movw	r30, r24
    2ad4:	13 82       	std	Z+3, r1	; 0x03
    2ad6:	12 82       	std	Z+2, r1	; 0x02
    2ad8:	48 ee       	ldi	r20, 0xE8	; 232
    2ada:	53 e0       	ldi	r21, 0x03	; 3
    2adc:	60 e0       	ldi	r22, 0x00	; 0
    2ade:	70 e0       	ldi	r23, 0x00	; 0
    2ae0:	44 83       	std	Z+4, r20	; 0x04
    2ae2:	55 83       	std	Z+5, r21	; 0x05
    2ae4:	66 83       	std	Z+6, r22	; 0x06
    2ae6:	77 83       	std	Z+7, r23	; 0x07
    2ae8:	8a e7       	ldi	r24, 0x7A	; 122
    2aea:	92 e0       	ldi	r25, 0x02	; 2
    2aec:	91 83       	std	Z+1, r25	; 0x01
    2aee:	80 83       	st	Z, r24
    2af0:	08 95       	ret

00002af2 <_ZN7TwoWire5beginEv>:
    2af2:	10 92 c6 09 	sts	0x09C6, r1
    2af6:	10 92 c5 09 	sts	0x09C5, r1
    2afa:	10 92 a3 09 	sts	0x09A3, r1
    2afe:	10 92 a2 09 	sts	0x09A2, r1
    2b02:	48 cd       	rjmp	.-1392   	; 0x2594 <twi_init>
    2b04:	08 95       	ret

00002b06 <_ZN7TwoWire11requestFromEhhh>:
    2b06:	86 2f       	mov	r24, r22
    2b08:	41 32       	cpi	r20, 0x21	; 33
    2b0a:	08 f0       	brcs	.+2      	; 0x2b0e <_ZN7TwoWire11requestFromEhhh+0x8>
    2b0c:	40 e2       	ldi	r20, 0x20	; 32
    2b0e:	67 ec       	ldi	r22, 0xC7	; 199
    2b10:	79 e0       	ldi	r23, 0x09	; 9
    2b12:	5e dd       	rcall	.-1348   	; 0x25d0 <twi_readFrom>
    2b14:	10 92 c6 09 	sts	0x09C6, r1
    2b18:	80 93 c5 09 	sts	0x09C5, r24
    2b1c:	08 95       	ret

00002b1e <_ZN7TwoWire11requestFromEhh>:
    2b1e:	21 e0       	ldi	r18, 0x01	; 1
    2b20:	f2 cf       	rjmp	.-28     	; 0x2b06 <_ZN7TwoWire11requestFromEhhh>
    2b22:	08 95       	ret

00002b24 <_ZN7TwoWire17beginTransmissionEh>:
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	80 93 a1 09 	sts	0x09A1, r24
    2b2a:	60 93 c4 09 	sts	0x09C4, r22
    2b2e:	10 92 a3 09 	sts	0x09A3, r1
    2b32:	10 92 a2 09 	sts	0x09A2, r1
    2b36:	08 95       	ret

00002b38 <_ZN7TwoWire15endTransmissionEh>:
    2b38:	0f 93       	push	r16
    2b3a:	06 2f       	mov	r16, r22
    2b3c:	21 e0       	ldi	r18, 0x01	; 1
    2b3e:	40 91 a2 09 	lds	r20, 0x09A2
    2b42:	64 ea       	ldi	r22, 0xA4	; 164
    2b44:	79 e0       	ldi	r23, 0x09	; 9
    2b46:	80 91 c4 09 	lds	r24, 0x09C4
    2b4a:	90 dd       	rcall	.-1248   	; 0x266c <twi_writeTo>
    2b4c:	10 92 a3 09 	sts	0x09A3, r1
    2b50:	10 92 a2 09 	sts	0x09A2, r1
    2b54:	10 92 a1 09 	sts	0x09A1, r1
    2b58:	0f 91       	pop	r16
    2b5a:	08 95       	ret

00002b5c <_ZN7TwoWire15endTransmissionEv>:
    2b5c:	61 e0       	ldi	r22, 0x01	; 1
    2b5e:	ec cf       	rjmp	.-40     	; 0x2b38 <_ZN7TwoWire15endTransmissionEh>
    2b60:	08 95       	ret

00002b62 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2b62:	85 e9       	ldi	r24, 0x95	; 149
    2b64:	99 e0       	ldi	r25, 0x09	; 9
    2b66:	b5 cf       	rjmp	.-150    	; 0x2ad2 <_ZN7TwoWireC1Ev>
    2b68:	08 95       	ret

00002b6a <__subsf3>:
    2b6a:	50 58       	subi	r21, 0x80	; 128

00002b6c <__addsf3>:
    2b6c:	bb 27       	eor	r27, r27
    2b6e:	aa 27       	eor	r26, r26
    2b70:	0e d0       	rcall	.+28     	; 0x2b8e <__addsf3x>
    2b72:	fc c1       	rjmp	.+1016   	; 0x2f6c <__fp_round>
    2b74:	ed d1       	rcall	.+986    	; 0x2f50 <__fp_pscA>
    2b76:	30 f0       	brcs	.+12     	; 0x2b84 <__addsf3+0x18>
    2b78:	f2 d1       	rcall	.+996    	; 0x2f5e <__fp_pscB>
    2b7a:	20 f0       	brcs	.+8      	; 0x2b84 <__addsf3+0x18>
    2b7c:	31 f4       	brne	.+12     	; 0x2b8a <__addsf3+0x1e>
    2b7e:	9f 3f       	cpi	r25, 0xFF	; 255
    2b80:	11 f4       	brne	.+4      	; 0x2b86 <__addsf3+0x1a>
    2b82:	1e f4       	brtc	.+6      	; 0x2b8a <__addsf3+0x1e>
    2b84:	bd c1       	rjmp	.+890    	; 0x2f00 <__fp_nan>
    2b86:	0e f4       	brtc	.+2      	; 0x2b8a <__addsf3+0x1e>
    2b88:	e0 95       	com	r30
    2b8a:	e7 fb       	bst	r30, 7
    2b8c:	b3 c1       	rjmp	.+870    	; 0x2ef4 <__fp_inf>

00002b8e <__addsf3x>:
    2b8e:	e9 2f       	mov	r30, r25
    2b90:	fe d1       	rcall	.+1020   	; 0x2f8e <__fp_split3>
    2b92:	80 f3       	brcs	.-32     	; 0x2b74 <__addsf3+0x8>
    2b94:	ba 17       	cp	r27, r26
    2b96:	62 07       	cpc	r22, r18
    2b98:	73 07       	cpc	r23, r19
    2b9a:	84 07       	cpc	r24, r20
    2b9c:	95 07       	cpc	r25, r21
    2b9e:	18 f0       	brcs	.+6      	; 0x2ba6 <__addsf3x+0x18>
    2ba0:	71 f4       	brne	.+28     	; 0x2bbe <__addsf3x+0x30>
    2ba2:	9e f5       	brtc	.+102    	; 0x2c0a <__addsf3x+0x7c>
    2ba4:	16 c2       	rjmp	.+1068   	; 0x2fd2 <__fp_zero>
    2ba6:	0e f4       	brtc	.+2      	; 0x2baa <__addsf3x+0x1c>
    2ba8:	e0 95       	com	r30
    2baa:	0b 2e       	mov	r0, r27
    2bac:	ba 2f       	mov	r27, r26
    2bae:	a0 2d       	mov	r26, r0
    2bb0:	0b 01       	movw	r0, r22
    2bb2:	b9 01       	movw	r22, r18
    2bb4:	90 01       	movw	r18, r0
    2bb6:	0c 01       	movw	r0, r24
    2bb8:	ca 01       	movw	r24, r20
    2bba:	a0 01       	movw	r20, r0
    2bbc:	11 24       	eor	r1, r1
    2bbe:	ff 27       	eor	r31, r31
    2bc0:	59 1b       	sub	r21, r25
    2bc2:	99 f0       	breq	.+38     	; 0x2bea <__addsf3x+0x5c>
    2bc4:	59 3f       	cpi	r21, 0xF9	; 249
    2bc6:	50 f4       	brcc	.+20     	; 0x2bdc <__addsf3x+0x4e>
    2bc8:	50 3e       	cpi	r21, 0xE0	; 224
    2bca:	68 f1       	brcs	.+90     	; 0x2c26 <__addsf3x+0x98>
    2bcc:	1a 16       	cp	r1, r26
    2bce:	f0 40       	sbci	r31, 0x00	; 0
    2bd0:	a2 2f       	mov	r26, r18
    2bd2:	23 2f       	mov	r18, r19
    2bd4:	34 2f       	mov	r19, r20
    2bd6:	44 27       	eor	r20, r20
    2bd8:	58 5f       	subi	r21, 0xF8	; 248
    2bda:	f3 cf       	rjmp	.-26     	; 0x2bc2 <__addsf3x+0x34>
    2bdc:	46 95       	lsr	r20
    2bde:	37 95       	ror	r19
    2be0:	27 95       	ror	r18
    2be2:	a7 95       	ror	r26
    2be4:	f0 40       	sbci	r31, 0x00	; 0
    2be6:	53 95       	inc	r21
    2be8:	c9 f7       	brne	.-14     	; 0x2bdc <__addsf3x+0x4e>
    2bea:	7e f4       	brtc	.+30     	; 0x2c0a <__addsf3x+0x7c>
    2bec:	1f 16       	cp	r1, r31
    2bee:	ba 0b       	sbc	r27, r26
    2bf0:	62 0b       	sbc	r22, r18
    2bf2:	73 0b       	sbc	r23, r19
    2bf4:	84 0b       	sbc	r24, r20
    2bf6:	ba f0       	brmi	.+46     	; 0x2c26 <__addsf3x+0x98>
    2bf8:	91 50       	subi	r25, 0x01	; 1
    2bfa:	a1 f0       	breq	.+40     	; 0x2c24 <__addsf3x+0x96>
    2bfc:	ff 0f       	add	r31, r31
    2bfe:	bb 1f       	adc	r27, r27
    2c00:	66 1f       	adc	r22, r22
    2c02:	77 1f       	adc	r23, r23
    2c04:	88 1f       	adc	r24, r24
    2c06:	c2 f7       	brpl	.-16     	; 0x2bf8 <__addsf3x+0x6a>
    2c08:	0e c0       	rjmp	.+28     	; 0x2c26 <__addsf3x+0x98>
    2c0a:	ba 0f       	add	r27, r26
    2c0c:	62 1f       	adc	r22, r18
    2c0e:	73 1f       	adc	r23, r19
    2c10:	84 1f       	adc	r24, r20
    2c12:	48 f4       	brcc	.+18     	; 0x2c26 <__addsf3x+0x98>
    2c14:	87 95       	ror	r24
    2c16:	77 95       	ror	r23
    2c18:	67 95       	ror	r22
    2c1a:	b7 95       	ror	r27
    2c1c:	f7 95       	ror	r31
    2c1e:	9e 3f       	cpi	r25, 0xFE	; 254
    2c20:	08 f0       	brcs	.+2      	; 0x2c24 <__addsf3x+0x96>
    2c22:	b3 cf       	rjmp	.-154    	; 0x2b8a <__addsf3+0x1e>
    2c24:	93 95       	inc	r25
    2c26:	88 0f       	add	r24, r24
    2c28:	08 f0       	brcs	.+2      	; 0x2c2c <__addsf3x+0x9e>
    2c2a:	99 27       	eor	r25, r25
    2c2c:	ee 0f       	add	r30, r30
    2c2e:	97 95       	ror	r25
    2c30:	87 95       	ror	r24
    2c32:	08 95       	ret
    2c34:	8d d1       	rcall	.+794    	; 0x2f50 <__fp_pscA>
    2c36:	58 f0       	brcs	.+22     	; 0x2c4e <__addsf3x+0xc0>
    2c38:	80 e8       	ldi	r24, 0x80	; 128
    2c3a:	91 e0       	ldi	r25, 0x01	; 1
    2c3c:	09 f4       	brne	.+2      	; 0x2c40 <__addsf3x+0xb2>
    2c3e:	9e ef       	ldi	r25, 0xFE	; 254
    2c40:	8e d1       	rcall	.+796    	; 0x2f5e <__fp_pscB>
    2c42:	28 f0       	brcs	.+10     	; 0x2c4e <__addsf3x+0xc0>
    2c44:	40 e8       	ldi	r20, 0x80	; 128
    2c46:	51 e0       	ldi	r21, 0x01	; 1
    2c48:	59 f4       	brne	.+22     	; 0x2c60 <atan2+0xe>
    2c4a:	5e ef       	ldi	r21, 0xFE	; 254
    2c4c:	09 c0       	rjmp	.+18     	; 0x2c60 <atan2+0xe>
    2c4e:	58 c1       	rjmp	.+688    	; 0x2f00 <__fp_nan>
    2c50:	c0 c1       	rjmp	.+896    	; 0x2fd2 <__fp_zero>

00002c52 <atan2>:
    2c52:	e9 2f       	mov	r30, r25
    2c54:	e0 78       	andi	r30, 0x80	; 128
    2c56:	9b d1       	rcall	.+822    	; 0x2f8e <__fp_split3>
    2c58:	68 f3       	brcs	.-38     	; 0x2c34 <__addsf3x+0xa6>
    2c5a:	09 2e       	mov	r0, r25
    2c5c:	05 2a       	or	r0, r21
    2c5e:	c1 f3       	breq	.-16     	; 0x2c50 <__addsf3x+0xc2>
    2c60:	26 17       	cp	r18, r22
    2c62:	37 07       	cpc	r19, r23
    2c64:	48 07       	cpc	r20, r24
    2c66:	59 07       	cpc	r21, r25
    2c68:	38 f0       	brcs	.+14     	; 0x2c78 <atan2+0x26>
    2c6a:	0e 2e       	mov	r0, r30
    2c6c:	07 f8       	bld	r0, 7
    2c6e:	e0 25       	eor	r30, r0
    2c70:	69 f0       	breq	.+26     	; 0x2c8c <atan2+0x3a>
    2c72:	e0 25       	eor	r30, r0
    2c74:	e0 64       	ori	r30, 0x40	; 64
    2c76:	0a c0       	rjmp	.+20     	; 0x2c8c <atan2+0x3a>
    2c78:	ef 63       	ori	r30, 0x3F	; 63
    2c7a:	07 f8       	bld	r0, 7
    2c7c:	00 94       	com	r0
    2c7e:	07 fa       	bst	r0, 7
    2c80:	db 01       	movw	r26, r22
    2c82:	b9 01       	movw	r22, r18
    2c84:	9d 01       	movw	r18, r26
    2c86:	dc 01       	movw	r26, r24
    2c88:	ca 01       	movw	r24, r20
    2c8a:	ad 01       	movw	r20, r26
    2c8c:	ef 93       	push	r30
    2c8e:	47 d0       	rcall	.+142    	; 0x2d1e <__divsf3_pse>
    2c90:	6d d1       	rcall	.+730    	; 0x2f6c <__fp_round>
    2c92:	0a d0       	rcall	.+20     	; 0x2ca8 <atan>
    2c94:	5f 91       	pop	r21
    2c96:	55 23       	and	r21, r21
    2c98:	31 f0       	breq	.+12     	; 0x2ca6 <atan2+0x54>
    2c9a:	2b ed       	ldi	r18, 0xDB	; 219
    2c9c:	3f e0       	ldi	r19, 0x0F	; 15
    2c9e:	49 e4       	ldi	r20, 0x49	; 73
    2ca0:	50 fd       	sbrc	r21, 0
    2ca2:	49 ec       	ldi	r20, 0xC9	; 201
    2ca4:	63 cf       	rjmp	.-314    	; 0x2b6c <__addsf3>
    2ca6:	08 95       	ret

00002ca8 <atan>:
    2ca8:	df 93       	push	r29
    2caa:	dd 27       	eor	r29, r29
    2cac:	b9 2f       	mov	r27, r25
    2cae:	bf 77       	andi	r27, 0x7F	; 127
    2cb0:	40 e8       	ldi	r20, 0x80	; 128
    2cb2:	5f e3       	ldi	r21, 0x3F	; 63
    2cb4:	16 16       	cp	r1, r22
    2cb6:	17 06       	cpc	r1, r23
    2cb8:	48 07       	cpc	r20, r24
    2cba:	5b 07       	cpc	r21, r27
    2cbc:	10 f4       	brcc	.+4      	; 0x2cc2 <atan+0x1a>
    2cbe:	d9 2f       	mov	r29, r25
    2cc0:	8f d1       	rcall	.+798    	; 0x2fe0 <inverse>
    2cc2:	9f 93       	push	r25
    2cc4:	8f 93       	push	r24
    2cc6:	7f 93       	push	r23
    2cc8:	6f 93       	push	r22
    2cca:	36 d2       	rcall	.+1132   	; 0x3138 <square>
    2ccc:	e6 e7       	ldi	r30, 0x76	; 118
    2cce:	f2 e0       	ldi	r31, 0x02	; 2
    2cd0:	1a d1       	rcall	.+564    	; 0x2f06 <__fp_powser>
    2cd2:	4c d1       	rcall	.+664    	; 0x2f6c <__fp_round>
    2cd4:	2f 91       	pop	r18
    2cd6:	3f 91       	pop	r19
    2cd8:	4f 91       	pop	r20
    2cda:	5f 91       	pop	r21
    2cdc:	94 d1       	rcall	.+808    	; 0x3006 <__mulsf3x>
    2cde:	dd 23       	and	r29, r29
    2ce0:	49 f0       	breq	.+18     	; 0x2cf4 <atan+0x4c>
    2ce2:	90 58       	subi	r25, 0x80	; 128
    2ce4:	a2 ea       	ldi	r26, 0xA2	; 162
    2ce6:	2a ed       	ldi	r18, 0xDA	; 218
    2ce8:	3f e0       	ldi	r19, 0x0F	; 15
    2cea:	49 ec       	ldi	r20, 0xC9	; 201
    2cec:	5f e3       	ldi	r21, 0x3F	; 63
    2cee:	d0 78       	andi	r29, 0x80	; 128
    2cf0:	5d 27       	eor	r21, r29
    2cf2:	4d df       	rcall	.-358    	; 0x2b8e <__addsf3x>
    2cf4:	df 91       	pop	r29
    2cf6:	3a c1       	rjmp	.+628    	; 0x2f6c <__fp_round>

00002cf8 <__cmpsf2>:
    2cf8:	d9 d0       	rcall	.+434    	; 0x2eac <__fp_cmp>
    2cfa:	08 f4       	brcc	.+2      	; 0x2cfe <__cmpsf2+0x6>
    2cfc:	81 e0       	ldi	r24, 0x01	; 1
    2cfe:	08 95       	ret

00002d00 <__divsf3>:
    2d00:	0c d0       	rcall	.+24     	; 0x2d1a <__divsf3x>
    2d02:	34 c1       	rjmp	.+616    	; 0x2f6c <__fp_round>
    2d04:	2c d1       	rcall	.+600    	; 0x2f5e <__fp_pscB>
    2d06:	40 f0       	brcs	.+16     	; 0x2d18 <__divsf3+0x18>
    2d08:	23 d1       	rcall	.+582    	; 0x2f50 <__fp_pscA>
    2d0a:	30 f0       	brcs	.+12     	; 0x2d18 <__divsf3+0x18>
    2d0c:	21 f4       	brne	.+8      	; 0x2d16 <__divsf3+0x16>
    2d0e:	5f 3f       	cpi	r21, 0xFF	; 255
    2d10:	19 f0       	breq	.+6      	; 0x2d18 <__divsf3+0x18>
    2d12:	f0 c0       	rjmp	.+480    	; 0x2ef4 <__fp_inf>
    2d14:	51 11       	cpse	r21, r1
    2d16:	5e c1       	rjmp	.+700    	; 0x2fd4 <__fp_szero>
    2d18:	f3 c0       	rjmp	.+486    	; 0x2f00 <__fp_nan>

00002d1a <__divsf3x>:
    2d1a:	39 d1       	rcall	.+626    	; 0x2f8e <__fp_split3>
    2d1c:	98 f3       	brcs	.-26     	; 0x2d04 <__divsf3+0x4>

00002d1e <__divsf3_pse>:
    2d1e:	99 23       	and	r25, r25
    2d20:	c9 f3       	breq	.-14     	; 0x2d14 <__divsf3+0x14>
    2d22:	55 23       	and	r21, r21
    2d24:	b1 f3       	breq	.-20     	; 0x2d12 <__divsf3+0x12>
    2d26:	95 1b       	sub	r25, r21
    2d28:	55 0b       	sbc	r21, r21
    2d2a:	bb 27       	eor	r27, r27
    2d2c:	aa 27       	eor	r26, r26
    2d2e:	62 17       	cp	r22, r18
    2d30:	73 07       	cpc	r23, r19
    2d32:	84 07       	cpc	r24, r20
    2d34:	38 f0       	brcs	.+14     	; 0x2d44 <__divsf3_pse+0x26>
    2d36:	9f 5f       	subi	r25, 0xFF	; 255
    2d38:	5f 4f       	sbci	r21, 0xFF	; 255
    2d3a:	22 0f       	add	r18, r18
    2d3c:	33 1f       	adc	r19, r19
    2d3e:	44 1f       	adc	r20, r20
    2d40:	aa 1f       	adc	r26, r26
    2d42:	a9 f3       	breq	.-22     	; 0x2d2e <__divsf3_pse+0x10>
    2d44:	33 d0       	rcall	.+102    	; 0x2dac <__divsf3_pse+0x8e>
    2d46:	0e 2e       	mov	r0, r30
    2d48:	3a f0       	brmi	.+14     	; 0x2d58 <__divsf3_pse+0x3a>
    2d4a:	e0 e8       	ldi	r30, 0x80	; 128
    2d4c:	30 d0       	rcall	.+96     	; 0x2dae <__divsf3_pse+0x90>
    2d4e:	91 50       	subi	r25, 0x01	; 1
    2d50:	50 40       	sbci	r21, 0x00	; 0
    2d52:	e6 95       	lsr	r30
    2d54:	00 1c       	adc	r0, r0
    2d56:	ca f7       	brpl	.-14     	; 0x2d4a <__divsf3_pse+0x2c>
    2d58:	29 d0       	rcall	.+82     	; 0x2dac <__divsf3_pse+0x8e>
    2d5a:	fe 2f       	mov	r31, r30
    2d5c:	27 d0       	rcall	.+78     	; 0x2dac <__divsf3_pse+0x8e>
    2d5e:	66 0f       	add	r22, r22
    2d60:	77 1f       	adc	r23, r23
    2d62:	88 1f       	adc	r24, r24
    2d64:	bb 1f       	adc	r27, r27
    2d66:	26 17       	cp	r18, r22
    2d68:	37 07       	cpc	r19, r23
    2d6a:	48 07       	cpc	r20, r24
    2d6c:	ab 07       	cpc	r26, r27
    2d6e:	b0 e8       	ldi	r27, 0x80	; 128
    2d70:	09 f0       	breq	.+2      	; 0x2d74 <__divsf3_pse+0x56>
    2d72:	bb 0b       	sbc	r27, r27
    2d74:	80 2d       	mov	r24, r0
    2d76:	bf 01       	movw	r22, r30
    2d78:	ff 27       	eor	r31, r31
    2d7a:	93 58       	subi	r25, 0x83	; 131
    2d7c:	5f 4f       	sbci	r21, 0xFF	; 255
    2d7e:	2a f0       	brmi	.+10     	; 0x2d8a <__divsf3_pse+0x6c>
    2d80:	9e 3f       	cpi	r25, 0xFE	; 254
    2d82:	51 05       	cpc	r21, r1
    2d84:	68 f0       	brcs	.+26     	; 0x2da0 <__divsf3_pse+0x82>
    2d86:	b6 c0       	rjmp	.+364    	; 0x2ef4 <__fp_inf>
    2d88:	25 c1       	rjmp	.+586    	; 0x2fd4 <__fp_szero>
    2d8a:	5f 3f       	cpi	r21, 0xFF	; 255
    2d8c:	ec f3       	brlt	.-6      	; 0x2d88 <__divsf3_pse+0x6a>
    2d8e:	98 3e       	cpi	r25, 0xE8	; 232
    2d90:	dc f3       	brlt	.-10     	; 0x2d88 <__divsf3_pse+0x6a>
    2d92:	86 95       	lsr	r24
    2d94:	77 95       	ror	r23
    2d96:	67 95       	ror	r22
    2d98:	b7 95       	ror	r27
    2d9a:	f7 95       	ror	r31
    2d9c:	9f 5f       	subi	r25, 0xFF	; 255
    2d9e:	c9 f7       	brne	.-14     	; 0x2d92 <__divsf3_pse+0x74>
    2da0:	88 0f       	add	r24, r24
    2da2:	91 1d       	adc	r25, r1
    2da4:	96 95       	lsr	r25
    2da6:	87 95       	ror	r24
    2da8:	97 f9       	bld	r25, 7
    2daa:	08 95       	ret
    2dac:	e1 e0       	ldi	r30, 0x01	; 1
    2dae:	66 0f       	add	r22, r22
    2db0:	77 1f       	adc	r23, r23
    2db2:	88 1f       	adc	r24, r24
    2db4:	bb 1f       	adc	r27, r27
    2db6:	62 17       	cp	r22, r18
    2db8:	73 07       	cpc	r23, r19
    2dba:	84 07       	cpc	r24, r20
    2dbc:	ba 07       	cpc	r27, r26
    2dbe:	20 f0       	brcs	.+8      	; 0x2dc8 <__divsf3_pse+0xaa>
    2dc0:	62 1b       	sub	r22, r18
    2dc2:	73 0b       	sbc	r23, r19
    2dc4:	84 0b       	sbc	r24, r20
    2dc6:	ba 0b       	sbc	r27, r26
    2dc8:	ee 1f       	adc	r30, r30
    2dca:	88 f7       	brcc	.-30     	; 0x2dae <__divsf3_pse+0x90>
    2dcc:	e0 95       	com	r30
    2dce:	08 95       	ret

00002dd0 <__fixsfsi>:
    2dd0:	04 d0       	rcall	.+8      	; 0x2dda <__fixunssfsi>
    2dd2:	68 94       	set
    2dd4:	b1 11       	cpse	r27, r1
    2dd6:	fe c0       	rjmp	.+508    	; 0x2fd4 <__fp_szero>
    2dd8:	08 95       	ret

00002dda <__fixunssfsi>:
    2dda:	e1 d0       	rcall	.+450    	; 0x2f9e <__fp_splitA>
    2ddc:	88 f0       	brcs	.+34     	; 0x2e00 <__fixunssfsi+0x26>
    2dde:	9f 57       	subi	r25, 0x7F	; 127
    2de0:	90 f0       	brcs	.+36     	; 0x2e06 <__fixunssfsi+0x2c>
    2de2:	b9 2f       	mov	r27, r25
    2de4:	99 27       	eor	r25, r25
    2de6:	b7 51       	subi	r27, 0x17	; 23
    2de8:	a0 f0       	brcs	.+40     	; 0x2e12 <__fixunssfsi+0x38>
    2dea:	d1 f0       	breq	.+52     	; 0x2e20 <__fixunssfsi+0x46>
    2dec:	66 0f       	add	r22, r22
    2dee:	77 1f       	adc	r23, r23
    2df0:	88 1f       	adc	r24, r24
    2df2:	99 1f       	adc	r25, r25
    2df4:	1a f0       	brmi	.+6      	; 0x2dfc <__fixunssfsi+0x22>
    2df6:	ba 95       	dec	r27
    2df8:	c9 f7       	brne	.-14     	; 0x2dec <__fixunssfsi+0x12>
    2dfa:	12 c0       	rjmp	.+36     	; 0x2e20 <__fixunssfsi+0x46>
    2dfc:	b1 30       	cpi	r27, 0x01	; 1
    2dfe:	81 f0       	breq	.+32     	; 0x2e20 <__fixunssfsi+0x46>
    2e00:	e8 d0       	rcall	.+464    	; 0x2fd2 <__fp_zero>
    2e02:	b1 e0       	ldi	r27, 0x01	; 1
    2e04:	08 95       	ret
    2e06:	e5 c0       	rjmp	.+458    	; 0x2fd2 <__fp_zero>
    2e08:	67 2f       	mov	r22, r23
    2e0a:	78 2f       	mov	r23, r24
    2e0c:	88 27       	eor	r24, r24
    2e0e:	b8 5f       	subi	r27, 0xF8	; 248
    2e10:	39 f0       	breq	.+14     	; 0x2e20 <__fixunssfsi+0x46>
    2e12:	b9 3f       	cpi	r27, 0xF9	; 249
    2e14:	cc f3       	brlt	.-14     	; 0x2e08 <__fixunssfsi+0x2e>
    2e16:	86 95       	lsr	r24
    2e18:	77 95       	ror	r23
    2e1a:	67 95       	ror	r22
    2e1c:	b3 95       	inc	r27
    2e1e:	d9 f7       	brne	.-10     	; 0x2e16 <__fixunssfsi+0x3c>
    2e20:	3e f4       	brtc	.+14     	; 0x2e30 <__fixunssfsi+0x56>
    2e22:	90 95       	com	r25
    2e24:	80 95       	com	r24
    2e26:	70 95       	com	r23
    2e28:	61 95       	neg	r22
    2e2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e2c:	8f 4f       	sbci	r24, 0xFF	; 255
    2e2e:	9f 4f       	sbci	r25, 0xFF	; 255
    2e30:	08 95       	ret

00002e32 <__floatunsisf>:
    2e32:	e8 94       	clt
    2e34:	09 c0       	rjmp	.+18     	; 0x2e48 <__floatsisf+0x12>

00002e36 <__floatsisf>:
    2e36:	97 fb       	bst	r25, 7
    2e38:	3e f4       	brtc	.+14     	; 0x2e48 <__floatsisf+0x12>
    2e3a:	90 95       	com	r25
    2e3c:	80 95       	com	r24
    2e3e:	70 95       	com	r23
    2e40:	61 95       	neg	r22
    2e42:	7f 4f       	sbci	r23, 0xFF	; 255
    2e44:	8f 4f       	sbci	r24, 0xFF	; 255
    2e46:	9f 4f       	sbci	r25, 0xFF	; 255
    2e48:	99 23       	and	r25, r25
    2e4a:	a9 f0       	breq	.+42     	; 0x2e76 <__floatsisf+0x40>
    2e4c:	f9 2f       	mov	r31, r25
    2e4e:	96 e9       	ldi	r25, 0x96	; 150
    2e50:	bb 27       	eor	r27, r27
    2e52:	93 95       	inc	r25
    2e54:	f6 95       	lsr	r31
    2e56:	87 95       	ror	r24
    2e58:	77 95       	ror	r23
    2e5a:	67 95       	ror	r22
    2e5c:	b7 95       	ror	r27
    2e5e:	f1 11       	cpse	r31, r1
    2e60:	f8 cf       	rjmp	.-16     	; 0x2e52 <__floatsisf+0x1c>
    2e62:	fa f4       	brpl	.+62     	; 0x2ea2 <__floatsisf+0x6c>
    2e64:	bb 0f       	add	r27, r27
    2e66:	11 f4       	brne	.+4      	; 0x2e6c <__floatsisf+0x36>
    2e68:	60 ff       	sbrs	r22, 0
    2e6a:	1b c0       	rjmp	.+54     	; 0x2ea2 <__floatsisf+0x6c>
    2e6c:	6f 5f       	subi	r22, 0xFF	; 255
    2e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e70:	8f 4f       	sbci	r24, 0xFF	; 255
    2e72:	9f 4f       	sbci	r25, 0xFF	; 255
    2e74:	16 c0       	rjmp	.+44     	; 0x2ea2 <__floatsisf+0x6c>
    2e76:	88 23       	and	r24, r24
    2e78:	11 f0       	breq	.+4      	; 0x2e7e <__floatsisf+0x48>
    2e7a:	96 e9       	ldi	r25, 0x96	; 150
    2e7c:	11 c0       	rjmp	.+34     	; 0x2ea0 <__floatsisf+0x6a>
    2e7e:	77 23       	and	r23, r23
    2e80:	21 f0       	breq	.+8      	; 0x2e8a <__floatsisf+0x54>
    2e82:	9e e8       	ldi	r25, 0x8E	; 142
    2e84:	87 2f       	mov	r24, r23
    2e86:	76 2f       	mov	r23, r22
    2e88:	05 c0       	rjmp	.+10     	; 0x2e94 <__floatsisf+0x5e>
    2e8a:	66 23       	and	r22, r22
    2e8c:	71 f0       	breq	.+28     	; 0x2eaa <__floatsisf+0x74>
    2e8e:	96 e8       	ldi	r25, 0x86	; 134
    2e90:	86 2f       	mov	r24, r22
    2e92:	70 e0       	ldi	r23, 0x00	; 0
    2e94:	60 e0       	ldi	r22, 0x00	; 0
    2e96:	2a f0       	brmi	.+10     	; 0x2ea2 <__floatsisf+0x6c>
    2e98:	9a 95       	dec	r25
    2e9a:	66 0f       	add	r22, r22
    2e9c:	77 1f       	adc	r23, r23
    2e9e:	88 1f       	adc	r24, r24
    2ea0:	da f7       	brpl	.-10     	; 0x2e98 <__floatsisf+0x62>
    2ea2:	88 0f       	add	r24, r24
    2ea4:	96 95       	lsr	r25
    2ea6:	87 95       	ror	r24
    2ea8:	97 f9       	bld	r25, 7
    2eaa:	08 95       	ret

00002eac <__fp_cmp>:
    2eac:	99 0f       	add	r25, r25
    2eae:	00 08       	sbc	r0, r0
    2eb0:	55 0f       	add	r21, r21
    2eb2:	aa 0b       	sbc	r26, r26
    2eb4:	e0 e8       	ldi	r30, 0x80	; 128
    2eb6:	fe ef       	ldi	r31, 0xFE	; 254
    2eb8:	16 16       	cp	r1, r22
    2eba:	17 06       	cpc	r1, r23
    2ebc:	e8 07       	cpc	r30, r24
    2ebe:	f9 07       	cpc	r31, r25
    2ec0:	c0 f0       	brcs	.+48     	; 0x2ef2 <__fp_cmp+0x46>
    2ec2:	12 16       	cp	r1, r18
    2ec4:	13 06       	cpc	r1, r19
    2ec6:	e4 07       	cpc	r30, r20
    2ec8:	f5 07       	cpc	r31, r21
    2eca:	98 f0       	brcs	.+38     	; 0x2ef2 <__fp_cmp+0x46>
    2ecc:	62 1b       	sub	r22, r18
    2ece:	73 0b       	sbc	r23, r19
    2ed0:	84 0b       	sbc	r24, r20
    2ed2:	95 0b       	sbc	r25, r21
    2ed4:	39 f4       	brne	.+14     	; 0x2ee4 <__fp_cmp+0x38>
    2ed6:	0a 26       	eor	r0, r26
    2ed8:	61 f0       	breq	.+24     	; 0x2ef2 <__fp_cmp+0x46>
    2eda:	23 2b       	or	r18, r19
    2edc:	24 2b       	or	r18, r20
    2ede:	25 2b       	or	r18, r21
    2ee0:	21 f4       	brne	.+8      	; 0x2eea <__fp_cmp+0x3e>
    2ee2:	08 95       	ret
    2ee4:	0a 26       	eor	r0, r26
    2ee6:	09 f4       	brne	.+2      	; 0x2eea <__fp_cmp+0x3e>
    2ee8:	a1 40       	sbci	r26, 0x01	; 1
    2eea:	a6 95       	lsr	r26
    2eec:	8f ef       	ldi	r24, 0xFF	; 255
    2eee:	81 1d       	adc	r24, r1
    2ef0:	81 1d       	adc	r24, r1
    2ef2:	08 95       	ret

00002ef4 <__fp_inf>:
    2ef4:	97 f9       	bld	r25, 7
    2ef6:	9f 67       	ori	r25, 0x7F	; 127
    2ef8:	80 e8       	ldi	r24, 0x80	; 128
    2efa:	70 e0       	ldi	r23, 0x00	; 0
    2efc:	60 e0       	ldi	r22, 0x00	; 0
    2efe:	08 95       	ret

00002f00 <__fp_nan>:
    2f00:	9f ef       	ldi	r25, 0xFF	; 255
    2f02:	80 ec       	ldi	r24, 0xC0	; 192
    2f04:	08 95       	ret

00002f06 <__fp_powser>:
    2f06:	df 93       	push	r29
    2f08:	cf 93       	push	r28
    2f0a:	1f 93       	push	r17
    2f0c:	0f 93       	push	r16
    2f0e:	ff 92       	push	r15
    2f10:	ef 92       	push	r14
    2f12:	df 92       	push	r13
    2f14:	7b 01       	movw	r14, r22
    2f16:	8c 01       	movw	r16, r24
    2f18:	68 94       	set
    2f1a:	05 c0       	rjmp	.+10     	; 0x2f26 <__fp_powser+0x20>
    2f1c:	da 2e       	mov	r13, r26
    2f1e:	ef 01       	movw	r28, r30
    2f20:	72 d0       	rcall	.+228    	; 0x3006 <__mulsf3x>
    2f22:	fe 01       	movw	r30, r28
    2f24:	e8 94       	clt
    2f26:	a5 91       	lpm	r26, Z+
    2f28:	25 91       	lpm	r18, Z+
    2f2a:	35 91       	lpm	r19, Z+
    2f2c:	45 91       	lpm	r20, Z+
    2f2e:	55 91       	lpm	r21, Z+
    2f30:	ae f3       	brts	.-22     	; 0x2f1c <__fp_powser+0x16>
    2f32:	ef 01       	movw	r28, r30
    2f34:	2c de       	rcall	.-936    	; 0x2b8e <__addsf3x>
    2f36:	fe 01       	movw	r30, r28
    2f38:	97 01       	movw	r18, r14
    2f3a:	a8 01       	movw	r20, r16
    2f3c:	da 94       	dec	r13
    2f3e:	79 f7       	brne	.-34     	; 0x2f1e <__fp_powser+0x18>
    2f40:	df 90       	pop	r13
    2f42:	ef 90       	pop	r14
    2f44:	ff 90       	pop	r15
    2f46:	0f 91       	pop	r16
    2f48:	1f 91       	pop	r17
    2f4a:	cf 91       	pop	r28
    2f4c:	df 91       	pop	r29
    2f4e:	08 95       	ret

00002f50 <__fp_pscA>:
    2f50:	00 24       	eor	r0, r0
    2f52:	0a 94       	dec	r0
    2f54:	16 16       	cp	r1, r22
    2f56:	17 06       	cpc	r1, r23
    2f58:	18 06       	cpc	r1, r24
    2f5a:	09 06       	cpc	r0, r25
    2f5c:	08 95       	ret

00002f5e <__fp_pscB>:
    2f5e:	00 24       	eor	r0, r0
    2f60:	0a 94       	dec	r0
    2f62:	12 16       	cp	r1, r18
    2f64:	13 06       	cpc	r1, r19
    2f66:	14 06       	cpc	r1, r20
    2f68:	05 06       	cpc	r0, r21
    2f6a:	08 95       	ret

00002f6c <__fp_round>:
    2f6c:	09 2e       	mov	r0, r25
    2f6e:	03 94       	inc	r0
    2f70:	00 0c       	add	r0, r0
    2f72:	11 f4       	brne	.+4      	; 0x2f78 <__fp_round+0xc>
    2f74:	88 23       	and	r24, r24
    2f76:	52 f0       	brmi	.+20     	; 0x2f8c <__fp_round+0x20>
    2f78:	bb 0f       	add	r27, r27
    2f7a:	40 f4       	brcc	.+16     	; 0x2f8c <__fp_round+0x20>
    2f7c:	bf 2b       	or	r27, r31
    2f7e:	11 f4       	brne	.+4      	; 0x2f84 <__fp_round+0x18>
    2f80:	60 ff       	sbrs	r22, 0
    2f82:	04 c0       	rjmp	.+8      	; 0x2f8c <__fp_round+0x20>
    2f84:	6f 5f       	subi	r22, 0xFF	; 255
    2f86:	7f 4f       	sbci	r23, 0xFF	; 255
    2f88:	8f 4f       	sbci	r24, 0xFF	; 255
    2f8a:	9f 4f       	sbci	r25, 0xFF	; 255
    2f8c:	08 95       	ret

00002f8e <__fp_split3>:
    2f8e:	57 fd       	sbrc	r21, 7
    2f90:	90 58       	subi	r25, 0x80	; 128
    2f92:	44 0f       	add	r20, r20
    2f94:	55 1f       	adc	r21, r21
    2f96:	59 f0       	breq	.+22     	; 0x2fae <__fp_splitA+0x10>
    2f98:	5f 3f       	cpi	r21, 0xFF	; 255
    2f9a:	71 f0       	breq	.+28     	; 0x2fb8 <__fp_splitA+0x1a>
    2f9c:	47 95       	ror	r20

00002f9e <__fp_splitA>:
    2f9e:	88 0f       	add	r24, r24
    2fa0:	97 fb       	bst	r25, 7
    2fa2:	99 1f       	adc	r25, r25
    2fa4:	61 f0       	breq	.+24     	; 0x2fbe <__fp_splitA+0x20>
    2fa6:	9f 3f       	cpi	r25, 0xFF	; 255
    2fa8:	79 f0       	breq	.+30     	; 0x2fc8 <__fp_splitA+0x2a>
    2faa:	87 95       	ror	r24
    2fac:	08 95       	ret
    2fae:	12 16       	cp	r1, r18
    2fb0:	13 06       	cpc	r1, r19
    2fb2:	14 06       	cpc	r1, r20
    2fb4:	55 1f       	adc	r21, r21
    2fb6:	f2 cf       	rjmp	.-28     	; 0x2f9c <__fp_split3+0xe>
    2fb8:	46 95       	lsr	r20
    2fba:	f1 df       	rcall	.-30     	; 0x2f9e <__fp_splitA>
    2fbc:	08 c0       	rjmp	.+16     	; 0x2fce <__fp_splitA+0x30>
    2fbe:	16 16       	cp	r1, r22
    2fc0:	17 06       	cpc	r1, r23
    2fc2:	18 06       	cpc	r1, r24
    2fc4:	99 1f       	adc	r25, r25
    2fc6:	f1 cf       	rjmp	.-30     	; 0x2faa <__fp_splitA+0xc>
    2fc8:	86 95       	lsr	r24
    2fca:	71 05       	cpc	r23, r1
    2fcc:	61 05       	cpc	r22, r1
    2fce:	08 94       	sec
    2fd0:	08 95       	ret

00002fd2 <__fp_zero>:
    2fd2:	e8 94       	clt

00002fd4 <__fp_szero>:
    2fd4:	bb 27       	eor	r27, r27
    2fd6:	66 27       	eor	r22, r22
    2fd8:	77 27       	eor	r23, r23
    2fda:	cb 01       	movw	r24, r22
    2fdc:	97 f9       	bld	r25, 7
    2fde:	08 95       	ret

00002fe0 <inverse>:
    2fe0:	9b 01       	movw	r18, r22
    2fe2:	ac 01       	movw	r20, r24
    2fe4:	60 e0       	ldi	r22, 0x00	; 0
    2fe6:	70 e0       	ldi	r23, 0x00	; 0
    2fe8:	80 e8       	ldi	r24, 0x80	; 128
    2fea:	9f e3       	ldi	r25, 0x3F	; 63
    2fec:	89 ce       	rjmp	.-750    	; 0x2d00 <__divsf3>

00002fee <__mulsf3>:
    2fee:	0b d0       	rcall	.+22     	; 0x3006 <__mulsf3x>
    2ff0:	bd cf       	rjmp	.-134    	; 0x2f6c <__fp_round>
    2ff2:	ae df       	rcall	.-164    	; 0x2f50 <__fp_pscA>
    2ff4:	28 f0       	brcs	.+10     	; 0x3000 <__mulsf3+0x12>
    2ff6:	b3 df       	rcall	.-154    	; 0x2f5e <__fp_pscB>
    2ff8:	18 f0       	brcs	.+6      	; 0x3000 <__mulsf3+0x12>
    2ffa:	95 23       	and	r25, r21
    2ffc:	09 f0       	breq	.+2      	; 0x3000 <__mulsf3+0x12>
    2ffe:	7a cf       	rjmp	.-268    	; 0x2ef4 <__fp_inf>
    3000:	7f cf       	rjmp	.-258    	; 0x2f00 <__fp_nan>
    3002:	11 24       	eor	r1, r1
    3004:	e7 cf       	rjmp	.-50     	; 0x2fd4 <__fp_szero>

00003006 <__mulsf3x>:
    3006:	c3 df       	rcall	.-122    	; 0x2f8e <__fp_split3>
    3008:	a0 f3       	brcs	.-24     	; 0x2ff2 <__mulsf3+0x4>

0000300a <__mulsf3_pse>:
    300a:	95 9f       	mul	r25, r21
    300c:	d1 f3       	breq	.-12     	; 0x3002 <__mulsf3+0x14>
    300e:	95 0f       	add	r25, r21
    3010:	50 e0       	ldi	r21, 0x00	; 0
    3012:	55 1f       	adc	r21, r21
    3014:	62 9f       	mul	r22, r18
    3016:	f0 01       	movw	r30, r0
    3018:	72 9f       	mul	r23, r18
    301a:	bb 27       	eor	r27, r27
    301c:	f0 0d       	add	r31, r0
    301e:	b1 1d       	adc	r27, r1
    3020:	63 9f       	mul	r22, r19
    3022:	aa 27       	eor	r26, r26
    3024:	f0 0d       	add	r31, r0
    3026:	b1 1d       	adc	r27, r1
    3028:	aa 1f       	adc	r26, r26
    302a:	64 9f       	mul	r22, r20
    302c:	66 27       	eor	r22, r22
    302e:	b0 0d       	add	r27, r0
    3030:	a1 1d       	adc	r26, r1
    3032:	66 1f       	adc	r22, r22
    3034:	82 9f       	mul	r24, r18
    3036:	22 27       	eor	r18, r18
    3038:	b0 0d       	add	r27, r0
    303a:	a1 1d       	adc	r26, r1
    303c:	62 1f       	adc	r22, r18
    303e:	73 9f       	mul	r23, r19
    3040:	b0 0d       	add	r27, r0
    3042:	a1 1d       	adc	r26, r1
    3044:	62 1f       	adc	r22, r18
    3046:	83 9f       	mul	r24, r19
    3048:	a0 0d       	add	r26, r0
    304a:	61 1d       	adc	r22, r1
    304c:	22 1f       	adc	r18, r18
    304e:	74 9f       	mul	r23, r20
    3050:	33 27       	eor	r19, r19
    3052:	a0 0d       	add	r26, r0
    3054:	61 1d       	adc	r22, r1
    3056:	23 1f       	adc	r18, r19
    3058:	84 9f       	mul	r24, r20
    305a:	60 0d       	add	r22, r0
    305c:	21 1d       	adc	r18, r1
    305e:	82 2f       	mov	r24, r18
    3060:	76 2f       	mov	r23, r22
    3062:	6a 2f       	mov	r22, r26
    3064:	11 24       	eor	r1, r1
    3066:	9f 57       	subi	r25, 0x7F	; 127
    3068:	50 40       	sbci	r21, 0x00	; 0
    306a:	8a f0       	brmi	.+34     	; 0x308e <__mulsf3_pse+0x84>
    306c:	e1 f0       	breq	.+56     	; 0x30a6 <__mulsf3_pse+0x9c>
    306e:	88 23       	and	r24, r24
    3070:	4a f0       	brmi	.+18     	; 0x3084 <__mulsf3_pse+0x7a>
    3072:	ee 0f       	add	r30, r30
    3074:	ff 1f       	adc	r31, r31
    3076:	bb 1f       	adc	r27, r27
    3078:	66 1f       	adc	r22, r22
    307a:	77 1f       	adc	r23, r23
    307c:	88 1f       	adc	r24, r24
    307e:	91 50       	subi	r25, 0x01	; 1
    3080:	50 40       	sbci	r21, 0x00	; 0
    3082:	a9 f7       	brne	.-22     	; 0x306e <__mulsf3_pse+0x64>
    3084:	9e 3f       	cpi	r25, 0xFE	; 254
    3086:	51 05       	cpc	r21, r1
    3088:	70 f0       	brcs	.+28     	; 0x30a6 <__mulsf3_pse+0x9c>
    308a:	34 cf       	rjmp	.-408    	; 0x2ef4 <__fp_inf>
    308c:	a3 cf       	rjmp	.-186    	; 0x2fd4 <__fp_szero>
    308e:	5f 3f       	cpi	r21, 0xFF	; 255
    3090:	ec f3       	brlt	.-6      	; 0x308c <__mulsf3_pse+0x82>
    3092:	98 3e       	cpi	r25, 0xE8	; 232
    3094:	dc f3       	brlt	.-10     	; 0x308c <__mulsf3_pse+0x82>
    3096:	86 95       	lsr	r24
    3098:	77 95       	ror	r23
    309a:	67 95       	ror	r22
    309c:	b7 95       	ror	r27
    309e:	f7 95       	ror	r31
    30a0:	e7 95       	ror	r30
    30a2:	9f 5f       	subi	r25, 0xFF	; 255
    30a4:	c1 f7       	brne	.-16     	; 0x3096 <__mulsf3_pse+0x8c>
    30a6:	fe 2b       	or	r31, r30
    30a8:	88 0f       	add	r24, r24
    30aa:	91 1d       	adc	r25, r1
    30ac:	96 95       	lsr	r25
    30ae:	87 95       	ror	r24
    30b0:	97 f9       	bld	r25, 7
    30b2:	08 95       	ret
    30b4:	11 f4       	brne	.+4      	; 0x30ba <__mulsf3_pse+0xb0>
    30b6:	0e f4       	brtc	.+2      	; 0x30ba <__mulsf3_pse+0xb0>
    30b8:	23 cf       	rjmp	.-442    	; 0x2f00 <__fp_nan>
    30ba:	41 c0       	rjmp	.+130    	; 0x313e <__fp_mpack>

000030bc <sqrt>:
    30bc:	70 df       	rcall	.-288    	; 0x2f9e <__fp_splitA>
    30be:	d0 f3       	brcs	.-12     	; 0x30b4 <__mulsf3_pse+0xaa>
    30c0:	99 23       	and	r25, r25
    30c2:	d9 f3       	breq	.-10     	; 0x30ba <__mulsf3_pse+0xb0>
    30c4:	ce f3       	brts	.-14     	; 0x30b8 <__mulsf3_pse+0xae>
    30c6:	9f 57       	subi	r25, 0x7F	; 127
    30c8:	55 0b       	sbc	r21, r21
    30ca:	87 ff       	sbrs	r24, 7
    30cc:	46 d0       	rcall	.+140    	; 0x315a <__fp_norm2>
    30ce:	00 24       	eor	r0, r0
    30d0:	a0 e6       	ldi	r26, 0x60	; 96
    30d2:	40 ea       	ldi	r20, 0xA0	; 160
    30d4:	90 01       	movw	r18, r0
    30d6:	80 58       	subi	r24, 0x80	; 128
    30d8:	56 95       	lsr	r21
    30da:	97 95       	ror	r25
    30dc:	28 f4       	brcc	.+10     	; 0x30e8 <sqrt+0x2c>
    30de:	80 5c       	subi	r24, 0xC0	; 192
    30e0:	66 0f       	add	r22, r22
    30e2:	77 1f       	adc	r23, r23
    30e4:	88 1f       	adc	r24, r24
    30e6:	20 f0       	brcs	.+8      	; 0x30f0 <sqrt+0x34>
    30e8:	26 17       	cp	r18, r22
    30ea:	37 07       	cpc	r19, r23
    30ec:	48 07       	cpc	r20, r24
    30ee:	30 f4       	brcc	.+12     	; 0x30fc <sqrt+0x40>
    30f0:	62 1b       	sub	r22, r18
    30f2:	73 0b       	sbc	r23, r19
    30f4:	84 0b       	sbc	r24, r20
    30f6:	20 29       	or	r18, r0
    30f8:	31 29       	or	r19, r1
    30fa:	4a 2b       	or	r20, r26
    30fc:	a6 95       	lsr	r26
    30fe:	17 94       	ror	r1
    3100:	07 94       	ror	r0
    3102:	20 25       	eor	r18, r0
    3104:	31 25       	eor	r19, r1
    3106:	4a 27       	eor	r20, r26
    3108:	58 f7       	brcc	.-42     	; 0x30e0 <sqrt+0x24>
    310a:	66 0f       	add	r22, r22
    310c:	77 1f       	adc	r23, r23
    310e:	88 1f       	adc	r24, r24
    3110:	20 f0       	brcs	.+8      	; 0x311a <sqrt+0x5e>
    3112:	26 17       	cp	r18, r22
    3114:	37 07       	cpc	r19, r23
    3116:	48 07       	cpc	r20, r24
    3118:	30 f4       	brcc	.+12     	; 0x3126 <sqrt+0x6a>
    311a:	62 0b       	sbc	r22, r18
    311c:	73 0b       	sbc	r23, r19
    311e:	84 0b       	sbc	r24, r20
    3120:	20 0d       	add	r18, r0
    3122:	31 1d       	adc	r19, r1
    3124:	41 1d       	adc	r20, r1
    3126:	a0 95       	com	r26
    3128:	81 f7       	brne	.-32     	; 0x310a <sqrt+0x4e>
    312a:	b9 01       	movw	r22, r18
    312c:	84 2f       	mov	r24, r20
    312e:	91 58       	subi	r25, 0x81	; 129
    3130:	88 0f       	add	r24, r24
    3132:	96 95       	lsr	r25
    3134:	87 95       	ror	r24
    3136:	08 95       	ret

00003138 <square>:
    3138:	9b 01       	movw	r18, r22
    313a:	ac 01       	movw	r20, r24
    313c:	58 cf       	rjmp	.-336    	; 0x2fee <__mulsf3>

0000313e <__fp_mpack>:
    313e:	9f 3f       	cpi	r25, 0xFF	; 255
    3140:	31 f0       	breq	.+12     	; 0x314e <__fp_mpack_finite+0xc>

00003142 <__fp_mpack_finite>:
    3142:	91 50       	subi	r25, 0x01	; 1
    3144:	20 f4       	brcc	.+8      	; 0x314e <__fp_mpack_finite+0xc>
    3146:	87 95       	ror	r24
    3148:	77 95       	ror	r23
    314a:	67 95       	ror	r22
    314c:	b7 95       	ror	r27
    314e:	88 0f       	add	r24, r24
    3150:	91 1d       	adc	r25, r1
    3152:	96 95       	lsr	r25
    3154:	87 95       	ror	r24
    3156:	97 f9       	bld	r25, 7
    3158:	08 95       	ret

0000315a <__fp_norm2>:
    315a:	91 50       	subi	r25, 0x01	; 1
    315c:	50 40       	sbci	r21, 0x00	; 0
    315e:	66 0f       	add	r22, r22
    3160:	77 1f       	adc	r23, r23
    3162:	88 1f       	adc	r24, r24
    3164:	d2 f7       	brpl	.-12     	; 0x315a <__fp_norm2>
    3166:	08 95       	ret

00003168 <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    3168:	fc 01       	movw	r30, r24
    316a:	81 8d       	ldd	r24, Z+25	; 0x19
    316c:	22 8d       	ldd	r18, Z+26	; 0x1a
    316e:	90 e0       	ldi	r25, 0x00	; 0
    3170:	80 5c       	subi	r24, 0xC0	; 192
    3172:	9f 4f       	sbci	r25, 0xFF	; 255
    3174:	82 1b       	sub	r24, r18
    3176:	91 09       	sbc	r25, r1
    3178:	8f 73       	andi	r24, 0x3F	; 63
    317a:	99 27       	eor	r25, r25
    317c:	08 95       	ret

0000317e <_ZN14HardwareSerial4peekEv>:
    317e:	fc 01       	movw	r30, r24
    3180:	91 8d       	ldd	r25, Z+25	; 0x19
    3182:	82 8d       	ldd	r24, Z+26	; 0x1a
    3184:	98 17       	cp	r25, r24
    3186:	31 f0       	breq	.+12     	; 0x3194 <_ZN14HardwareSerial4peekEv+0x16>
    3188:	82 8d       	ldd	r24, Z+26	; 0x1a
    318a:	e8 0f       	add	r30, r24
    318c:	f1 1d       	adc	r31, r1
    318e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3190:	90 e0       	ldi	r25, 0x00	; 0
    3192:	08 95       	ret
    3194:	8f ef       	ldi	r24, 0xFF	; 255
    3196:	9f ef       	ldi	r25, 0xFF	; 255
    3198:	08 95       	ret

0000319a <_ZN14HardwareSerial4readEv>:
    319a:	fc 01       	movw	r30, r24
    319c:	91 8d       	ldd	r25, Z+25	; 0x19
    319e:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a0:	98 17       	cp	r25, r24
    31a2:	61 f0       	breq	.+24     	; 0x31bc <_ZN14HardwareSerial4readEv+0x22>
    31a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a6:	df 01       	movw	r26, r30
    31a8:	a8 0f       	add	r26, r24
    31aa:	b1 1d       	adc	r27, r1
    31ac:	5d 96       	adiw	r26, 0x1d	; 29
    31ae:	8c 91       	ld	r24, X
    31b0:	92 8d       	ldd	r25, Z+26	; 0x1a
    31b2:	9f 5f       	subi	r25, 0xFF	; 255
    31b4:	9f 73       	andi	r25, 0x3F	; 63
    31b6:	92 8f       	std	Z+26, r25	; 0x1a
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	08 95       	ret
    31bc:	8f ef       	ldi	r24, 0xFF	; 255
    31be:	9f ef       	ldi	r25, 0xFF	; 255
    31c0:	08 95       	ret

000031c2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    31c2:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    31c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    31c6:	df 01       	movw	r26, r30
    31c8:	a8 0f       	add	r26, r24
    31ca:	b1 1d       	adc	r27, r1
    31cc:	a3 5a       	subi	r26, 0xA3	; 163
    31ce:	bf 4f       	sbci	r27, 0xFF	; 255
    31d0:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    31d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    31d4:	90 e0       	ldi	r25, 0x00	; 0
    31d6:	01 96       	adiw	r24, 0x01	; 1
    31d8:	8f 73       	andi	r24, 0x3F	; 63
    31da:	90 78       	andi	r25, 0x80	; 128
    31dc:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    31de:	a6 89       	ldd	r26, Z+22	; 0x16
    31e0:	b7 89       	ldd	r27, Z+23	; 0x17
    31e2:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    31e4:	a0 89       	ldd	r26, Z+16	; 0x10
    31e6:	b1 89       	ldd	r27, Z+17	; 0x11
    31e8:	8c 91       	ld	r24, X
    31ea:	80 64       	ori	r24, 0x40	; 64
    31ec:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    31ee:	93 8d       	ldd	r25, Z+27	; 0x1b
    31f0:	84 8d       	ldd	r24, Z+28	; 0x1c
    31f2:	98 13       	cpse	r25, r24
    31f4:	06 c0       	rjmp	.+12     	; 0x3202 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    31f6:	02 88       	ldd	r0, Z+18	; 0x12
    31f8:	f3 89       	ldd	r31, Z+19	; 0x13
    31fa:	e0 2d       	mov	r30, r0
    31fc:	80 81       	ld	r24, Z
    31fe:	8f 7d       	andi	r24, 0xDF	; 223
    3200:	80 83       	st	Z, r24
    3202:	08 95       	ret

00003204 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    3204:	cf 93       	push	r28
    3206:	df 93       	push	r29
    3208:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    320a:	88 8d       	ldd	r24, Y+24	; 0x18
    320c:	81 11       	cpse	r24, r1
    320e:	0a c0       	rjmp	.+20     	; 0x3224 <_ZN14HardwareSerial5flushEv+0x20>
    3210:	1a c0       	rjmp	.+52     	; 0x3246 <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    3212:	0f b6       	in	r0, 0x3f	; 63
    3214:	07 fc       	sbrc	r0, 7
    3216:	08 c0       	rjmp	.+16     	; 0x3228 <_ZN14HardwareSerial5flushEv+0x24>
    3218:	80 81       	ld	r24, Z
    321a:	85 ff       	sbrs	r24, 5
    321c:	05 c0       	rjmp	.+10     	; 0x3228 <_ZN14HardwareSerial5flushEv+0x24>
    321e:	0d c0       	rjmp	.+26     	; 0x323a <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    3220:	ce 01       	movw	r24, r28
    3222:	cf df       	rcall	.-98     	; 0x31c2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    3224:	ea 89       	ldd	r30, Y+18	; 0x12
    3226:	fb 89       	ldd	r31, Y+19	; 0x13
    3228:	80 81       	ld	r24, Z
    322a:	85 fd       	sbrc	r24, 5
    322c:	f2 cf       	rjmp	.-28     	; 0x3212 <_ZN14HardwareSerial5flushEv+0xe>
    322e:	a8 89       	ldd	r26, Y+16	; 0x10
    3230:	b9 89       	ldd	r27, Y+17	; 0x11
    3232:	8c 91       	ld	r24, X
    3234:	86 ff       	sbrs	r24, 6
    3236:	ed cf       	rjmp	.-38     	; 0x3212 <_ZN14HardwareSerial5flushEv+0xe>
    3238:	06 c0       	rjmp	.+12     	; 0x3246 <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    323a:	a8 89       	ldd	r26, Y+16	; 0x10
    323c:	b9 89       	ldd	r27, Y+17	; 0x11
    323e:	8c 91       	ld	r24, X
    3240:	85 ff       	sbrs	r24, 5
    3242:	f2 cf       	rjmp	.-28     	; 0x3228 <_ZN14HardwareSerial5flushEv+0x24>
    3244:	ed cf       	rjmp	.-38     	; 0x3220 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    3246:	df 91       	pop	r29
    3248:	cf 91       	pop	r28
    324a:	08 95       	ret

0000324c <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    324c:	0f 93       	push	r16
    324e:	1f 93       	push	r17
    3250:	cf 93       	push	r28
    3252:	df 93       	push	r29
    3254:	ec 01       	movw	r28, r24
    3256:	16 2f       	mov	r17, r22
  _written = true;
    3258:	81 e0       	ldi	r24, 0x01	; 1
    325a:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    325c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    325e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3260:	98 13       	cpse	r25, r24
    3262:	21 c0       	rjmp	.+66     	; 0x32a6 <_ZN14HardwareSerial5writeEh+0x5a>
    3264:	e8 89       	ldd	r30, Y+16	; 0x10
    3266:	f9 89       	ldd	r31, Y+17	; 0x11
    3268:	80 81       	ld	r24, Z
    326a:	85 fd       	sbrc	r24, 5
    326c:	23 c0       	rjmp	.+70     	; 0x32b4 <_ZN14HardwareSerial5writeEh+0x68>
    326e:	1b c0       	rjmp	.+54     	; 0x32a6 <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    3270:	0f b6       	in	r0, 0x3f	; 63
    3272:	07 fc       	sbrc	r0, 7
    3274:	07 c0       	rjmp	.+14     	; 0x3284 <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    3276:	e8 89       	ldd	r30, Y+16	; 0x10
    3278:	f9 89       	ldd	r31, Y+17	; 0x11
    327a:	80 81       	ld	r24, Z
    327c:	85 ff       	sbrs	r24, 5
    327e:	02 c0       	rjmp	.+4      	; 0x3284 <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    3280:	ce 01       	movw	r24, r28
    3282:	9f df       	rcall	.-194    	; 0x31c2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3284:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3286:	09 17       	cp	r16, r25
    3288:	99 f3       	breq	.-26     	; 0x3270 <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    328a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    328c:	fe 01       	movw	r30, r28
    328e:	e8 0f       	add	r30, r24
    3290:	f1 1d       	adc	r31, r1
    3292:	e3 5a       	subi	r30, 0xA3	; 163
    3294:	ff 4f       	sbci	r31, 0xFF	; 255
    3296:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    3298:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    329a:	ea 89       	ldd	r30, Y+18	; 0x12
    329c:	fb 89       	ldd	r31, Y+19	; 0x13
    329e:	80 81       	ld	r24, Z
    32a0:	80 62       	ori	r24, 0x20	; 32
    32a2:	80 83       	st	Z, r24
  
  return 1;
    32a4:	0f c0       	rjmp	.+30     	; 0x32c4 <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    32a6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    32a8:	90 e0       	ldi	r25, 0x00	; 0
    32aa:	01 96       	adiw	r24, 0x01	; 1
    32ac:	8f 73       	andi	r24, 0x3F	; 63
    32ae:	90 78       	andi	r25, 0x80	; 128
    32b0:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    32b2:	e8 cf       	rjmp	.-48     	; 0x3284 <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    32b4:	ee 89       	ldd	r30, Y+22	; 0x16
    32b6:	ff 89       	ldd	r31, Y+23	; 0x17
    32b8:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    32ba:	e8 89       	ldd	r30, Y+16	; 0x10
    32bc:	f9 89       	ldd	r31, Y+17	; 0x11
    32be:	80 81       	ld	r24, Z
    32c0:	80 64       	ori	r24, 0x40	; 64
    32c2:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    32c4:	81 e0       	ldi	r24, 0x01	; 1
    32c6:	90 e0       	ldi	r25, 0x00	; 0
    32c8:	df 91       	pop	r29
    32ca:	cf 91       	pop	r28
    32cc:	1f 91       	pop	r17
    32ce:	0f 91       	pop	r16
    32d0:	08 95       	ret

000032d2 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    32d2:	cf 92       	push	r12
    32d4:	df 92       	push	r13
    32d6:	ef 92       	push	r14
    32d8:	ff 92       	push	r15
    32da:	1f 93       	push	r17
    32dc:	cf 93       	push	r28
    32de:	df 93       	push	r29
    32e0:	ec 01       	movw	r28, r24
    32e2:	6a 01       	movw	r12, r20
    32e4:	7b 01       	movw	r14, r22
    32e6:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    32e8:	e8 89       	ldd	r30, Y+16	; 0x10
    32ea:	f9 89       	ldd	r31, Y+17	; 0x11
    32ec:	82 e0       	ldi	r24, 0x02	; 2
    32ee:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    32f0:	41 15       	cp	r20, r1
    32f2:	81 ee       	ldi	r24, 0xE1	; 225
    32f4:	58 07       	cpc	r21, r24
    32f6:	61 05       	cpc	r22, r1
    32f8:	71 05       	cpc	r23, r1
    32fa:	a9 f0       	breq	.+42     	; 0x3326 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    32fc:	60 e0       	ldi	r22, 0x00	; 0
    32fe:	79 e0       	ldi	r23, 0x09	; 9
    3300:	8d e3       	ldi	r24, 0x3D	; 61
    3302:	90 e0       	ldi	r25, 0x00	; 0
    3304:	a7 01       	movw	r20, r14
    3306:	96 01       	movw	r18, r12
    3308:	ce d3       	rcall	.+1948   	; 0x3aa6 <__udivmodsi4>
    330a:	ba 01       	movw	r22, r20
    330c:	a9 01       	movw	r20, r18
    330e:	41 50       	subi	r20, 0x01	; 1
    3310:	51 09       	sbc	r21, r1
    3312:	61 09       	sbc	r22, r1
    3314:	71 09       	sbc	r23, r1
    3316:	76 95       	lsr	r23
    3318:	67 95       	ror	r22
    331a:	57 95       	ror	r21
    331c:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    331e:	41 15       	cp	r20, r1
    3320:	80 e1       	ldi	r24, 0x10	; 16
    3322:	58 07       	cpc	r21, r24
    3324:	a0 f0       	brcs	.+40     	; 0x334e <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    3326:	e8 89       	ldd	r30, Y+16	; 0x10
    3328:	f9 89       	ldd	r31, Y+17	; 0x11
    332a:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    332c:	60 e8       	ldi	r22, 0x80	; 128
    332e:	74 e8       	ldi	r23, 0x84	; 132
    3330:	8e e1       	ldi	r24, 0x1E	; 30
    3332:	90 e0       	ldi	r25, 0x00	; 0
    3334:	a7 01       	movw	r20, r14
    3336:	96 01       	movw	r18, r12
    3338:	b6 d3       	rcall	.+1900   	; 0x3aa6 <__udivmodsi4>
    333a:	ba 01       	movw	r22, r20
    333c:	a9 01       	movw	r20, r18
    333e:	41 50       	subi	r20, 0x01	; 1
    3340:	51 09       	sbc	r21, r1
    3342:	61 09       	sbc	r22, r1
    3344:	71 09       	sbc	r23, r1
    3346:	76 95       	lsr	r23
    3348:	67 95       	ror	r22
    334a:	57 95       	ror	r21
    334c:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    334e:	ec 85       	ldd	r30, Y+12	; 0x0c
    3350:	fd 85       	ldd	r31, Y+13	; 0x0d
    3352:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    3354:	ee 85       	ldd	r30, Y+14	; 0x0e
    3356:	ff 85       	ldd	r31, Y+15	; 0x0f
    3358:	40 83       	st	Z, r20

  _written = false;
    335a:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    335c:	ec 89       	ldd	r30, Y+20	; 0x14
    335e:	fd 89       	ldd	r31, Y+21	; 0x15
    3360:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    3362:	ea 89       	ldd	r30, Y+18	; 0x12
    3364:	fb 89       	ldd	r31, Y+19	; 0x13
    3366:	80 81       	ld	r24, Z
    3368:	80 61       	ori	r24, 0x10	; 16
    336a:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    336c:	ea 89       	ldd	r30, Y+18	; 0x12
    336e:	fb 89       	ldd	r31, Y+19	; 0x13
    3370:	80 81       	ld	r24, Z
    3372:	88 60       	ori	r24, 0x08	; 8
    3374:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    3376:	ea 89       	ldd	r30, Y+18	; 0x12
    3378:	fb 89       	ldd	r31, Y+19	; 0x13
    337a:	80 81       	ld	r24, Z
    337c:	80 68       	ori	r24, 0x80	; 128
    337e:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    3380:	ea 89       	ldd	r30, Y+18	; 0x12
    3382:	fb 89       	ldd	r31, Y+19	; 0x13
    3384:	80 81       	ld	r24, Z
    3386:	8f 7d       	andi	r24, 0xDF	; 223
    3388:	80 83       	st	Z, r24
}
    338a:	df 91       	pop	r29
    338c:	cf 91       	pop	r28
    338e:	1f 91       	pop	r17
    3390:	ff 90       	pop	r15
    3392:	ef 90       	pop	r14
    3394:	df 90       	pop	r13
    3396:	cf 90       	pop	r12
    3398:	08 95       	ret

0000339a <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    339a:	1f 92       	push	r1
    339c:	0f 92       	push	r0
    339e:	0f b6       	in	r0, 0x3f	; 63
    33a0:	0f 92       	push	r0
    33a2:	11 24       	eor	r1, r1
    33a4:	0b b6       	in	r0, 0x3b	; 59
    33a6:	0f 92       	push	r0
    33a8:	2f 93       	push	r18
    33aa:	8f 93       	push	r24
    33ac:	9f 93       	push	r25
    33ae:	af 93       	push	r26
    33b0:	bf 93       	push	r27
    33b2:	ef 93       	push	r30
    33b4:	ff 93       	push	r31
    33b6:	e0 91 f7 09 	lds	r30, 0x09F7
    33ba:	f0 91 f8 09 	lds	r31, 0x09F8
    33be:	80 81       	ld	r24, Z
    33c0:	82 fd       	sbrc	r24, 2
    33c2:	17 c0       	rjmp	.+46     	; 0x33f2 <__vector_25+0x58>
    33c4:	e0 91 fd 09 	lds	r30, 0x09FD
    33c8:	f0 91 fe 09 	lds	r31, 0x09FE
    33cc:	20 81       	ld	r18, Z
    33ce:	80 91 00 0a 	lds	r24, 0x0A00
    33d2:	8f 5f       	subi	r24, 0xFF	; 255
    33d4:	8f 73       	andi	r24, 0x3F	; 63
    33d6:	90 91 01 0a 	lds	r25, 0x0A01
    33da:	89 17       	cp	r24, r25
    33dc:	79 f0       	breq	.+30     	; 0x33fc <__vector_25+0x62>
    33de:	e0 e0       	ldi	r30, 0x00	; 0
    33e0:	fa e0       	ldi	r31, 0x0A	; 10
    33e2:	a0 81       	ld	r26, Z
    33e4:	b0 e0       	ldi	r27, 0x00	; 0
    33e6:	a9 51       	subi	r26, 0x19	; 25
    33e8:	b6 4f       	sbci	r27, 0xF6	; 246
    33ea:	5d 96       	adiw	r26, 0x1d	; 29
    33ec:	2c 93       	st	X, r18
    33ee:	80 83       	st	Z, r24
    33f0:	05 c0       	rjmp	.+10     	; 0x33fc <__vector_25+0x62>
    33f2:	e0 91 fd 09 	lds	r30, 0x09FD
    33f6:	f0 91 fe 09 	lds	r31, 0x09FE
    33fa:	80 81       	ld	r24, Z
    33fc:	ff 91       	pop	r31
    33fe:	ef 91       	pop	r30
    3400:	bf 91       	pop	r27
    3402:	af 91       	pop	r26
    3404:	9f 91       	pop	r25
    3406:	8f 91       	pop	r24
    3408:	2f 91       	pop	r18
    340a:	0f 90       	pop	r0
    340c:	0b be       	out	0x3b, r0	; 59
    340e:	0f 90       	pop	r0
    3410:	0f be       	out	0x3f, r0	; 63
    3412:	0f 90       	pop	r0
    3414:	1f 90       	pop	r1
    3416:	18 95       	reti

00003418 <__vector_26>:
    3418:	1f 92       	push	r1
    341a:	0f 92       	push	r0
    341c:	0f b6       	in	r0, 0x3f	; 63
    341e:	0f 92       	push	r0
    3420:	11 24       	eor	r1, r1
    3422:	0b b6       	in	r0, 0x3b	; 59
    3424:	0f 92       	push	r0
    3426:	2f 93       	push	r18
    3428:	3f 93       	push	r19
    342a:	4f 93       	push	r20
    342c:	5f 93       	push	r21
    342e:	6f 93       	push	r22
    3430:	7f 93       	push	r23
    3432:	8f 93       	push	r24
    3434:	9f 93       	push	r25
    3436:	af 93       	push	r26
    3438:	bf 93       	push	r27
    343a:	ef 93       	push	r30
    343c:	ff 93       	push	r31
    343e:	87 ee       	ldi	r24, 0xE7	; 231
    3440:	99 e0       	ldi	r25, 0x09	; 9
    3442:	bf de       	rcall	.-642    	; 0x31c2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3444:	ff 91       	pop	r31
    3446:	ef 91       	pop	r30
    3448:	bf 91       	pop	r27
    344a:	af 91       	pop	r26
    344c:	9f 91       	pop	r25
    344e:	8f 91       	pop	r24
    3450:	7f 91       	pop	r23
    3452:	6f 91       	pop	r22
    3454:	5f 91       	pop	r21
    3456:	4f 91       	pop	r20
    3458:	3f 91       	pop	r19
    345a:	2f 91       	pop	r18
    345c:	0f 90       	pop	r0
    345e:	0b be       	out	0x3b, r0	; 59
    3460:	0f 90       	pop	r0
    3462:	0f be       	out	0x3f, r0	; 63
    3464:	0f 90       	pop	r0
    3466:	1f 90       	pop	r1
    3468:	18 95       	reti

0000346a <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    346a:	10 92 ea 09 	sts	0x09EA, r1
    346e:	10 92 e9 09 	sts	0x09E9, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    3472:	88 ee       	ldi	r24, 0xE8	; 232
    3474:	93 e0       	ldi	r25, 0x03	; 3
    3476:	a0 e0       	ldi	r26, 0x00	; 0
    3478:	b0 e0       	ldi	r27, 0x00	; 0
    347a:	80 93 eb 09 	sts	0x09EB, r24
    347e:	90 93 ec 09 	sts	0x09EC, r25
    3482:	a0 93 ed 09 	sts	0x09ED, r26
    3486:	b0 93 ee 09 	sts	0x09EE, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    348a:	8a e8       	ldi	r24, 0x8A	; 138
    348c:	92 e0       	ldi	r25, 0x02	; 2
    348e:	90 93 e8 09 	sts	0x09E8, r25
    3492:	80 93 e7 09 	sts	0x09E7, r24
    3496:	85 ec       	ldi	r24, 0xC5	; 197
    3498:	90 e0       	ldi	r25, 0x00	; 0
    349a:	90 93 f4 09 	sts	0x09F4, r25
    349e:	80 93 f3 09 	sts	0x09F3, r24
    34a2:	84 ec       	ldi	r24, 0xC4	; 196
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	90 93 f6 09 	sts	0x09F6, r25
    34aa:	80 93 f5 09 	sts	0x09F5, r24
    34ae:	80 ec       	ldi	r24, 0xC0	; 192
    34b0:	90 e0       	ldi	r25, 0x00	; 0
    34b2:	90 93 f8 09 	sts	0x09F8, r25
    34b6:	80 93 f7 09 	sts	0x09F7, r24
    34ba:	81 ec       	ldi	r24, 0xC1	; 193
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	90 93 fa 09 	sts	0x09FA, r25
    34c2:	80 93 f9 09 	sts	0x09F9, r24
    34c6:	82 ec       	ldi	r24, 0xC2	; 194
    34c8:	90 e0       	ldi	r25, 0x00	; 0
    34ca:	90 93 fc 09 	sts	0x09FC, r25
    34ce:	80 93 fb 09 	sts	0x09FB, r24
    34d2:	86 ec       	ldi	r24, 0xC6	; 198
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	90 93 fe 09 	sts	0x09FE, r25
    34da:	80 93 fd 09 	sts	0x09FD, r24
    34de:	10 92 00 0a 	sts	0x0A00, r1
    34e2:	10 92 01 0a 	sts	0x0A01, r1
    34e6:	10 92 02 0a 	sts	0x0A02, r1
    34ea:	10 92 03 0a 	sts	0x0A03, r1
    34ee:	08 95       	ret

000034f0 <_ZN5Print5writeEPKhj>:
size_t Print::println(const Printable& x)
{
  size_t n = print(x);
  n += println();
  return n;
}
    34f0:	cf 92       	push	r12
    34f2:	df 92       	push	r13
    34f4:	ef 92       	push	r14
    34f6:	ff 92       	push	r15
    34f8:	0f 93       	push	r16
    34fa:	1f 93       	push	r17
    34fc:	cf 93       	push	r28
    34fe:	df 93       	push	r29
    3500:	6c 01       	movw	r12, r24
    3502:	41 15       	cp	r20, r1
    3504:	51 05       	cpc	r21, r1
    3506:	b1 f0       	breq	.+44     	; 0x3534 <_ZN5Print5writeEPKhj+0x44>
    3508:	06 2f       	mov	r16, r22
    350a:	17 2f       	mov	r17, r23
    350c:	ea 01       	movw	r28, r20
    350e:	e1 2c       	mov	r14, r1
    3510:	f1 2c       	mov	r15, r1
    3512:	d8 01       	movw	r26, r16
    3514:	6d 91       	ld	r22, X+
    3516:	8d 01       	movw	r16, r26
    3518:	d6 01       	movw	r26, r12
    351a:	ed 91       	ld	r30, X+
    351c:	fc 91       	ld	r31, X
    351e:	01 90       	ld	r0, Z+
    3520:	f0 81       	ld	r31, Z
    3522:	e0 2d       	mov	r30, r0
    3524:	c6 01       	movw	r24, r12
    3526:	19 95       	eicall
    3528:	e8 0e       	add	r14, r24
    352a:	f9 1e       	adc	r15, r25
    352c:	21 97       	sbiw	r28, 0x01	; 1
    352e:	20 97       	sbiw	r28, 0x00	; 0
    3530:	81 f7       	brne	.-32     	; 0x3512 <_ZN5Print5writeEPKhj+0x22>
    3532:	02 c0       	rjmp	.+4      	; 0x3538 <_ZN5Print5writeEPKhj+0x48>
    3534:	e1 2c       	mov	r14, r1
    3536:	f1 2c       	mov	r15, r1
    3538:	c7 01       	movw	r24, r14
    353a:	df 91       	pop	r29
    353c:	cf 91       	pop	r28
    353e:	1f 91       	pop	r17
    3540:	0f 91       	pop	r16
    3542:	ff 90       	pop	r15
    3544:	ef 90       	pop	r14
    3546:	df 90       	pop	r13
    3548:	cf 90       	pop	r12
    354a:	08 95       	ret

0000354c <_ZN5Print5printEc>:
    354c:	dc 01       	movw	r26, r24
    354e:	ed 91       	ld	r30, X+
    3550:	fc 91       	ld	r31, X
    3552:	01 90       	ld	r0, Z+
    3554:	f0 81       	ld	r31, Z
    3556:	e0 2d       	mov	r30, r0
    3558:	19 95       	eicall
    355a:	08 95       	ret

0000355c <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
    355c:	6f 92       	push	r6
    355e:	7f 92       	push	r7
    3560:	8f 92       	push	r8
    3562:	9f 92       	push	r9
    3564:	af 92       	push	r10
    3566:	bf 92       	push	r11
    3568:	cf 92       	push	r12
    356a:	df 92       	push	r13
    356c:	ef 92       	push	r14
    356e:	ff 92       	push	r15
    3570:	0f 93       	push	r16
    3572:	1f 93       	push	r17
    3574:	cf 93       	push	r28
    3576:	df 93       	push	r29
    3578:	cd b7       	in	r28, 0x3d	; 61
    357a:	de b7       	in	r29, 0x3e	; 62
    357c:	a1 97       	sbiw	r28, 0x21	; 33
    357e:	0f b6       	in	r0, 0x3f	; 63
    3580:	f8 94       	cli
    3582:	de bf       	out	0x3e, r29	; 62
    3584:	0f be       	out	0x3f, r0	; 63
    3586:	cd bf       	out	0x3d, r28	; 61
    3588:	6c 01       	movw	r12, r24
    358a:	74 2e       	mov	r7, r20
    358c:	35 2f       	mov	r19, r21
    358e:	86 2f       	mov	r24, r22
    3590:	97 2f       	mov	r25, r23
    3592:	62 2e       	mov	r6, r18
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    3594:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    3596:	21 e0       	ldi	r18, 0x01	; 1
    3598:	26 15       	cp	r18, r6
    359a:	20 f0       	brcs	.+8      	; 0x35a4 <_ZN5Print11printNumberEmh+0x48>
    359c:	0f 2e       	mov	r0, r31
    359e:	fa e0       	ldi	r31, 0x0A	; 10
    35a0:	6f 2e       	mov	r6, r31
    35a2:	f0 2d       	mov	r31, r0
    35a4:	7e 01       	movw	r14, r28
    35a6:	a1 e2       	ldi	r26, 0x21	; 33
    35a8:	ea 0e       	add	r14, r26
    35aa:	f1 1c       	adc	r15, r1

  do {
    unsigned long m = n;
    n /= base;
    35ac:	86 2c       	mov	r8, r6
    35ae:	91 2c       	mov	r9, r1
    35b0:	a1 2c       	mov	r10, r1
    35b2:	b1 2c       	mov	r11, r1
    35b4:	67 2d       	mov	r22, r7
    35b6:	73 2f       	mov	r23, r19
    35b8:	a5 01       	movw	r20, r10
    35ba:	94 01       	movw	r18, r8
    35bc:	74 d2       	rcall	.+1256   	; 0x3aa6 <__udivmodsi4>
    35be:	e2 2f       	mov	r30, r18
    35c0:	73 2f       	mov	r23, r19
    35c2:	02 2f       	mov	r16, r18
    35c4:	13 2f       	mov	r17, r19
    35c6:	24 2f       	mov	r18, r20
    35c8:	35 2f       	mov	r19, r21
    char c = m - base * n;
    35ca:	f7 2d       	mov	r31, r7
    35cc:	6e 9e       	mul	r6, r30
    35ce:	f0 19       	sub	r31, r0
    35d0:	11 24       	eor	r1, r1
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    35d2:	b1 e0       	ldi	r27, 0x01	; 1
    35d4:	eb 1a       	sub	r14, r27
    35d6:	f1 08       	sbc	r15, r1
    35d8:	fa 30       	cpi	r31, 0x0A	; 10
    35da:	10 f4       	brcc	.+4      	; 0x35e0 <_ZN5Print11printNumberEmh+0x84>
    35dc:	f0 5d       	subi	r31, 0xD0	; 208
    35de:	01 c0       	rjmp	.+2      	; 0x35e2 <_ZN5Print11printNumberEmh+0x86>
    35e0:	f9 5c       	subi	r31, 0xC9	; 201
    35e2:	d7 01       	movw	r26, r14
    35e4:	fc 93       	st	X, r31
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    35e6:	01 2b       	or	r16, r17
    35e8:	02 2b       	or	r16, r18
    35ea:	03 2b       	or	r16, r19
    35ec:	29 f0       	breq	.+10     	; 0x35f8 <_ZN5Print11printNumberEmh+0x9c>
    unsigned long m = n;
    n /= base;
    35ee:	7e 2e       	mov	r7, r30
    35f0:	37 2f       	mov	r19, r23
    35f2:	84 2f       	mov	r24, r20
    35f4:	95 2f       	mov	r25, r21
    35f6:	de cf       	rjmp	.-68     	; 0x35b4 <_ZN5Print11printNumberEmh+0x58>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    35f8:	e1 14       	cp	r14, r1
    35fa:	f1 04       	cpc	r15, r1
    35fc:	91 f0       	breq	.+36     	; 0x3622 <_ZN5Print11printNumberEmh+0xc6>
      return write((const uint8_t *)str, strlen(str));
    35fe:	f7 01       	movw	r30, r14
    3600:	01 90       	ld	r0, Z+
    3602:	00 20       	and	r0, r0
    3604:	e9 f7       	brne	.-6      	; 0x3600 <_ZN5Print11printNumberEmh+0xa4>
    3606:	31 97       	sbiw	r30, 0x01	; 1
    3608:	af 01       	movw	r20, r30
    360a:	4e 19       	sub	r20, r14
    360c:	5f 09       	sbc	r21, r15
    360e:	d6 01       	movw	r26, r12
    3610:	ed 91       	ld	r30, X+
    3612:	fc 91       	ld	r31, X
    3614:	02 80       	ldd	r0, Z+2	; 0x02
    3616:	f3 81       	ldd	r31, Z+3	; 0x03
    3618:	e0 2d       	mov	r30, r0
    361a:	b7 01       	movw	r22, r14
    361c:	c6 01       	movw	r24, r12
    361e:	19 95       	eicall
    3620:	02 c0       	rjmp	.+4      	; 0x3626 <_ZN5Print11printNumberEmh+0xca>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    3622:	80 e0       	ldi	r24, 0x00	; 0
    3624:	90 e0       	ldi	r25, 0x00	; 0
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
}
    3626:	a1 96       	adiw	r28, 0x21	; 33
    3628:	0f b6       	in	r0, 0x3f	; 63
    362a:	f8 94       	cli
    362c:	de bf       	out	0x3e, r29	; 62
    362e:	0f be       	out	0x3f, r0	; 63
    3630:	cd bf       	out	0x3d, r28	; 61
    3632:	df 91       	pop	r29
    3634:	cf 91       	pop	r28
    3636:	1f 91       	pop	r17
    3638:	0f 91       	pop	r16
    363a:	ff 90       	pop	r15
    363c:	ef 90       	pop	r14
    363e:	df 90       	pop	r13
    3640:	cf 90       	pop	r12
    3642:	bf 90       	pop	r11
    3644:	af 90       	pop	r10
    3646:	9f 90       	pop	r9
    3648:	8f 90       	pop	r8
    364a:	7f 90       	pop	r7
    364c:	6f 90       	pop	r6
    364e:	08 95       	ret

00003650 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    3650:	cf 92       	push	r12
    3652:	df 92       	push	r13
    3654:	ef 92       	push	r14
    3656:	ff 92       	push	r15
    3658:	0f 93       	push	r16
    365a:	1f 93       	push	r17
    365c:	cf 93       	push	r28
    365e:	df 93       	push	r29
    3660:	ec 01       	movw	r28, r24
    3662:	6a 01       	movw	r12, r20
    3664:	7b 01       	movw	r14, r22
  if (base == 0) {
    3666:	21 15       	cp	r18, r1
    3668:	31 05       	cpc	r19, r1
    366a:	41 f4       	brne	.+16     	; 0x367c <_ZN5Print5printEli+0x2c>
    return write(n);
    366c:	e8 81       	ld	r30, Y
    366e:	f9 81       	ldd	r31, Y+1	; 0x01
    3670:	01 90       	ld	r0, Z+
    3672:	f0 81       	ld	r31, Z
    3674:	e0 2d       	mov	r30, r0
    3676:	64 2f       	mov	r22, r20
    3678:	19 95       	eicall
    367a:	19 c0       	rjmp	.+50     	; 0x36ae <_ZN5Print5printEli+0x5e>
  } else if (base == 10) {
    367c:	2a 30       	cpi	r18, 0x0A	; 10
    367e:	31 05       	cpc	r19, r1
    3680:	a9 f4       	brne	.+42     	; 0x36ac <_ZN5Print5printEli+0x5c>
    if (n < 0) {
    3682:	77 23       	and	r23, r23
    3684:	84 f4       	brge	.+32     	; 0x36a6 <_ZN5Print5printEli+0x56>
      int t = print('-');
    3686:	6d e2       	ldi	r22, 0x2D	; 45
    3688:	61 df       	rcall	.-318    	; 0x354c <_ZN5Print5printEc>
    368a:	8c 01       	movw	r16, r24
      n = -n;
    368c:	44 27       	eor	r20, r20
    368e:	55 27       	eor	r21, r21
    3690:	ba 01       	movw	r22, r20
    3692:	4c 19       	sub	r20, r12
    3694:	5d 09       	sbc	r21, r13
    3696:	6e 09       	sbc	r22, r14
    3698:	7f 09       	sbc	r23, r15
      return printNumber(n, 10) + t;
    369a:	2a e0       	ldi	r18, 0x0A	; 10
    369c:	ce 01       	movw	r24, r28
    369e:	5e df       	rcall	.-324    	; 0x355c <_ZN5Print11printNumberEmh>
    36a0:	80 0f       	add	r24, r16
    36a2:	91 1f       	adc	r25, r17
    36a4:	04 c0       	rjmp	.+8      	; 0x36ae <_ZN5Print5printEli+0x5e>
    }
    return printNumber(n, 10);
    36a6:	2a e0       	ldi	r18, 0x0A	; 10
    36a8:	59 df       	rcall	.-334    	; 0x355c <_ZN5Print11printNumberEmh>
    36aa:	01 c0       	rjmp	.+2      	; 0x36ae <_ZN5Print5printEli+0x5e>
  } else {
    return printNumber(n, base);
    36ac:	57 df       	rcall	.-338    	; 0x355c <_ZN5Print11printNumberEmh>
  }
}
    36ae:	df 91       	pop	r29
    36b0:	cf 91       	pop	r28
    36b2:	1f 91       	pop	r17
    36b4:	0f 91       	pop	r16
    36b6:	ff 90       	pop	r15
    36b8:	ef 90       	pop	r14
    36ba:	df 90       	pop	r13
    36bc:	cf 90       	pop	r12
    36be:	08 95       	ret

000036c0 <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    36c0:	9a 01       	movw	r18, r20
  return print((long) n, base);
    36c2:	ab 01       	movw	r20, r22
    36c4:	66 27       	eor	r22, r22
    36c6:	57 fd       	sbrc	r21, 7
    36c8:	60 95       	com	r22
    36ca:	76 2f       	mov	r23, r22
    36cc:	c1 cf       	rjmp	.-126    	; 0x3650 <_ZN5Print5printEli>
}
    36ce:	08 95       	ret

000036d0 <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    36d0:	1f 92       	push	r1
    36d2:	0f 92       	push	r0
    36d4:	0f b6       	in	r0, 0x3f	; 63
    36d6:	0f 92       	push	r0
    36d8:	11 24       	eor	r1, r1
    36da:	2f 93       	push	r18
    36dc:	3f 93       	push	r19
    36de:	8f 93       	push	r24
    36e0:	9f 93       	push	r25
    36e2:	af 93       	push	r26
    36e4:	bf 93       	push	r27
    36e6:	80 91 85 0a 	lds	r24, 0x0A85
    36ea:	90 91 86 0a 	lds	r25, 0x0A86
    36ee:	a0 91 87 0a 	lds	r26, 0x0A87
    36f2:	b0 91 88 0a 	lds	r27, 0x0A88
    36f6:	30 91 84 0a 	lds	r19, 0x0A84
    36fa:	23 e0       	ldi	r18, 0x03	; 3
    36fc:	23 0f       	add	r18, r19
    36fe:	2d 37       	cpi	r18, 0x7D	; 125
    3700:	20 f4       	brcc	.+8      	; 0x370a <__vector_23+0x3a>
    3702:	01 96       	adiw	r24, 0x01	; 1
    3704:	a1 1d       	adc	r26, r1
    3706:	b1 1d       	adc	r27, r1
    3708:	05 c0       	rjmp	.+10     	; 0x3714 <__vector_23+0x44>
    370a:	26 e8       	ldi	r18, 0x86	; 134
    370c:	23 0f       	add	r18, r19
    370e:	02 96       	adiw	r24, 0x02	; 2
    3710:	a1 1d       	adc	r26, r1
    3712:	b1 1d       	adc	r27, r1
    3714:	20 93 84 0a 	sts	0x0A84, r18
    3718:	80 93 85 0a 	sts	0x0A85, r24
    371c:	90 93 86 0a 	sts	0x0A86, r25
    3720:	a0 93 87 0a 	sts	0x0A87, r26
    3724:	b0 93 88 0a 	sts	0x0A88, r27
    3728:	80 91 89 0a 	lds	r24, 0x0A89
    372c:	90 91 8a 0a 	lds	r25, 0x0A8A
    3730:	a0 91 8b 0a 	lds	r26, 0x0A8B
    3734:	b0 91 8c 0a 	lds	r27, 0x0A8C
    3738:	01 96       	adiw	r24, 0x01	; 1
    373a:	a1 1d       	adc	r26, r1
    373c:	b1 1d       	adc	r27, r1
    373e:	80 93 89 0a 	sts	0x0A89, r24
    3742:	90 93 8a 0a 	sts	0x0A8A, r25
    3746:	a0 93 8b 0a 	sts	0x0A8B, r26
    374a:	b0 93 8c 0a 	sts	0x0A8C, r27
    374e:	bf 91       	pop	r27
    3750:	af 91       	pop	r26
    3752:	9f 91       	pop	r25
    3754:	8f 91       	pop	r24
    3756:	3f 91       	pop	r19
    3758:	2f 91       	pop	r18
    375a:	0f 90       	pop	r0
    375c:	0f be       	out	0x3f, r0	; 63
    375e:	0f 90       	pop	r0
    3760:	1f 90       	pop	r1
    3762:	18 95       	reti

00003764 <millis>:
    3764:	2f b7       	in	r18, 0x3f	; 63
    3766:	f8 94       	cli
    3768:	60 91 85 0a 	lds	r22, 0x0A85
    376c:	70 91 86 0a 	lds	r23, 0x0A86
    3770:	80 91 87 0a 	lds	r24, 0x0A87
    3774:	90 91 88 0a 	lds	r25, 0x0A88
    3778:	2f bf       	out	0x3f, r18	; 63
    377a:	08 95       	ret

0000377c <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    377c:	82 30       	cpi	r24, 0x02	; 2
    377e:	91 05       	cpc	r25, r1
    3780:	38 f0       	brcs	.+14     	; 0x3790 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    3782:	88 0f       	add	r24, r24
    3784:	99 1f       	adc	r25, r25
    3786:	88 0f       	add	r24, r24
    3788:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    378a:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    378c:	01 97       	sbiw	r24, 0x01	; 1
    378e:	f1 f7       	brne	.-4      	; 0x378c <delayMicroseconds+0x10>
    3790:	08 95       	ret

00003792 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    3792:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    3794:	84 b5       	in	r24, 0x24	; 36
    3796:	82 60       	ori	r24, 0x02	; 2
    3798:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    379a:	84 b5       	in	r24, 0x24	; 36
    379c:	81 60       	ori	r24, 0x01	; 1
    379e:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    37a0:	85 b5       	in	r24, 0x25	; 37
    37a2:	82 60       	ori	r24, 0x02	; 2
    37a4:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    37a6:	85 b5       	in	r24, 0x25	; 37
    37a8:	81 60       	ori	r24, 0x01	; 1
    37aa:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    37ac:	ee e6       	ldi	r30, 0x6E	; 110
    37ae:	f0 e0       	ldi	r31, 0x00	; 0
    37b0:	80 81       	ld	r24, Z
    37b2:	81 60       	ori	r24, 0x01	; 1
    37b4:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    37b6:	e1 e8       	ldi	r30, 0x81	; 129
    37b8:	f0 e0       	ldi	r31, 0x00	; 0
    37ba:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    37bc:	80 81       	ld	r24, Z
    37be:	82 60       	ori	r24, 0x02	; 2
    37c0:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    37c2:	80 81       	ld	r24, Z
    37c4:	81 60       	ori	r24, 0x01	; 1
    37c6:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    37c8:	e0 e8       	ldi	r30, 0x80	; 128
    37ca:	f0 e0       	ldi	r31, 0x00	; 0
    37cc:	80 81       	ld	r24, Z
    37ce:	81 60       	ori	r24, 0x01	; 1
    37d0:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    37d2:	e1 eb       	ldi	r30, 0xB1	; 177
    37d4:	f0 e0       	ldi	r31, 0x00	; 0
    37d6:	80 81       	ld	r24, Z
    37d8:	84 60       	ori	r24, 0x04	; 4
    37da:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    37dc:	e0 eb       	ldi	r30, 0xB0	; 176
    37de:	f0 e0       	ldi	r31, 0x00	; 0
    37e0:	80 81       	ld	r24, Z
    37e2:	81 60       	ori	r24, 0x01	; 1
    37e4:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    37e6:	e1 e9       	ldi	r30, 0x91	; 145
    37e8:	f0 e0       	ldi	r31, 0x00	; 0
    37ea:	80 81       	ld	r24, Z
    37ec:	82 60       	ori	r24, 0x02	; 2
    37ee:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    37f0:	80 81       	ld	r24, Z
    37f2:	81 60       	ori	r24, 0x01	; 1
    37f4:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    37f6:	e0 e9       	ldi	r30, 0x90	; 144
    37f8:	f0 e0       	ldi	r31, 0x00	; 0
    37fa:	80 81       	ld	r24, Z
    37fc:	81 60       	ori	r24, 0x01	; 1
    37fe:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    3800:	e1 ea       	ldi	r30, 0xA1	; 161
    3802:	f0 e0       	ldi	r31, 0x00	; 0
    3804:	80 81       	ld	r24, Z
    3806:	82 60       	ori	r24, 0x02	; 2
    3808:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    380a:	80 81       	ld	r24, Z
    380c:	81 60       	ori	r24, 0x01	; 1
    380e:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    3810:	e0 ea       	ldi	r30, 0xA0	; 160
    3812:	f0 e0       	ldi	r31, 0x00	; 0
    3814:	80 81       	ld	r24, Z
    3816:	81 60       	ori	r24, 0x01	; 1
    3818:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    381a:	e1 e2       	ldi	r30, 0x21	; 33
    381c:	f1 e0       	ldi	r31, 0x01	; 1
    381e:	80 81       	ld	r24, Z
    3820:	82 60       	ori	r24, 0x02	; 2
    3822:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    3824:	80 81       	ld	r24, Z
    3826:	81 60       	ori	r24, 0x01	; 1
    3828:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    382a:	e0 e2       	ldi	r30, 0x20	; 32
    382c:	f1 e0       	ldi	r31, 0x01	; 1
    382e:	80 81       	ld	r24, Z
    3830:	81 60       	ori	r24, 0x01	; 1
    3832:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    3834:	ea e7       	ldi	r30, 0x7A	; 122
    3836:	f0 e0       	ldi	r31, 0x00	; 0
    3838:	80 81       	ld	r24, Z
    383a:	84 60       	ori	r24, 0x04	; 4
    383c:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    383e:	80 81       	ld	r24, Z
    3840:	82 60       	ori	r24, 0x02	; 2
    3842:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    3844:	80 81       	ld	r24, Z
    3846:	81 60       	ori	r24, 0x01	; 1
    3848:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    384a:	80 81       	ld	r24, Z
    384c:	80 68       	ori	r24, 0x80	; 128
    384e:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    3850:	10 92 c1 00 	sts	0x00C1, r1
    3854:	08 95       	ret

00003856 <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
    3856:	80 93 12 02 	sts	0x0212, r24
    385a:	08 95       	ret

0000385c <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	fc 01       	movw	r30, r24
    3860:	31 97       	sbiw	r30, 0x01	; 1
    3862:	e2 31       	cpi	r30, 0x12	; 18
    3864:	f1 05       	cpc	r31, r1
    3866:	08 f0       	brcs	.+2      	; 0x386a <turnOffPWM+0xe>
    3868:	5e c0       	rjmp	.+188    	; 0x3926 <turnOffPWM+0xca>
    386a:	ee 5a       	subi	r30, 0xAE	; 174
    386c:	fe 4f       	sbci	r31, 0xFE	; 254
    386e:	3d c1       	rjmp	.+634    	; 0x3aea <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    3870:	e0 e8       	ldi	r30, 0x80	; 128
    3872:	f0 e0       	ldi	r31, 0x00	; 0
    3874:	80 81       	ld	r24, Z
    3876:	8f 77       	andi	r24, 0x7F	; 127
    3878:	80 83       	st	Z, r24
    387a:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    387c:	e0 e8       	ldi	r30, 0x80	; 128
    387e:	f0 e0       	ldi	r31, 0x00	; 0
    3880:	80 81       	ld	r24, Z
    3882:	8f 7d       	andi	r24, 0xDF	; 223
    3884:	80 83       	st	Z, r24
    3886:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    3888:	e0 e8       	ldi	r30, 0x80	; 128
    388a:	f0 e0       	ldi	r31, 0x00	; 0
    388c:	80 81       	ld	r24, Z
    388e:	87 7f       	andi	r24, 0xF7	; 247
    3890:	80 83       	st	Z, r24
    3892:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    3894:	84 b5       	in	r24, 0x24	; 36
    3896:	8f 77       	andi	r24, 0x7F	; 127
    3898:	84 bd       	out	0x24, r24	; 36
    389a:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    389c:	84 b5       	in	r24, 0x24	; 36
    389e:	8f 7d       	andi	r24, 0xDF	; 223
    38a0:	84 bd       	out	0x24, r24	; 36
    38a2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    38a4:	e0 eb       	ldi	r30, 0xB0	; 176
    38a6:	f0 e0       	ldi	r31, 0x00	; 0
    38a8:	80 81       	ld	r24, Z
    38aa:	8f 77       	andi	r24, 0x7F	; 127
    38ac:	80 83       	st	Z, r24
    38ae:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    38b0:	e0 eb       	ldi	r30, 0xB0	; 176
    38b2:	f0 e0       	ldi	r31, 0x00	; 0
    38b4:	80 81       	ld	r24, Z
    38b6:	8f 7d       	andi	r24, 0xDF	; 223
    38b8:	80 83       	st	Z, r24
    38ba:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    38bc:	e0 e9       	ldi	r30, 0x90	; 144
    38be:	f0 e0       	ldi	r31, 0x00	; 0
    38c0:	80 81       	ld	r24, Z
    38c2:	8f 77       	andi	r24, 0x7F	; 127
    38c4:	80 83       	st	Z, r24
    38c6:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    38c8:	e0 e9       	ldi	r30, 0x90	; 144
    38ca:	f0 e0       	ldi	r31, 0x00	; 0
    38cc:	80 81       	ld	r24, Z
    38ce:	8f 7d       	andi	r24, 0xDF	; 223
    38d0:	80 83       	st	Z, r24
    38d2:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    38d4:	e0 e9       	ldi	r30, 0x90	; 144
    38d6:	f0 e0       	ldi	r31, 0x00	; 0
    38d8:	80 81       	ld	r24, Z
    38da:	87 7f       	andi	r24, 0xF7	; 247
    38dc:	80 83       	st	Z, r24
    38de:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    38e0:	e0 ea       	ldi	r30, 0xA0	; 160
    38e2:	f0 e0       	ldi	r31, 0x00	; 0
    38e4:	80 81       	ld	r24, Z
    38e6:	8f 77       	andi	r24, 0x7F	; 127
    38e8:	80 83       	st	Z, r24
    38ea:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    38ec:	e0 ea       	ldi	r30, 0xA0	; 160
    38ee:	f0 e0       	ldi	r31, 0x00	; 0
    38f0:	80 81       	ld	r24, Z
    38f2:	8f 7d       	andi	r24, 0xDF	; 223
    38f4:	80 83       	st	Z, r24
    38f6:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    38f8:	e0 ea       	ldi	r30, 0xA0	; 160
    38fa:	f0 e0       	ldi	r31, 0x00	; 0
    38fc:	80 81       	ld	r24, Z
    38fe:	87 7f       	andi	r24, 0xF7	; 247
    3900:	80 83       	st	Z, r24
    3902:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3904:	e0 e2       	ldi	r30, 0x20	; 32
    3906:	f1 e0       	ldi	r31, 0x01	; 1
    3908:	80 81       	ld	r24, Z
    390a:	8f 77       	andi	r24, 0x7F	; 127
    390c:	80 83       	st	Z, r24
    390e:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    3910:	e0 e2       	ldi	r30, 0x20	; 32
    3912:	f1 e0       	ldi	r31, 0x01	; 1
    3914:	80 81       	ld	r24, Z
    3916:	8f 7d       	andi	r24, 0xDF	; 223
    3918:	80 83       	st	Z, r24
    391a:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    391c:	e0 e2       	ldi	r30, 0x20	; 32
    391e:	f1 e0       	ldi	r31, 0x01	; 1
    3920:	80 81       	ld	r24, Z
    3922:	87 7f       	andi	r24, 0xF7	; 247
    3924:	80 83       	st	Z, r24
    3926:	08 95       	ret

00003928 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    3928:	cf 93       	push	r28
    392a:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	fc 01       	movw	r30, r24
    3930:	e2 5f       	subi	r30, 0xF2	; 242
    3932:	fc 4f       	sbci	r31, 0xFC	; 252
    3934:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    3936:	fc 01       	movw	r30, r24
    3938:	ec 5a       	subi	r30, 0xAC	; 172
    393a:	fc 4f       	sbci	r31, 0xFC	; 252
    393c:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    393e:	88 23       	and	r24, r24
    3940:	71 f1       	breq	.+92     	; 0x399e <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3942:	90 e0       	ldi	r25, 0x00	; 0
    3944:	88 0f       	add	r24, r24
    3946:	99 1f       	adc	r25, r25
    3948:	fc 01       	movw	r30, r24
    394a:	e2 53       	subi	r30, 0x32	; 50
    394c:	fc 4f       	sbci	r31, 0xFC	; 252
    394e:	a5 91       	lpm	r26, Z+
    3950:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    3952:	8c 54       	subi	r24, 0x4C	; 76
    3954:	9c 4f       	sbci	r25, 0xFC	; 252
    3956:	fc 01       	movw	r30, r24
    3958:	c5 91       	lpm	r28, Z+
    395a:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    395c:	61 11       	cpse	r22, r1
    395e:	0b c0       	rjmp	.+22     	; 0x3976 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    3960:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3962:	f8 94       	cli
		*reg &= ~bit;
    3964:	9c 91       	ld	r25, X
    3966:	20 95       	com	r18
    3968:	92 23       	and	r25, r18
    396a:	9c 93       	st	X, r25
		*out &= ~bit;
    396c:	e8 81       	ld	r30, Y
    396e:	2e 23       	and	r18, r30
    3970:	28 83       	st	Y, r18
		SREG = oldSREG;
    3972:	8f bf       	out	0x3f, r24	; 63
    3974:	14 c0       	rjmp	.+40     	; 0x399e <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    3976:	62 30       	cpi	r22, 0x02	; 2
    3978:	61 f4       	brne	.+24     	; 0x3992 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    397a:	8f b7       	in	r24, 0x3f	; 63
                cli();
    397c:	f8 94       	cli
		*reg &= ~bit;
    397e:	3c 91       	ld	r19, X
    3980:	92 2f       	mov	r25, r18
    3982:	90 95       	com	r25
    3984:	93 23       	and	r25, r19
    3986:	9c 93       	st	X, r25
		*out |= bit;
    3988:	e8 81       	ld	r30, Y
    398a:	2e 2b       	or	r18, r30
    398c:	28 83       	st	Y, r18
		SREG = oldSREG;
    398e:	8f bf       	out	0x3f, r24	; 63
    3990:	06 c0       	rjmp	.+12     	; 0x399e <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    3992:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3994:	f8 94       	cli
		*reg |= bit;
    3996:	ec 91       	ld	r30, X
    3998:	2e 2b       	or	r18, r30
    399a:	2c 93       	st	X, r18
		SREG = oldSREG;
    399c:	8f bf       	out	0x3f, r24	; 63
	}
}
    399e:	df 91       	pop	r29
    39a0:	cf 91       	pop	r28
    39a2:	08 95       	ret

000039a4 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    39a4:	1f 93       	push	r17
    39a6:	cf 93       	push	r28
    39a8:	df 93       	push	r29
    39aa:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    39ac:	28 2f       	mov	r18, r24
    39ae:	30 e0       	ldi	r19, 0x00	; 0
    39b0:	f9 01       	movw	r30, r18
    39b2:	e8 53       	subi	r30, 0x38	; 56
    39b4:	fd 4f       	sbci	r31, 0xFD	; 253
    39b6:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    39b8:	f9 01       	movw	r30, r18
    39ba:	e2 5f       	subi	r30, 0xF2	; 242
    39bc:	fc 4f       	sbci	r31, 0xFC	; 252
    39be:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    39c0:	f9 01       	movw	r30, r18
    39c2:	ec 5a       	subi	r30, 0xAC	; 172
    39c4:	fc 4f       	sbci	r31, 0xFC	; 252
    39c6:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    39c8:	dd 23       	and	r29, r29
    39ca:	c1 f0       	breq	.+48     	; 0x39fc <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    39cc:	81 11       	cpse	r24, r1
    39ce:	46 df       	rcall	.-372    	; 0x385c <turnOffPWM>

	out = portOutputRegister(port);
    39d0:	2d 2f       	mov	r18, r29
    39d2:	30 e0       	ldi	r19, 0x00	; 0
    39d4:	f9 01       	movw	r30, r18
    39d6:	ee 0f       	add	r30, r30
    39d8:	ff 1f       	adc	r31, r31
    39da:	ec 54       	subi	r30, 0x4C	; 76
    39dc:	fc 4f       	sbci	r31, 0xFC	; 252
    39de:	a5 91       	lpm	r26, Z+
    39e0:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    39e2:	8f b7       	in	r24, 0x3f	; 63
	cli();
    39e4:	f8 94       	cli

	if (val == LOW) {
    39e6:	c1 11       	cpse	r28, r1
    39e8:	05 c0       	rjmp	.+10     	; 0x39f4 <digitalWrite+0x50>
		*out &= ~bit;
    39ea:	ec 91       	ld	r30, X
    39ec:	10 95       	com	r17
    39ee:	1e 23       	and	r17, r30
    39f0:	1c 93       	st	X, r17
    39f2:	03 c0       	rjmp	.+6      	; 0x39fa <digitalWrite+0x56>
	} else {
		*out |= bit;
    39f4:	ec 91       	ld	r30, X
    39f6:	1e 2b       	or	r17, r30
    39f8:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    39fa:	8f bf       	out	0x3f, r24	; 63
}
    39fc:	df 91       	pop	r29
    39fe:	cf 91       	pop	r28
    3a00:	1f 91       	pop	r17
    3a02:	08 95       	ret

00003a04 <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3a04:	0f 93       	push	r16
    3a06:	1f 93       	push	r17
    3a08:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    3a0a:	90 e0       	ldi	r25, 0x00	; 0
    3a0c:	fc 01       	movw	r30, r24
    3a0e:	e2 5f       	subi	r30, 0xF2	; 242
    3a10:	fc 4f       	sbci	r31, 0xFC	; 252
    3a12:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    3a14:	fc 01       	movw	r30, r24
    3a16:	ec 5a       	subi	r30, 0xAC	; 172
    3a18:	fc 4f       	sbci	r31, 0xFC	; 252
    3a1a:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    3a1c:	71 11       	cpse	r23, r1
    3a1e:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3a20:	f0 e0       	ldi	r31, 0x00	; 0
    3a22:	ee 0f       	add	r30, r30
    3a24:	ff 1f       	adc	r31, r31
    3a26:	e6 56       	subi	r30, 0x66	; 102
    3a28:	fc 4f       	sbci	r31, 0xFC	; 252
    3a2a:	85 91       	lpm	r24, Z+
    3a2c:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    3a2e:	89 01       	movw	r16, r18
    3a30:	9a 01       	movw	r18, r20
    3a32:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3a34:	47 2f       	mov	r20, r23
    3a36:	0e 94 29 02 	call	0x452	; 0x452 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    3a3a:	61 15       	cp	r22, r1
    3a3c:	71 05       	cpc	r23, r1
    3a3e:	81 05       	cpc	r24, r1
    3a40:	91 05       	cpc	r25, r1
    3a42:	49 f0       	breq	.+18     	; 0x3a56 <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    3a44:	dc 01       	movw	r26, r24
    3a46:	cb 01       	movw	r24, r22
    3a48:	01 96       	adiw	r24, 0x01	; 1
    3a4a:	a1 1d       	adc	r26, r1
    3a4c:	b1 1d       	adc	r27, r1
    3a4e:	bc 01       	movw	r22, r24
    3a50:	cd 01       	movw	r24, r26
    3a52:	9f 70       	andi	r25, 0x0F	; 15
    3a54:	03 c0       	rjmp	.+6      	; 0x3a5c <pulseIn+0x58>
	else
		return 0;
    3a56:	60 e0       	ldi	r22, 0x00	; 0
    3a58:	70 e0       	ldi	r23, 0x00	; 0
    3a5a:	cb 01       	movw	r24, r22
}
    3a5c:	1f 91       	pop	r17
    3a5e:	0f 91       	pop	r16
    3a60:	08 95       	ret

00003a62 <__mulsi3>:
    3a62:	db 01       	movw	r26, r22
    3a64:	8f 93       	push	r24
    3a66:	9f 93       	push	r25
    3a68:	46 d0       	rcall	.+140    	; 0x3af6 <__muluhisi3>
    3a6a:	bf 91       	pop	r27
    3a6c:	af 91       	pop	r26
    3a6e:	a2 9f       	mul	r26, r18
    3a70:	80 0d       	add	r24, r0
    3a72:	91 1d       	adc	r25, r1
    3a74:	a3 9f       	mul	r26, r19
    3a76:	90 0d       	add	r25, r0
    3a78:	b2 9f       	mul	r27, r18
    3a7a:	90 0d       	add	r25, r0
    3a7c:	11 24       	eor	r1, r1
    3a7e:	08 95       	ret

00003a80 <__divmodhi4>:
    3a80:	97 fb       	bst	r25, 7
    3a82:	07 2e       	mov	r0, r23
    3a84:	16 f4       	brtc	.+4      	; 0x3a8a <__divmodhi4+0xa>
    3a86:	00 94       	com	r0
    3a88:	06 d0       	rcall	.+12     	; 0x3a96 <__divmodhi4_neg1>
    3a8a:	77 fd       	sbrc	r23, 7
    3a8c:	08 d0       	rcall	.+16     	; 0x3a9e <__divmodhi4_neg2>
    3a8e:	41 d0       	rcall	.+130    	; 0x3b12 <__udivmodhi4>
    3a90:	07 fc       	sbrc	r0, 7
    3a92:	05 d0       	rcall	.+10     	; 0x3a9e <__divmodhi4_neg2>
    3a94:	3e f4       	brtc	.+14     	; 0x3aa4 <__divmodhi4_exit>

00003a96 <__divmodhi4_neg1>:
    3a96:	90 95       	com	r25
    3a98:	81 95       	neg	r24
    3a9a:	9f 4f       	sbci	r25, 0xFF	; 255
    3a9c:	08 95       	ret

00003a9e <__divmodhi4_neg2>:
    3a9e:	70 95       	com	r23
    3aa0:	61 95       	neg	r22
    3aa2:	7f 4f       	sbci	r23, 0xFF	; 255

00003aa4 <__divmodhi4_exit>:
    3aa4:	08 95       	ret

00003aa6 <__udivmodsi4>:
    3aa6:	a1 e2       	ldi	r26, 0x21	; 33
    3aa8:	1a 2e       	mov	r1, r26
    3aaa:	aa 1b       	sub	r26, r26
    3aac:	bb 1b       	sub	r27, r27
    3aae:	fd 01       	movw	r30, r26
    3ab0:	0d c0       	rjmp	.+26     	; 0x3acc <__udivmodsi4_ep>

00003ab2 <__udivmodsi4_loop>:
    3ab2:	aa 1f       	adc	r26, r26
    3ab4:	bb 1f       	adc	r27, r27
    3ab6:	ee 1f       	adc	r30, r30
    3ab8:	ff 1f       	adc	r31, r31
    3aba:	a2 17       	cp	r26, r18
    3abc:	b3 07       	cpc	r27, r19
    3abe:	e4 07       	cpc	r30, r20
    3ac0:	f5 07       	cpc	r31, r21
    3ac2:	20 f0       	brcs	.+8      	; 0x3acc <__udivmodsi4_ep>
    3ac4:	a2 1b       	sub	r26, r18
    3ac6:	b3 0b       	sbc	r27, r19
    3ac8:	e4 0b       	sbc	r30, r20
    3aca:	f5 0b       	sbc	r31, r21

00003acc <__udivmodsi4_ep>:
    3acc:	66 1f       	adc	r22, r22
    3ace:	77 1f       	adc	r23, r23
    3ad0:	88 1f       	adc	r24, r24
    3ad2:	99 1f       	adc	r25, r25
    3ad4:	1a 94       	dec	r1
    3ad6:	69 f7       	brne	.-38     	; 0x3ab2 <__udivmodsi4_loop>
    3ad8:	60 95       	com	r22
    3ada:	70 95       	com	r23
    3adc:	80 95       	com	r24
    3ade:	90 95       	com	r25
    3ae0:	9b 01       	movw	r18, r22
    3ae2:	ac 01       	movw	r20, r24
    3ae4:	bd 01       	movw	r22, r26
    3ae6:	cf 01       	movw	r24, r30
    3ae8:	08 95       	ret

00003aea <__tablejump2__>:
    3aea:	ee 0f       	add	r30, r30
    3aec:	ff 1f       	adc	r31, r31

00003aee <__tablejump__>:
    3aee:	05 90       	lpm	r0, Z+
    3af0:	f4 91       	lpm	r31, Z
    3af2:	e0 2d       	mov	r30, r0
    3af4:	19 94       	eijmp

00003af6 <__muluhisi3>:
    3af6:	21 d0       	rcall	.+66     	; 0x3b3a <__umulhisi3>
    3af8:	a5 9f       	mul	r26, r21
    3afa:	90 0d       	add	r25, r0
    3afc:	b4 9f       	mul	r27, r20
    3afe:	90 0d       	add	r25, r0
    3b00:	a4 9f       	mul	r26, r20
    3b02:	80 0d       	add	r24, r0
    3b04:	91 1d       	adc	r25, r1
    3b06:	11 24       	eor	r1, r1
    3b08:	08 95       	ret

00003b0a <__tablejump_elpm__>:
    3b0a:	07 90       	elpm	r0, Z+
    3b0c:	f6 91       	elpm	r31, Z
    3b0e:	e0 2d       	mov	r30, r0
    3b10:	19 94       	eijmp

00003b12 <__udivmodhi4>:
    3b12:	aa 1b       	sub	r26, r26
    3b14:	bb 1b       	sub	r27, r27
    3b16:	51 e1       	ldi	r21, 0x11	; 17
    3b18:	07 c0       	rjmp	.+14     	; 0x3b28 <__udivmodhi4_ep>

00003b1a <__udivmodhi4_loop>:
    3b1a:	aa 1f       	adc	r26, r26
    3b1c:	bb 1f       	adc	r27, r27
    3b1e:	a6 17       	cp	r26, r22
    3b20:	b7 07       	cpc	r27, r23
    3b22:	10 f0       	brcs	.+4      	; 0x3b28 <__udivmodhi4_ep>
    3b24:	a6 1b       	sub	r26, r22
    3b26:	b7 0b       	sbc	r27, r23

00003b28 <__udivmodhi4_ep>:
    3b28:	88 1f       	adc	r24, r24
    3b2a:	99 1f       	adc	r25, r25
    3b2c:	5a 95       	dec	r21
    3b2e:	a9 f7       	brne	.-22     	; 0x3b1a <__udivmodhi4_loop>
    3b30:	80 95       	com	r24
    3b32:	90 95       	com	r25
    3b34:	bc 01       	movw	r22, r24
    3b36:	cd 01       	movw	r24, r26
    3b38:	08 95       	ret

00003b3a <__umulhisi3>:
    3b3a:	a2 9f       	mul	r26, r18
    3b3c:	b0 01       	movw	r22, r0
    3b3e:	b3 9f       	mul	r27, r19
    3b40:	c0 01       	movw	r24, r0
    3b42:	a3 9f       	mul	r26, r19
    3b44:	70 0d       	add	r23, r0
    3b46:	81 1d       	adc	r24, r1
    3b48:	11 24       	eor	r1, r1
    3b4a:	91 1d       	adc	r25, r1
    3b4c:	b2 9f       	mul	r27, r18
    3b4e:	70 0d       	add	r23, r0
    3b50:	81 1d       	adc	r24, r1
    3b52:	11 24       	eor	r1, r1
    3b54:	91 1d       	adc	r25, r1
    3b56:	08 95       	ret

00003b58 <_exit>:
    3b58:	f8 94       	cli

00003b5a <__stop_program>:
    3b5a:	ff cf       	rjmp	.-2      	; 0x3b5a <__stop_program>
