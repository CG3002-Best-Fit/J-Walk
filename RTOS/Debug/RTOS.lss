
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009e  00800200  00003714  000037a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003714  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007f1  0080029e  0080029e  00003846  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003846  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000760  00000000  00000000  00003878  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000f4e5  00000000  00000000  00003fd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002d72  00000000  00000000  000134bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005195  00000000  00000000  0001622f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000015cc  00000000  00000000  0001b3c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000036db  00000000  00000000  0001c990  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000078d4  00000000  00000000  0002006b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000720  00000000  00000000  0002793f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c2       	rjmp	.+1088   	; 0x442 <__ctors_end>
       2:	00 00       	nop
       4:	4f c2       	rjmp	.+1182   	; 0x4a4 <__bad_interrupt>
       6:	00 00       	nop
       8:	4d c2       	rjmp	.+1178   	; 0x4a4 <__bad_interrupt>
       a:	00 00       	nop
       c:	4b c2       	rjmp	.+1174   	; 0x4a4 <__bad_interrupt>
       e:	00 00       	nop
      10:	49 c2       	rjmp	.+1170   	; 0x4a4 <__bad_interrupt>
      12:	00 00       	nop
      14:	47 c2       	rjmp	.+1166   	; 0x4a4 <__bad_interrupt>
      16:	00 00       	nop
      18:	45 c2       	rjmp	.+1162   	; 0x4a4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	43 c2       	rjmp	.+1158   	; 0x4a4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	41 c2       	rjmp	.+1154   	; 0x4a4 <__bad_interrupt>
      22:	00 00       	nop
      24:	3f c2       	rjmp	.+1150   	; 0x4a4 <__bad_interrupt>
      26:	00 00       	nop
      28:	3d c2       	rjmp	.+1146   	; 0x4a4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3b c2       	rjmp	.+1142   	; 0x4a4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	39 c2       	rjmp	.+1138   	; 0x4a4 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 2e 09 	jmp	0x125c	; 0x125c <__vector_13>
      38:	35 c2       	rjmp	.+1130   	; 0x4a4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	33 c2       	rjmp	.+1126   	; 0x4a4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	31 c2       	rjmp	.+1122   	; 0x4a4 <__bad_interrupt>
      42:	00 00       	nop
      44:	2f c2       	rjmp	.+1118   	; 0x4a4 <__bad_interrupt>
      46:	00 00       	nop
      48:	2d c2       	rjmp	.+1114   	; 0x4a4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2b c2       	rjmp	.+1110   	; 0x4a4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	29 c2       	rjmp	.+1106   	; 0x4a4 <__bad_interrupt>
      52:	00 00       	nop
      54:	27 c2       	rjmp	.+1102   	; 0x4a4 <__bad_interrupt>
      56:	00 00       	nop
      58:	25 c2       	rjmp	.+1098   	; 0x4a4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 c5 18 	jmp	0x318a	; 0x318a <__vector_23>
      60:	21 c2       	rjmp	.+1090   	; 0x4a4 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 10 17 	jmp	0x2e20	; 0x2e20 <__vector_25>
      68:	0c 94 4f 17 	jmp	0x2e9e	; 0x2e9e <__vector_26>
      6c:	1b c2       	rjmp	.+1078   	; 0x4a4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	19 c2       	rjmp	.+1074   	; 0x4a4 <__bad_interrupt>
      72:	00 00       	nop
      74:	17 c2       	rjmp	.+1070   	; 0x4a4 <__bad_interrupt>
      76:	00 00       	nop
      78:	15 c2       	rjmp	.+1066   	; 0x4a4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	13 c2       	rjmp	.+1062   	; 0x4a4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	11 c2       	rjmp	.+1058   	; 0x4a4 <__bad_interrupt>
      82:	00 00       	nop
      84:	0f c2       	rjmp	.+1054   	; 0x4a4 <__bad_interrupt>
      86:	00 00       	nop
      88:	0d c2       	rjmp	.+1050   	; 0x4a4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0b c2       	rjmp	.+1046   	; 0x4a4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	09 c2       	rjmp	.+1042   	; 0x4a4 <__bad_interrupt>
      92:	00 00       	nop
      94:	07 c2       	rjmp	.+1038   	; 0x4a4 <__bad_interrupt>
      96:	00 00       	nop
      98:	05 c2       	rjmp	.+1034   	; 0x4a4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 b1 10 	jmp	0x2162	; 0x2162 <__vector_39>
      a0:	01 c2       	rjmp	.+1026   	; 0x4a4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ff c1       	rjmp	.+1022   	; 0x4a4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	fd c1       	rjmp	.+1018   	; 0x4a4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	fb c1       	rjmp	.+1014   	; 0x4a4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	f9 c1       	rjmp	.+1010   	; 0x4a4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	f7 c1       	rjmp	.+1006   	; 0x4a4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	f5 c1       	rjmp	.+1002   	; 0x4a4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	f3 c1       	rjmp	.+998    	; 0x4a4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	f1 c1       	rjmp	.+994    	; 0x4a4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	ef c1       	rjmp	.+990    	; 0x4a4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	ed c1       	rjmp	.+986    	; 0x4a4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	eb c1       	rjmp	.+982    	; 0x4a4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	e9 c1       	rjmp	.+978    	; 0x4a4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	e7 c1       	rjmp	.+974    	; 0x4a4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	e5 c1       	rjmp	.+970    	; 0x4a4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	e3 c1       	rjmp	.+966    	; 0x4a4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	e1 c1       	rjmp	.+962    	; 0x4a4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	b7 11       	cpse	r27, r7
      e6:	ba 11       	cpse	r27, r10
      e8:	ba 11       	cpse	r27, r10
      ea:	ba 11       	cpse	r27, r10
      ec:	ba 11       	cpse	r27, r10
      ee:	ba 11       	cpse	r27, r10
      f0:	ba 11       	cpse	r27, r10
      f2:	ba 11       	cpse	r27, r10
      f4:	d1 10       	cpse	r13, r1
      f6:	ba 11       	cpse	r27, r10
      f8:	ba 11       	cpse	r27, r10
      fa:	ba 11       	cpse	r27, r10
      fc:	ba 11       	cpse	r27, r10
      fe:	ba 11       	cpse	r27, r10
     100:	ba 11       	cpse	r27, r10
     102:	ba 11       	cpse	r27, r10
     104:	d1 10       	cpse	r13, r1
     106:	ba 11       	cpse	r27, r10
     108:	ba 11       	cpse	r27, r10
     10a:	ba 11       	cpse	r27, r10
     10c:	ba 11       	cpse	r27, r10
     10e:	ba 11       	cpse	r27, r10
     110:	ba 11       	cpse	r27, r10
     112:	ba 11       	cpse	r27, r10
     114:	d9 10       	cpse	r13, r9
     116:	ba 11       	cpse	r27, r10
     118:	ba 11       	cpse	r27, r10
     11a:	ba 11       	cpse	r27, r10
     11c:	ba 11       	cpse	r27, r10
     11e:	ba 11       	cpse	r27, r10
     120:	ba 11       	cpse	r27, r10
     122:	ba 11       	cpse	r27, r10
     124:	fe 10       	cpse	r15, r14
     126:	ba 11       	cpse	r27, r10
     128:	ba 11       	cpse	r27, r10
     12a:	ba 11       	cpse	r27, r10
     12c:	ba 11       	cpse	r27, r10
     12e:	ba 11       	cpse	r27, r10
     130:	ba 11       	cpse	r27, r10
     132:	ba 11       	cpse	r27, r10
     134:	d9 10       	cpse	r13, r9
     136:	ba 11       	cpse	r27, r10
     138:	ba 11       	cpse	r27, r10
     13a:	ba 11       	cpse	r27, r10
     13c:	ba 11       	cpse	r27, r10
     13e:	ba 11       	cpse	r27, r10
     140:	ba 11       	cpse	r27, r10
     142:	ba 11       	cpse	r27, r10
     144:	03 11       	cpse	r16, r3
     146:	ba 11       	cpse	r27, r10
     148:	ba 11       	cpse	r27, r10
     14a:	ba 11       	cpse	r27, r10
     14c:	ba 11       	cpse	r27, r10
     14e:	ba 11       	cpse	r27, r10
     150:	ba 11       	cpse	r27, r10
     152:	ba 11       	cpse	r27, r10
     154:	08 11       	cpse	r16, r8
     156:	ba 11       	cpse	r27, r10
     158:	ba 11       	cpse	r27, r10
     15a:	ba 11       	cpse	r27, r10
     15c:	ba 11       	cpse	r27, r10
     15e:	ba 11       	cpse	r27, r10
     160:	ba 11       	cpse	r27, r10
     162:	ba 11       	cpse	r27, r10
     164:	19 11       	cpse	r17, r9
     166:	ba 11       	cpse	r27, r10
     168:	ba 11       	cpse	r27, r10
     16a:	ba 11       	cpse	r27, r10
     16c:	ba 11       	cpse	r27, r10
     16e:	ba 11       	cpse	r27, r10
     170:	ba 11       	cpse	r27, r10
     172:	ba 11       	cpse	r27, r10
     174:	42 11       	cpse	r20, r2
     176:	ba 11       	cpse	r27, r10
     178:	ba 11       	cpse	r27, r10
     17a:	ba 11       	cpse	r27, r10
     17c:	ba 11       	cpse	r27, r10
     17e:	ba 11       	cpse	r27, r10
     180:	ba 11       	cpse	r27, r10
     182:	ba 11       	cpse	r27, r10
     184:	0d 11       	cpse	r16, r13
     186:	ba 11       	cpse	r27, r10
     188:	ba 11       	cpse	r27, r10
     18a:	ba 11       	cpse	r27, r10
     18c:	ba 11       	cpse	r27, r10
     18e:	ba 11       	cpse	r27, r10
     190:	ba 11       	cpse	r27, r10
     192:	ba 11       	cpse	r27, r10
     194:	27 11       	cpse	r18, r7
     196:	ba 11       	cpse	r27, r10
     198:	ba 11       	cpse	r27, r10
     19a:	ba 11       	cpse	r27, r10
     19c:	ba 11       	cpse	r27, r10
     19e:	ba 11       	cpse	r27, r10
     1a0:	ba 11       	cpse	r27, r10
     1a2:	ba 11       	cpse	r27, r10
     1a4:	44 11       	cpse	r20, r4
     1a6:	ba 11       	cpse	r27, r10
     1a8:	ba 11       	cpse	r27, r10
     1aa:	ba 11       	cpse	r27, r10
     1ac:	ba 11       	cpse	r27, r10
     1ae:	ba 11       	cpse	r27, r10
     1b0:	ba 11       	cpse	r27, r10
     1b2:	ba 11       	cpse	r27, r10
     1b4:	44 11       	cpse	r20, r4
     1b6:	ba 11       	cpse	r27, r10
     1b8:	ba 11       	cpse	r27, r10
     1ba:	ba 11       	cpse	r27, r10
     1bc:	ba 11       	cpse	r27, r10
     1be:	ba 11       	cpse	r27, r10
     1c0:	ba 11       	cpse	r27, r10
     1c2:	ba 11       	cpse	r27, r10
     1c4:	44 11       	cpse	r20, r4
     1c6:	ba 11       	cpse	r27, r10
     1c8:	ba 11       	cpse	r27, r10
     1ca:	ba 11       	cpse	r27, r10
     1cc:	ba 11       	cpse	r27, r10
     1ce:	ba 11       	cpse	r27, r10
     1d0:	ba 11       	cpse	r27, r10
     1d2:	ba 11       	cpse	r27, r10
     1d4:	44 11       	cpse	r20, r4
     1d6:	ba 11       	cpse	r27, r10
     1d8:	ba 11       	cpse	r27, r10
     1da:	ba 11       	cpse	r27, r10
     1dc:	ba 11       	cpse	r27, r10
     1de:	ba 11       	cpse	r27, r10
     1e0:	ba 11       	cpse	r27, r10
     1e2:	ba 11       	cpse	r27, r10
     1e4:	4d 11       	cpse	r20, r13
     1e6:	ba 11       	cpse	r27, r10
     1e8:	ba 11       	cpse	r27, r10
     1ea:	ba 11       	cpse	r27, r10
     1ec:	ba 11       	cpse	r27, r10
     1ee:	ba 11       	cpse	r27, r10
     1f0:	ba 11       	cpse	r27, r10
     1f2:	ba 11       	cpse	r27, r10
     1f4:	7e 11       	cpse	r23, r14
     1f6:	ba 11       	cpse	r27, r10
     1f8:	ba 11       	cpse	r27, r10
     1fa:	ba 11       	cpse	r27, r10
     1fc:	ba 11       	cpse	r27, r10
     1fe:	ba 11       	cpse	r27, r10
     200:	ba 11       	cpse	r27, r10
     202:	ba 11       	cpse	r27, r10
     204:	4d 11       	cpse	r20, r13
     206:	ba 11       	cpse	r27, r10
     208:	ba 11       	cpse	r27, r10
     20a:	ba 11       	cpse	r27, r10
     20c:	ba 11       	cpse	r27, r10
     20e:	ba 11       	cpse	r27, r10
     210:	ba 11       	cpse	r27, r10
     212:	ba 11       	cpse	r27, r10
     214:	7e 11       	cpse	r23, r14
     216:	ba 11       	cpse	r27, r10
     218:	ba 11       	cpse	r27, r10
     21a:	ba 11       	cpse	r27, r10
     21c:	ba 11       	cpse	r27, r10
     21e:	ba 11       	cpse	r27, r10
     220:	ba 11       	cpse	r27, r10
     222:	ba 11       	cpse	r27, r10
     224:	65 11       	cpse	r22, r5
     226:	ba 11       	cpse	r27, r10
     228:	ba 11       	cpse	r27, r10
     22a:	ba 11       	cpse	r27, r10
     22c:	ba 11       	cpse	r27, r10
     22e:	ba 11       	cpse	r27, r10
     230:	ba 11       	cpse	r27, r10
     232:	ba 11       	cpse	r27, r10
     234:	82 11       	cpse	r24, r2
     236:	ba 11       	cpse	r27, r10
     238:	ba 11       	cpse	r27, r10
     23a:	ba 11       	cpse	r27, r10
     23c:	ba 11       	cpse	r27, r10
     23e:	ba 11       	cpse	r27, r10
     240:	ba 11       	cpse	r27, r10
     242:	ba 11       	cpse	r27, r10
     244:	82 11       	cpse	r24, r2
     246:	ba 11       	cpse	r27, r10
     248:	ba 11       	cpse	r27, r10
     24a:	ba 11       	cpse	r27, r10
     24c:	ba 11       	cpse	r27, r10
     24e:	ba 11       	cpse	r27, r10
     250:	ba 11       	cpse	r27, r10
     252:	ba 11       	cpse	r27, r10
     254:	97 11       	cpse	r25, r7
     256:	ba 11       	cpse	r27, r10
     258:	ba 11       	cpse	r27, r10
     25a:	ba 11       	cpse	r27, r10
     25c:	ba 11       	cpse	r27, r10
     25e:	ba 11       	cpse	r27, r10
     260:	ba 11       	cpse	r27, r10
     262:	ba 11       	cpse	r27, r10
     264:	b1 11       	cpse	r27, r1
     266:	ba 11       	cpse	r27, r10
     268:	ba 11       	cpse	r27, r10
     26a:	ba 11       	cpse	r27, r10
     26c:	ba 11       	cpse	r27, r10
     26e:	ba 11       	cpse	r27, r10
     270:	ba 11       	cpse	r27, r10
     272:	ba 11       	cpse	r27, r10
     274:	b1 11       	cpse	r27, r1
     276:	07 63       	ori	r16, 0x37	; 55
     278:	42 36       	cpi	r20, 0x62	; 98
     27a:	b7 9b       	sbis	0x16, 7	; 22
     27c:	d8 a7       	std	Y+40, r29	; 0x28
     27e:	1a 39       	cpi	r17, 0x9A	; 154
     280:	68 56       	subi	r22, 0x68	; 104
     282:	18 ae       	std	Y+56, r1	; 0x38
     284:	ba ab       	std	Y+50, r27	; 0x32
     286:	55 8c       	ldd	r5, Z+29	; 0x1d
     288:	1d 3c       	cpi	r17, 0xCD	; 205
     28a:	b7 cc       	rjmp	.-1682   	; 0xfffffbfa <__eeprom_end+0xff7efbfa>
     28c:	57 63       	ori	r21, 0x37	; 55
     28e:	bd 6d       	ori	r27, 0xDD	; 221
     290:	ed fd       	.word	0xfded	; ????
     292:	75 3e       	cpi	r23, 0xE5	; 229
     294:	f6 17       	cp	r31, r22
     296:	72 31       	cpi	r23, 0x12	; 18
     298:	bf 00       	.word	0x00bf	; ????
     29a:	00 00       	nop
     29c:	80 3f       	cpi	r24, 0xF0	; 240
     29e:	08 00       	.word	0x0008	; ????
     2a0:	00 00       	nop
     2a2:	be 92       	st	-X, r11
     2a4:	24 49       	sbci	r18, 0x94	; 148
     2a6:	12 3e       	cpi	r17, 0xE2	; 226
     2a8:	ab aa       	std	Y+51, r10	; 0x33
     2aa:	aa 2a       	or	r10, r26
     2ac:	be cd       	rjmp	.-1156   	; 0xfffffe2a <__eeprom_end+0xff7efe2a>
     2ae:	cc cc       	rjmp	.-1640   	; 0xfffffc48 <__eeprom_end+0xff7efc48>
     2b0:	4c 3e       	cpi	r20, 0xEC	; 236
     2b2:	00 00       	nop
     2b4:	00 80       	ld	r0, Z
     2b6:	be ab       	std	Y+54, r27	; 0x36
     2b8:	aa aa       	std	Y+50, r10	; 0x32
     2ba:	aa 3e       	cpi	r26, 0xEA	; 234
     2bc:	00 00       	nop
     2be:	00 00       	nop
     2c0:	bf 00       	.word	0x00bf	; ????
     2c2:	00 00       	nop
     2c4:	80 3f       	cpi	r24, 0xF0	; 240
     2c6:	00 00       	nop
     2c8:	00 00       	nop
     2ca:	00 08       	sbc	r0, r0
     2cc:	41 78       	andi	r20, 0x81	; 129
     2ce:	d3 bb       	out	0x13, r29	; 19
     2d0:	43 87       	std	Z+11, r20	; 0x0b
     2d2:	d1 13       	cpse	r29, r17
     2d4:	3d 19       	sub	r19, r13
     2d6:	0e 3c       	cpi	r16, 0xCE	; 206
     2d8:	c3 bd       	out	0x23, r28	; 35
     2da:	42 82       	std	Z+2, r4	; 0x02
     2dc:	ad 2b       	or	r26, r29
     2de:	3e 68       	ori	r19, 0x8E	; 142
     2e0:	ec 82       	std	Y+4, r14	; 0x04
     2e2:	76 be       	out	0x36, r7	; 54
     2e4:	d9 8f       	std	Y+25, r29	; 0x19
     2e6:	e1 a9       	ldd	r30, Z+49	; 0x31
     2e8:	3e 4c       	sbci	r19, 0xCE	; 206
     2ea:	80 ef       	ldi	r24, 0xF0	; 240
     2ec:	ff be       	out	0x3f, r15	; 63
     2ee:	01 c4       	rjmp	.+2050   	; 0xaf2 <_ZN6LSM3037readAccEv+0xa>
     2f0:	ff 7f       	andi	r31, 0xFF	; 255
     2f2:	3f 00       	.word	0x003f	; ????
     2f4:	00 00       	nop
     2f6:	00 00       	nop
     2f8:	cb 19       	sub	r28, r11
     2fa:	cf 19       	sub	r28, r15
     2fc:	b9 19       	sub	r27, r9
     2fe:	bf 19       	sub	r27, r15
     300:	c5 19       	sub	r28, r5
     302:	14 1a       	sub	r1, r20
     304:	d3 19       	sub	r29, r3
     306:	d9 19       	sub	r29, r9
     308:	df 19       	sub	r29, r15
     30a:	e5 19       	sub	r30, r5
     30c:	eb 19       	sub	r30, r11
     30e:	f1 19       	sub	r31, r1
     310:	f7 19       	sub	r31, r7
     312:	fd 19       	sub	r31, r13
     314:	14 1a       	sub	r1, r20
     316:	03 1a       	sub	r0, r19
     318:	09 1a       	sub	r0, r25
     31a:	0f 1a       	sub	r0, r31

0000031c <__trampolines_end>:
     31c:	00 00       	nop
     31e:	0a 0b       	sbc	r16, r26
     320:	02 09       	sbc	r16, r2
     322:	0c 0d       	add	r16, r12
     324:	0e 08       	sbc	r0, r14
     326:	07 03       	mulsu	r16, r23
     328:	04 01       	movw	r0, r8
	...
     346:	00 00       	nop
     348:	12 11       	cpse	r17, r2
     34a:	10 00       	.word	0x0010	; ????
	...

00000362 <digital_pin_to_bit_mask_PGM>:
     362:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     372:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     382:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     392:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     3a2:	04 08 10 20 40 80                                   ... @.

000003a8 <digital_pin_to_port_PGM>:
     3a8:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     3b8:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     3c8:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     3d8:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     3e8:	0b 0b 0b 0b 0b 0b                                   ......

000003ee <port_to_input_PGM>:
     3ee:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     3fe:	00 01 00 00 03 01 06 01 09 01                       ..........

00000408 <port_to_output_PGM>:
     408:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     418:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000422 <port_to_mode_PGM>:
     422:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     432:	01 01 00 00 04 01 07 01 0a 01                       ..........

0000043c <__ctors_start>:
     43c:	35 0b       	sbc	r19, r21
     43e:	9f 12       	cpse	r9, r31
     440:	78 17       	cp	r23, r24

00000442 <__ctors_end>:
     442:	11 24       	eor	r1, r1
     444:	1f be       	out	0x3f, r1	; 63
     446:	cf ef       	ldi	r28, 0xFF	; 255
     448:	d1 e2       	ldi	r29, 0x21	; 33
     44a:	de bf       	out	0x3e, r29	; 62
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	00 e0       	ldi	r16, 0x00	; 0
     450:	0c bf       	out	0x3c, r16	; 60

00000452 <__do_copy_data>:
     452:	12 e0       	ldi	r17, 0x02	; 2
     454:	a0 e0       	ldi	r26, 0x00	; 0
     456:	b2 e0       	ldi	r27, 0x02	; 2
     458:	e4 e1       	ldi	r30, 0x14	; 20
     45a:	f7 e3       	ldi	r31, 0x37	; 55
     45c:	00 e0       	ldi	r16, 0x00	; 0
     45e:	0b bf       	out	0x3b, r16	; 59
     460:	02 c0       	rjmp	.+4      	; 0x466 <__do_copy_data+0x14>
     462:	07 90       	elpm	r0, Z+
     464:	0d 92       	st	X+, r0
     466:	ae 39       	cpi	r26, 0x9E	; 158
     468:	b1 07       	cpc	r27, r17
     46a:	d9 f7       	brne	.-10     	; 0x462 <__do_copy_data+0x10>

0000046c <__do_clear_bss>:
     46c:	2a e0       	ldi	r18, 0x0A	; 10
     46e:	ae e9       	ldi	r26, 0x9E	; 158
     470:	b2 e0       	ldi	r27, 0x02	; 2
     472:	01 c0       	rjmp	.+2      	; 0x476 <.do_clear_bss_start>

00000474 <.do_clear_bss_loop>:
     474:	1d 92       	st	X+, r1

00000476 <.do_clear_bss_start>:
     476:	af 38       	cpi	r26, 0x8F	; 143
     478:	b2 07       	cpc	r27, r18
     47a:	e1 f7       	brne	.-8      	; 0x474 <.do_clear_bss_loop>

0000047c <__do_global_ctors>:
     47c:	14 e0       	ldi	r17, 0x04	; 4
     47e:	c2 e4       	ldi	r28, 0x42	; 66
     480:	d4 e0       	ldi	r29, 0x04	; 4
     482:	00 e0       	ldi	r16, 0x00	; 0
     484:	06 c0       	rjmp	.+12     	; 0x492 <__do_global_ctors+0x16>
     486:	22 97       	sbiw	r28, 0x02	; 2
     488:	01 09       	sbc	r16, r1
     48a:	fe 01       	movw	r30, r28
     48c:	0b bf       	out	0x3b, r16	; 59
     48e:	0e 94 61 1b 	call	0x36c2	; 0x36c2 <__tablejump_elpm__>
     492:	cc 33       	cpi	r28, 0x3C	; 60
     494:	d1 07       	cpc	r29, r17
     496:	80 e0       	ldi	r24, 0x00	; 0
     498:	08 07       	cpc	r16, r24
     49a:	a9 f7       	brne	.-22     	; 0x486 <__do_global_ctors+0xa>
     49c:	0e 94 c9 0a 	call	0x1592	; 0x1592 <main>
     4a0:	0c 94 88 1b 	jmp	0x3710	; 0x3710 <_exit>

000004a4 <__bad_interrupt>:
     4a4:	ad cd       	rjmp	.-1190   	; 0x0 <__vectors>

000004a6 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     4a6:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     4a8:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     4aa:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     4ac:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     4ae:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     4b0:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     4b2:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     4b4:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     4b6:	05 c0       	rjmp	.+10     	; 0x4c2 <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     4b8:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4ba:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4bc:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     4be:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     4c0:	61 f1       	breq	.+88     	; 0x51a <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     4c2:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     4c4:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     4c6:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     4c8:	b9 f3       	breq	.-18     	; 0x4b8 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     4ca:	05 c0       	rjmp	.+10     	; 0x4d6 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     4cc:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4ce:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4d0:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     4d2:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     4d4:	11 f1       	breq	.+68     	; 0x51a <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     4d6:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     4d8:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     4da:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     4dc:	f7 cf       	rjmp	.-18     	; 0x4cc <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     4de:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     4e0:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     4e2:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     4e4:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     4e6:	0a c0       	rjmp	.+20     	; 0x4fc <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     4e8:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     4ea:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     4ec:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     4ee:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     4f0:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     4f2:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     4f4:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     4f6:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     4f8:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     4fa:	79 f0       	breq	.+30     	; 0x51a <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     4fc:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     4fe:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     500:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     502:	91 f3       	breq	.-28     	; 0x4e8 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     504:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     506:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     508:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     50a:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     50c:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     50e:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     510:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     512:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     514:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     516:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     518:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     51a:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     51c:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     51e:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     520:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     522:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     524:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     526:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     528:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     52a:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     52c:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     52e:	08 95       	ret

00000530 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
     534:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     536:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     53a:	80 91 9e 02 	lds	r24, 0x029E
     53e:	90 91 9f 02 	lds	r25, 0x029F
     542:	89 2b       	or	r24, r25
     544:	31 f4       	brne	.+12     	; 0x552 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     546:	83 ea       	ldi	r24, 0xA3	; 163
     548:	92 e0       	ldi	r25, 0x02	; 2
     54a:	90 93 9f 02 	sts	0x029F, r25
     54e:	80 93 9e 02 	sts	0x029E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     552:	40 91 a0 02 	lds	r20, 0x02A0
     556:	50 91 a1 02 	lds	r21, 0x02A1
     55a:	9e 01       	movw	r18, r28
     55c:	24 0f       	add	r18, r20
     55e:	35 1f       	adc	r19, r21
     560:	2b 3d       	cpi	r18, 0xDB	; 219
     562:	85 e0       	ldi	r24, 0x05	; 5
     564:	38 07       	cpc	r19, r24
     566:	70 f4       	brcc	.+28     	; 0x584 <pvPortMalloc+0x54>
     568:	42 17       	cp	r20, r18
     56a:	53 07       	cpc	r21, r19
     56c:	70 f4       	brcc	.+28     	; 0x58a <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     56e:	c0 91 9e 02 	lds	r28, 0x029E
     572:	d0 91 9f 02 	lds	r29, 0x029F
     576:	c4 0f       	add	r28, r20
     578:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     57a:	30 93 a1 02 	sts	0x02A1, r19
     57e:	20 93 a0 02 	sts	0x02A0, r18
     582:	05 c0       	rjmp	.+10     	; 0x58e <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     584:	c0 e0       	ldi	r28, 0x00	; 0
     586:	d0 e0       	ldi	r29, 0x00	; 0
     588:	02 c0       	rjmp	.+4      	; 0x58e <pvPortMalloc+0x5e>
     58a:	c0 e0       	ldi	r28, 0x00	; 0
     58c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     58e:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     592:	ce 01       	movw	r24, r28
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	08 95       	ret

0000059a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     59a:	08 95       	ret

0000059c <_ZN3L3GC1Ev>:
  Wire.requestFrom(address, (byte)1);
  value = Wire.read();
  Wire.endTransmission();

  return value;
}
     59c:	fc 01       	movw	r30, r24
     59e:	83 e0       	ldi	r24, 0x03	; 3
     5a0:	87 83       	std	Z+7, r24	; 0x07
     5a2:	12 86       	std	Z+10, r1	; 0x0a
     5a4:	11 86       	std	Z+9, r1	; 0x09
     5a6:	13 86       	std	Z+11, r1	; 0x0b
     5a8:	08 95       	ret

000005aa <_ZN3L3G8writeRegEhh>:
     5aa:	0f 93       	push	r16
     5ac:	1f 93       	push	r17
     5ae:	cf 93       	push	r28
     5b0:	df 93       	push	r29
     5b2:	ec 01       	movw	r28, r24
     5b4:	06 2f       	mov	r16, r22
     5b6:	14 2f       	mov	r17, r20
     5b8:	68 85       	ldd	r22, Y+8	; 0x08
     5ba:	87 e9       	ldi	r24, 0x97	; 151
     5bc:	99 e0       	ldi	r25, 0x09	; 9
     5be:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
     5c2:	60 2f       	mov	r22, r16
     5c4:	87 e9       	ldi	r24, 0x97	; 151
     5c6:	99 e0       	ldi	r25, 0x09	; 9
     5c8:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
     5cc:	61 2f       	mov	r22, r17
     5ce:	87 e9       	ldi	r24, 0x97	; 151
     5d0:	99 e0       	ldi	r25, 0x09	; 9
     5d2:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
     5d6:	87 e9       	ldi	r24, 0x97	; 151
     5d8:	99 e0       	ldi	r25, 0x09	; 9
     5da:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     5de:	8e 83       	std	Y+6, r24	; 0x06
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	1f 91       	pop	r17
     5e6:	0f 91       	pop	r16
     5e8:	08 95       	ret

000005ea <_ZN3L3G13enableDefaultEv>:
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	ec 01       	movw	r28, r24
     5f0:	8f 81       	ldd	r24, Y+7	; 0x07
     5f2:	82 30       	cpi	r24, 0x02	; 2
     5f4:	21 f4       	brne	.+8      	; 0x5fe <_ZN3L3G13enableDefaultEv+0x14>
     5f6:	40 e0       	ldi	r20, 0x00	; 0
     5f8:	69 e3       	ldi	r22, 0x39	; 57
     5fa:	ce 01       	movw	r24, r28
     5fc:	d6 df       	rcall	.-84     	; 0x5aa <_ZN3L3G8writeRegEhh>
     5fe:	40 e0       	ldi	r20, 0x00	; 0
     600:	63 e2       	ldi	r22, 0x23	; 35
     602:	ce 01       	movw	r24, r28
     604:	d2 df       	rcall	.-92     	; 0x5aa <_ZN3L3G8writeRegEhh>
     606:	4f e6       	ldi	r20, 0x6F	; 111
     608:	60 e2       	ldi	r22, 0x20	; 32
     60a:	ce 01       	movw	r24, r28
     60c:	ce df       	rcall	.-100    	; 0x5aa <_ZN3L3G8writeRegEhh>
     60e:	df 91       	pop	r29
     610:	cf 91       	pop	r28
     612:	08 95       	ret

00000614 <_ZN3L3G4readEv>:

// Reads the 3 gyro channels and stores them in vector g
void L3G::read()
{
     614:	9f 92       	push	r9
     616:	af 92       	push	r10
     618:	bf 92       	push	r11
     61a:	cf 92       	push	r12
     61c:	df 92       	push	r13
     61e:	ef 92       	push	r14
     620:	ff 92       	push	r15
     622:	0f 93       	push	r16
     624:	1f 93       	push	r17
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     62c:	68 85       	ldd	r22, Y+8	; 0x08
     62e:	87 e9       	ldi	r24, 0x97	; 151
     630:	99 e0       	ldi	r25, 0x09	; 9
     632:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     636:	e0 91 97 09 	lds	r30, 0x0997
     63a:	f0 91 98 09 	lds	r31, 0x0998
     63e:	01 90       	ld	r0, Z+
     640:	f0 81       	ld	r31, Z
     642:	e0 2d       	mov	r30, r0
     644:	68 ea       	ldi	r22, 0xA8	; 168
     646:	87 e9       	ldi	r24, 0x97	; 151
     648:	99 e0       	ldi	r25, 0x09	; 9
     64a:	19 95       	eicall
  // assert the MSB of the address to get the gyro
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
     64c:	87 e9       	ldi	r24, 0x97	; 151
     64e:	99 e0       	ldi	r25, 0x09	; 9
     650:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)6);
     654:	46 e0       	ldi	r20, 0x06	; 6
     656:	68 85       	ldd	r22, Y+8	; 0x08
     658:	87 e9       	ldi	r24, 0x97	; 151
     65a:	99 e0       	ldi	r25, 0x09	; 9
     65c:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire11requestFromEhh>
  
  unsigned int millis_start = millis();
     660:	0e 94 0f 19 	call	0x321e	; 0x321e <millis>
     664:	8b 01       	movw	r16, r22
  while (Wire.available() < 6)
     666:	10 c0       	rjmp	.+32     	; 0x688 <_ZN3L3G4readEv+0x74>
  {
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     668:	89 85       	ldd	r24, Y+9	; 0x09
     66a:	9a 85       	ldd	r25, Y+10	; 0x0a
     66c:	89 2b       	or	r24, r25
     66e:	61 f0       	breq	.+24     	; 0x688 <_ZN3L3G4readEv+0x74>
     670:	0e 94 0f 19 	call	0x321e	; 0x321e <millis>
     674:	60 1b       	sub	r22, r16
     676:	71 0b       	sbc	r23, r17
     678:	89 85       	ldd	r24, Y+9	; 0x09
     67a:	9a 85       	ldd	r25, Y+10	; 0x0a
     67c:	86 17       	cp	r24, r22
     67e:	97 07       	cpc	r25, r23
     680:	18 f4       	brcc	.+6      	; 0x688 <_ZN3L3G4readEv+0x74>
    {
      did_timeout = true;
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	8b 87       	std	Y+11, r24	; 0x0b
      return;
     686:	32 c0       	rjmp	.+100    	; 0x6ec <_ZN3L3G4readEv+0xd8>
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
  Wire.requestFrom(address, (byte)6);
  
  unsigned int millis_start = millis();
  while (Wire.available() < 6)
     688:	87 e9       	ldi	r24, 0x97	; 151
     68a:	99 e0       	ldi	r25, 0x09	; 9
     68c:	0e 94 cd 11 	call	0x239a	; 0x239a <_ZN7TwoWire9availableEv>
     690:	06 97       	sbiw	r24, 0x06	; 6
     692:	54 f3       	brlt	.-44     	; 0x668 <_ZN3L3G4readEv+0x54>
      did_timeout = true;
      return;
    }
  }

  uint8_t xlg = Wire.read();
     694:	87 e9       	ldi	r24, 0x97	; 151
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     69c:	a8 2e       	mov	r10, r24
  uint8_t xhg = Wire.read();
     69e:	87 e9       	ldi	r24, 0x97	; 151
     6a0:	99 e0       	ldi	r25, 0x09	; 9
     6a2:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     6a6:	98 2e       	mov	r9, r24
  uint8_t ylg = Wire.read();
     6a8:	87 e9       	ldi	r24, 0x97	; 151
     6aa:	99 e0       	ldi	r25, 0x09	; 9
     6ac:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     6b0:	08 2f       	mov	r16, r24
  uint8_t yhg = Wire.read();
     6b2:	87 e9       	ldi	r24, 0x97	; 151
     6b4:	99 e0       	ldi	r25, 0x09	; 9
     6b6:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     6ba:	b8 2e       	mov	r11, r24
  uint8_t zlg = Wire.read();
     6bc:	87 e9       	ldi	r24, 0x97	; 151
     6be:	99 e0       	ldi	r25, 0x09	; 9
     6c0:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     6c4:	18 2f       	mov	r17, r24
  uint8_t zhg = Wire.read();
     6c6:	87 e9       	ldi	r24, 0x97	; 151
     6c8:	99 e0       	ldi	r25, 0x09	; 9
     6ca:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
     6ce:	d9 2c       	mov	r13, r9
     6d0:	c1 2c       	mov	r12, r1
     6d2:	ca 28       	or	r12, r10
     6d4:	d9 82       	std	Y+1, r13	; 0x01
     6d6:	c8 82       	st	Y, r12
  g.y = (int16_t)(yhg << 8 | ylg);
     6d8:	fb 2c       	mov	r15, r11
     6da:	e1 2c       	mov	r14, r1
     6dc:	e0 2a       	or	r14, r16
     6de:	fb 82       	std	Y+3, r15	; 0x03
     6e0:	ea 82       	std	Y+2, r14	; 0x02
  g.z = (int16_t)(zhg << 8 | zlg);
     6e2:	98 2f       	mov	r25, r24
     6e4:	88 27       	eor	r24, r24
     6e6:	81 2b       	or	r24, r17
     6e8:	9d 83       	std	Y+5, r25	; 0x05
     6ea:	8c 83       	std	Y+4, r24	; 0x04
}
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	1f 91       	pop	r17
     6f2:	0f 91       	pop	r16
     6f4:	ff 90       	pop	r15
     6f6:	ef 90       	pop	r14
     6f8:	df 90       	pop	r13
     6fa:	cf 90       	pop	r12
     6fc:	bf 90       	pop	r11
     6fe:	af 90       	pop	r10
     700:	9f 90       	pop	r9
     702:	08 95       	ret

00000704 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	c6 2f       	mov	r28, r22
     70a:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     70c:	87 e9       	ldi	r24, 0x97	; 151
     70e:	99 e0       	ldi	r25, 0x09	; 9
     710:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     714:	6d 2f       	mov	r22, r29
     716:	87 e9       	ldi	r24, 0x97	; 151
     718:	99 e0       	ldi	r25, 0x09	; 9
     71a:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     71e:	87 e9       	ldi	r24, 0x97	; 151
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     726:	81 11       	cpse	r24, r1
     728:	11 c0       	rjmp	.+34     	; 0x74c <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     72a:	41 e0       	ldi	r20, 0x01	; 1
     72c:	6c 2f       	mov	r22, r28
     72e:	87 e9       	ldi	r24, 0x97	; 151
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     736:	87 e9       	ldi	r24, 0x97	; 151
     738:	99 e0       	ldi	r25, 0x09	; 9
     73a:	0e 94 cd 11 	call	0x239a	; 0x239a <_ZN7TwoWire9availableEv>
     73e:	89 2b       	or	r24, r25
     740:	41 f0       	breq	.+16     	; 0x752 <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     742:	87 e9       	ldi	r24, 0x97	; 151
     744:	99 e0       	ldi	r25, 0x09	; 9
     746:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     74a:	05 c0       	rjmp	.+10     	; 0x756 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     74c:	8f ef       	ldi	r24, 0xFF	; 255
     74e:	9f ef       	ldi	r25, 0xFF	; 255
     750:	02 c0       	rjmp	.+4      	; 0x756 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     752:	8f ef       	ldi	r24, 0xFF	; 255
     754:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	08 95       	ret

0000075c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     75c:	0f 93       	push	r16
     75e:	1f 93       	push	r17
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
     766:	16 2f       	mov	r17, r22
     768:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     76a:	63 30       	cpi	r22, 0x03	; 3
     76c:	09 f4       	brne	.+2      	; 0x770 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     76e:	56 c0       	rjmp	.+172    	; 0x81c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     770:	42 30       	cpi	r20, 0x02	; 2
     772:	c9 f5       	brne	.+114    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     774:	56 c0       	rjmp	.+172    	; 0x822 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     776:	13 30       	cpi	r17, 0x03	; 3
     778:	09 f0       	breq	.+2      	; 0x77c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     77a:	58 c0       	rjmp	.+176    	; 0x82c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     77c:	87 3d       	cpi	r24, 0xD7	; 215
     77e:	91 05       	cpc	r25, r1
     780:	09 f4       	brne	.+2      	; 0x784 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     782:	58 c0       	rjmp	.+176    	; 0x834 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     784:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     786:	11 e0       	ldi	r17, 0x01	; 1
     788:	2c c0       	rjmp	.+88     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     78a:	01 30       	cpi	r16, 0x01	; 1
     78c:	91 f0       	breq	.+36     	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     78e:	4f e0       	ldi	r20, 0x0F	; 15
     790:	6a e6       	ldi	r22, 0x6A	; 106
     792:	ce 01       	movw	r24, r28
     794:	b7 df       	rcall	.-146    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     796:	8f 3f       	cpi	r24, 0xFF	; 255
     798:	2f ef       	ldi	r18, 0xFF	; 255
     79a:	92 07       	cpc	r25, r18
     79c:	51 f0       	breq	.+20     	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     79e:	13 30       	cpi	r17, 0x03	; 3
     7a0:	09 f0       	breq	.+2      	; 0x7a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     7a2:	46 c0       	rjmp	.+140    	; 0x830 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7a4:	87 3d       	cpi	r24, 0xD7	; 215
     7a6:	91 05       	cpc	r25, r1
     7a8:	09 f0       	breq	.+2      	; 0x7ac <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     7aa:	47 c0       	rjmp	.+142    	; 0x83a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7ac:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7ae:	12 e0       	ldi	r17, 0x02	; 2
     7b0:	18 c0       	rjmp	.+48     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     7b2:	13 30       	cpi	r17, 0x03	; 3
     7b4:	11 f0       	breq	.+4      	; 0x7ba <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     7b6:	11 11       	cpse	r17, r1
     7b8:	14 c0       	rjmp	.+40     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7ba:	00 23       	and	r16, r16
     7bc:	49 f0       	breq	.+18     	; 0x7d0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     7be:	4f e0       	ldi	r20, 0x0F	; 15
     7c0:	69 e6       	ldi	r22, 0x69	; 105
     7c2:	ce 01       	movw	r24, r28
     7c4:	9f df       	rcall	.-194    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     7c6:	83 3d       	cpi	r24, 0xD3	; 211
     7c8:	91 05       	cpc	r25, r1
     7ca:	d1 f1       	breq	.+116    	; 0x840 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7cc:	01 30       	cpi	r16, 0x01	; 1
     7ce:	39 f0       	breq	.+14     	; 0x7de <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     7d0:	4f e0       	ldi	r20, 0x0F	; 15
     7d2:	68 e6       	ldi	r22, 0x68	; 104
     7d4:	ce 01       	movw	r24, r28
     7d6:	96 df       	rcall	.-212    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     7d8:	83 3d       	cpi	r24, 0xD3	; 211
     7da:	91 05       	cpc	r25, r1
     7dc:	99 f1       	breq	.+102    	; 0x844 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     7de:	13 30       	cpi	r17, 0x03	; 3
     7e0:	b9 f0       	breq	.+46     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     7e2:	02 30       	cpi	r16, 0x02	; 2
     7e4:	b9 f0       	breq	.+46     	; 0x814 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     7e6:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     7e8:	11 23       	and	r17, r17
     7ea:	51 f0       	breq	.+20     	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     7ec:	13 30       	cpi	r17, 0x03	; 3
     7ee:	a0 f4       	brcc	.+40     	; 0x818 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     7f0:	01 30       	cpi	r16, 0x01	; 1
     7f2:	11 f4       	brne	.+4      	; 0x7f8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     7f4:	8b e6       	ldi	r24, 0x6B	; 107
     7f6:	01 c0       	rjmp	.+2      	; 0x7fa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     7f8:	8a e6       	ldi	r24, 0x6A	; 106
     7fa:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     7fc:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     7fe:	41 c0       	rjmp	.+130    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     800:	01 30       	cpi	r16, 0x01	; 1
     802:	11 f4       	brne	.+4      	; 0x808 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     804:	89 e6       	ldi	r24, 0x69	; 105
     806:	01 c0       	rjmp	.+2      	; 0x80a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     808:	88 e6       	ldi	r24, 0x68	; 104
     80a:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     80c:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     80e:	39 c0       	rjmp	.+114    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	37 c0       	rjmp	.+110    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	35 c0       	rjmp	.+106    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	33 c0       	rjmp	.+102    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     81c:	44 23       	and	r20, r20
     81e:	41 f1       	breq	.+80     	; 0x870 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     820:	1e c0       	rjmp	.+60     	; 0x85e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     822:	8f ef       	ldi	r24, 0xFF	; 255
     824:	86 0f       	add	r24, r22
     826:	83 30       	cpi	r24, 0x03	; 3
     828:	30 f6       	brcc	.-116    	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     82a:	0f c0       	rjmp	.+30     	; 0x84a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     82c:	01 e0       	ldi	r16, 0x01	; 1
     82e:	c3 cf       	rjmp	.-122    	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     830:	00 e0       	ldi	r16, 0x00	; 0
     832:	c1 cf       	rjmp	.-126    	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     834:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     836:	12 e0       	ldi	r17, 0x02	; 2
     838:	d4 cf       	rjmp	.-88     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     83a:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     83c:	11 e0       	ldi	r17, 0x01	; 1
     83e:	d1 cf       	rjmp	.-94     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     840:	01 e0       	ldi	r16, 0x01	; 1
     842:	01 c0       	rjmp	.+2      	; 0x846 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     844:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     846:	1f 82       	std	Y+7, r1	; 0x07
     848:	db cf       	rjmp	.-74     	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     84a:	4f e0       	ldi	r20, 0x0F	; 15
     84c:	6b e6       	ldi	r22, 0x6B	; 107
     84e:	ce 01       	movw	r24, r28
     850:	59 df       	rcall	.-334    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     852:	8f 3f       	cpi	r24, 0xFF	; 255
     854:	2f ef       	ldi	r18, 0xFF	; 255
     856:	92 07       	cpc	r25, r18
     858:	09 f0       	breq	.+2      	; 0x85c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     85a:	8d cf       	rjmp	.-230    	; 0x776 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     85c:	98 cf       	rjmp	.-208    	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     85e:	4f e0       	ldi	r20, 0x0F	; 15
     860:	6b e6       	ldi	r22, 0x6B	; 107
     862:	50 df       	rcall	.-352    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     864:	8f 3f       	cpi	r24, 0xFF	; 255
     866:	2f ef       	ldi	r18, 0xFF	; 255
     868:	92 07       	cpc	r25, r18
     86a:	09 f0       	breq	.+2      	; 0x86e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     86c:	87 cf       	rjmp	.-242    	; 0x77c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     86e:	8d cf       	rjmp	.-230    	; 0x78a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     870:	4f e0       	ldi	r20, 0x0F	; 15
     872:	6a e6       	ldi	r22, 0x6A	; 106
     874:	47 df       	rcall	.-370    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     876:	8f 3f       	cpi	r24, 0xFF	; 255
     878:	2f ef       	ldi	r18, 0xFF	; 255
     87a:	92 07       	cpc	r25, r18
     87c:	09 f0       	breq	.+2      	; 0x880 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     87e:	92 cf       	rjmp	.-220    	; 0x7a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     880:	98 cf       	rjmp	.-208    	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	1f 91       	pop	r17
     888:	0f 91       	pop	r16
     88a:	08 95       	ret

0000088c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     88c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     88e:	03 96       	adiw	r24, 0x03	; 3
     890:	92 83       	std	Z+2, r25	; 0x02
     892:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     894:	2f ef       	ldi	r18, 0xFF	; 255
     896:	3f ef       	ldi	r19, 0xFF	; 255
     898:	34 83       	std	Z+4, r19	; 0x04
     89a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     89c:	96 83       	std	Z+6, r25	; 0x06
     89e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a0:	90 87       	std	Z+8, r25	; 0x08
     8a2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8a4:	10 82       	st	Z, r1
     8a6:	08 95       	ret

000008a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8a8:	fc 01       	movw	r30, r24
     8aa:	11 86       	std	Z+9, r1	; 0x09
     8ac:	10 86       	std	Z+8, r1	; 0x08
     8ae:	08 95       	ret

000008b0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8b0:	cf 93       	push	r28
     8b2:	df 93       	push	r29
     8b4:	9c 01       	movw	r18, r24
     8b6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8b8:	dc 01       	movw	r26, r24
     8ba:	11 96       	adiw	r26, 0x01	; 1
     8bc:	cd 91       	ld	r28, X+
     8be:	dc 91       	ld	r29, X
     8c0:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8c2:	d3 83       	std	Z+3, r29	; 0x03
     8c4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8c6:	8c 81       	ldd	r24, Y+4	; 0x04
     8c8:	9d 81       	ldd	r25, Y+5	; 0x05
     8ca:	95 83       	std	Z+5, r25	; 0x05
     8cc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8ce:	8c 81       	ldd	r24, Y+4	; 0x04
     8d0:	9d 81       	ldd	r25, Y+5	; 0x05
     8d2:	dc 01       	movw	r26, r24
     8d4:	13 96       	adiw	r26, 0x03	; 3
     8d6:	7c 93       	st	X, r23
     8d8:	6e 93       	st	-X, r22
     8da:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     8dc:	7d 83       	std	Y+5, r23	; 0x05
     8de:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8e0:	31 87       	std	Z+9, r19	; 0x09
     8e2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     8e4:	f9 01       	movw	r30, r18
     8e6:	80 81       	ld	r24, Z
     8e8:	8f 5f       	subi	r24, 0xFF	; 255
     8ea:	80 83       	st	Z, r24
}
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	08 95       	ret

000008f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8f2:	cf 93       	push	r28
     8f4:	df 93       	push	r29
     8f6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     8f8:	48 81       	ld	r20, Y
     8fa:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     8fc:	4f 3f       	cpi	r20, 0xFF	; 255
     8fe:	2f ef       	ldi	r18, 0xFF	; 255
     900:	52 07       	cpc	r21, r18
     902:	21 f4       	brne	.+8      	; 0x90c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     904:	fc 01       	movw	r30, r24
     906:	a7 81       	ldd	r26, Z+7	; 0x07
     908:	b0 85       	ldd	r27, Z+8	; 0x08
     90a:	0d c0       	rjmp	.+26     	; 0x926 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     90c:	dc 01       	movw	r26, r24
     90e:	13 96       	adiw	r26, 0x03	; 3
     910:	12 96       	adiw	r26, 0x02	; 2
     912:	ed 91       	ld	r30, X+
     914:	fc 91       	ld	r31, X
     916:	13 97       	sbiw	r26, 0x03	; 3
     918:	20 81       	ld	r18, Z
     91a:	31 81       	ldd	r19, Z+1	; 0x01
     91c:	42 17       	cp	r20, r18
     91e:	53 07       	cpc	r21, r19
     920:	10 f0       	brcs	.+4      	; 0x926 <vListInsert+0x34>
     922:	df 01       	movw	r26, r30
     924:	f5 cf       	rjmp	.-22     	; 0x910 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     926:	12 96       	adiw	r26, 0x02	; 2
     928:	ed 91       	ld	r30, X+
     92a:	fc 91       	ld	r31, X
     92c:	13 97       	sbiw	r26, 0x03	; 3
     92e:	fb 83       	std	Y+3, r31	; 0x03
     930:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     932:	d5 83       	std	Z+5, r29	; 0x05
     934:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     936:	bd 83       	std	Y+5, r27	; 0x05
     938:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     93a:	13 96       	adiw	r26, 0x03	; 3
     93c:	dc 93       	st	X, r29
     93e:	ce 93       	st	-X, r28
     940:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     942:	99 87       	std	Y+9, r25	; 0x09
     944:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     946:	fc 01       	movw	r30, r24
     948:	20 81       	ld	r18, Z
     94a:	2f 5f       	subi	r18, 0xFF	; 255
     94c:	20 83       	st	Z, r18
}
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	08 95       	ret

00000954 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     95a:	a0 85       	ldd	r26, Z+8	; 0x08
     95c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     95e:	c2 81       	ldd	r28, Z+2	; 0x02
     960:	d3 81       	ldd	r29, Z+3	; 0x03
     962:	84 81       	ldd	r24, Z+4	; 0x04
     964:	95 81       	ldd	r25, Z+5	; 0x05
     966:	9d 83       	std	Y+5, r25	; 0x05
     968:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     96a:	c4 81       	ldd	r28, Z+4	; 0x04
     96c:	d5 81       	ldd	r29, Z+5	; 0x05
     96e:	82 81       	ldd	r24, Z+2	; 0x02
     970:	93 81       	ldd	r25, Z+3	; 0x03
     972:	9b 83       	std	Y+3, r25	; 0x03
     974:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     976:	11 96       	adiw	r26, 0x01	; 1
     978:	cd 91       	ld	r28, X+
     97a:	dc 91       	ld	r29, X
     97c:	12 97       	sbiw	r26, 0x02	; 2
     97e:	ce 17       	cp	r28, r30
     980:	df 07       	cpc	r29, r31
     982:	31 f4       	brne	.+12     	; 0x990 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     984:	8c 81       	ldd	r24, Y+4	; 0x04
     986:	9d 81       	ldd	r25, Y+5	; 0x05
     988:	12 96       	adiw	r26, 0x02	; 2
     98a:	9c 93       	st	X, r25
     98c:	8e 93       	st	-X, r24
     98e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     990:	11 86       	std	Z+9, r1	; 0x09
     992:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     994:	8c 91       	ld	r24, X
     996:	81 50       	subi	r24, 0x01	; 1
     998:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	08 95       	ret

000009a0 <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	ec 01       	movw	r28, r24
     9a6:	86 e0       	ldi	r24, 0x06	; 6
     9a8:	e9 e0       	ldi	r30, 0x09	; 9
     9aa:	f2 e0       	ldi	r31, 0x02	; 2
     9ac:	de 01       	movw	r26, r28
     9ae:	52 96       	adiw	r26, 0x12	; 18
     9b0:	01 90       	ld	r0, Z+
     9b2:	0d 92       	st	X+, r0
     9b4:	8a 95       	dec	r24
     9b6:	e1 f7       	brne	.-8      	; 0x9b0 <_ZN6LSM303C1Ev+0x10>
     9b8:	86 e0       	ldi	r24, 0x06	; 6
     9ba:	ef e0       	ldi	r30, 0x0F	; 15
     9bc:	f2 e0       	ldi	r31, 0x02	; 2
     9be:	de 01       	movw	r26, r28
     9c0:	1c 96       	adiw	r26, 0x0c	; 12
     9c2:	01 90       	ld	r0, Z+
     9c4:	0d 92       	st	X+, r0
     9c6:	8a 95       	dec	r24
     9c8:	e1 f7       	brne	.-8      	; 0x9c2 <_ZN6LSM303C1Ev+0x22>
     9ca:	84 e0       	ldi	r24, 0x04	; 4
     9cc:	89 8f       	std	Y+25, r24	; 0x19
     9ce:	1c a2       	std	Y+36, r1	; 0x24
     9d0:	1b a2       	std	Y+35, r1	; 0x23
     9d2:	1d a2       	std	Y+37, r1	; 0x25
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	08 95       	ret

000009da <_ZN6LSM30311writeAccRegEhh>:
     9da:	0f 93       	push	r16
     9dc:	1f 93       	push	r17
     9de:	cf 93       	push	r28
     9e0:	df 93       	push	r29
     9e2:	ec 01       	movw	r28, r24
     9e4:	06 2f       	mov	r16, r22
     9e6:	14 2f       	mov	r17, r20
     9e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
     9ea:	87 e9       	ldi	r24, 0x97	; 151
     9ec:	99 e0       	ldi	r25, 0x09	; 9
     9ee:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
     9f2:	60 2f       	mov	r22, r16
     9f4:	87 e9       	ldi	r24, 0x97	; 151
     9f6:	99 e0       	ldi	r25, 0x09	; 9
     9f8:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
     9fc:	61 2f       	mov	r22, r17
     9fe:	87 e9       	ldi	r24, 0x97	; 151
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
     a06:	87 e9       	ldi	r24, 0x97	; 151
     a08:	99 e0       	ldi	r25, 0x09	; 9
     a0a:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     a0e:	88 8f       	std	Y+24, r24	; 0x18
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	1f 91       	pop	r17
     a16:	0f 91       	pop	r16
     a18:	08 95       	ret

00000a1a <_ZN6LSM30311writeMagRegEhh>:
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	ec 01       	movw	r28, r24
     a24:	06 2f       	mov	r16, r22
     a26:	14 2f       	mov	r17, r20
     a28:	6b 8d       	ldd	r22, Y+27	; 0x1b
     a2a:	87 e9       	ldi	r24, 0x97	; 151
     a2c:	99 e0       	ldi	r25, 0x09	; 9
     a2e:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
     a32:	60 2f       	mov	r22, r16
     a34:	87 e9       	ldi	r24, 0x97	; 151
     a36:	99 e0       	ldi	r25, 0x09	; 9
     a38:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
     a3c:	61 2f       	mov	r22, r17
     a3e:	87 e9       	ldi	r24, 0x97	; 151
     a40:	99 e0       	ldi	r25, 0x09	; 9
     a42:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
     a46:	87 e9       	ldi	r24, 0x97	; 151
     a48:	99 e0       	ldi	r25, 0x09	; 9
     a4a:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     a4e:	88 8f       	std	Y+24, r24	; 0x18
     a50:	df 91       	pop	r29
     a52:	cf 91       	pop	r28
     a54:	1f 91       	pop	r17
     a56:	0f 91       	pop	r16
     a58:	08 95       	ret

00000a5a <_ZN6LSM3038writeRegEhh>:
     a5a:	fc 01       	movw	r30, r24
     a5c:	21 8d       	ldd	r18, Z+25	; 0x19
     a5e:	23 30       	cpi	r18, 0x03	; 3
     a60:	11 f0       	breq	.+4      	; 0xa66 <_ZN6LSM3038writeRegEhh+0xc>
     a62:	60 32       	cpi	r22, 0x20	; 32
     a64:	10 f4       	brcc	.+4      	; 0xa6a <_ZN6LSM3038writeRegEhh+0x10>
     a66:	d9 cf       	rjmp	.-78     	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     a68:	08 95       	ret
     a6a:	b7 cf       	rjmp	.-146    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     a6c:	08 95       	ret

00000a6e <_ZN6LSM30313enableDefaultEv>:
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	ec 01       	movw	r28, r24
     a74:	89 8d       	ldd	r24, Y+25	; 0x19
     a76:	83 30       	cpi	r24, 0x03	; 3
     a78:	a9 f4       	brne	.+42     	; 0xaa4 <_ZN6LSM30313enableDefaultEv+0x36>
     a7a:	40 e0       	ldi	r20, 0x00	; 0
     a7c:	61 e2       	ldi	r22, 0x21	; 33
     a7e:	ce 01       	movw	r24, r28
     a80:	ec df       	rcall	.-40     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a82:	47 e5       	ldi	r20, 0x57	; 87
     a84:	60 e2       	ldi	r22, 0x20	; 32
     a86:	ce 01       	movw	r24, r28
     a88:	e8 df       	rcall	.-48     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a8a:	44 e6       	ldi	r20, 0x64	; 100
     a8c:	64 e2       	ldi	r22, 0x24	; 36
     a8e:	ce 01       	movw	r24, r28
     a90:	e4 df       	rcall	.-56     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a92:	40 e2       	ldi	r20, 0x20	; 32
     a94:	65 e2       	ldi	r22, 0x25	; 37
     a96:	ce 01       	movw	r24, r28
     a98:	e0 df       	rcall	.-64     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a9a:	40 e0       	ldi	r20, 0x00	; 0
     a9c:	66 e2       	ldi	r22, 0x26	; 38
     a9e:	ce 01       	movw	r24, r28
     aa0:	dc df       	rcall	.-72     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     aa2:	1f c0       	rjmp	.+62     	; 0xae2 <_ZN6LSM30313enableDefaultEv+0x74>
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	49 f4       	brne	.+18     	; 0xaba <_ZN6LSM30313enableDefaultEv+0x4c>
     aa8:	48 e0       	ldi	r20, 0x08	; 8
     aaa:	63 e2       	ldi	r22, 0x23	; 35
     aac:	ce 01       	movw	r24, r28
     aae:	95 df       	rcall	.-214    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     ab0:	47 e4       	ldi	r20, 0x47	; 71
     ab2:	60 e2       	ldi	r22, 0x20	; 32
     ab4:	ce 01       	movw	r24, r28
     ab6:	91 df       	rcall	.-222    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     ab8:	08 c0       	rjmp	.+16     	; 0xaca <_ZN6LSM30313enableDefaultEv+0x5c>
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	63 e2       	ldi	r22, 0x23	; 35
     abe:	ce 01       	movw	r24, r28
     ac0:	8c df       	rcall	.-232    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     ac2:	47 e2       	ldi	r20, 0x27	; 39
     ac4:	60 e2       	ldi	r22, 0x20	; 32
     ac6:	ce 01       	movw	r24, r28
     ac8:	88 df       	rcall	.-240    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     aca:	4c e0       	ldi	r20, 0x0C	; 12
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	ce 01       	movw	r24, r28
     ad0:	a4 df       	rcall	.-184    	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     ad2:	40 e2       	ldi	r20, 0x20	; 32
     ad4:	61 e0       	ldi	r22, 0x01	; 1
     ad6:	ce 01       	movw	r24, r28
     ad8:	a0 df       	rcall	.-192    	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     ada:	40 e0       	ldi	r20, 0x00	; 0
     adc:	62 e0       	ldi	r22, 0x02	; 2
     ade:	ce 01       	movw	r24, r28
     ae0:	9c df       	rcall	.-200    	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
     ae8:	9f 92       	push	r9
     aea:	af 92       	push	r10
     aec:	bf 92       	push	r11
     aee:	cf 92       	push	r12
     af0:	df 92       	push	r13
     af2:	ef 92       	push	r14
     af4:	ff 92       	push	r15
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
     b00:	6a 8d       	ldd	r22, Y+26	; 0x1a
     b02:	87 e9       	ldi	r24, 0x97	; 151
     b04:	99 e0       	ldi	r25, 0x09	; 9
     b06:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
     b0a:	e0 91 97 09 	lds	r30, 0x0997
     b0e:	f0 91 98 09 	lds	r31, 0x0998
     b12:	01 90       	ld	r0, Z+
     b14:	f0 81       	ld	r31, Z
     b16:	e0 2d       	mov	r30, r0
     b18:	68 ea       	ldi	r22, 0xA8	; 168
     b1a:	87 e9       	ldi	r24, 0x97	; 151
     b1c:	99 e0       	ldi	r25, 0x09	; 9
     b1e:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
     b20:	87 e9       	ldi	r24, 0x97	; 151
     b22:	99 e0       	ldi	r25, 0x09	; 9
     b24:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     b28:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
     b2a:	46 e0       	ldi	r20, 0x06	; 6
     b2c:	6a 8d       	ldd	r22, Y+26	; 0x1a
     b2e:	87 e9       	ldi	r24, 0x97	; 151
     b30:	99 e0       	ldi	r25, 0x09	; 9
     b32:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     b36:	0e 94 0f 19 	call	0x321e	; 0x321e <millis>
     b3a:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     b3c:	10 c0       	rjmp	.+32     	; 0xb5e <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     b3e:	8b a1       	ldd	r24, Y+35	; 0x23
     b40:	9c a1       	ldd	r25, Y+36	; 0x24
     b42:	89 2b       	or	r24, r25
     b44:	61 f0       	breq	.+24     	; 0xb5e <_ZN6LSM3037readAccEv+0x76>
     b46:	0e 94 0f 19 	call	0x321e	; 0x321e <millis>
     b4a:	60 1b       	sub	r22, r16
     b4c:	71 0b       	sbc	r23, r17
     b4e:	8b a1       	ldd	r24, Y+35	; 0x23
     b50:	9c a1       	ldd	r25, Y+36	; 0x24
     b52:	86 17       	cp	r24, r22
     b54:	97 07       	cpc	r25, r23
     b56:	18 f4       	brcc	.+6      	; 0xb5e <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	8d a3       	std	Y+37, r24	; 0x25
      return;
     b5c:	32 c0       	rjmp	.+100    	; 0xbc2 <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     b5e:	87 e9       	ldi	r24, 0x97	; 151
     b60:	99 e0       	ldi	r25, 0x09	; 9
     b62:	0e 94 cd 11 	call	0x239a	; 0x239a <_ZN7TwoWire9availableEv>
     b66:	06 97       	sbiw	r24, 0x06	; 6
     b68:	54 f3       	brlt	.-44     	; 0xb3e <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
     b6a:	87 e9       	ldi	r24, 0x97	; 151
     b6c:	99 e0       	ldi	r25, 0x09	; 9
     b6e:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     b72:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
     b74:	87 e9       	ldi	r24, 0x97	; 151
     b76:	99 e0       	ldi	r25, 0x09	; 9
     b78:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     b7c:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
     b7e:	87 e9       	ldi	r24, 0x97	; 151
     b80:	99 e0       	ldi	r25, 0x09	; 9
     b82:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     b86:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
     b88:	87 e9       	ldi	r24, 0x97	; 151
     b8a:	99 e0       	ldi	r25, 0x09	; 9
     b8c:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     b90:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
     b92:	87 e9       	ldi	r24, 0x97	; 151
     b94:	99 e0       	ldi	r25, 0x09	; 9
     b96:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     b9a:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
     b9c:	87 e9       	ldi	r24, 0x97	; 151
     b9e:	99 e0       	ldi	r25, 0x09	; 9
     ba0:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
     ba4:	d9 2c       	mov	r13, r9
     ba6:	c1 2c       	mov	r12, r1
     ba8:	ca 28       	or	r12, r10
     baa:	d9 82       	std	Y+1, r13	; 0x01
     bac:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
     bae:	fb 2c       	mov	r15, r11
     bb0:	e1 2c       	mov	r14, r1
     bb2:	e0 2a       	or	r14, r16
     bb4:	fb 82       	std	Y+3, r15	; 0x03
     bb6:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
     bb8:	98 2f       	mov	r25, r24
     bba:	88 27       	eor	r24, r24
     bbc:	81 2b       	or	r24, r17
     bbe:	9d 83       	std	Y+5, r25	; 0x05
     bc0:	8c 83       	std	Y+4, r24	; 0x04
}
     bc2:	df 91       	pop	r29
     bc4:	cf 91       	pop	r28
     bc6:	1f 91       	pop	r17
     bc8:	0f 91       	pop	r16
     bca:	ff 90       	pop	r15
     bcc:	ef 90       	pop	r14
     bce:	df 90       	pop	r13
     bd0:	cf 90       	pop	r12
     bd2:	bf 90       	pop	r11
     bd4:	af 90       	pop	r10
     bd6:	9f 90       	pop	r9
     bd8:	08 95       	ret

00000bda <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
     bec:	6b 8d       	ldd	r22, Y+27	; 0x1b
     bee:	87 e9       	ldi	r24, 0x97	; 151
     bf0:	99 e0       	ldi	r25, 0x09	; 9
     bf2:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
     bf6:	89 8d       	ldd	r24, Y+25	; 0x19
     bf8:	83 30       	cpi	r24, 0x03	; 3
     bfa:	31 f4       	brne	.+12     	; 0xc08 <_ZN6LSM3037readMagEv+0x2e>
     bfc:	6e 8d       	ldd	r22, Y+30	; 0x1e
     bfe:	77 27       	eor	r23, r23
     c00:	67 fd       	sbrc	r22, 7
     c02:	70 95       	com	r23
     c04:	60 68       	ori	r22, 0x80	; 128
     c06:	04 c0       	rjmp	.+8      	; 0xc10 <_ZN6LSM3037readMagEv+0x36>
     c08:	6d 8d       	ldd	r22, Y+29	; 0x1d
     c0a:	77 27       	eor	r23, r23
     c0c:	67 fd       	sbrc	r22, 7
     c0e:	70 95       	com	r23
     c10:	e0 91 97 09 	lds	r30, 0x0997
     c14:	f0 91 98 09 	lds	r31, 0x0998
     c18:	01 90       	ld	r0, Z+
     c1a:	f0 81       	ld	r31, Z
     c1c:	e0 2d       	mov	r30, r0
     c1e:	87 e9       	ldi	r24, 0x97	; 151
     c20:	99 e0       	ldi	r25, 0x09	; 9
     c22:	19 95       	eicall
  last_status = Wire.endTransmission();
     c24:	87 e9       	ldi	r24, 0x97	; 151
     c26:	99 e0       	ldi	r25, 0x09	; 9
     c28:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     c2c:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
     c2e:	46 e0       	ldi	r20, 0x06	; 6
     c30:	6b 8d       	ldd	r22, Y+27	; 0x1b
     c32:	87 e9       	ldi	r24, 0x97	; 151
     c34:	99 e0       	ldi	r25, 0x09	; 9
     c36:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     c3a:	0e 94 0f 19 	call	0x321e	; 0x321e <millis>
     c3e:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     c40:	10 c0       	rjmp	.+32     	; 0xc62 <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     c42:	8b a1       	ldd	r24, Y+35	; 0x23
     c44:	9c a1       	ldd	r25, Y+36	; 0x24
     c46:	89 2b       	or	r24, r25
     c48:	61 f0       	breq	.+24     	; 0xc62 <_ZN6LSM3037readMagEv+0x88>
     c4a:	0e 94 0f 19 	call	0x321e	; 0x321e <millis>
     c4e:	60 1b       	sub	r22, r16
     c50:	71 0b       	sbc	r23, r17
     c52:	8b a1       	ldd	r24, Y+35	; 0x23
     c54:	9c a1       	ldd	r25, Y+36	; 0x24
     c56:	86 17       	cp	r24, r22
     c58:	97 07       	cpc	r25, r23
     c5a:	18 f4       	brcc	.+6      	; 0xc62 <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	8d a3       	std	Y+37, r24	; 0x25
      return;
     c60:	6e c0       	rjmp	.+220    	; 0xd3e <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     c62:	87 e9       	ldi	r24, 0x97	; 151
     c64:	99 e0       	ldi	r25, 0x09	; 9
     c66:	0e 94 cd 11 	call	0x239a	; 0x239a <_ZN7TwoWire9availableEv>
     c6a:	06 97       	sbiw	r24, 0x06	; 6
     c6c:	54 f3       	brlt	.-44     	; 0xc42 <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
     c6e:	89 8d       	ldd	r24, Y+25	; 0x19
     c70:	83 30       	cpi	r24, 0x03	; 3
     c72:	f9 f4       	brne	.+62     	; 0xcb2 <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
     c74:	87 e9       	ldi	r24, 0x97	; 151
     c76:	99 e0       	ldi	r25, 0x09	; 9
     c78:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     c7c:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
     c7e:	87 e9       	ldi	r24, 0x97	; 151
     c80:	99 e0       	ldi	r25, 0x09	; 9
     c82:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     c86:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
     c88:	87 e9       	ldi	r24, 0x97	; 151
     c8a:	99 e0       	ldi	r25, 0x09	; 9
     c8c:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     c90:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
     c92:	87 e9       	ldi	r24, 0x97	; 151
     c94:	99 e0       	ldi	r25, 0x09	; 9
     c96:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     c9a:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
     c9c:	87 e9       	ldi	r24, 0x97	; 151
     c9e:	99 e0       	ldi	r25, 0x09	; 9
     ca0:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     ca4:	08 2f       	mov	r16, r24
    zhm = Wire.read();
     ca6:	87 e9       	ldi	r24, 0x97	; 151
     ca8:	99 e0       	ldi	r25, 0x09	; 9
     caa:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cae:	18 2f       	mov	r17, r24
     cb0:	36 c0       	rjmp	.+108    	; 0xd1e <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
     cb2:	87 e9       	ldi	r24, 0x97	; 151
     cb4:	99 e0       	ldi	r25, 0x09	; 9
     cb6:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cba:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
     cbc:	87 e9       	ldi	r24, 0x97	; 151
     cbe:	99 e0       	ldi	r25, 0x09	; 9
     cc0:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cc4:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
     cc6:	89 8d       	ldd	r24, Y+25	; 0x19
     cc8:	81 11       	cpse	r24, r1
     cca:	15 c0       	rjmp	.+42     	; 0xcf6 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
     ccc:	87 e9       	ldi	r24, 0x97	; 151
     cce:	99 e0       	ldi	r25, 0x09	; 9
     cd0:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cd4:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
     cd6:	87 e9       	ldi	r24, 0x97	; 151
     cd8:	99 e0       	ldi	r25, 0x09	; 9
     cda:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cde:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
     ce0:	87 e9       	ldi	r24, 0x97	; 151
     ce2:	99 e0       	ldi	r25, 0x09	; 9
     ce4:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     ce8:	18 2f       	mov	r17, r24
      zlm = Wire.read();
     cea:	87 e9       	ldi	r24, 0x97	; 151
     cec:	99 e0       	ldi	r25, 0x09	; 9
     cee:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cf2:	08 2f       	mov	r16, r24
     cf4:	14 c0       	rjmp	.+40     	; 0xd1e <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
     cf6:	87 e9       	ldi	r24, 0x97	; 151
     cf8:	99 e0       	ldi	r25, 0x09	; 9
     cfa:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     cfe:	18 2f       	mov	r17, r24
      zlm = Wire.read();
     d00:	87 e9       	ldi	r24, 0x97	; 151
     d02:	99 e0       	ldi	r25, 0x09	; 9
     d04:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     d08:	08 2f       	mov	r16, r24
      yhm = Wire.read();
     d0a:	87 e9       	ldi	r24, 0x97	; 151
     d0c:	99 e0       	ldi	r25, 0x09	; 9
     d0e:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     d12:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
     d14:	87 e9       	ldi	r24, 0x97	; 151
     d16:	99 e0       	ldi	r25, 0x09	; 9
     d18:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     d1c:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
     d1e:	6c 2d       	mov	r22, r12
     d20:	70 e0       	ldi	r23, 0x00	; 0
     d22:	7d 29       	or	r23, r13
     d24:	7f 83       	std	Y+7, r23	; 0x07
     d26:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
     d28:	4e 2d       	mov	r20, r14
     d2a:	50 e0       	ldi	r21, 0x00	; 0
     d2c:	5f 29       	or	r21, r15
     d2e:	59 87       	std	Y+9, r21	; 0x09
     d30:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
     d32:	20 2f       	mov	r18, r16
     d34:	30 e0       	ldi	r19, 0x00	; 0
     d36:	c9 01       	movw	r24, r18
     d38:	91 2b       	or	r25, r17
     d3a:	9b 87       	std	Y+11, r25	; 0x0b
     d3c:	8a 87       	std	Y+10, r24	; 0x0a
}
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	ff 90       	pop	r15
     d48:	ef 90       	pop	r14
     d4a:	df 90       	pop	r13
     d4c:	cf 90       	pop	r12
     d4e:	08 95       	ret

00000d50 <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	ec 01       	movw	r28, r24
  readAcc();
     d56:	c8 de       	rcall	.-624    	; 0xae8 <_ZN6LSM3037readAccEv>
  readMag();
     d58:	ce 01       	movw	r24, r28
     d5a:	3f df       	rcall	.-386    	; 0xbda <_ZN6LSM3037readMagEv>
}
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	08 95       	ret

00000d62 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
     d62:	cf 93       	push	r28
     d64:	df 93       	push	r29
     d66:	c6 2f       	mov	r28, r22
     d68:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     d6a:	87 e9       	ldi	r24, 0x97	; 151
     d6c:	99 e0       	ldi	r25, 0x09	; 9
     d6e:	0e 94 80 12 	call	0x2500	; 0x2500 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     d72:	6d 2f       	mov	r22, r29
     d74:	87 e9       	ldi	r24, 0x97	; 151
     d76:	99 e0       	ldi	r25, 0x09	; 9
     d78:	0e 94 27 12 	call	0x244e	; 0x244e <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     d7c:	87 e9       	ldi	r24, 0x97	; 151
     d7e:	99 e0       	ldi	r25, 0x09	; 9
     d80:	0e 94 9c 12 	call	0x2538	; 0x2538 <_ZN7TwoWire15endTransmissionEv>
     d84:	81 11       	cpse	r24, r1
     d86:	11 c0       	rjmp	.+34     	; 0xdaa <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     d88:	41 e0       	ldi	r20, 0x01	; 1
     d8a:	6c 2f       	mov	r22, r28
     d8c:	87 e9       	ldi	r24, 0x97	; 151
     d8e:	99 e0       	ldi	r25, 0x09	; 9
     d90:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     d94:	87 e9       	ldi	r24, 0x97	; 151
     d96:	99 e0       	ldi	r25, 0x09	; 9
     d98:	0e 94 cd 11 	call	0x239a	; 0x239a <_ZN7TwoWire9availableEv>
     d9c:	89 2b       	or	r24, r25
     d9e:	41 f0       	breq	.+16     	; 0xdb0 <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     da0:	87 e9       	ldi	r24, 0x97	; 151
     da2:	99 e0       	ldi	r25, 0x09	; 9
     da4:	0e 94 d5 11 	call	0x23aa	; 0x23aa <_ZN7TwoWire4readEv>
     da8:	05 c0       	rjmp	.+10     	; 0xdb4 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     daa:	8f ef       	ldi	r24, 0xFF	; 255
     dac:	9f ef       	ldi	r25, 0xFF	; 255
     dae:	02 c0       	rjmp	.+4      	; 0xdb4 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     db0:	8f ef       	ldi	r24, 0xFF	; 255
     db2:	9f ef       	ldi	r25, 0xFF	; 255
  }
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	08 95       	ret

00000dba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
     dba:	0f 93       	push	r16
     dbc:	1f 93       	push	r17
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	ec 01       	movw	r28, r24
     dc4:	16 2f       	mov	r17, r22
     dc6:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     dc8:	64 30       	cpi	r22, 0x04	; 4
     dca:	09 f4       	brne	.+2      	; 0xdce <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
     dcc:	ad c0       	rjmp	.+346    	; 0xf28 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
     dce:	42 30       	cpi	r20, 0x02	; 2
     dd0:	09 f0       	breq	.+2      	; 0xdd4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
     dd2:	47 c0       	rjmp	.+142    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     dd4:	ad c0       	rjmp	.+346    	; 0xf30 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     dd6:	4f e0       	ldi	r20, 0x0F	; 15
     dd8:	6d e1       	ldi	r22, 0x1D	; 29
     dda:	ce 01       	movw	r24, r28
     ddc:	c2 df       	rcall	.-124    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     dde:	89 34       	cpi	r24, 0x49	; 73
     de0:	91 05       	cpc	r25, r1
     de2:	09 f4       	brne	.+2      	; 0xde6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
     de4:	ab c0       	rjmp	.+342    	; 0xf3c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
     de6:	01 30       	cpi	r16, 0x01	; 1
     de8:	41 f0       	breq	.+16     	; 0xdfa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     dea:	4f e0       	ldi	r20, 0x0F	; 15
     dec:	6e e1       	ldi	r22, 0x1E	; 30
     dee:	ce 01       	movw	r24, r28
     df0:	b8 df       	rcall	.-144    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     df2:	89 34       	cpi	r24, 0x49	; 73
     df4:	91 05       	cpc	r25, r1
     df6:	09 f4       	brne	.+2      	; 0xdfa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     df8:	a3 c0       	rjmp	.+326    	; 0xf40 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
     dfa:	14 30       	cpi	r17, 0x04	; 4
     dfc:	11 f0       	breq	.+4      	; 0xe02 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
     dfe:	13 30       	cpi	r17, 0x03	; 3
     e00:	68 f5       	brcc	.+90     	; 0xe5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     e02:	00 23       	and	r16, r16
     e04:	a9 f0       	breq	.+42     	; 0xe30 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
     e06:	40 e2       	ldi	r20, 0x20	; 32
     e08:	69 e1       	ldi	r22, 0x19	; 25
     e0a:	ce 01       	movw	r24, r28
     e0c:	aa df       	rcall	.-172    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e0e:	01 96       	adiw	r24, 0x01	; 1
     e10:	69 f0       	breq	.+26     	; 0xe2c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
     e12:	14 30       	cpi	r17, 0x04	; 4
     e14:	09 f0       	breq	.+2      	; 0xe18 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
     e16:	99 c0       	rjmp	.+306    	; 0xf4a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     e18:	4f e0       	ldi	r20, 0x0F	; 15
     e1a:	6e e1       	ldi	r22, 0x1E	; 30
     e1c:	ce 01       	movw	r24, r28
     e1e:	a1 df       	rcall	.-190    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e20:	cc 97       	sbiw	r24, 0x3c	; 60
     e22:	09 f0       	breq	.+2      	; 0xe26 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
     e24:	94 c0       	rjmp	.+296    	; 0xf4e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     e26:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     e28:	12 e0       	ldi	r17, 0x02	; 2
     e2a:	1b c0       	rjmp	.+54     	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     e2c:	01 30       	cpi	r16, 0x01	; 1
     e2e:	99 f0       	breq	.+38     	; 0xe56 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
     e30:	40 e2       	ldi	r20, 0x20	; 32
     e32:	68 e1       	ldi	r22, 0x18	; 24
     e34:	ce 01       	movw	r24, r28
     e36:	95 df       	rcall	.-214    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e38:	01 96       	adiw	r24, 0x01	; 1
     e3a:	69 f0       	breq	.+26     	; 0xe56 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
     e3c:	14 30       	cpi	r17, 0x04	; 4
     e3e:	09 f0       	breq	.+2      	; 0xe42 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
     e40:	89 c0       	rjmp	.+274    	; 0xf54 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
     e42:	4f e0       	ldi	r20, 0x0F	; 15
     e44:	6e e1       	ldi	r22, 0x1E	; 30
     e46:	ce 01       	movw	r24, r28
     e48:	8c df       	rcall	.-232    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e4a:	11 e0       	ldi	r17, 0x01	; 1
     e4c:	cc 97       	sbiw	r24, 0x3c	; 60
     e4e:	09 f0       	breq	.+2      	; 0xe52 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
     e50:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     e52:	00 e0       	ldi	r16, 0x00	; 0
     e54:	06 c0       	rjmp	.+12     	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     e56:	14 30       	cpi	r17, 0x04	; 4
     e58:	09 f4       	brne	.+2      	; 0xe5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
     e5a:	60 c0       	rjmp	.+192    	; 0xf1c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
     e5c:	02 30       	cpi	r16, 0x02	; 2
     e5e:	09 f4       	brne	.+2      	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     e60:	5f c0       	rjmp	.+190    	; 0xf20 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
     e62:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
     e64:	11 30       	cpi	r17, 0x01	; 1
     e66:	71 f1       	breq	.+92     	; 0xec4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
     e68:	08 f4       	brcc	.+2      	; 0xe6c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
     e6a:	42 c0       	rjmp	.+132    	; 0xef0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
     e6c:	12 30       	cpi	r17, 0x02	; 2
     e6e:	c1 f0       	breq	.+48     	; 0xea0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
     e70:	13 30       	cpi	r17, 0x03	; 3
     e72:	09 f0       	breq	.+2      	; 0xe76 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
     e74:	57 c0       	rjmp	.+174    	; 0xf24 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
     e76:	01 30       	cpi	r16, 0x01	; 1
     e78:	11 f4       	brne	.+4      	; 0xe7e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
     e7a:	8d e1       	ldi	r24, 0x1D	; 29
     e7c:	01 c0       	rjmp	.+2      	; 0xe80 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
     e7e:	8e e1       	ldi	r24, 0x1E	; 30
     e80:	8b 8f       	std	Y+27, r24	; 0x1b
     e82:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
     e84:	88 e0       	ldi	r24, 0x08	; 8
     e86:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
     e88:	89 e0       	ldi	r24, 0x09	; 9
     e8a:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
     e8c:	8a e0       	ldi	r24, 0x0A	; 10
     e8e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
     e90:	8b e0       	ldi	r24, 0x0B	; 11
     e92:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
     e94:	8c e0       	ldi	r24, 0x0C	; 12
     e96:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
     e98:	8d e0       	ldi	r24, 0x0D	; 13
     e9a:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     e9c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
     e9e:	64 c0       	rjmp	.+200    	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
     ea0:	89 e1       	ldi	r24, 0x19	; 25
     ea2:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     ea4:	8e e1       	ldi	r24, 0x1E	; 30
     ea6:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
     ea8:	83 e0       	ldi	r24, 0x03	; 3
     eaa:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
     eac:	84 e0       	ldi	r24, 0x04	; 4
     eae:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
     eb0:	87 e0       	ldi	r24, 0x07	; 7
     eb2:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
     eb4:	88 e0       	ldi	r24, 0x08	; 8
     eb6:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
     eb8:	85 e0       	ldi	r24, 0x05	; 5
     eba:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
     ebc:	86 e0       	ldi	r24, 0x06	; 6
     ebe:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     ec0:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
     ec2:	52 c0       	rjmp	.+164    	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     ec4:	01 30       	cpi	r16, 0x01	; 1
     ec6:	11 f4       	brne	.+4      	; 0xecc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
     ec8:	89 e1       	ldi	r24, 0x19	; 25
     eca:	01 c0       	rjmp	.+2      	; 0xece <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
     ecc:	88 e1       	ldi	r24, 0x18	; 24
     ece:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     ed0:	8e e1       	ldi	r24, 0x1E	; 30
     ed2:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
     ed4:	83 e0       	ldi	r24, 0x03	; 3
     ed6:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
     ed8:	84 e0       	ldi	r24, 0x04	; 4
     eda:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
     edc:	87 e0       	ldi	r24, 0x07	; 7
     ede:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
     ee0:	88 e0       	ldi	r24, 0x08	; 8
     ee2:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
     ee4:	85 e0       	ldi	r24, 0x05	; 5
     ee6:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
     ee8:	86 e0       	ldi	r24, 0x06	; 6
     eea:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     eec:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
     eee:	3c c0       	rjmp	.+120    	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     ef0:	01 30       	cpi	r16, 0x01	; 1
     ef2:	11 f4       	brne	.+4      	; 0xef8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
     ef4:	89 e1       	ldi	r24, 0x19	; 25
     ef6:	01 c0       	rjmp	.+2      	; 0xefa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
     ef8:	88 e1       	ldi	r24, 0x18	; 24
     efa:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     efc:	8e e1       	ldi	r24, 0x1E	; 30
     efe:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
     f00:	83 e0       	ldi	r24, 0x03	; 3
     f02:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
     f04:	84 e0       	ldi	r24, 0x04	; 4
     f06:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
     f08:	85 e0       	ldi	r24, 0x05	; 5
     f0a:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
     f0c:	86 e0       	ldi	r24, 0x06	; 6
     f0e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
     f10:	87 e0       	ldi	r24, 0x07	; 7
     f12:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
     f14:	88 e0       	ldi	r24, 0x08	; 8
     f16:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
     f18:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
     f1a:	26 c0       	rjmp	.+76     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	24 c0       	rjmp	.+72     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
     f20:	80 e0       	ldi	r24, 0x00	; 0
     f22:	22 c0       	rjmp	.+68     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	20 c0       	rjmp	.+64     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     f28:	44 23       	and	r20, r20
     f2a:	09 f4       	brne	.+2      	; 0xf2e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
     f2c:	5e cf       	rjmp	.-324    	; 0xdea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
     f2e:	53 cf       	rjmp	.-346    	; 0xdd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
     f30:	8d ef       	ldi	r24, 0xFD	; 253
     f32:	86 0f       	add	r24, r22
     f34:	82 30       	cpi	r24, 0x02	; 2
     f36:	08 f0       	brcs	.+2      	; 0xf3a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
     f38:	62 cf       	rjmp	.-316    	; 0xdfe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
     f3a:	0e c0       	rjmp	.+28     	; 0xf58 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     f3c:	01 e0       	ldi	r16, 0x01	; 1
     f3e:	03 c0       	rjmp	.+6      	; 0xf46 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
     f40:	00 e0       	ldi	r16, 0x00	; 0
     f42:	01 c0       	rjmp	.+2      	; 0xf46 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     f44:	01 e0       	ldi	r16, 0x01	; 1
     f46:	13 e0       	ldi	r17, 0x03	; 3
     f48:	89 cf       	rjmp	.-238    	; 0xe5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     f4a:	01 e0       	ldi	r16, 0x01	; 1
     f4c:	8a cf       	rjmp	.-236    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     f4e:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     f50:	10 e0       	ldi	r17, 0x00	; 0
     f52:	87 cf       	rjmp	.-242    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     f54:	00 e0       	ldi	r16, 0x00	; 0
     f56:	85 cf       	rjmp	.-246    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     f58:	4f e0       	ldi	r20, 0x0F	; 15
     f5a:	6d e1       	ldi	r22, 0x1D	; 29
     f5c:	ce 01       	movw	r24, r28
     f5e:	01 df       	rcall	.-510    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     f60:	89 34       	cpi	r24, 0x49	; 73
     f62:	91 05       	cpc	r25, r1
     f64:	79 f3       	breq	.-34     	; 0xf44 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
     f66:	41 cf       	rjmp	.-382    	; 0xdea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
     f68:	df 91       	pop	r29
     f6a:	cf 91       	pop	r28
     f6c:	1f 91       	pop	r17
     f6e:	0f 91       	pop	r16
     f70:	08 95       	ret

00000f72 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f72:	31 e1       	ldi	r19, 0x11	; 17
     f74:	fc 01       	movw	r30, r24
     f76:	30 83       	st	Z, r19
     f78:	31 97       	sbiw	r30, 0x01	; 1
     f7a:	22 e2       	ldi	r18, 0x22	; 34
     f7c:	20 83       	st	Z, r18
     f7e:	31 97       	sbiw	r30, 0x01	; 1
     f80:	a3 e3       	ldi	r26, 0x33	; 51
     f82:	a0 83       	st	Z, r26
     f84:	31 97       	sbiw	r30, 0x01	; 1
     f86:	60 83       	st	Z, r22
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	70 83       	st	Z, r23
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	10 82       	st	Z, r1
     f90:	31 97       	sbiw	r30, 0x01	; 1
     f92:	10 82       	st	Z, r1
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	60 e8       	ldi	r22, 0x80	; 128
     f98:	60 83       	st	Z, r22
     f9a:	31 97       	sbiw	r30, 0x01	; 1
     f9c:	10 82       	st	Z, r1
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	10 82       	st	Z, r1
     fa2:	31 97       	sbiw	r30, 0x01	; 1
     fa4:	10 82       	st	Z, r1
     fa6:	31 97       	sbiw	r30, 0x01	; 1
     fa8:	62 e0       	ldi	r22, 0x02	; 2
     faa:	60 83       	st	Z, r22
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	63 e0       	ldi	r22, 0x03	; 3
     fb0:	60 83       	st	Z, r22
     fb2:	31 97       	sbiw	r30, 0x01	; 1
     fb4:	64 e0       	ldi	r22, 0x04	; 4
     fb6:	60 83       	st	Z, r22
     fb8:	31 97       	sbiw	r30, 0x01	; 1
     fba:	65 e0       	ldi	r22, 0x05	; 5
     fbc:	60 83       	st	Z, r22
     fbe:	31 97       	sbiw	r30, 0x01	; 1
     fc0:	66 e0       	ldi	r22, 0x06	; 6
     fc2:	60 83       	st	Z, r22
     fc4:	31 97       	sbiw	r30, 0x01	; 1
     fc6:	67 e0       	ldi	r22, 0x07	; 7
     fc8:	60 83       	st	Z, r22
     fca:	31 97       	sbiw	r30, 0x01	; 1
     fcc:	68 e0       	ldi	r22, 0x08	; 8
     fce:	60 83       	st	Z, r22
     fd0:	31 97       	sbiw	r30, 0x01	; 1
     fd2:	69 e0       	ldi	r22, 0x09	; 9
     fd4:	60 83       	st	Z, r22
     fd6:	31 97       	sbiw	r30, 0x01	; 1
     fd8:	60 e1       	ldi	r22, 0x10	; 16
     fda:	60 83       	st	Z, r22
     fdc:	31 97       	sbiw	r30, 0x01	; 1
     fde:	30 83       	st	Z, r19
     fe0:	31 97       	sbiw	r30, 0x01	; 1
     fe2:	32 e1       	ldi	r19, 0x12	; 18
     fe4:	30 83       	st	Z, r19
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	33 e1       	ldi	r19, 0x13	; 19
     fea:	30 83       	st	Z, r19
     fec:	31 97       	sbiw	r30, 0x01	; 1
     fee:	34 e1       	ldi	r19, 0x14	; 20
     ff0:	30 83       	st	Z, r19
     ff2:	31 97       	sbiw	r30, 0x01	; 1
     ff4:	35 e1       	ldi	r19, 0x15	; 21
     ff6:	30 83       	st	Z, r19
     ff8:	31 97       	sbiw	r30, 0x01	; 1
     ffa:	36 e1       	ldi	r19, 0x16	; 22
     ffc:	30 83       	st	Z, r19
     ffe:	31 97       	sbiw	r30, 0x01	; 1
    1000:	37 e1       	ldi	r19, 0x17	; 23
    1002:	30 83       	st	Z, r19
    1004:	31 97       	sbiw	r30, 0x01	; 1
    1006:	38 e1       	ldi	r19, 0x18	; 24
    1008:	30 83       	st	Z, r19
    100a:	31 97       	sbiw	r30, 0x01	; 1
    100c:	39 e1       	ldi	r19, 0x19	; 25
    100e:	30 83       	st	Z, r19
    1010:	31 97       	sbiw	r30, 0x01	; 1
    1012:	30 e2       	ldi	r19, 0x20	; 32
    1014:	30 83       	st	Z, r19
    1016:	31 97       	sbiw	r30, 0x01	; 1
    1018:	31 e2       	ldi	r19, 0x21	; 33
    101a:	30 83       	st	Z, r19
    101c:	31 97       	sbiw	r30, 0x01	; 1
    101e:	20 83       	st	Z, r18
    1020:	31 97       	sbiw	r30, 0x01	; 1
    1022:	23 e2       	ldi	r18, 0x23	; 35
    1024:	20 83       	st	Z, r18
    1026:	31 97       	sbiw	r30, 0x01	; 1
    1028:	40 83       	st	Z, r20
    102a:	31 97       	sbiw	r30, 0x01	; 1
    102c:	50 83       	st	Z, r21
    102e:	31 97       	sbiw	r30, 0x01	; 1
    1030:	26 e2       	ldi	r18, 0x26	; 38
    1032:	20 83       	st	Z, r18
    1034:	31 97       	sbiw	r30, 0x01	; 1
    1036:	27 e2       	ldi	r18, 0x27	; 39
    1038:	20 83       	st	Z, r18
    103a:	31 97       	sbiw	r30, 0x01	; 1
    103c:	28 e2       	ldi	r18, 0x28	; 40
    103e:	20 83       	st	Z, r18
    1040:	31 97       	sbiw	r30, 0x01	; 1
    1042:	29 e2       	ldi	r18, 0x29	; 41
    1044:	20 83       	st	Z, r18
    1046:	31 97       	sbiw	r30, 0x01	; 1
    1048:	20 e3       	ldi	r18, 0x30	; 48
    104a:	20 83       	st	Z, r18
    104c:	31 97       	sbiw	r30, 0x01	; 1
    104e:	21 e3       	ldi	r18, 0x31	; 49
    1050:	20 83       	st	Z, r18
    1052:	89 97       	sbiw	r24, 0x29	; 41
    1054:	08 95       	ret

00001056 <xPortStartScheduler>:
    1056:	82 e0       	ldi	r24, 0x02	; 2
    1058:	80 93 b0 00 	sts	0x00B0, r24
    105c:	10 92 b2 00 	sts	0x00B2, r1
    1060:	80 e3       	ldi	r24, 0x30	; 48
    1062:	80 93 b3 00 	sts	0x00B3, r24
    1066:	e0 e7       	ldi	r30, 0x70	; 112
    1068:	f0 e0       	ldi	r31, 0x00	; 0
    106a:	80 81       	ld	r24, Z
    106c:	82 60       	ori	r24, 0x02	; 2
    106e:	80 83       	st	Z, r24
    1070:	84 e0       	ldi	r24, 0x04	; 4
    1072:	80 93 b1 00 	sts	0x00B1, r24
    1076:	a0 91 27 09 	lds	r26, 0x0927
    107a:	b0 91 28 09 	lds	r27, 0x0928
    107e:	cd 91       	ld	r28, X+
    1080:	cd bf       	out	0x3d, r28	; 61
    1082:	dd 91       	ld	r29, X+
    1084:	de bf       	out	0x3e, r29	; 62
    1086:	ff 91       	pop	r31
    1088:	ef 91       	pop	r30
    108a:	df 91       	pop	r29
    108c:	cf 91       	pop	r28
    108e:	bf 91       	pop	r27
    1090:	af 91       	pop	r26
    1092:	9f 91       	pop	r25
    1094:	8f 91       	pop	r24
    1096:	7f 91       	pop	r23
    1098:	6f 91       	pop	r22
    109a:	5f 91       	pop	r21
    109c:	4f 91       	pop	r20
    109e:	3f 91       	pop	r19
    10a0:	2f 91       	pop	r18
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
    10a6:	ff 90       	pop	r15
    10a8:	ef 90       	pop	r14
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	bf 90       	pop	r11
    10b0:	af 90       	pop	r10
    10b2:	9f 90       	pop	r9
    10b4:	8f 90       	pop	r8
    10b6:	7f 90       	pop	r7
    10b8:	6f 90       	pop	r6
    10ba:	5f 90       	pop	r5
    10bc:	4f 90       	pop	r4
    10be:	3f 90       	pop	r3
    10c0:	2f 90       	pop	r2
    10c2:	1f 90       	pop	r1
    10c4:	0f 90       	pop	r0
    10c6:	0c be       	out	0x3c, r0	; 60
    10c8:	0f 90       	pop	r0
    10ca:	0b be       	out	0x3b, r0	; 59
    10cc:	0f 90       	pop	r0
    10ce:	0f be       	out	0x3f, r0	; 63
    10d0:	0f 90       	pop	r0
    10d2:	08 95       	ret
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	08 95       	ret

000010d8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    10d8:	0f 92       	push	r0
    10da:	0f b6       	in	r0, 0x3f	; 63
    10dc:	f8 94       	cli
    10de:	0f 92       	push	r0
    10e0:	0c b6       	in	r0, 0x3c	; 60
    10e2:	0f 92       	push	r0
    10e4:	0b b6       	in	r0, 0x3b	; 59
    10e6:	0f 92       	push	r0
    10e8:	1f 92       	push	r1
    10ea:	11 24       	eor	r1, r1
    10ec:	2f 92       	push	r2
    10ee:	3f 92       	push	r3
    10f0:	4f 92       	push	r4
    10f2:	5f 92       	push	r5
    10f4:	6f 92       	push	r6
    10f6:	7f 92       	push	r7
    10f8:	8f 92       	push	r8
    10fa:	9f 92       	push	r9
    10fc:	af 92       	push	r10
    10fe:	bf 92       	push	r11
    1100:	cf 92       	push	r12
    1102:	df 92       	push	r13
    1104:	ef 92       	push	r14
    1106:	ff 92       	push	r15
    1108:	0f 93       	push	r16
    110a:	1f 93       	push	r17
    110c:	2f 93       	push	r18
    110e:	3f 93       	push	r19
    1110:	4f 93       	push	r20
    1112:	5f 93       	push	r21
    1114:	6f 93       	push	r22
    1116:	7f 93       	push	r23
    1118:	8f 93       	push	r24
    111a:	9f 93       	push	r25
    111c:	af 93       	push	r26
    111e:	bf 93       	push	r27
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	ef 93       	push	r30
    1126:	ff 93       	push	r31
    1128:	a0 91 27 09 	lds	r26, 0x0927
    112c:	b0 91 28 09 	lds	r27, 0x0928
    1130:	0d b6       	in	r0, 0x3d	; 61
    1132:	0d 92       	st	X+, r0
    1134:	0e b6       	in	r0, 0x3e	; 62
    1136:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1138:	bd d6       	rcall	.+3450   	; 0x1eb4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    113a:	a0 91 27 09 	lds	r26, 0x0927
    113e:	b0 91 28 09 	lds	r27, 0x0928
    1142:	cd 91       	ld	r28, X+
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	dd 91       	ld	r29, X+
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	ff 91       	pop	r31
    114c:	ef 91       	pop	r30
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	bf 91       	pop	r27
    1154:	af 91       	pop	r26
    1156:	9f 91       	pop	r25
    1158:	8f 91       	pop	r24
    115a:	7f 91       	pop	r23
    115c:	6f 91       	pop	r22
    115e:	5f 91       	pop	r21
    1160:	4f 91       	pop	r20
    1162:	3f 91       	pop	r19
    1164:	2f 91       	pop	r18
    1166:	1f 91       	pop	r17
    1168:	0f 91       	pop	r16
    116a:	ff 90       	pop	r15
    116c:	ef 90       	pop	r14
    116e:	df 90       	pop	r13
    1170:	cf 90       	pop	r12
    1172:	bf 90       	pop	r11
    1174:	af 90       	pop	r10
    1176:	9f 90       	pop	r9
    1178:	8f 90       	pop	r8
    117a:	7f 90       	pop	r7
    117c:	6f 90       	pop	r6
    117e:	5f 90       	pop	r5
    1180:	4f 90       	pop	r4
    1182:	3f 90       	pop	r3
    1184:	2f 90       	pop	r2
    1186:	1f 90       	pop	r1
    1188:	0f 90       	pop	r0
    118a:	0c be       	out	0x3c, r0	; 60
    118c:	0f 90       	pop	r0
    118e:	0b be       	out	0x3b, r0	; 59
    1190:	0f 90       	pop	r0
    1192:	0f be       	out	0x3f, r0	; 63
    1194:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1196:	08 95       	ret

00001198 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1198:	0f 92       	push	r0
    119a:	0f b6       	in	r0, 0x3f	; 63
    119c:	f8 94       	cli
    119e:	0f 92       	push	r0
    11a0:	0c b6       	in	r0, 0x3c	; 60
    11a2:	0f 92       	push	r0
    11a4:	0b b6       	in	r0, 0x3b	; 59
    11a6:	0f 92       	push	r0
    11a8:	1f 92       	push	r1
    11aa:	11 24       	eor	r1, r1
    11ac:	2f 92       	push	r2
    11ae:	3f 92       	push	r3
    11b0:	4f 92       	push	r4
    11b2:	5f 92       	push	r5
    11b4:	6f 92       	push	r6
    11b6:	7f 92       	push	r7
    11b8:	8f 92       	push	r8
    11ba:	9f 92       	push	r9
    11bc:	af 92       	push	r10
    11be:	bf 92       	push	r11
    11c0:	cf 92       	push	r12
    11c2:	df 92       	push	r13
    11c4:	ef 92       	push	r14
    11c6:	ff 92       	push	r15
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	2f 93       	push	r18
    11ce:	3f 93       	push	r19
    11d0:	4f 93       	push	r20
    11d2:	5f 93       	push	r21
    11d4:	6f 93       	push	r22
    11d6:	7f 93       	push	r23
    11d8:	8f 93       	push	r24
    11da:	9f 93       	push	r25
    11dc:	af 93       	push	r26
    11de:	bf 93       	push	r27
    11e0:	cf 93       	push	r28
    11e2:	df 93       	push	r29
    11e4:	ef 93       	push	r30
    11e6:	ff 93       	push	r31
    11e8:	a0 91 27 09 	lds	r26, 0x0927
    11ec:	b0 91 28 09 	lds	r27, 0x0928
    11f0:	0d b6       	in	r0, 0x3d	; 61
    11f2:	0d 92       	st	X+, r0
    11f4:	0e b6       	in	r0, 0x3e	; 62
    11f6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    11f8:	c9 d4       	rcall	.+2450   	; 0x1b8c <xTaskIncrementTick>
    11fa:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    11fc:	5b d6       	rcall	.+3254   	; 0x1eb4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    11fe:	a0 91 27 09 	lds	r26, 0x0927
    1202:	b0 91 28 09 	lds	r27, 0x0928
    1206:	cd 91       	ld	r28, X+
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	dd 91       	ld	r29, X+
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	ff 91       	pop	r31
    1210:	ef 91       	pop	r30
    1212:	df 91       	pop	r29
    1214:	cf 91       	pop	r28
    1216:	bf 91       	pop	r27
    1218:	af 91       	pop	r26
    121a:	9f 91       	pop	r25
    121c:	8f 91       	pop	r24
    121e:	7f 91       	pop	r23
    1220:	6f 91       	pop	r22
    1222:	5f 91       	pop	r21
    1224:	4f 91       	pop	r20
    1226:	3f 91       	pop	r19
    1228:	2f 91       	pop	r18
    122a:	1f 91       	pop	r17
    122c:	0f 91       	pop	r16
    122e:	ff 90       	pop	r15
    1230:	ef 90       	pop	r14
    1232:	df 90       	pop	r13
    1234:	cf 90       	pop	r12
    1236:	bf 90       	pop	r11
    1238:	af 90       	pop	r10
    123a:	9f 90       	pop	r9
    123c:	8f 90       	pop	r8
    123e:	7f 90       	pop	r7
    1240:	6f 90       	pop	r6
    1242:	5f 90       	pop	r5
    1244:	4f 90       	pop	r4
    1246:	3f 90       	pop	r3
    1248:	2f 90       	pop	r2
    124a:	1f 90       	pop	r1
    124c:	0f 90       	pop	r0
    124e:	0c be       	out	0x3c, r0	; 60
    1250:	0f 90       	pop	r0
    1252:	0b be       	out	0x3b, r0	; 59
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	0f 90       	pop	r0

	asm volatile ( "ret" );
    125a:	08 95       	ret

0000125c <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    125c:	9d df       	rcall	.-198    	; 0x1198 <vPortYieldFromTick>
	asm volatile ( "reti" );
    125e:	18 95       	reti

00001260 <_Z16taskReadInfraredPv>:
		//}
	}
}

void vApplicationIdleHook()
{
    1260:	ce e8       	ldi	r28, 0x8E	; 142
    1262:	d8 e0       	ldi	r29, 0x08	; 8
    1264:	80 e9       	ldi	r24, 0x90	; 144
    1266:	98 e0       	ldi	r25, 0x08	; 8
    1268:	c5 d2       	rcall	.+1418   	; 0x17f4 <_ZN7SharpIR8distanceEv>
    126a:	99 83       	std	Y+1, r25	; 0x01
    126c:	88 83       	st	Y, r24
    126e:	88 ee       	ldi	r24, 0xE8	; 232
    1270:	93 e0       	ldi	r25, 0x03	; 3
    1272:	cb d5       	rcall	.+2966   	; 0x1e0a <vTaskDelay>
    1274:	f7 cf       	rjmp	.-18     	; 0x1264 <_Z16taskReadInfraredPv+0x4>

00001276 <_Z13taskReadSonarPv>:
    1276:	c2 e0       	ldi	r28, 0x02	; 2
    1278:	d2 e0       	ldi	r29, 0x02	; 2
    127a:	04 e0       	ldi	r16, 0x04	; 4
    127c:	12 e0       	ldi	r17, 0x02	; 2
    127e:	0f 2e       	mov	r0, r31
    1280:	f0 e8       	ldi	r31, 0x80	; 128
    1282:	af 2e       	mov	r10, r31
    1284:	f8 e0       	ldi	r31, 0x08	; 8
    1286:	bf 2e       	mov	r11, r31
    1288:	f0 2d       	mov	r31, r0
    128a:	7a d4       	rcall	.+2292   	; 0x1b80 <vTaskSuspendAll>
    128c:	60 e0       	ldi	r22, 0x00	; 0
    128e:	88 81       	ld	r24, Y
    1290:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <digitalWrite>
    1294:	85 e0       	ldi	r24, 0x05	; 5
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	0e 94 1b 19 	call	0x3236	; 0x3236 <delayMicroseconds>
    129c:	61 e0       	ldi	r22, 0x01	; 1
    129e:	88 81       	ld	r24, Y
    12a0:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <digitalWrite>
    12a4:	8a e0       	ldi	r24, 0x0A	; 10
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	0e 94 1b 19 	call	0x3236	; 0x3236 <delayMicroseconds>
    12ac:	60 e0       	ldi	r22, 0x00	; 0
    12ae:	88 81       	ld	r24, Y
    12b0:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <digitalWrite>
    12b4:	60 e0       	ldi	r22, 0x00	; 0
    12b6:	f8 01       	movw	r30, r16
    12b8:	80 81       	ld	r24, Z
    12ba:	0e 94 15 1a 	call	0x342a	; 0x342a <pinMode>
    12be:	20 e4       	ldi	r18, 0x40	; 64
    12c0:	32 e4       	ldi	r19, 0x42	; 66
    12c2:	4f e0       	ldi	r20, 0x0F	; 15
    12c4:	50 e0       	ldi	r21, 0x00	; 0
    12c6:	61 e0       	ldi	r22, 0x01	; 1
    12c8:	f8 01       	movw	r30, r16
    12ca:	80 81       	ld	r24, Z
    12cc:	0e 94 83 1a 	call	0x3506	; 0x3506 <pulseIn>
    12d0:	6b 01       	movw	r12, r22
    12d2:	7c 01       	movw	r14, r24
    12d4:	19 d5       	rcall	.+2610   	; 0x1d08 <xTaskResumeAll>
    12d6:	c6 01       	movw	r24, r12
    12d8:	99 23       	and	r25, r25
    12da:	0c f4       	brge	.+2      	; 0x12de <_Z13taskReadSonarPv+0x68>
    12dc:	01 96       	adiw	r24, 0x01	; 1
    12de:	bc 01       	movw	r22, r24
    12e0:	75 95       	asr	r23
    12e2:	67 95       	ror	r22
    12e4:	88 27       	eor	r24, r24
    12e6:	77 fd       	sbrc	r23, 7
    12e8:	80 95       	com	r24
    12ea:	98 2f       	mov	r25, r24
    12ec:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    12f0:	2d ec       	ldi	r18, 0xCD	; 205
    12f2:	3c ec       	ldi	r19, 0xCC	; 204
    12f4:	48 ee       	ldi	r20, 0xE8	; 232
    12f6:	51 e4       	ldi	r21, 0x41	; 65
    12f8:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    12fc:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    1300:	f5 01       	movw	r30, r10
    1302:	71 83       	std	Z+1, r23	; 0x01
    1304:	60 83       	st	Z, r22
    1306:	88 e8       	ldi	r24, 0x88	; 136
    1308:	93 e1       	ldi	r25, 0x13	; 19
    130a:	7f d5       	rcall	.+2814   	; 0x1e0a <vTaskDelay>
    130c:	be cf       	rjmp	.-132    	; 0x128a <_Z13taskReadSonarPv+0x14>

0000130e <_Z11taskReadAccPv>:
    130e:	0f 2e       	mov	r0, r31
    1310:	fc ea       	ldi	r31, 0xAC	; 172
    1312:	af 2e       	mov	r10, r31
    1314:	f8 e0       	ldi	r31, 0x08	; 8
    1316:	bf 2e       	mov	r11, r31
    1318:	f0 2d       	mov	r31, r0
    131a:	0e ea       	ldi	r16, 0xAE	; 174
    131c:	18 e0       	ldi	r17, 0x08	; 8
    131e:	c2 e8       	ldi	r28, 0x82	; 130
    1320:	d8 e0       	ldi	r29, 0x08	; 8
    1322:	0f 2e       	mov	r0, r31
    1324:	f4 e8       	ldi	r31, 0x84	; 132
    1326:	8f 2e       	mov	r8, r31
    1328:	f8 e0       	ldi	r31, 0x08	; 8
    132a:	9f 2e       	mov	r9, r31
    132c:	f0 2d       	mov	r31, r0
    132e:	0f 2e       	mov	r0, r31
    1330:	f6 e8       	ldi	r31, 0x86	; 134
    1332:	2f 2e       	mov	r2, r31
    1334:	f8 e0       	ldi	r31, 0x08	; 8
    1336:	3f 2e       	mov	r3, r31
    1338:	f0 2d       	mov	r31, r0
    133a:	8a ea       	ldi	r24, 0xAA	; 170
    133c:	98 e0       	ldi	r25, 0x08	; 8
    133e:	08 dd       	rcall	.-1520   	; 0xd50 <_ZN6LSM3034readEv>
    1340:	f5 01       	movw	r30, r10
    1342:	60 81       	ld	r22, Z
    1344:	71 81       	ldd	r23, Z+1	; 0x01
    1346:	88 27       	eor	r24, r24
    1348:	77 fd       	sbrc	r23, 7
    134a:	80 95       	com	r24
    134c:	98 2f       	mov	r25, r24
    134e:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    1352:	20 e0       	ldi	r18, 0x00	; 0
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	4a e7       	ldi	r20, 0x7A	; 122
    1358:	54 e4       	ldi	r21, 0x44	; 68
    135a:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	44 e7       	ldi	r20, 0x74	; 116
    1364:	52 e4       	ldi	r21, 0x42	; 66
    1366:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    136a:	2f e6       	ldi	r18, 0x6F	; 111
    136c:	32 e1       	ldi	r19, 0x12	; 18
    136e:	43 e8       	ldi	r20, 0x83	; 131
    1370:	5a e3       	ldi	r21, 0x3A	; 58
    1372:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    1376:	2d ec       	ldi	r18, 0xCD	; 205
    1378:	3c ec       	ldi	r19, 0xCC	; 204
    137a:	4c e1       	ldi	r20, 0x1C	; 28
    137c:	51 e4       	ldi	r21, 0x41	; 65
    137e:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    1382:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    1386:	2b 01       	movw	r4, r22
    1388:	3c 01       	movw	r6, r24
    138a:	f8 01       	movw	r30, r16
    138c:	60 81       	ld	r22, Z
    138e:	71 81       	ldd	r23, Z+1	; 0x01
    1390:	88 27       	eor	r24, r24
    1392:	77 fd       	sbrc	r23, 7
    1394:	80 95       	com	r24
    1396:	98 2f       	mov	r25, r24
    1398:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    139c:	20 e0       	ldi	r18, 0x00	; 0
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	4a e7       	ldi	r20, 0x7A	; 122
    13a2:	54 e4       	ldi	r21, 0x44	; 68
    13a4:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    13a8:	20 e0       	ldi	r18, 0x00	; 0
    13aa:	30 e0       	ldi	r19, 0x00	; 0
    13ac:	44 e7       	ldi	r20, 0x74	; 116
    13ae:	52 e4       	ldi	r21, 0x42	; 66
    13b0:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    13b4:	2f e6       	ldi	r18, 0x6F	; 111
    13b6:	32 e1       	ldi	r19, 0x12	; 18
    13b8:	43 e8       	ldi	r20, 0x83	; 131
    13ba:	5a e3       	ldi	r21, 0x3A	; 58
    13bc:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    13c0:	2d ec       	ldi	r18, 0xCD	; 205
    13c2:	3c ec       	ldi	r19, 0xCC	; 204
    13c4:	4c e1       	ldi	r20, 0x1C	; 28
    13c6:	51 e4       	ldi	r21, 0x41	; 65
    13c8:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    13cc:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    13d0:	6b 01       	movw	r12, r22
    13d2:	7c 01       	movw	r14, r24
    13d4:	80 91 aa 08 	lds	r24, 0x08AA
    13d8:	90 91 ab 08 	lds	r25, 0x08AB
    13dc:	bc 01       	movw	r22, r24
    13de:	88 27       	eor	r24, r24
    13e0:	77 fd       	sbrc	r23, 7
    13e2:	80 95       	com	r24
    13e4:	98 2f       	mov	r25, r24
    13e6:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    13ea:	20 e0       	ldi	r18, 0x00	; 0
    13ec:	30 e0       	ldi	r19, 0x00	; 0
    13ee:	4a e7       	ldi	r20, 0x7A	; 122
    13f0:	54 e4       	ldi	r21, 0x44	; 68
    13f2:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    13f6:	20 e0       	ldi	r18, 0x00	; 0
    13f8:	30 e0       	ldi	r19, 0x00	; 0
    13fa:	44 e7       	ldi	r20, 0x74	; 116
    13fc:	52 e4       	ldi	r21, 0x42	; 66
    13fe:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    1402:	2f e6       	ldi	r18, 0x6F	; 111
    1404:	32 e1       	ldi	r19, 0x12	; 18
    1406:	43 e8       	ldi	r20, 0x83	; 131
    1408:	5a e3       	ldi	r21, 0x3A	; 58
    140a:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    140e:	2d ec       	ldi	r18, 0xCD	; 205
    1410:	3c ec       	ldi	r19, 0xCC	; 204
    1412:	4c e1       	ldi	r20, 0x1C	; 28
    1414:	51 e4       	ldi	r21, 0x41	; 65
    1416:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    141a:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    141e:	79 83       	std	Y+1, r23	; 0x01
    1420:	68 83       	st	Y, r22
    1422:	f4 01       	movw	r30, r8
    1424:	51 82       	std	Z+1, r5	; 0x01
    1426:	40 82       	st	Z, r4
    1428:	f1 01       	movw	r30, r2
    142a:	d1 82       	std	Z+1, r13	; 0x01
    142c:	c0 82       	st	Z, r12
    142e:	88 ee       	ldi	r24, 0xE8	; 232
    1430:	93 e0       	ldi	r25, 0x03	; 3
    1432:	eb d4       	rcall	.+2518   	; 0x1e0a <vTaskDelay>
    1434:	82 cf       	rjmp	.-252    	; 0x133a <_Z11taskReadAccPv+0x2c>

00001436 <_Z12taskReadGyroPv>:
    1436:	0f 2e       	mov	r0, r31
    1438:	f0 ea       	ldi	r31, 0xA0	; 160
    143a:	af 2e       	mov	r10, r31
    143c:	f8 e0       	ldi	r31, 0x08	; 8
    143e:	bf 2e       	mov	r11, r31
    1440:	f0 2d       	mov	r31, r0
    1442:	02 ea       	ldi	r16, 0xA2	; 162
    1444:	18 e0       	ldi	r17, 0x08	; 8
    1446:	c8 e8       	ldi	r28, 0x88	; 136
    1448:	d8 e0       	ldi	r29, 0x08	; 8
    144a:	0f 2e       	mov	r0, r31
    144c:	fa e8       	ldi	r31, 0x8A	; 138
    144e:	8f 2e       	mov	r8, r31
    1450:	f8 e0       	ldi	r31, 0x08	; 8
    1452:	9f 2e       	mov	r9, r31
    1454:	f0 2d       	mov	r31, r0
    1456:	0f 2e       	mov	r0, r31
    1458:	fc e8       	ldi	r31, 0x8C	; 140
    145a:	2f 2e       	mov	r2, r31
    145c:	f8 e0       	ldi	r31, 0x08	; 8
    145e:	3f 2e       	mov	r3, r31
    1460:	f0 2d       	mov	r31, r0
    1462:	8e e9       	ldi	r24, 0x9E	; 158
    1464:	98 e0       	ldi	r25, 0x08	; 8
    1466:	d6 d8       	rcall	.-3668   	; 0x614 <_ZN3L3G4readEv>
    1468:	f5 01       	movw	r30, r10
    146a:	60 81       	ld	r22, Z
    146c:	71 81       	ldd	r23, Z+1	; 0x01
    146e:	88 27       	eor	r24, r24
    1470:	77 fd       	sbrc	r23, 7
    1472:	80 95       	com	r24
    1474:	98 2f       	mov	r25, r24
    1476:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    147a:	20 e0       	ldi	r18, 0x00	; 0
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	4c e0       	ldi	r20, 0x0C	; 12
    1480:	51 e4       	ldi	r21, 0x41	; 65
    1482:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    1486:	20 e0       	ldi	r18, 0x00	; 0
    1488:	30 e0       	ldi	r19, 0x00	; 0
    148a:	4a e7       	ldi	r20, 0x7A	; 122
    148c:	54 e4       	ldi	r21, 0x44	; 68
    148e:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    1492:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    1496:	2b 01       	movw	r4, r22
    1498:	3c 01       	movw	r6, r24
    149a:	f8 01       	movw	r30, r16
    149c:	60 81       	ld	r22, Z
    149e:	71 81       	ldd	r23, Z+1	; 0x01
    14a0:	88 27       	eor	r24, r24
    14a2:	77 fd       	sbrc	r23, 7
    14a4:	80 95       	com	r24
    14a6:	98 2f       	mov	r25, r24
    14a8:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    14ac:	20 e0       	ldi	r18, 0x00	; 0
    14ae:	30 e0       	ldi	r19, 0x00	; 0
    14b0:	4c e0       	ldi	r20, 0x0C	; 12
    14b2:	51 e4       	ldi	r21, 0x41	; 65
    14b4:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    14b8:	20 e0       	ldi	r18, 0x00	; 0
    14ba:	30 e0       	ldi	r19, 0x00	; 0
    14bc:	4a e7       	ldi	r20, 0x7A	; 122
    14be:	54 e4       	ldi	r21, 0x44	; 68
    14c0:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    14c4:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    14c8:	6b 01       	movw	r12, r22
    14ca:	7c 01       	movw	r14, r24
    14cc:	80 91 9e 08 	lds	r24, 0x089E
    14d0:	90 91 9f 08 	lds	r25, 0x089F
    14d4:	bc 01       	movw	r22, r24
    14d6:	88 27       	eor	r24, r24
    14d8:	77 fd       	sbrc	r23, 7
    14da:	80 95       	com	r24
    14dc:	98 2f       	mov	r25, r24
    14de:	0e 94 a3 13 	call	0x2746	; 0x2746 <__floatsisf>
    14e2:	20 e0       	ldi	r18, 0x00	; 0
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	4c e0       	ldi	r20, 0x0C	; 12
    14e8:	51 e4       	ldi	r21, 0x41	; 65
    14ea:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    14ee:	20 e0       	ldi	r18, 0x00	; 0
    14f0:	30 e0       	ldi	r19, 0x00	; 0
    14f2:	4a e7       	ldi	r20, 0x7A	; 122
    14f4:	54 e4       	ldi	r21, 0x44	; 68
    14f6:	0e 94 08 13 	call	0x2610	; 0x2610 <__divsf3>
    14fa:	0e 94 70 13 	call	0x26e0	; 0x26e0 <__fixsfsi>
    14fe:	79 83       	std	Y+1, r23	; 0x01
    1500:	68 83       	st	Y, r22
    1502:	f4 01       	movw	r30, r8
    1504:	51 82       	std	Z+1, r5	; 0x01
    1506:	40 82       	st	Z, r4
    1508:	f1 01       	movw	r30, r2
    150a:	d1 82       	std	Z+1, r13	; 0x01
    150c:	c0 82       	st	Z, r12
    150e:	88 ee       	ldi	r24, 0xE8	; 232
    1510:	93 e0       	ldi	r25, 0x03	; 3
    1512:	7b d4       	rcall	.+2294   	; 0x1e0a <vTaskDelay>
    1514:	a6 cf       	rjmp	.-180    	; 0x1462 <_Z12taskReadGyroPv+0x2c>

00001516 <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1516:	26 e0       	ldi	r18, 0x06	; 6
    1518:	40 e8       	ldi	r20, 0x80	; 128
    151a:	55 e2       	ldi	r21, 0x25	; 37
    151c:	60 e0       	ldi	r22, 0x00	; 0
    151e:	70 e0       	ldi	r23, 0x00	; 0
    1520:	89 ee       	ldi	r24, 0xE9	; 233
    1522:	99 e0       	ldi	r25, 0x09	; 9
    1524:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <_ZN14HardwareSerial5beginEmh>
	vSemaphoreCreateBinary(analogSema);
	xSemaphoreGive(gyroSema);*/
	// Starting up serial monitor
	Serial.begin(9600);
	// Setting up compass
	Wire.begin();
    1528:	87 e9       	ldi	r24, 0x97	; 151
    152a:	99 e0       	ldi	r25, 0x09	; 9
    152c:	d0 d7       	rcall	.+4000   	; 0x24ce <_ZN7TwoWire5beginEv>
	compass.init();
    152e:	42 e0       	ldi	r20, 0x02	; 2
    1530:	64 e0       	ldi	r22, 0x04	; 4
    1532:	8a ea       	ldi	r24, 0xAA	; 170
    1534:	98 e0       	ldi	r25, 0x08	; 8
    1536:	41 dc       	rcall	.-1918   	; 0xdba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    1538:	8a ea       	ldi	r24, 0xAA	; 170
    153a:	98 e0       	ldi	r25, 0x08	; 8
    153c:	98 da       	rcall	.-2768   	; 0xa6e <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    153e:	86 e0       	ldi	r24, 0x06	; 6
    1540:	e5 e1       	ldi	r30, 0x15	; 21
    1542:	f2 e0       	ldi	r31, 0x02	; 2
    1544:	ac eb       	ldi	r26, 0xBC	; 188
    1546:	b8 e0       	ldi	r27, 0x08	; 8
    1548:	01 90       	ld	r0, Z+
    154a:	0d 92       	st	X+, r0
    154c:	8a 95       	dec	r24
    154e:	e1 f7       	brne	.-8      	; 0x1548 <setup+0x32>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    1550:	86 e0       	ldi	r24, 0x06	; 6
    1552:	eb e1       	ldi	r30, 0x1B	; 27
    1554:	f2 e0       	ldi	r31, 0x02	; 2
    1556:	a6 eb       	ldi	r26, 0xB6	; 182
    1558:	b8 e0       	ldi	r27, 0x08	; 8
    155a:	01 90       	ld	r0, Z+
    155c:	0d 92       	st	X+, r0
    155e:	8a 95       	dec	r24
    1560:	e1 f7       	brne	.-8      	; 0x155a <setup+0x44>
	gyro.init();
    1562:	42 e0       	ldi	r20, 0x02	; 2
    1564:	63 e0       	ldi	r22, 0x03	; 3
    1566:	8e e9       	ldi	r24, 0x9E	; 158
    1568:	98 e0       	ldi	r25, 0x08	; 8
    156a:	f8 d8       	rcall	.-3600   	; 0x75c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
	gyro.enableDefault();
    156c:	8e e9       	ldi	r24, 0x9E	; 158
    156e:	98 e0       	ldi	r25, 0x08	; 8
    1570:	3c d8       	rcall	.-3976   	; 0x5ea <_ZN3L3G13enableDefaultEv>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    1572:	61 e0       	ldi	r22, 0x01	; 1
    1574:	80 91 02 02 	lds	r24, 0x0202
    1578:	0e 94 15 1a 	call	0x342a	; 0x342a <pinMode>
	pinMode(echo_1, INPUT);
    157c:	60 e0       	ldi	r22, 0x00	; 0
    157e:	80 91 04 02 	lds	r24, 0x0204
    1582:	0e 94 15 1a 	call	0x342a	; 0x342a <pinMode>
	pinMode(analog_1, INPUT);
    1586:	60 e0       	ldi	r22, 0x00	; 0
    1588:	80 91 00 02 	lds	r24, 0x0200
    158c:	0c 94 15 1a 	jmp	0x342a	; 0x342a <pinMode>
    1590:	08 95       	ret

00001592 <main>:
}

int main(void)
{
    1592:	af 92       	push	r10
    1594:	bf 92       	push	r11
    1596:	cf 92       	push	r12
    1598:	df 92       	push	r13
    159a:	ef 92       	push	r14
    159c:	ff 92       	push	r15
    159e:	0f 93       	push	r16
    15a0:	cf 93       	push	r28
    15a2:	df 93       	push	r29
    15a4:	cd b7       	in	r28, 0x3d	; 61
    15a6:	de b7       	in	r29, 0x3e	; 62
    15a8:	2a 97       	sbiw	r28, 0x0a	; 10
    15aa:	0f b6       	in	r0, 0x3f	; 63
    15ac:	f8 94       	cli
    15ae:	de bf       	out	0x3e, r29	; 62
    15b0:	0f be       	out	0x3f, r0	; 63
    15b2:	cd bf       	out	0x3d, r28	; 61
	init();
    15b4:	0e 94 26 19 	call	0x324c	; 0x324c <init>
	setup();
    15b8:	ae df       	rcall	.-164    	; 0x1516 <setup>
	TaskHandle_t t1, t2, t3, t4, t5, t6;
	// Create tasks
	xTaskCreate(printArray, "printA", STACK_DEPTH, NULL, 10, &t1);
    15ba:	a1 2c       	mov	r10, r1
    15bc:	b1 2c       	mov	r11, r1
    15be:	c1 2c       	mov	r12, r1
    15c0:	d1 2c       	mov	r13, r1
    15c2:	ce 01       	movw	r24, r28
    15c4:	09 96       	adiw	r24, 0x09	; 9
    15c6:	7c 01       	movw	r14, r24
    15c8:	0a e0       	ldi	r16, 0x0A	; 10
    15ca:	20 e0       	ldi	r18, 0x00	; 0
    15cc:	30 e0       	ldi	r19, 0x00	; 0
    15ce:	40 e8       	ldi	r20, 0x80	; 128
    15d0:	50 e0       	ldi	r21, 0x00	; 0
    15d2:	61 e2       	ldi	r22, 0x21	; 33
    15d4:	72 e0       	ldi	r23, 0x02	; 2
    15d6:	8c e4       	ldi	r24, 0x4C	; 76
    15d8:	9b e0       	ldi	r25, 0x0B	; 11
    15da:	a1 d1       	rcall	.+834    	; 0x191e <xTaskGenericCreate>
	xTaskCreate(taskReadGyro, "Read Gyrometer", STACK_DEPTH, NULL, 9, &t2);
    15dc:	ce 01       	movw	r24, r28
    15de:	07 96       	adiw	r24, 0x07	; 7
    15e0:	7c 01       	movw	r14, r24
    15e2:	09 e0       	ldi	r16, 0x09	; 9
    15e4:	20 e0       	ldi	r18, 0x00	; 0
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	40 e8       	ldi	r20, 0x80	; 128
    15ea:	50 e0       	ldi	r21, 0x00	; 0
    15ec:	68 e2       	ldi	r22, 0x28	; 40
    15ee:	72 e0       	ldi	r23, 0x02	; 2
    15f0:	8b e1       	ldi	r24, 0x1B	; 27
    15f2:	9a e0       	ldi	r25, 0x0A	; 10
    15f4:	94 d1       	rcall	.+808    	; 0x191e <xTaskGenericCreate>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
    15f6:	ce 01       	movw	r24, r28
    15f8:	05 96       	adiw	r24, 0x05	; 5
    15fa:	7c 01       	movw	r14, r24
    15fc:	08 e0       	ldi	r16, 0x08	; 8
    15fe:	20 e0       	ldi	r18, 0x00	; 0
    1600:	30 e0       	ldi	r19, 0x00	; 0
    1602:	40 e8       	ldi	r20, 0x80	; 128
    1604:	50 e0       	ldi	r21, 0x00	; 0
    1606:	67 e3       	ldi	r22, 0x37	; 55
    1608:	72 e0       	ldi	r23, 0x02	; 2
    160a:	87 e8       	ldi	r24, 0x87	; 135
    160c:	99 e0       	ldi	r25, 0x09	; 9
    160e:	87 d1       	rcall	.+782    	; 0x191e <xTaskGenericCreate>
	xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
    1610:	ce 01       	movw	r24, r28
    1612:	03 96       	adiw	r24, 0x03	; 3
    1614:	7c 01       	movw	r14, r24
    1616:	07 e0       	ldi	r16, 0x07	; 7
    1618:	20 e0       	ldi	r18, 0x00	; 0
    161a:	30 e0       	ldi	r19, 0x00	; 0
    161c:	40 e8       	ldi	r20, 0x80	; 128
    161e:	50 e0       	ldi	r21, 0x00	; 0
    1620:	6a e4       	ldi	r22, 0x4A	; 74
    1622:	72 e0       	ldi	r23, 0x02	; 2
    1624:	80 e3       	ldi	r24, 0x30	; 48
    1626:	99 e0       	ldi	r25, 0x09	; 9
    1628:	7a d1       	rcall	.+756    	; 0x191e <xTaskGenericCreate>
	//xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
    162a:	ce 01       	movw	r24, r28
    162c:	01 96       	adiw	r24, 0x01	; 1
    162e:	7c 01       	movw	r14, r24
    1630:	05 e0       	ldi	r16, 0x05	; 5
    1632:	20 e0       	ldi	r18, 0x00	; 0
    1634:	30 e0       	ldi	r19, 0x00	; 0
    1636:	40 e8       	ldi	r20, 0x80	; 128
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	68 e5       	ldi	r22, 0x58	; 88
    163c:	72 e0       	ldi	r23, 0x02	; 2
    163e:	8b e3       	ldi	r24, 0x3B	; 59
    1640:	99 e0       	ldi	r25, 0x09	; 9
    1642:	6d d1       	rcall	.+730    	; 0x191e <xTaskGenericCreate>
	vTaskStartScheduler();
    1644:	74 d2       	rcall	.+1256   	; 0x1b2e <vTaskStartScheduler>
}
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	90 e0       	ldi	r25, 0x00	; 0
    164a:	2a 96       	adiw	r28, 0x0a	; 10
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	de bf       	out	0x3e, r29	; 62
    1652:	0f be       	out	0x3f, r0	; 63
    1654:	cd bf       	out	0x3d, r28	; 61
    1656:	df 91       	pop	r29
    1658:	cf 91       	pop	r28
    165a:	0f 91       	pop	r16
    165c:	ff 90       	pop	r15
    165e:	ef 90       	pop	r14
    1660:	df 90       	pop	r13
    1662:	cf 90       	pop	r12
    1664:	bf 90       	pop	r11
    1666:	af 90       	pop	r10
    1668:	08 95       	ret

0000166a <_GLOBAL__sub_I_echo_1>:
    166a:	0f 93       	push	r16
    166c:	1f 93       	push	r17
// xSemaphoreHandle sonarSema, magnetoSema, gyroSema, acceSema, analogSema = 0;
int echo_1 = 3; //pin 3 for sonar echo
int trigger_1 = 4; //pin 4 for sonar trigger
int analog_1 = A0; 
int numOfData = 8;
LSM303 compass;
    166e:	8a ea       	ldi	r24, 0xAA	; 170
    1670:	98 e0       	ldi	r25, 0x08	; 8
    1672:	96 d9       	rcall	.-3284   	; 0x9a0 <_ZN6LSM303C1Ev>
L3G gyro;
    1674:	8e e9       	ldi	r24, 0x9E	; 158
    1676:	98 e0       	ldi	r25, 0x08	; 8
    1678:	0e 94 ce 02 	call	0x59c	; 0x59c <_ZN3L3GC1Ev>
SharpIR sharp(A0, 25, 93, 20150);
    167c:	06 eb       	ldi	r16, 0xB6	; 182
    167e:	1e e4       	ldi	r17, 0x4E	; 78
    1680:	2d e5       	ldi	r18, 0x5D	; 93
    1682:	30 e0       	ldi	r19, 0x00	; 0
    1684:	49 e1       	ldi	r20, 0x19	; 25
    1686:	50 e0       	ldi	r21, 0x00	; 0
    1688:	66 e3       	ldi	r22, 0x36	; 54
    168a:	70 e0       	ldi	r23, 0x00	; 0
    168c:	80 e9       	ldi	r24, 0x90	; 144
    168e:	98 e0       	ldi	r25, 0x08	; 8
    1690:	2f d0       	rcall	.+94     	; 0x16f0 <_ZN7SharpIRC1Eiiii>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
	xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	//xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
	vTaskStartScheduler();
}
    1692:	1f 91       	pop	r17
    1694:	0f 91       	pop	r16
    1696:	08 95       	ret

00001698 <_Z10printArrayPv>:
index 9 for compass heading
*/

void printArray(void *p) {
	int i;
	char canRead = '0';
    1698:	c0 e3       	ldi	r28, 0x30	; 48
    169a:	0f 2e       	mov	r0, r31
    169c:	f0 e8       	ldi	r31, 0x80	; 128
    169e:	ef 2e       	mov	r14, r31
    16a0:	f8 e0       	ldi	r31, 0x08	; 8
    16a2:	ff 2e       	mov	r15, r31
    16a4:	f0 2d       	mov	r31, r0
    16a6:	00 e9       	ldi	r16, 0x90	; 144
    16a8:	18 e0       	ldi	r17, 0x08	; 8
	while(1) {
		if(Serial.available()){
    16aa:	89 ee       	ldi	r24, 0xE9	; 233
    16ac:	99 e0       	ldi	r25, 0x09	; 9
    16ae:	0e 94 f7 15 	call	0x2bee	; 0x2bee <_ZN14HardwareSerial9availableEv>
    16b2:	89 2b       	or	r24, r25
    16b4:	29 f0       	breq	.+10     	; 0x16c0 <_Z10printArrayPv+0x28>
			canRead = Serial.read();
    16b6:	89 ee       	ldi	r24, 0xE9	; 233
    16b8:	99 e0       	ldi	r25, 0x09	; 9
    16ba:	0e 94 10 16 	call	0x2c20	; 0x2c20 <_ZN14HardwareSerial4readEv>
    16be:	c8 2f       	mov	r28, r24
		}
		if(canRead - '0'){
    16c0:	c0 33       	cpi	r28, 0x30	; 48
    16c2:	91 f0       	breq	.+36     	; 0x16e8 <_Z10printArrayPv+0x50>
    16c4:	e7 01       	movw	r28, r14
			//Serial.print(numOfData);
			//Serial.print('\r');
			for(i = 1; i < 9; i++) {
				Serial.println(data[i]);
    16c6:	69 91       	ld	r22, Y+
    16c8:	79 91       	ld	r23, Y+
    16ca:	4a e0       	ldi	r20, 0x0A	; 10
    16cc:	50 e0       	ldi	r21, 0x00	; 0
    16ce:	89 ee       	ldi	r24, 0xE9	; 233
    16d0:	99 e0       	ldi	r25, 0x09	; 9
    16d2:	0e 94 af 18 	call	0x315e	; 0x315e <_ZN5Print7printlnEii>
				Serial.print('\r');
    16d6:	6d e0       	ldi	r22, 0x0D	; 13
    16d8:	89 ee       	ldi	r24, 0xE9	; 233
    16da:	99 e0       	ldi	r25, 0x09	; 9
    16dc:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <_ZN5Print5printEc>
			canRead = Serial.read();
		}
		if(canRead - '0'){
			//Serial.print(numOfData);
			//Serial.print('\r');
			for(i = 1; i < 9; i++) {
    16e0:	c0 17       	cp	r28, r16
    16e2:	d1 07       	cpc	r29, r17
    16e4:	81 f7       	brne	.-32     	; 0x16c6 <_Z10printArrayPv+0x2e>
				Serial.println(data[i]);
				Serial.print('\r');
			}
			canRead = '0';
    16e6:	c0 e3       	ldi	r28, 0x30	; 48
		/*if(canRead - '0') {
			i = canRead - '0';
			Serial.print(data[i]);
			canRead = '0';
		}*/
		vTaskDelay(1000);
    16e8:	88 ee       	ldi	r24, 0xE8	; 232
    16ea:	93 e0       	ldi	r25, 0x03	; 3
    16ec:	8e d3       	rcall	.+1820   	; 0x1e0a <vTaskDelay>
	}
    16ee:	dd cf       	rjmp	.-70     	; 0x16aa <_Z10printArrayPv+0x12>

000016f0 <_ZN7SharpIRC1Eiiii>:
#include "Arduino.h"
#include "SharpIR.h"



SharpIR::SharpIR(int irPin, int avg, int tolerance, int sensorModel) {
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	fc 01       	movw	r30, r24
    16f6:	c9 01       	movw	r24, r18
  
    _irPin=irPin;
    16f8:	71 83       	std	Z+1, r23	; 0x01
    16fa:	60 83       	st	Z, r22
    _avg=avg;
    16fc:	55 83       	std	Z+5, r21	; 0x05
    16fe:	44 83       	std	Z+4, r20	; 0x04
    _tol=tolerance/100;
    1700:	64 e6       	ldi	r22, 0x64	; 100
    1702:	70 e0       	ldi	r23, 0x00	; 0
    1704:	0e 94 00 1b 	call	0x3600	; 0x3600 <__divmodhi4>
    1708:	75 87       	std	Z+13, r23	; 0x0d
    170a:	64 87       	std	Z+12, r22	; 0x0c
    _model=sensorModel;
    170c:	13 83       	std	Z+3, r17	; 0x03
    170e:	02 83       	std	Z+2, r16	; 0x02
    
    analogReference(DEFAULT);
    1710:	81 e0       	ldi	r24, 0x01	; 1
    1712:	0e 94 88 19 	call	0x3310	; 0x3310 <analogReference>
 
}
    1716:	1f 91       	pop	r17
    1718:	0f 91       	pop	r16
    171a:	08 95       	ret

0000171c <_ZN7SharpIR2cmEv>:
//    distance range they are designed for (in cm)
 



int SharpIR::cm() {
    171c:	8f 92       	push	r8
    171e:	9f 92       	push	r9
    1720:	af 92       	push	r10
    1722:	bf 92       	push	r11
    1724:	cf 92       	push	r12
    1726:	df 92       	push	r13
    1728:	ef 92       	push	r14
    172a:	ff 92       	push	r15
    172c:	0f 93       	push	r16
    172e:	1f 93       	push	r17
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
    1734:	ec 01       	movw	r28, r24
    
    int raw=analogRead(_irPin);
    1736:	88 81       	ld	r24, Y
    1738:	0e 94 8b 19 	call	0x3316	; 0x3316 <analogRead>
    float voltFromRaw=map(raw, 0, 1023, 0, 5000);
    173c:	bc 01       	movw	r22, r24
    173e:	88 27       	eor	r24, r24
    1740:	77 fd       	sbrc	r23, 7
    1742:	80 95       	com	r24
    1744:	98 2f       	mov	r25, r24
    1746:	1f 92       	push	r1
    1748:	1f 92       	push	r1
    174a:	23 e1       	ldi	r18, 0x13	; 19
    174c:	2f 93       	push	r18
    174e:	28 e8       	ldi	r18, 0x88	; 136
    1750:	2f 93       	push	r18
    1752:	a1 2c       	mov	r10, r1
    1754:	b1 2c       	mov	r11, r1
    1756:	65 01       	movw	r12, r10
    1758:	ee 24       	eor	r14, r14
    175a:	ea 94       	dec	r14
    175c:	13 e0       	ldi	r17, 0x03	; 3
    175e:	f1 2e       	mov	r15, r17
    1760:	00 e0       	ldi	r16, 0x00	; 0
    1762:	10 e0       	ldi	r17, 0x00	; 0
    1764:	20 e0       	ldi	r18, 0x00	; 0
    1766:	30 e0       	ldi	r19, 0x00	; 0
    1768:	a9 01       	movw	r20, r18
    176a:	0e 94 b2 1a 	call	0x3564	; 0x3564 <_Z3maplllll>
    176e:	eb d7       	rcall	.+4054   	; 0x2746 <__floatsisf>
    
    int puntualDistance;
    
    if (_model==1080) {
    1770:	2a 81       	ldd	r18, Y+2	; 0x02
    1772:	3b 81       	ldd	r19, Y+3	; 0x03
    1774:	0f 90       	pop	r0
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	0f 90       	pop	r0
    177c:	28 33       	cpi	r18, 0x38	; 56
    177e:	44 e0       	ldi	r20, 0x04	; 4
    1780:	34 07       	cpc	r19, r20
    1782:	a1 f4       	brne	.+40     	; 0x17ac <_ZN7SharpIR2cmEv+0x90>
        
        puntualDistance=27.728*pow(voltFromRaw/1000, -1.2045);
    1784:	20 e0       	ldi	r18, 0x00	; 0
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	4a e7       	ldi	r20, 0x7A	; 122
    178a:	54 e4       	ldi	r21, 0x44	; 68
    178c:	41 d7       	rcall	.+3714   	; 0x2610 <__divsf3>
    178e:	2e e0       	ldi	r18, 0x0E	; 14
    1790:	3d e2       	ldi	r19, 0x2D	; 45
    1792:	4a e9       	ldi	r20, 0x9A	; 154
    1794:	5f eb       	ldi	r21, 0xBF	; 191
    1796:	0e 94 be 14 	call	0x297c	; 0x297c <pow>
    179a:	22 ef       	ldi	r18, 0xF2	; 242
    179c:	32 ed       	ldi	r19, 0xD2	; 210
    179e:	4d ed       	ldi	r20, 0xDD	; 221
    17a0:	51 e4       	ldi	r21, 0x41	; 65
    17a2:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    17a6:	9c d7       	rcall	.+3896   	; 0x26e0 <__fixsfsi>
    17a8:	4b 01       	movw	r8, r22
    17aa:	16 c0       	rjmp	.+44     	; 0x17d8 <_ZN7SharpIR2cmEv+0xbc>
        
    }else if (_model==20150){
    17ac:	26 3b       	cpi	r18, 0xB6	; 182
    17ae:	3e 44       	sbci	r19, 0x4E	; 78
    17b0:	99 f4       	brne	.+38     	; 0x17d8 <_ZN7SharpIR2cmEv+0xbc>
    
        puntualDistance=61.573*pow(voltFromRaw/1000, -1.1068);
    17b2:	20 e0       	ldi	r18, 0x00	; 0
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	4a e7       	ldi	r20, 0x7A	; 122
    17b8:	54 e4       	ldi	r21, 0x44	; 68
    17ba:	2a d7       	rcall	.+3668   	; 0x2610 <__divsf3>
    17bc:	2f e9       	ldi	r18, 0x9F	; 159
    17be:	3b ea       	ldi	r19, 0xAB	; 171
    17c0:	4d e8       	ldi	r20, 0x8D	; 141
    17c2:	5f eb       	ldi	r21, 0xBF	; 191
    17c4:	0e 94 be 14 	call	0x297c	; 0x297c <pow>
    17c8:	21 ec       	ldi	r18, 0xC1	; 193
    17ca:	3a e4       	ldi	r19, 0x4A	; 74
    17cc:	46 e7       	ldi	r20, 0x76	; 118
    17ce:	52 e4       	ldi	r21, 0x42	; 66
    17d0:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <__mulsf3>
    17d4:	85 d7       	rcall	.+3850   	; 0x26e0 <__fixsfsi>
    17d6:	4b 01       	movw	r8, r22
    
    
    return puntualDistance;


}
    17d8:	c4 01       	movw	r24, r8
    17da:	df 91       	pop	r29
    17dc:	cf 91       	pop	r28
    17de:	1f 91       	pop	r17
    17e0:	0f 91       	pop	r16
    17e2:	ff 90       	pop	r15
    17e4:	ef 90       	pop	r14
    17e6:	df 90       	pop	r13
    17e8:	cf 90       	pop	r12
    17ea:	bf 90       	pop	r11
    17ec:	af 90       	pop	r10
    17ee:	9f 90       	pop	r9
    17f0:	8f 90       	pop	r8
    17f2:	08 95       	ret

000017f4 <_ZN7SharpIR8distanceEv>:



int SharpIR::distance() {
    17f4:	0f 93       	push	r16
    17f6:	1f 93       	push	r17
    17f8:	cf 93       	push	r28
    17fa:	df 93       	push	r29
    17fc:	ec 01       	movw	r28, r24

    _p=0;
    17fe:	1f 82       	std	Y+7, r1	; 0x07
    1800:	1e 82       	std	Y+6, r1	; 0x06
    _sum=0;
    1802:	19 86       	std	Y+9, r1	; 0x09
    1804:	18 86       	std	Y+8, r1	; 0x08

    
    for (int i=0; i<_avg; i++){
    1806:	8c 81       	ldd	r24, Y+4	; 0x04
    1808:	9d 81       	ldd	r25, Y+5	; 0x05
    180a:	18 16       	cp	r1, r24
    180c:	19 06       	cpc	r1, r25
    180e:	34 f5       	brge	.+76     	; 0x185c <_ZN7SharpIR8distanceEv+0x68>
    1810:	00 e0       	ldi	r16, 0x00	; 0
    1812:	10 e0       	ldi	r17, 0x00	; 0
        
        int foo=cm();
    1814:	ce 01       	movw	r24, r28
    1816:	82 df       	rcall	.-252    	; 0x171c <_ZN7SharpIR2cmEv>
        
        if (foo>=(_tol*_previousDistance)){
    1818:	6c 85       	ldd	r22, Y+12	; 0x0c
    181a:	7d 85       	ldd	r23, Y+13	; 0x0d
    181c:	4a 85       	ldd	r20, Y+10	; 0x0a
    181e:	5b 85       	ldd	r21, Y+11	; 0x0b
    1820:	64 9f       	mul	r22, r20
    1822:	90 01       	movw	r18, r0
    1824:	65 9f       	mul	r22, r21
    1826:	30 0d       	add	r19, r0
    1828:	74 9f       	mul	r23, r20
    182a:	30 0d       	add	r19, r0
    182c:	11 24       	eor	r1, r1
    182e:	82 17       	cp	r24, r18
    1830:	93 07       	cpc	r25, r19
    1832:	6c f0       	brlt	.+26     	; 0x184e <_ZN7SharpIR8distanceEv+0x5a>
        
            _previousDistance=foo;
    1834:	9b 87       	std	Y+11, r25	; 0x0b
    1836:	8a 87       	std	Y+10, r24	; 0x0a
            _sum=_sum+foo;
    1838:	28 85       	ldd	r18, Y+8	; 0x08
    183a:	39 85       	ldd	r19, Y+9	; 0x09
    183c:	82 0f       	add	r24, r18
    183e:	93 1f       	adc	r25, r19
    1840:	99 87       	std	Y+9, r25	; 0x09
    1842:	88 87       	std	Y+8, r24	; 0x08
            _p++;
    1844:	8e 81       	ldd	r24, Y+6	; 0x06
    1846:	9f 81       	ldd	r25, Y+7	; 0x07
    1848:	01 96       	adiw	r24, 0x01	; 1
    184a:	9f 83       	std	Y+7, r25	; 0x07
    184c:	8e 83       	std	Y+6, r24	; 0x06

    _p=0;
    _sum=0;

    
    for (int i=0; i<_avg; i++){
    184e:	0f 5f       	subi	r16, 0xFF	; 255
    1850:	1f 4f       	sbci	r17, 0xFF	; 255
    1852:	8c 81       	ldd	r24, Y+4	; 0x04
    1854:	9d 81       	ldd	r25, Y+5	; 0x05
    1856:	08 17       	cp	r16, r24
    1858:	19 07       	cpc	r17, r25
    185a:	e4 f2       	brlt	.-72     	; 0x1814 <_ZN7SharpIR8distanceEv+0x20>
        
        
    }

    
    int accurateDistance=_sum/_p;
    185c:	88 85       	ldd	r24, Y+8	; 0x08
    185e:	99 85       	ldd	r25, Y+9	; 0x09
    1860:	6e 81       	ldd	r22, Y+6	; 0x06
    1862:	7f 81       	ldd	r23, Y+7	; 0x07
    1864:	0e 94 00 1b 	call	0x3600	; 0x3600 <__divmodhi4>
    1868:	cb 01       	movw	r24, r22
    
    return accurateDistance;

}
    186a:	df 91       	pop	r29
    186c:	cf 91       	pop	r28
    186e:	1f 91       	pop	r17
    1870:	0f 91       	pop	r16
    1872:	08 95       	ret

00001874 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1874:	e0 91 ef 08 	lds	r30, 0x08EF
    1878:	f0 91 f0 08 	lds	r31, 0x08F0
    187c:	80 81       	ld	r24, Z
    187e:	81 11       	cpse	r24, r1
    1880:	07 c0       	rjmp	.+14     	; 0x1890 <prvResetNextTaskUnblockTime+0x1c>
    1882:	8f ef       	ldi	r24, 0xFF	; 255
    1884:	9f ef       	ldi	r25, 0xFF	; 255
    1886:	90 93 07 02 	sts	0x0207, r25
    188a:	80 93 06 02 	sts	0x0206, r24
    188e:	08 95       	ret
    1890:	e0 91 ef 08 	lds	r30, 0x08EF
    1894:	f0 91 f0 08 	lds	r31, 0x08F0
    1898:	05 80       	ldd	r0, Z+5	; 0x05
    189a:	f6 81       	ldd	r31, Z+6	; 0x06
    189c:	e0 2d       	mov	r30, r0
    189e:	06 80       	ldd	r0, Z+6	; 0x06
    18a0:	f7 81       	ldd	r31, Z+7	; 0x07
    18a2:	e0 2d       	mov	r30, r0
    18a4:	82 81       	ldd	r24, Z+2	; 0x02
    18a6:	93 81       	ldd	r25, Z+3	; 0x03
    18a8:	90 93 07 02 	sts	0x0207, r25
    18ac:	80 93 06 02 	sts	0x0206, r24
    18b0:	08 95       	ret

000018b2 <prvAddCurrentTaskToDelayedList>:
    18b2:	cf 93       	push	r28
    18b4:	df 93       	push	r29
    18b6:	ec 01       	movw	r28, r24
    18b8:	e0 91 27 09 	lds	r30, 0x0927
    18bc:	f0 91 28 09 	lds	r31, 0x0928
    18c0:	93 83       	std	Z+3, r25	; 0x03
    18c2:	82 83       	std	Z+2, r24	; 0x02
    18c4:	80 91 d7 08 	lds	r24, 0x08D7
    18c8:	90 91 d8 08 	lds	r25, 0x08D8
    18cc:	c8 17       	cp	r28, r24
    18ce:	d9 07       	cpc	r29, r25
    18d0:	60 f4       	brcc	.+24     	; 0x18ea <prvAddCurrentTaskToDelayedList+0x38>
    18d2:	60 91 27 09 	lds	r22, 0x0927
    18d6:	70 91 28 09 	lds	r23, 0x0928
    18da:	80 91 ed 08 	lds	r24, 0x08ED
    18de:	90 91 ee 08 	lds	r25, 0x08EE
    18e2:	6e 5f       	subi	r22, 0xFE	; 254
    18e4:	7f 4f       	sbci	r23, 0xFF	; 255
    18e6:	05 d8       	rcall	.-4086   	; 0x8f2 <vListInsert>
    18e8:	17 c0       	rjmp	.+46     	; 0x1918 <prvAddCurrentTaskToDelayedList+0x66>
    18ea:	60 91 27 09 	lds	r22, 0x0927
    18ee:	70 91 28 09 	lds	r23, 0x0928
    18f2:	80 91 ef 08 	lds	r24, 0x08EF
    18f6:	90 91 f0 08 	lds	r25, 0x08F0
    18fa:	6e 5f       	subi	r22, 0xFE	; 254
    18fc:	7f 4f       	sbci	r23, 0xFF	; 255
    18fe:	0e 94 79 04 	call	0x8f2	; 0x8f2 <vListInsert>
    1902:	80 91 06 02 	lds	r24, 0x0206
    1906:	90 91 07 02 	lds	r25, 0x0207
    190a:	c8 17       	cp	r28, r24
    190c:	d9 07       	cpc	r29, r25
    190e:	20 f4       	brcc	.+8      	; 0x1918 <prvAddCurrentTaskToDelayedList+0x66>
    1910:	d0 93 07 02 	sts	0x0207, r29
    1914:	c0 93 06 02 	sts	0x0206, r28
    1918:	df 91       	pop	r29
    191a:	cf 91       	pop	r28
    191c:	08 95       	ret

0000191e <xTaskGenericCreate>:
    191e:	4f 92       	push	r4
    1920:	5f 92       	push	r5
    1922:	6f 92       	push	r6
    1924:	7f 92       	push	r7
    1926:	8f 92       	push	r8
    1928:	9f 92       	push	r9
    192a:	af 92       	push	r10
    192c:	bf 92       	push	r11
    192e:	cf 92       	push	r12
    1930:	df 92       	push	r13
    1932:	ef 92       	push	r14
    1934:	ff 92       	push	r15
    1936:	0f 93       	push	r16
    1938:	1f 93       	push	r17
    193a:	cf 93       	push	r28
    193c:	df 93       	push	r29
    193e:	4c 01       	movw	r8, r24
    1940:	5b 01       	movw	r10, r22
    1942:	2a 01       	movw	r4, r20
    1944:	39 01       	movw	r6, r18
    1946:	81 e2       	ldi	r24, 0x21	; 33
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	0e 94 98 02 	call	0x530	; 0x530 <pvPortMalloc>
    194e:	ec 01       	movw	r28, r24
    1950:	00 97       	sbiw	r24, 0x00	; 0
    1952:	09 f4       	brne	.+2      	; 0x1956 <xTaskGenericCreate+0x38>
    1954:	da c0       	rjmp	.+436    	; 0x1b0a <xTaskGenericCreate+0x1ec>
    1956:	c1 14       	cp	r12, r1
    1958:	d1 04       	cpc	r13, r1
    195a:	09 f0       	breq	.+2      	; 0x195e <xTaskGenericCreate+0x40>
    195c:	bf c0       	rjmp	.+382    	; 0x1adc <xTaskGenericCreate+0x1be>
    195e:	c2 01       	movw	r24, r4
    1960:	0e 94 98 02 	call	0x530	; 0x530 <pvPortMalloc>
    1964:	98 8f       	std	Y+24, r25	; 0x18
    1966:	8f 8b       	std	Y+23, r24	; 0x17
    1968:	89 2b       	or	r24, r25
    196a:	09 f0       	breq	.+2      	; 0x196e <xTaskGenericCreate+0x50>
    196c:	b9 c0       	rjmp	.+370    	; 0x1ae0 <xTaskGenericCreate+0x1c2>
    196e:	ce 01       	movw	r24, r28
    1970:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortFree>
    1974:	ca c0       	rjmp	.+404    	; 0x1b0a <xTaskGenericCreate+0x1ec>
    1976:	cf 01       	movw	r24, r30
    1978:	31 91       	ld	r19, Z+
    197a:	da 01       	movw	r26, r20
    197c:	3d 93       	st	X+, r19
    197e:	ad 01       	movw	r20, r26
    1980:	dc 01       	movw	r26, r24
    1982:	8c 91       	ld	r24, X
    1984:	88 23       	and	r24, r24
    1986:	11 f0       	breq	.+4      	; 0x198c <xTaskGenericCreate+0x6e>
    1988:	21 50       	subi	r18, 0x01	; 1
    198a:	a9 f7       	brne	.-22     	; 0x1976 <xTaskGenericCreate+0x58>
    198c:	18 a2       	std	Y+32, r1	; 0x20
    198e:	10 2f       	mov	r17, r16
    1990:	04 30       	cpi	r16, 0x04	; 4
    1992:	08 f0       	brcs	.+2      	; 0x1996 <xTaskGenericCreate+0x78>
    1994:	13 e0       	ldi	r17, 0x03	; 3
    1996:	1e 8b       	std	Y+22, r17	; 0x16
    1998:	5e 01       	movw	r10, r28
    199a:	b2 e0       	ldi	r27, 0x02	; 2
    199c:	ab 0e       	add	r10, r27
    199e:	b1 1c       	adc	r11, r1
    19a0:	c5 01       	movw	r24, r10
    19a2:	0e 94 54 04 	call	0x8a8	; 0x8a8 <vListInitialiseItem>
    19a6:	ce 01       	movw	r24, r28
    19a8:	0c 96       	adiw	r24, 0x0c	; 12
    19aa:	0e 94 54 04 	call	0x8a8	; 0x8a8 <vListInitialiseItem>
    19ae:	d9 87       	std	Y+9, r29	; 0x09
    19b0:	c8 87       	std	Y+8, r28	; 0x08
    19b2:	84 e0       	ldi	r24, 0x04	; 4
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	81 1b       	sub	r24, r17
    19b8:	91 09       	sbc	r25, r1
    19ba:	9d 87       	std	Y+13, r25	; 0x0d
    19bc:	8c 87       	std	Y+12, r24	; 0x0c
    19be:	db 8b       	std	Y+19, r29	; 0x13
    19c0:	ca 8b       	std	Y+18, r28	; 0x12
    19c2:	a3 01       	movw	r20, r6
    19c4:	b4 01       	movw	r22, r8
    19c6:	c6 01       	movw	r24, r12
    19c8:	d4 da       	rcall	.-2648   	; 0xf72 <pxPortInitialiseStack>
    19ca:	99 83       	std	Y+1, r25	; 0x01
    19cc:	88 83       	st	Y, r24
    19ce:	e1 14       	cp	r14, r1
    19d0:	f1 04       	cpc	r15, r1
    19d2:	19 f0       	breq	.+6      	; 0x19da <xTaskGenericCreate+0xbc>
    19d4:	f7 01       	movw	r30, r14
    19d6:	d1 83       	std	Z+1, r29	; 0x01
    19d8:	c0 83       	st	Z, r28
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	f8 94       	cli
    19de:	0f 92       	push	r0
    19e0:	80 91 d9 08 	lds	r24, 0x08D9
    19e4:	8f 5f       	subi	r24, 0xFF	; 255
    19e6:	80 93 d9 08 	sts	0x08D9, r24
    19ea:	80 91 27 09 	lds	r24, 0x0927
    19ee:	90 91 28 09 	lds	r25, 0x0928
    19f2:	89 2b       	or	r24, r25
    19f4:	a9 f5       	brne	.+106    	; 0x1a60 <xTaskGenericCreate+0x142>
    19f6:	d0 93 28 09 	sts	0x0928, r29
    19fa:	c0 93 27 09 	sts	0x0927, r28
    19fe:	80 91 d9 08 	lds	r24, 0x08D9
    1a02:	81 30       	cpi	r24, 0x01	; 1
    1a04:	e1 f5       	brne	.+120    	; 0x1a7e <xTaskGenericCreate+0x160>
    1a06:	83 e0       	ldi	r24, 0x03	; 3
    1a08:	99 e0       	ldi	r25, 0x09	; 9
    1a0a:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a0e:	8c e0       	ldi	r24, 0x0C	; 12
    1a10:	99 e0       	ldi	r25, 0x09	; 9
    1a12:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a16:	85 e1       	ldi	r24, 0x15	; 21
    1a18:	99 e0       	ldi	r25, 0x09	; 9
    1a1a:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a1e:	8e e1       	ldi	r24, 0x1E	; 30
    1a20:	99 e0       	ldi	r25, 0x09	; 9
    1a22:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a26:	8a ef       	ldi	r24, 0xFA	; 250
    1a28:	98 e0       	ldi	r25, 0x08	; 8
    1a2a:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a2e:	81 ef       	ldi	r24, 0xF1	; 241
    1a30:	98 e0       	ldi	r25, 0x08	; 8
    1a32:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a36:	84 ee       	ldi	r24, 0xE4	; 228
    1a38:	98 e0       	ldi	r25, 0x08	; 8
    1a3a:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a3e:	8b ed       	ldi	r24, 0xDB	; 219
    1a40:	98 e0       	ldi	r25, 0x08	; 8
    1a42:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a46:	8a ef       	ldi	r24, 0xFA	; 250
    1a48:	98 e0       	ldi	r25, 0x08	; 8
    1a4a:	90 93 f0 08 	sts	0x08F0, r25
    1a4e:	80 93 ef 08 	sts	0x08EF, r24
    1a52:	81 ef       	ldi	r24, 0xF1	; 241
    1a54:	98 e0       	ldi	r25, 0x08	; 8
    1a56:	90 93 ee 08 	sts	0x08EE, r25
    1a5a:	80 93 ed 08 	sts	0x08ED, r24
    1a5e:	0f c0       	rjmp	.+30     	; 0x1a7e <xTaskGenericCreate+0x160>
    1a60:	80 91 d5 08 	lds	r24, 0x08D5
    1a64:	81 11       	cpse	r24, r1
    1a66:	0b c0       	rjmp	.+22     	; 0x1a7e <xTaskGenericCreate+0x160>
    1a68:	e0 91 27 09 	lds	r30, 0x0927
    1a6c:	f0 91 28 09 	lds	r31, 0x0928
    1a70:	86 89       	ldd	r24, Z+22	; 0x16
    1a72:	08 17       	cp	r16, r24
    1a74:	20 f0       	brcs	.+8      	; 0x1a7e <xTaskGenericCreate+0x160>
    1a76:	d0 93 28 09 	sts	0x0928, r29
    1a7a:	c0 93 27 09 	sts	0x0927, r28
    1a7e:	80 91 d1 08 	lds	r24, 0x08D1
    1a82:	8f 5f       	subi	r24, 0xFF	; 255
    1a84:	80 93 d1 08 	sts	0x08D1, r24
    1a88:	8e 89       	ldd	r24, Y+22	; 0x16
    1a8a:	90 91 d6 08 	lds	r25, 0x08D6
    1a8e:	98 17       	cp	r25, r24
    1a90:	10 f4       	brcc	.+4      	; 0x1a96 <xTaskGenericCreate+0x178>
    1a92:	80 93 d6 08 	sts	0x08D6, r24
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	9c 01       	movw	r18, r24
    1a9a:	22 0f       	add	r18, r18
    1a9c:	33 1f       	adc	r19, r19
    1a9e:	22 0f       	add	r18, r18
    1aa0:	33 1f       	adc	r19, r19
    1aa2:	22 0f       	add	r18, r18
    1aa4:	33 1f       	adc	r19, r19
    1aa6:	82 0f       	add	r24, r18
    1aa8:	93 1f       	adc	r25, r19
    1aaa:	b5 01       	movw	r22, r10
    1aac:	8d 5f       	subi	r24, 0xFD	; 253
    1aae:	96 4f       	sbci	r25, 0xF6	; 246
    1ab0:	0e 94 58 04 	call	0x8b0	; 0x8b0 <vListInsertEnd>
    1ab4:	0f 90       	pop	r0
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	80 91 d5 08 	lds	r24, 0x08D5
    1abc:	88 23       	and	r24, r24
    1abe:	51 f0       	breq	.+20     	; 0x1ad4 <xTaskGenericCreate+0x1b6>
    1ac0:	e0 91 27 09 	lds	r30, 0x0927
    1ac4:	f0 91 28 09 	lds	r31, 0x0928
    1ac8:	86 89       	ldd	r24, Z+22	; 0x16
    1aca:	80 17       	cp	r24, r16
    1acc:	28 f4       	brcc	.+10     	; 0x1ad8 <xTaskGenericCreate+0x1ba>
    1ace:	04 db       	rcall	.-2552   	; 0x10d8 <vPortYield>
    1ad0:	81 e0       	ldi	r24, 0x01	; 1
    1ad2:	1c c0       	rjmp	.+56     	; 0x1b0c <xTaskGenericCreate+0x1ee>
    1ad4:	81 e0       	ldi	r24, 0x01	; 1
    1ad6:	1a c0       	rjmp	.+52     	; 0x1b0c <xTaskGenericCreate+0x1ee>
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	18 c0       	rjmp	.+48     	; 0x1b0c <xTaskGenericCreate+0x1ee>
    1adc:	d8 8e       	std	Y+24, r13	; 0x18
    1ade:	cf 8a       	std	Y+23, r12	; 0x17
    1ae0:	f1 e0       	ldi	r31, 0x01	; 1
    1ae2:	4f 1a       	sub	r4, r31
    1ae4:	51 08       	sbc	r5, r1
    1ae6:	cf 88       	ldd	r12, Y+23	; 0x17
    1ae8:	d8 8c       	ldd	r13, Y+24	; 0x18
    1aea:	c4 0c       	add	r12, r4
    1aec:	d5 1c       	adc	r13, r5
    1aee:	d5 01       	movw	r26, r10
    1af0:	8c 91       	ld	r24, X
    1af2:	89 8f       	std	Y+25, r24	; 0x19
    1af4:	8c 91       	ld	r24, X
    1af6:	88 23       	and	r24, r24
    1af8:	09 f4       	brne	.+2      	; 0x1afc <xTaskGenericCreate+0x1de>
    1afa:	48 cf       	rjmp	.-368    	; 0x198c <xTaskGenericCreate+0x6e>
    1afc:	ae 01       	movw	r20, r28
    1afe:	46 5e       	subi	r20, 0xE6	; 230
    1b00:	5f 4f       	sbci	r21, 0xFF	; 255
    1b02:	f5 01       	movw	r30, r10
    1b04:	31 96       	adiw	r30, 0x01	; 1
    1b06:	27 e0       	ldi	r18, 0x07	; 7
    1b08:	36 cf       	rjmp	.-404    	; 0x1976 <xTaskGenericCreate+0x58>
    1b0a:	8f ef       	ldi	r24, 0xFF	; 255
    1b0c:	df 91       	pop	r29
    1b0e:	cf 91       	pop	r28
    1b10:	1f 91       	pop	r17
    1b12:	0f 91       	pop	r16
    1b14:	ff 90       	pop	r15
    1b16:	ef 90       	pop	r14
    1b18:	df 90       	pop	r13
    1b1a:	cf 90       	pop	r12
    1b1c:	bf 90       	pop	r11
    1b1e:	af 90       	pop	r10
    1b20:	9f 90       	pop	r9
    1b22:	8f 90       	pop	r8
    1b24:	7f 90       	pop	r7
    1b26:	6f 90       	pop	r6
    1b28:	5f 90       	pop	r5
    1b2a:	4f 90       	pop	r4
    1b2c:	08 95       	ret

00001b2e <vTaskStartScheduler>:
    1b2e:	af 92       	push	r10
    1b30:	bf 92       	push	r11
    1b32:	cf 92       	push	r12
    1b34:	df 92       	push	r13
    1b36:	ef 92       	push	r14
    1b38:	ff 92       	push	r15
    1b3a:	0f 93       	push	r16
    1b3c:	a1 2c       	mov	r10, r1
    1b3e:	b1 2c       	mov	r11, r1
    1b40:	c1 2c       	mov	r12, r1
    1b42:	d1 2c       	mov	r13, r1
    1b44:	e1 2c       	mov	r14, r1
    1b46:	f1 2c       	mov	r15, r1
    1b48:	00 e0       	ldi	r16, 0x00	; 0
    1b4a:	20 e0       	ldi	r18, 0x00	; 0
    1b4c:	30 e0       	ldi	r19, 0x00	; 0
    1b4e:	45 e5       	ldi	r20, 0x55	; 85
    1b50:	50 e0       	ldi	r21, 0x00	; 0
    1b52:	68 e6       	ldi	r22, 0x68	; 104
    1b54:	72 e0       	ldi	r23, 0x02	; 2
    1b56:	81 e2       	ldi	r24, 0x21	; 33
    1b58:	9f e0       	ldi	r25, 0x0F	; 15
    1b5a:	e1 de       	rcall	.-574    	; 0x191e <xTaskGenericCreate>
    1b5c:	81 30       	cpi	r24, 0x01	; 1
    1b5e:	41 f4       	brne	.+16     	; 0x1b70 <vTaskStartScheduler+0x42>
    1b60:	f8 94       	cli
    1b62:	80 93 d5 08 	sts	0x08D5, r24
    1b66:	10 92 d8 08 	sts	0x08D8, r1
    1b6a:	10 92 d7 08 	sts	0x08D7, r1
    1b6e:	73 da       	rcall	.-2842   	; 0x1056 <xPortStartScheduler>
    1b70:	0f 91       	pop	r16
    1b72:	ff 90       	pop	r15
    1b74:	ef 90       	pop	r14
    1b76:	df 90       	pop	r13
    1b78:	cf 90       	pop	r12
    1b7a:	bf 90       	pop	r11
    1b7c:	af 90       	pop	r10
    1b7e:	08 95       	ret

00001b80 <vTaskSuspendAll>:
    1b80:	80 91 d0 08 	lds	r24, 0x08D0
    1b84:	8f 5f       	subi	r24, 0xFF	; 255
    1b86:	80 93 d0 08 	sts	0x08D0, r24
    1b8a:	08 95       	ret

00001b8c <xTaskIncrementTick>:
    1b8c:	cf 92       	push	r12
    1b8e:	df 92       	push	r13
    1b90:	ef 92       	push	r14
    1b92:	ff 92       	push	r15
    1b94:	0f 93       	push	r16
    1b96:	1f 93       	push	r17
    1b98:	cf 93       	push	r28
    1b9a:	df 93       	push	r29
    1b9c:	80 91 d0 08 	lds	r24, 0x08D0
    1ba0:	81 11       	cpse	r24, r1
    1ba2:	99 c0       	rjmp	.+306    	; 0x1cd6 <xTaskIncrementTick+0x14a>
    1ba4:	80 91 d7 08 	lds	r24, 0x08D7
    1ba8:	90 91 d8 08 	lds	r25, 0x08D8
    1bac:	01 96       	adiw	r24, 0x01	; 1
    1bae:	90 93 d8 08 	sts	0x08D8, r25
    1bb2:	80 93 d7 08 	sts	0x08D7, r24
    1bb6:	e0 90 d7 08 	lds	r14, 0x08D7
    1bba:	f0 90 d8 08 	lds	r15, 0x08D8
    1bbe:	e1 14       	cp	r14, r1
    1bc0:	f1 04       	cpc	r15, r1
    1bc2:	b1 f4       	brne	.+44     	; 0x1bf0 <xTaskIncrementTick+0x64>
    1bc4:	80 91 ef 08 	lds	r24, 0x08EF
    1bc8:	90 91 f0 08 	lds	r25, 0x08F0
    1bcc:	20 91 ed 08 	lds	r18, 0x08ED
    1bd0:	30 91 ee 08 	lds	r19, 0x08EE
    1bd4:	30 93 f0 08 	sts	0x08F0, r19
    1bd8:	20 93 ef 08 	sts	0x08EF, r18
    1bdc:	90 93 ee 08 	sts	0x08EE, r25
    1be0:	80 93 ed 08 	sts	0x08ED, r24
    1be4:	80 91 d2 08 	lds	r24, 0x08D2
    1be8:	8f 5f       	subi	r24, 0xFF	; 255
    1bea:	80 93 d2 08 	sts	0x08D2, r24
    1bee:	42 de       	rcall	.-892    	; 0x1874 <prvResetNextTaskUnblockTime>
    1bf0:	80 91 06 02 	lds	r24, 0x0206
    1bf4:	90 91 07 02 	lds	r25, 0x0207
    1bf8:	e8 16       	cp	r14, r24
    1bfa:	f9 06       	cpc	r15, r25
    1bfc:	08 f4       	brcc	.+2      	; 0x1c00 <xTaskIncrementTick+0x74>
    1bfe:	54 c0       	rjmp	.+168    	; 0x1ca8 <xTaskIncrementTick+0x11c>
    1c00:	d1 2c       	mov	r13, r1
    1c02:	cc 24       	eor	r12, r12
    1c04:	c3 94       	inc	r12
    1c06:	01 c0       	rjmp	.+2      	; 0x1c0a <xTaskIncrementTick+0x7e>
    1c08:	dc 2c       	mov	r13, r12
    1c0a:	e0 91 ef 08 	lds	r30, 0x08EF
    1c0e:	f0 91 f0 08 	lds	r31, 0x08F0
    1c12:	80 81       	ld	r24, Z
    1c14:	81 11       	cpse	r24, r1
    1c16:	07 c0       	rjmp	.+14     	; 0x1c26 <xTaskIncrementTick+0x9a>
    1c18:	8f ef       	ldi	r24, 0xFF	; 255
    1c1a:	9f ef       	ldi	r25, 0xFF	; 255
    1c1c:	90 93 07 02 	sts	0x0207, r25
    1c20:	80 93 06 02 	sts	0x0206, r24
    1c24:	42 c0       	rjmp	.+132    	; 0x1caa <xTaskIncrementTick+0x11e>
    1c26:	e0 91 ef 08 	lds	r30, 0x08EF
    1c2a:	f0 91 f0 08 	lds	r31, 0x08F0
    1c2e:	05 80       	ldd	r0, Z+5	; 0x05
    1c30:	f6 81       	ldd	r31, Z+6	; 0x06
    1c32:	e0 2d       	mov	r30, r0
    1c34:	c6 81       	ldd	r28, Z+6	; 0x06
    1c36:	d7 81       	ldd	r29, Z+7	; 0x07
    1c38:	2a 81       	ldd	r18, Y+2	; 0x02
    1c3a:	3b 81       	ldd	r19, Y+3	; 0x03
    1c3c:	e2 16       	cp	r14, r18
    1c3e:	f3 06       	cpc	r15, r19
    1c40:	28 f4       	brcc	.+10     	; 0x1c4c <xTaskIncrementTick+0xc0>
    1c42:	30 93 07 02 	sts	0x0207, r19
    1c46:	20 93 06 02 	sts	0x0206, r18
    1c4a:	2f c0       	rjmp	.+94     	; 0x1caa <xTaskIncrementTick+0x11e>
    1c4c:	8e 01       	movw	r16, r28
    1c4e:	0e 5f       	subi	r16, 0xFE	; 254
    1c50:	1f 4f       	sbci	r17, 0xFF	; 255
    1c52:	c8 01       	movw	r24, r16
    1c54:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1c58:	8c 89       	ldd	r24, Y+20	; 0x14
    1c5a:	9d 89       	ldd	r25, Y+21	; 0x15
    1c5c:	89 2b       	or	r24, r25
    1c5e:	21 f0       	breq	.+8      	; 0x1c68 <xTaskIncrementTick+0xdc>
    1c60:	ce 01       	movw	r24, r28
    1c62:	0c 96       	adiw	r24, 0x0c	; 12
    1c64:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1c68:	2e 89       	ldd	r18, Y+22	; 0x16
    1c6a:	80 91 d6 08 	lds	r24, 0x08D6
    1c6e:	82 17       	cp	r24, r18
    1c70:	10 f4       	brcc	.+4      	; 0x1c76 <xTaskIncrementTick+0xea>
    1c72:	20 93 d6 08 	sts	0x08D6, r18
    1c76:	30 e0       	ldi	r19, 0x00	; 0
    1c78:	c9 01       	movw	r24, r18
    1c7a:	88 0f       	add	r24, r24
    1c7c:	99 1f       	adc	r25, r25
    1c7e:	88 0f       	add	r24, r24
    1c80:	99 1f       	adc	r25, r25
    1c82:	88 0f       	add	r24, r24
    1c84:	99 1f       	adc	r25, r25
    1c86:	82 0f       	add	r24, r18
    1c88:	93 1f       	adc	r25, r19
    1c8a:	b8 01       	movw	r22, r16
    1c8c:	8d 5f       	subi	r24, 0xFD	; 253
    1c8e:	96 4f       	sbci	r25, 0xF6	; 246
    1c90:	0e 94 58 04 	call	0x8b0	; 0x8b0 <vListInsertEnd>
    1c94:	e0 91 27 09 	lds	r30, 0x0927
    1c98:	f0 91 28 09 	lds	r31, 0x0928
    1c9c:	9e 89       	ldd	r25, Y+22	; 0x16
    1c9e:	86 89       	ldd	r24, Z+22	; 0x16
    1ca0:	98 17       	cp	r25, r24
    1ca2:	08 f0       	brcs	.+2      	; 0x1ca6 <xTaskIncrementTick+0x11a>
    1ca4:	b1 cf       	rjmp	.-158    	; 0x1c08 <xTaskIncrementTick+0x7c>
    1ca6:	b1 cf       	rjmp	.-158    	; 0x1c0a <xTaskIncrementTick+0x7e>
    1ca8:	d1 2c       	mov	r13, r1
    1caa:	e0 91 27 09 	lds	r30, 0x0927
    1cae:	f0 91 28 09 	lds	r31, 0x0928
    1cb2:	86 89       	ldd	r24, Z+22	; 0x16
    1cb4:	90 e0       	ldi	r25, 0x00	; 0
    1cb6:	fc 01       	movw	r30, r24
    1cb8:	ee 0f       	add	r30, r30
    1cba:	ff 1f       	adc	r31, r31
    1cbc:	ee 0f       	add	r30, r30
    1cbe:	ff 1f       	adc	r31, r31
    1cc0:	ee 0f       	add	r30, r30
    1cc2:	ff 1f       	adc	r31, r31
    1cc4:	8e 0f       	add	r24, r30
    1cc6:	9f 1f       	adc	r25, r31
    1cc8:	fc 01       	movw	r30, r24
    1cca:	ed 5f       	subi	r30, 0xFD	; 253
    1ccc:	f6 4f       	sbci	r31, 0xF6	; 246
    1cce:	80 81       	ld	r24, Z
    1cd0:	82 30       	cpi	r24, 0x02	; 2
    1cd2:	40 f4       	brcc	.+16     	; 0x1ce4 <xTaskIncrementTick+0x158>
    1cd4:	09 c0       	rjmp	.+18     	; 0x1ce8 <xTaskIncrementTick+0x15c>
    1cd6:	80 91 d4 08 	lds	r24, 0x08D4
    1cda:	8f 5f       	subi	r24, 0xFF	; 255
    1cdc:	80 93 d4 08 	sts	0x08D4, r24
    1ce0:	d1 2c       	mov	r13, r1
    1ce2:	02 c0       	rjmp	.+4      	; 0x1ce8 <xTaskIncrementTick+0x15c>
    1ce4:	dd 24       	eor	r13, r13
    1ce6:	d3 94       	inc	r13
    1ce8:	80 91 d3 08 	lds	r24, 0x08D3
    1cec:	88 23       	and	r24, r24
    1cee:	11 f0       	breq	.+4      	; 0x1cf4 <xTaskIncrementTick+0x168>
    1cf0:	dd 24       	eor	r13, r13
    1cf2:	d3 94       	inc	r13
    1cf4:	8d 2d       	mov	r24, r13
    1cf6:	df 91       	pop	r29
    1cf8:	cf 91       	pop	r28
    1cfa:	1f 91       	pop	r17
    1cfc:	0f 91       	pop	r16
    1cfe:	ff 90       	pop	r15
    1d00:	ef 90       	pop	r14
    1d02:	df 90       	pop	r13
    1d04:	cf 90       	pop	r12
    1d06:	08 95       	ret

00001d08 <xTaskResumeAll>:
    1d08:	df 92       	push	r13
    1d0a:	ef 92       	push	r14
    1d0c:	ff 92       	push	r15
    1d0e:	0f 93       	push	r16
    1d10:	1f 93       	push	r17
    1d12:	cf 93       	push	r28
    1d14:	df 93       	push	r29
    1d16:	0f b6       	in	r0, 0x3f	; 63
    1d18:	f8 94       	cli
    1d1a:	0f 92       	push	r0
    1d1c:	80 91 d0 08 	lds	r24, 0x08D0
    1d20:	81 50       	subi	r24, 0x01	; 1
    1d22:	80 93 d0 08 	sts	0x08D0, r24
    1d26:	80 91 d0 08 	lds	r24, 0x08D0
    1d2a:	81 11       	cpse	r24, r1
    1d2c:	5f c0       	rjmp	.+190    	; 0x1dec <xTaskResumeAll+0xe4>
    1d2e:	80 91 d9 08 	lds	r24, 0x08D9
    1d32:	88 23       	and	r24, r24
    1d34:	09 f4       	brne	.+2      	; 0x1d38 <xTaskResumeAll+0x30>
    1d36:	5c c0       	rjmp	.+184    	; 0x1df0 <xTaskResumeAll+0xe8>
    1d38:	0f 2e       	mov	r0, r31
    1d3a:	f4 ee       	ldi	r31, 0xE4	; 228
    1d3c:	ef 2e       	mov	r14, r31
    1d3e:	f8 e0       	ldi	r31, 0x08	; 8
    1d40:	ff 2e       	mov	r15, r31
    1d42:	f0 2d       	mov	r31, r0
    1d44:	dd 24       	eor	r13, r13
    1d46:	d3 94       	inc	r13
    1d48:	30 c0       	rjmp	.+96     	; 0x1daa <xTaskResumeAll+0xa2>
    1d4a:	e0 91 e9 08 	lds	r30, 0x08E9
    1d4e:	f0 91 ea 08 	lds	r31, 0x08EA
    1d52:	c6 81       	ldd	r28, Z+6	; 0x06
    1d54:	d7 81       	ldd	r29, Z+7	; 0x07
    1d56:	ce 01       	movw	r24, r28
    1d58:	0c 96       	adiw	r24, 0x0c	; 12
    1d5a:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1d5e:	8e 01       	movw	r16, r28
    1d60:	0e 5f       	subi	r16, 0xFE	; 254
    1d62:	1f 4f       	sbci	r17, 0xFF	; 255
    1d64:	c8 01       	movw	r24, r16
    1d66:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1d6a:	8e 89       	ldd	r24, Y+22	; 0x16
    1d6c:	90 91 d6 08 	lds	r25, 0x08D6
    1d70:	98 17       	cp	r25, r24
    1d72:	10 f4       	brcc	.+4      	; 0x1d78 <xTaskResumeAll+0x70>
    1d74:	80 93 d6 08 	sts	0x08D6, r24
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	9c 01       	movw	r18, r24
    1d7c:	22 0f       	add	r18, r18
    1d7e:	33 1f       	adc	r19, r19
    1d80:	22 0f       	add	r18, r18
    1d82:	33 1f       	adc	r19, r19
    1d84:	22 0f       	add	r18, r18
    1d86:	33 1f       	adc	r19, r19
    1d88:	82 0f       	add	r24, r18
    1d8a:	93 1f       	adc	r25, r19
    1d8c:	b8 01       	movw	r22, r16
    1d8e:	8d 5f       	subi	r24, 0xFD	; 253
    1d90:	96 4f       	sbci	r25, 0xF6	; 246
    1d92:	0e 94 58 04 	call	0x8b0	; 0x8b0 <vListInsertEnd>
    1d96:	e0 91 27 09 	lds	r30, 0x0927
    1d9a:	f0 91 28 09 	lds	r31, 0x0928
    1d9e:	9e 89       	ldd	r25, Y+22	; 0x16
    1da0:	86 89       	ldd	r24, Z+22	; 0x16
    1da2:	98 17       	cp	r25, r24
    1da4:	10 f0       	brcs	.+4      	; 0x1daa <xTaskResumeAll+0xa2>
    1da6:	d0 92 d3 08 	sts	0x08D3, r13
    1daa:	f7 01       	movw	r30, r14
    1dac:	80 81       	ld	r24, Z
    1dae:	81 11       	cpse	r24, r1
    1db0:	cc cf       	rjmp	.-104    	; 0x1d4a <xTaskResumeAll+0x42>
    1db2:	80 91 d4 08 	lds	r24, 0x08D4
    1db6:	88 23       	and	r24, r24
    1db8:	91 f0       	breq	.+36     	; 0x1dde <xTaskResumeAll+0xd6>
    1dba:	80 91 d4 08 	lds	r24, 0x08D4
    1dbe:	88 23       	and	r24, r24
    1dc0:	71 f0       	breq	.+28     	; 0x1dde <xTaskResumeAll+0xd6>
    1dc2:	c1 e0       	ldi	r28, 0x01	; 1
    1dc4:	e3 de       	rcall	.-570    	; 0x1b8c <xTaskIncrementTick>
    1dc6:	81 11       	cpse	r24, r1
    1dc8:	c0 93 d3 08 	sts	0x08D3, r28
    1dcc:	80 91 d4 08 	lds	r24, 0x08D4
    1dd0:	81 50       	subi	r24, 0x01	; 1
    1dd2:	80 93 d4 08 	sts	0x08D4, r24
    1dd6:	80 91 d4 08 	lds	r24, 0x08D4
    1dda:	81 11       	cpse	r24, r1
    1ddc:	f3 cf       	rjmp	.-26     	; 0x1dc4 <xTaskResumeAll+0xbc>
    1dde:	80 91 d3 08 	lds	r24, 0x08D3
    1de2:	81 30       	cpi	r24, 0x01	; 1
    1de4:	39 f4       	brne	.+14     	; 0x1df4 <xTaskResumeAll+0xec>
    1de6:	78 d9       	rcall	.-3344   	; 0x10d8 <vPortYield>
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	05 c0       	rjmp	.+10     	; 0x1df6 <xTaskResumeAll+0xee>
    1dec:	80 e0       	ldi	r24, 0x00	; 0
    1dee:	03 c0       	rjmp	.+6      	; 0x1df6 <xTaskResumeAll+0xee>
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	01 c0       	rjmp	.+2      	; 0x1df6 <xTaskResumeAll+0xee>
    1df4:	80 e0       	ldi	r24, 0x00	; 0
    1df6:	0f 90       	pop	r0
    1df8:	0f be       	out	0x3f, r0	; 63
    1dfa:	df 91       	pop	r29
    1dfc:	cf 91       	pop	r28
    1dfe:	1f 91       	pop	r17
    1e00:	0f 91       	pop	r16
    1e02:	ff 90       	pop	r15
    1e04:	ef 90       	pop	r14
    1e06:	df 90       	pop	r13
    1e08:	08 95       	ret

00001e0a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1e0a:	cf 93       	push	r28
    1e0c:	df 93       	push	r29
    1e0e:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1e10:	00 97       	sbiw	r24, 0x00	; 0
    1e12:	99 f0       	breq	.+38     	; 0x1e3a <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1e14:	b5 de       	rcall	.-662    	; 0x1b80 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e16:	80 91 d7 08 	lds	r24, 0x08D7
    1e1a:	90 91 d8 08 	lds	r25, 0x08D8
    1e1e:	c8 0f       	add	r28, r24
    1e20:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1e22:	80 91 27 09 	lds	r24, 0x0927
    1e26:	90 91 28 09 	lds	r25, 0x0928
    1e2a:	02 96       	adiw	r24, 0x02	; 2
    1e2c:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e30:	ce 01       	movw	r24, r28
    1e32:	3f dd       	rcall	.-1410   	; 0x18b2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e34:	69 df       	rcall	.-302    	; 0x1d08 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e36:	81 11       	cpse	r24, r1
    1e38:	01 c0       	rjmp	.+2      	; 0x1e3c <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    1e3a:	4e d9       	rcall	.-3428   	; 0x10d8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	08 95       	ret

00001e42 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1e42:	0f 2e       	mov	r0, r31
    1e44:	f3 e0       	ldi	r31, 0x03	; 3
    1e46:	ef 2e       	mov	r14, r31
    1e48:	f9 e0       	ldi	r31, 0x09	; 9
    1e4a:	ff 2e       	mov	r15, r31
    1e4c:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1e4e:	cb ed       	ldi	r28, 0xDB	; 219
    1e50:	d8 e0       	ldi	r29, 0x08	; 8
    1e52:	26 c0       	rjmp	.+76     	; 0x1ea0 <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    1e54:	95 de       	rcall	.-726    	; 0x1b80 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1e56:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    1e58:	57 df       	rcall	.-338    	; 0x1d08 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1e5a:	11 23       	and	r17, r17
    1e5c:	09 f1       	breq	.+66     	; 0x1ea0 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1e5e:	0f b6       	in	r0, 0x3f	; 63
    1e60:	f8 94       	cli
    1e62:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1e64:	e0 91 e0 08 	lds	r30, 0x08E0
    1e68:	f0 91 e1 08 	lds	r31, 0x08E1
    1e6c:	06 81       	ldd	r16, Z+6	; 0x06
    1e6e:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1e70:	c8 01       	movw	r24, r16
    1e72:	02 96       	adiw	r24, 0x02	; 2
    1e74:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1e78:	80 91 d9 08 	lds	r24, 0x08D9
    1e7c:	81 50       	subi	r24, 0x01	; 1
    1e7e:	80 93 d9 08 	sts	0x08D9, r24
					--uxTasksDeleted;
    1e82:	80 91 da 08 	lds	r24, 0x08DA
    1e86:	81 50       	subi	r24, 0x01	; 1
    1e88:	80 93 da 08 	sts	0x08DA, r24
				}
				taskEXIT_CRITICAL();
    1e8c:	0f 90       	pop	r0
    1e8e:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    1e90:	f8 01       	movw	r30, r16
    1e92:	87 89       	ldd	r24, Z+23	; 0x17
    1e94:	90 8d       	ldd	r25, Z+24	; 0x18
    1e96:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortFree>
		vPortFree( pxTCB );
    1e9a:	c8 01       	movw	r24, r16
    1e9c:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1ea0:	80 91 da 08 	lds	r24, 0x08DA
    1ea4:	81 11       	cpse	r24, r1
    1ea6:	d6 cf       	rjmp	.-84     	; 0x1e54 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1ea8:	f7 01       	movw	r30, r14
    1eaa:	80 81       	ld	r24, Z
    1eac:	82 30       	cpi	r24, 0x02	; 2
    1eae:	c0 f3       	brcs	.-16     	; 0x1ea0 <prvIdleTask+0x5e>
			{
				taskYIELD();
    1eb0:	13 d9       	rcall	.-3546   	; 0x10d8 <vPortYield>
    1eb2:	f6 cf       	rjmp	.-20     	; 0x1ea0 <prvIdleTask+0x5e>

00001eb4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1eb4:	80 91 d0 08 	lds	r24, 0x08D0
    1eb8:	88 23       	and	r24, r24
    1eba:	21 f0       	breq	.+8      	; 0x1ec4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	80 93 d3 08 	sts	0x08D3, r24
    1ec2:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1ec4:	10 92 d3 08 	sts	0x08D3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1ec8:	80 91 d6 08 	lds	r24, 0x08D6
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	fc 01       	movw	r30, r24
    1ed0:	ee 0f       	add	r30, r30
    1ed2:	ff 1f       	adc	r31, r31
    1ed4:	ee 0f       	add	r30, r30
    1ed6:	ff 1f       	adc	r31, r31
    1ed8:	ee 0f       	add	r30, r30
    1eda:	ff 1f       	adc	r31, r31
    1edc:	8e 0f       	add	r24, r30
    1ede:	9f 1f       	adc	r25, r31
    1ee0:	fc 01       	movw	r30, r24
    1ee2:	ed 5f       	subi	r30, 0xFD	; 253
    1ee4:	f6 4f       	sbci	r31, 0xF6	; 246
    1ee6:	80 81       	ld	r24, Z
    1ee8:	81 11       	cpse	r24, r1
    1eea:	17 c0       	rjmp	.+46     	; 0x1f1a <vTaskSwitchContext+0x66>
    1eec:	80 91 d6 08 	lds	r24, 0x08D6
    1ef0:	81 50       	subi	r24, 0x01	; 1
    1ef2:	80 93 d6 08 	sts	0x08D6, r24
    1ef6:	80 91 d6 08 	lds	r24, 0x08D6
    1efa:	90 e0       	ldi	r25, 0x00	; 0
    1efc:	fc 01       	movw	r30, r24
    1efe:	ee 0f       	add	r30, r30
    1f00:	ff 1f       	adc	r31, r31
    1f02:	ee 0f       	add	r30, r30
    1f04:	ff 1f       	adc	r31, r31
    1f06:	ee 0f       	add	r30, r30
    1f08:	ff 1f       	adc	r31, r31
    1f0a:	8e 0f       	add	r24, r30
    1f0c:	9f 1f       	adc	r25, r31
    1f0e:	fc 01       	movw	r30, r24
    1f10:	ed 5f       	subi	r30, 0xFD	; 253
    1f12:	f6 4f       	sbci	r31, 0xF6	; 246
    1f14:	80 81       	ld	r24, Z
    1f16:	88 23       	and	r24, r24
    1f18:	49 f3       	breq	.-46     	; 0x1eec <vTaskSwitchContext+0x38>
    1f1a:	e0 91 d6 08 	lds	r30, 0x08D6
    1f1e:	f0 e0       	ldi	r31, 0x00	; 0
    1f20:	cf 01       	movw	r24, r30
    1f22:	88 0f       	add	r24, r24
    1f24:	99 1f       	adc	r25, r25
    1f26:	88 0f       	add	r24, r24
    1f28:	99 1f       	adc	r25, r25
    1f2a:	88 0f       	add	r24, r24
    1f2c:	99 1f       	adc	r25, r25
    1f2e:	e8 0f       	add	r30, r24
    1f30:	f9 1f       	adc	r31, r25
    1f32:	ed 5f       	subi	r30, 0xFD	; 253
    1f34:	f6 4f       	sbci	r31, 0xF6	; 246
    1f36:	a1 81       	ldd	r26, Z+1	; 0x01
    1f38:	b2 81       	ldd	r27, Z+2	; 0x02
    1f3a:	12 96       	adiw	r26, 0x02	; 2
    1f3c:	0d 90       	ld	r0, X+
    1f3e:	bc 91       	ld	r27, X
    1f40:	a0 2d       	mov	r26, r0
    1f42:	b2 83       	std	Z+2, r27	; 0x02
    1f44:	a1 83       	std	Z+1, r26	; 0x01
    1f46:	cf 01       	movw	r24, r30
    1f48:	03 96       	adiw	r24, 0x03	; 3
    1f4a:	a8 17       	cp	r26, r24
    1f4c:	b9 07       	cpc	r27, r25
    1f4e:	31 f4       	brne	.+12     	; 0x1f5c <vTaskSwitchContext+0xa8>
    1f50:	12 96       	adiw	r26, 0x02	; 2
    1f52:	8d 91       	ld	r24, X+
    1f54:	9c 91       	ld	r25, X
    1f56:	13 97       	sbiw	r26, 0x03	; 3
    1f58:	92 83       	std	Z+2, r25	; 0x02
    1f5a:	81 83       	std	Z+1, r24	; 0x01
    1f5c:	01 80       	ldd	r0, Z+1	; 0x01
    1f5e:	f2 81       	ldd	r31, Z+2	; 0x02
    1f60:	e0 2d       	mov	r30, r0
    1f62:	86 81       	ldd	r24, Z+6	; 0x06
    1f64:	97 81       	ldd	r25, Z+7	; 0x07
    1f66:	90 93 28 09 	sts	0x0928, r25
    1f6a:	80 93 27 09 	sts	0x0927, r24
    1f6e:	08 95       	ret

00001f70 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1f70:	10 92 96 09 	sts	0x0996, r1
    1f74:	81 e0       	ldi	r24, 0x01	; 1
    1f76:	80 93 94 09 	sts	0x0994, r24
    1f7a:	10 92 93 09 	sts	0x0993, r1
    1f7e:	61 e0       	ldi	r22, 0x01	; 1
    1f80:	84 e1       	ldi	r24, 0x14	; 20
    1f82:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <digitalWrite>
    1f86:	61 e0       	ldi	r22, 0x01	; 1
    1f88:	85 e1       	ldi	r24, 0x15	; 21
    1f8a:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <digitalWrite>
    1f8e:	e9 eb       	ldi	r30, 0xB9	; 185
    1f90:	f0 e0       	ldi	r31, 0x00	; 0
    1f92:	80 81       	ld	r24, Z
    1f94:	8e 7f       	andi	r24, 0xFE	; 254
    1f96:	80 83       	st	Z, r24
    1f98:	80 81       	ld	r24, Z
    1f9a:	8d 7f       	andi	r24, 0xFD	; 253
    1f9c:	80 83       	st	Z, r24
    1f9e:	8d ef       	ldi	r24, 0xFD	; 253
    1fa0:	80 93 b8 00 	sts	0x00B8, r24
    1fa4:	85 e4       	ldi	r24, 0x45	; 69
    1fa6:	80 93 bc 00 	sts	0x00BC, r24
    1faa:	08 95       	ret

00001fac <twi_readFrom>:
    1fac:	41 32       	cpi	r20, 0x21	; 33
    1fae:	08 f0       	brcs	.+2      	; 0x1fb2 <twi_readFrom+0x6>
    1fb0:	45 c0       	rjmp	.+138    	; 0x203c <twi_readFrom+0x90>
    1fb2:	90 91 96 09 	lds	r25, 0x0996
    1fb6:	91 11       	cpse	r25, r1
    1fb8:	fc cf       	rjmp	.-8      	; 0x1fb2 <twi_readFrom+0x6>
    1fba:	91 e0       	ldi	r25, 0x01	; 1
    1fbc:	90 93 96 09 	sts	0x0996, r25
    1fc0:	20 93 94 09 	sts	0x0994, r18
    1fc4:	2f ef       	ldi	r18, 0xFF	; 255
    1fc6:	20 93 29 09 	sts	0x0929, r18
    1fca:	10 92 6e 09 	sts	0x096E, r1
    1fce:	24 0f       	add	r18, r20
    1fd0:	20 93 6d 09 	sts	0x096D, r18
    1fd4:	90 93 95 09 	sts	0x0995, r25
    1fd8:	90 91 95 09 	lds	r25, 0x0995
    1fdc:	88 0f       	add	r24, r24
    1fde:	89 2b       	or	r24, r25
    1fe0:	80 93 95 09 	sts	0x0995, r24
    1fe4:	80 91 93 09 	lds	r24, 0x0993
    1fe8:	81 30       	cpi	r24, 0x01	; 1
    1fea:	51 f4       	brne	.+20     	; 0x2000 <twi_readFrom+0x54>
    1fec:	10 92 93 09 	sts	0x0993, r1
    1ff0:	80 91 95 09 	lds	r24, 0x0995
    1ff4:	80 93 bb 00 	sts	0x00BB, r24
    1ff8:	85 ec       	ldi	r24, 0xC5	; 197
    1ffa:	80 93 bc 00 	sts	0x00BC, r24
    1ffe:	03 c0       	rjmp	.+6      	; 0x2006 <twi_readFrom+0x5a>
    2000:	85 ee       	ldi	r24, 0xE5	; 229
    2002:	80 93 bc 00 	sts	0x00BC, r24
    2006:	80 91 96 09 	lds	r24, 0x0996
    200a:	81 30       	cpi	r24, 0x01	; 1
    200c:	e1 f3       	breq	.-8      	; 0x2006 <twi_readFrom+0x5a>
    200e:	80 91 6e 09 	lds	r24, 0x096E
    2012:	84 17       	cp	r24, r20
    2014:	10 f4       	brcc	.+4      	; 0x201a <twi_readFrom+0x6e>
    2016:	40 91 6e 09 	lds	r20, 0x096E
    201a:	44 23       	and	r20, r20
    201c:	89 f0       	breq	.+34     	; 0x2040 <twi_readFrom+0x94>
    201e:	ef e6       	ldi	r30, 0x6F	; 111
    2020:	f9 e0       	ldi	r31, 0x09	; 9
    2022:	a6 2f       	mov	r26, r22
    2024:	b7 2f       	mov	r27, r23
    2026:	2f ef       	ldi	r18, 0xFF	; 255
    2028:	24 0f       	add	r18, r20
    202a:	30 e0       	ldi	r19, 0x00	; 0
    202c:	20 59       	subi	r18, 0x90	; 144
    202e:	36 4f       	sbci	r19, 0xF6	; 246
    2030:	91 91       	ld	r25, Z+
    2032:	9d 93       	st	X+, r25
    2034:	e2 17       	cp	r30, r18
    2036:	f3 07       	cpc	r31, r19
    2038:	d9 f7       	brne	.-10     	; 0x2030 <twi_readFrom+0x84>
    203a:	04 c0       	rjmp	.+8      	; 0x2044 <twi_readFrom+0x98>
    203c:	80 e0       	ldi	r24, 0x00	; 0
    203e:	08 95       	ret
    2040:	84 2f       	mov	r24, r20
    2042:	08 95       	ret
    2044:	84 2f       	mov	r24, r20
    2046:	08 95       	ret

00002048 <twi_writeTo>:
    2048:	0f 93       	push	r16
    204a:	41 32       	cpi	r20, 0x21	; 33
    204c:	08 f0       	brcs	.+2      	; 0x2050 <twi_writeTo+0x8>
    204e:	50 c0       	rjmp	.+160    	; 0x20f0 <twi_writeTo+0xa8>
    2050:	90 91 96 09 	lds	r25, 0x0996
    2054:	91 11       	cpse	r25, r1
    2056:	fc cf       	rjmp	.-8      	; 0x2050 <twi_writeTo+0x8>
    2058:	92 e0       	ldi	r25, 0x02	; 2
    205a:	90 93 96 09 	sts	0x0996, r25
    205e:	00 93 94 09 	sts	0x0994, r16
    2062:	9f ef       	ldi	r25, 0xFF	; 255
    2064:	90 93 29 09 	sts	0x0929, r25
    2068:	10 92 6e 09 	sts	0x096E, r1
    206c:	40 93 6d 09 	sts	0x096D, r20
    2070:	44 23       	and	r20, r20
    2072:	69 f0       	breq	.+26     	; 0x208e <twi_writeTo+0x46>
    2074:	fb 01       	movw	r30, r22
    2076:	af e6       	ldi	r26, 0x6F	; 111
    2078:	b9 e0       	ldi	r27, 0x09	; 9
    207a:	6f 5f       	subi	r22, 0xFF	; 255
    207c:	7f 4f       	sbci	r23, 0xFF	; 255
    207e:	41 50       	subi	r20, 0x01	; 1
    2080:	64 0f       	add	r22, r20
    2082:	71 1d       	adc	r23, r1
    2084:	91 91       	ld	r25, Z+
    2086:	9d 93       	st	X+, r25
    2088:	e6 17       	cp	r30, r22
    208a:	f7 07       	cpc	r31, r23
    208c:	d9 f7       	brne	.-10     	; 0x2084 <twi_writeTo+0x3c>
    208e:	10 92 95 09 	sts	0x0995, r1
    2092:	90 91 95 09 	lds	r25, 0x0995
    2096:	88 0f       	add	r24, r24
    2098:	89 2b       	or	r24, r25
    209a:	80 93 95 09 	sts	0x0995, r24
    209e:	80 91 93 09 	lds	r24, 0x0993
    20a2:	81 30       	cpi	r24, 0x01	; 1
    20a4:	51 f4       	brne	.+20     	; 0x20ba <twi_writeTo+0x72>
    20a6:	10 92 93 09 	sts	0x0993, r1
    20aa:	80 91 95 09 	lds	r24, 0x0995
    20ae:	80 93 bb 00 	sts	0x00BB, r24
    20b2:	85 ec       	ldi	r24, 0xC5	; 197
    20b4:	80 93 bc 00 	sts	0x00BC, r24
    20b8:	03 c0       	rjmp	.+6      	; 0x20c0 <twi_writeTo+0x78>
    20ba:	85 ee       	ldi	r24, 0xE5	; 229
    20bc:	80 93 bc 00 	sts	0x00BC, r24
    20c0:	22 23       	and	r18, r18
    20c2:	41 f0       	breq	.+16     	; 0x20d4 <twi_writeTo+0x8c>
    20c4:	80 91 96 09 	lds	r24, 0x0996
    20c8:	82 30       	cpi	r24, 0x02	; 2
    20ca:	21 f4       	brne	.+8      	; 0x20d4 <twi_writeTo+0x8c>
    20cc:	80 91 96 09 	lds	r24, 0x0996
    20d0:	82 30       	cpi	r24, 0x02	; 2
    20d2:	e1 f3       	breq	.-8      	; 0x20cc <twi_writeTo+0x84>
    20d4:	80 91 29 09 	lds	r24, 0x0929
    20d8:	8f 3f       	cpi	r24, 0xFF	; 255
    20da:	61 f0       	breq	.+24     	; 0x20f4 <twi_writeTo+0xac>
    20dc:	80 91 29 09 	lds	r24, 0x0929
    20e0:	80 32       	cpi	r24, 0x20	; 32
    20e2:	51 f0       	breq	.+20     	; 0x20f8 <twi_writeTo+0xb0>
    20e4:	80 91 29 09 	lds	r24, 0x0929
    20e8:	80 33       	cpi	r24, 0x30	; 48
    20ea:	41 f4       	brne	.+16     	; 0x20fc <twi_writeTo+0xb4>
    20ec:	83 e0       	ldi	r24, 0x03	; 3
    20ee:	07 c0       	rjmp	.+14     	; 0x20fe <twi_writeTo+0xb6>
    20f0:	81 e0       	ldi	r24, 0x01	; 1
    20f2:	05 c0       	rjmp	.+10     	; 0x20fe <twi_writeTo+0xb6>
    20f4:	80 e0       	ldi	r24, 0x00	; 0
    20f6:	03 c0       	rjmp	.+6      	; 0x20fe <twi_writeTo+0xb6>
    20f8:	82 e0       	ldi	r24, 0x02	; 2
    20fa:	01 c0       	rjmp	.+2      	; 0x20fe <twi_writeTo+0xb6>
    20fc:	84 e0       	ldi	r24, 0x04	; 4
    20fe:	0f 91       	pop	r16
    2100:	08 95       	ret

00002102 <twi_transmit>:
    2102:	61 32       	cpi	r22, 0x21	; 33
    2104:	a8 f4       	brcc	.+42     	; 0x2130 <twi_transmit+0x2e>
    2106:	20 91 96 09 	lds	r18, 0x0996
    210a:	24 30       	cpi	r18, 0x04	; 4
    210c:	99 f4       	brne	.+38     	; 0x2134 <twi_transmit+0x32>
    210e:	60 93 4b 09 	sts	0x094B, r22
    2112:	66 23       	and	r22, r22
    2114:	89 f0       	breq	.+34     	; 0x2138 <twi_transmit+0x36>
    2116:	fc 01       	movw	r30, r24
    2118:	ad e4       	ldi	r26, 0x4D	; 77
    211a:	b9 e0       	ldi	r27, 0x09	; 9
    211c:	01 96       	adiw	r24, 0x01	; 1
    211e:	61 50       	subi	r22, 0x01	; 1
    2120:	86 0f       	add	r24, r22
    2122:	91 1d       	adc	r25, r1
    2124:	21 91       	ld	r18, Z+
    2126:	2d 93       	st	X+, r18
    2128:	e8 17       	cp	r30, r24
    212a:	f9 07       	cpc	r31, r25
    212c:	d9 f7       	brne	.-10     	; 0x2124 <twi_transmit+0x22>
    212e:	06 c0       	rjmp	.+12     	; 0x213c <twi_transmit+0x3a>
    2130:	81 e0       	ldi	r24, 0x01	; 1
    2132:	08 95       	ret
    2134:	82 e0       	ldi	r24, 0x02	; 2
    2136:	08 95       	ret
    2138:	80 e0       	ldi	r24, 0x00	; 0
    213a:	08 95       	ret
    213c:	80 e0       	ldi	r24, 0x00	; 0
    213e:	08 95       	ret

00002140 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    2140:	85 ed       	ldi	r24, 0xD5	; 213
    2142:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    2146:	ec eb       	ldi	r30, 0xBC	; 188
    2148:	f0 e0       	ldi	r31, 0x00	; 0
    214a:	80 81       	ld	r24, Z
    214c:	84 fd       	sbrc	r24, 4
    214e:	fd cf       	rjmp	.-6      	; 0x214a <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    2150:	10 92 96 09 	sts	0x0996, r1
    2154:	08 95       	ret

00002156 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2156:	85 ec       	ldi	r24, 0xC5	; 197
    2158:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    215c:	10 92 96 09 	sts	0x0996, r1
    2160:	08 95       	ret

00002162 <__vector_39>:
}

ISR(TWI_vect)
{
    2162:	1f 92       	push	r1
    2164:	0f 92       	push	r0
    2166:	0f b6       	in	r0, 0x3f	; 63
    2168:	0f 92       	push	r0
    216a:	11 24       	eor	r1, r1
    216c:	0b b6       	in	r0, 0x3b	; 59
    216e:	0f 92       	push	r0
    2170:	2f 93       	push	r18
    2172:	3f 93       	push	r19
    2174:	4f 93       	push	r20
    2176:	5f 93       	push	r21
    2178:	6f 93       	push	r22
    217a:	7f 93       	push	r23
    217c:	8f 93       	push	r24
    217e:	9f 93       	push	r25
    2180:	af 93       	push	r26
    2182:	bf 93       	push	r27
    2184:	ef 93       	push	r30
    2186:	ff 93       	push	r31
  switch(TW_STATUS){
    2188:	80 91 b9 00 	lds	r24, 0x00B9
    218c:	88 7f       	andi	r24, 0xF8	; 248
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	89 3c       	cpi	r24, 0xC9	; 201
    2192:	91 05       	cpc	r25, r1
    2194:	08 f0       	brcs	.+2      	; 0x2198 <__vector_39+0x36>
    2196:	ee c0       	rjmp	.+476    	; 0x2374 <__stack+0x175>
    2198:	fc 01       	movw	r30, r24
    219a:	ee 58       	subi	r30, 0x8E	; 142
    219c:	ff 4f       	sbci	r31, 0xFF	; 255
    219e:	0c 94 51 1b 	jmp	0x36a2	; 0x36a2 <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    21a2:	80 91 95 09 	lds	r24, 0x0995
    21a6:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    21aa:	85 ec       	ldi	r24, 0xC5	; 197
    21ac:	80 93 bc 00 	sts	0x00BC, r24
    21b0:	e1 c0       	rjmp	.+450    	; 0x2374 <__stack+0x175>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    21b2:	90 91 6e 09 	lds	r25, 0x096E
    21b6:	80 91 6d 09 	lds	r24, 0x096D
    21ba:	98 17       	cp	r25, r24
    21bc:	80 f4       	brcc	.+32     	; 0x21de <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    21be:	e0 91 6e 09 	lds	r30, 0x096E
    21c2:	81 e0       	ldi	r24, 0x01	; 1
    21c4:	8e 0f       	add	r24, r30
    21c6:	80 93 6e 09 	sts	0x096E, r24
    21ca:	f0 e0       	ldi	r31, 0x00	; 0
    21cc:	e1 59       	subi	r30, 0x91	; 145
    21ce:	f6 4f       	sbci	r31, 0xF6	; 246
    21d0:	80 81       	ld	r24, Z
    21d2:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    21d6:	85 ec       	ldi	r24, 0xC5	; 197
    21d8:	80 93 bc 00 	sts	0x00BC, r24
    21dc:	cb c0       	rjmp	.+406    	; 0x2374 <__stack+0x175>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    21de:	80 91 94 09 	lds	r24, 0x0994
    21e2:	88 23       	and	r24, r24
    21e4:	11 f0       	breq	.+4      	; 0x21ea <__vector_39+0x88>
          twi_stop();
    21e6:	ac df       	rcall	.-168    	; 0x2140 <twi_stop>
    21e8:	c5 c0       	rjmp	.+394    	; 0x2374 <__stack+0x175>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	80 93 93 09 	sts	0x0993, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    21f0:	84 ea       	ldi	r24, 0xA4	; 164
    21f2:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    21f6:	10 92 96 09 	sts	0x0996, r1
    21fa:	bc c0       	rjmp	.+376    	; 0x2374 <__stack+0x175>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    21fc:	80 e2       	ldi	r24, 0x20	; 32
    21fe:	80 93 29 09 	sts	0x0929, r24
      twi_stop();
    2202:	9e df       	rcall	.-196    	; 0x2140 <twi_stop>
      break;
    2204:	b7 c0       	rjmp	.+366    	; 0x2374 <__stack+0x175>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    2206:	80 e3       	ldi	r24, 0x30	; 48
    2208:	80 93 29 09 	sts	0x0929, r24
      twi_stop();
    220c:	99 df       	rcall	.-206    	; 0x2140 <twi_stop>
      break;
    220e:	b2 c0       	rjmp	.+356    	; 0x2374 <__stack+0x175>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    2210:	88 e3       	ldi	r24, 0x38	; 56
    2212:	80 93 29 09 	sts	0x0929, r24
      twi_releaseBus();
    2216:	9f df       	rcall	.-194    	; 0x2156 <twi_releaseBus>
      break;
    2218:	ad c0       	rjmp	.+346    	; 0x2374 <__stack+0x175>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    221a:	e0 91 6e 09 	lds	r30, 0x096E
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	8e 0f       	add	r24, r30
    2222:	80 93 6e 09 	sts	0x096E, r24
    2226:	80 91 bb 00 	lds	r24, 0x00BB
    222a:	f0 e0       	ldi	r31, 0x00	; 0
    222c:	e1 59       	subi	r30, 0x91	; 145
    222e:	f6 4f       	sbci	r31, 0xF6	; 246
    2230:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2232:	90 91 6e 09 	lds	r25, 0x096E
    2236:	80 91 6d 09 	lds	r24, 0x096D
    223a:	98 17       	cp	r25, r24
    223c:	20 f4       	brcc	.+8      	; 0x2246 <__stack+0x47>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    223e:	85 ec       	ldi	r24, 0xC5	; 197
    2240:	80 93 bc 00 	sts	0x00BC, r24
    2244:	97 c0       	rjmp	.+302    	; 0x2374 <__stack+0x175>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2246:	85 e8       	ldi	r24, 0x85	; 133
    2248:	80 93 bc 00 	sts	0x00BC, r24
    224c:	93 c0       	rjmp	.+294    	; 0x2374 <__stack+0x175>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    224e:	e0 91 6e 09 	lds	r30, 0x096E
    2252:	81 e0       	ldi	r24, 0x01	; 1
    2254:	8e 0f       	add	r24, r30
    2256:	80 93 6e 09 	sts	0x096E, r24
    225a:	80 91 bb 00 	lds	r24, 0x00BB
    225e:	f0 e0       	ldi	r31, 0x00	; 0
    2260:	e1 59       	subi	r30, 0x91	; 145
    2262:	f6 4f       	sbci	r31, 0xF6	; 246
    2264:	80 83       	st	Z, r24
	if (twi_sendStop)
    2266:	80 91 94 09 	lds	r24, 0x0994
    226a:	88 23       	and	r24, r24
    226c:	11 f0       	breq	.+4      	; 0x2272 <__stack+0x73>
          twi_stop();
    226e:	68 df       	rcall	.-304    	; 0x2140 <twi_stop>
    2270:	81 c0       	rjmp	.+258    	; 0x2374 <__stack+0x175>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	80 93 93 09 	sts	0x0993, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2278:	84 ea       	ldi	r24, 0xA4	; 164
    227a:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    227e:	10 92 96 09 	sts	0x0996, r1
    2282:	78 c0       	rjmp	.+240    	; 0x2374 <__stack+0x175>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    2284:	5d df       	rcall	.-326    	; 0x2140 <twi_stop>
      break;
    2286:	76 c0       	rjmp	.+236    	; 0x2374 <__stack+0x175>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    2288:	83 e0       	ldi	r24, 0x03	; 3
    228a:	80 93 96 09 	sts	0x0996, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    228e:	10 92 2a 09 	sts	0x092A, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2292:	85 ec       	ldi	r24, 0xC5	; 197
    2294:	80 93 bc 00 	sts	0x00BC, r24
    2298:	6d c0       	rjmp	.+218    	; 0x2374 <__stack+0x175>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    229a:	80 91 2a 09 	lds	r24, 0x092A
    229e:	80 32       	cpi	r24, 0x20	; 32
    22a0:	80 f4       	brcc	.+32     	; 0x22c2 <__stack+0xc3>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    22a2:	e0 91 2a 09 	lds	r30, 0x092A
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	8e 0f       	add	r24, r30
    22aa:	80 93 2a 09 	sts	0x092A, r24
    22ae:	80 91 bb 00 	lds	r24, 0x00BB
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	e5 5d       	subi	r30, 0xD5	; 213
    22b6:	f6 4f       	sbci	r31, 0xF6	; 246
    22b8:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    22ba:	85 ec       	ldi	r24, 0xC5	; 197
    22bc:	80 93 bc 00 	sts	0x00BC, r24
    22c0:	59 c0       	rjmp	.+178    	; 0x2374 <__stack+0x175>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    22c2:	85 e8       	ldi	r24, 0x85	; 133
    22c4:	80 93 bc 00 	sts	0x00BC, r24
    22c8:	55 c0       	rjmp	.+170    	; 0x2374 <__stack+0x175>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    22ca:	80 91 2a 09 	lds	r24, 0x092A
    22ce:	80 32       	cpi	r24, 0x20	; 32
    22d0:	30 f4       	brcc	.+12     	; 0x22de <__stack+0xdf>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    22d2:	e0 91 2a 09 	lds	r30, 0x092A
    22d6:	f0 e0       	ldi	r31, 0x00	; 0
    22d8:	e5 5d       	subi	r30, 0xD5	; 213
    22da:	f6 4f       	sbci	r31, 0xF6	; 246
    22dc:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    22de:	30 df       	rcall	.-416    	; 0x2140 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    22e0:	60 91 2a 09 	lds	r22, 0x092A
    22e4:	70 e0       	ldi	r23, 0x00	; 0
    22e6:	e0 91 8f 09 	lds	r30, 0x098F
    22ea:	f0 91 90 09 	lds	r31, 0x0990
    22ee:	8b e2       	ldi	r24, 0x2B	; 43
    22f0:	99 e0       	ldi	r25, 0x09	; 9
    22f2:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    22f4:	10 92 2a 09 	sts	0x092A, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    22f8:	2e df       	rcall	.-420    	; 0x2156 <twi_releaseBus>
      break;
    22fa:	3c c0       	rjmp	.+120    	; 0x2374 <__stack+0x175>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    22fc:	85 e8       	ldi	r24, 0x85	; 133
    22fe:	80 93 bc 00 	sts	0x00BC, r24
    2302:	38 c0       	rjmp	.+112    	; 0x2374 <__stack+0x175>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    2304:	84 e0       	ldi	r24, 0x04	; 4
    2306:	80 93 96 09 	sts	0x0996, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    230a:	10 92 4c 09 	sts	0x094C, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    230e:	10 92 4b 09 	sts	0x094B, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    2312:	e0 91 91 09 	lds	r30, 0x0991
    2316:	f0 91 92 09 	lds	r31, 0x0992
    231a:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    231c:	80 91 4b 09 	lds	r24, 0x094B
    2320:	81 11       	cpse	r24, r1
    2322:	05 c0       	rjmp	.+10     	; 0x232e <__stack+0x12f>
        twi_txBufferLength = 1;
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	80 93 4b 09 	sts	0x094B, r24
        twi_txBuffer[0] = 0x00;
    232a:	10 92 4d 09 	sts	0x094D, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    232e:	e0 91 4c 09 	lds	r30, 0x094C
    2332:	81 e0       	ldi	r24, 0x01	; 1
    2334:	8e 0f       	add	r24, r30
    2336:	80 93 4c 09 	sts	0x094C, r24
    233a:	f0 e0       	ldi	r31, 0x00	; 0
    233c:	e3 5b       	subi	r30, 0xB3	; 179
    233e:	f6 4f       	sbci	r31, 0xF6	; 246
    2340:	80 81       	ld	r24, Z
    2342:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    2346:	90 91 4c 09 	lds	r25, 0x094C
    234a:	80 91 4b 09 	lds	r24, 0x094B
    234e:	98 17       	cp	r25, r24
    2350:	20 f4       	brcc	.+8      	; 0x235a <__stack+0x15b>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2352:	85 ec       	ldi	r24, 0xC5	; 197
    2354:	80 93 bc 00 	sts	0x00BC, r24
    2358:	0d c0       	rjmp	.+26     	; 0x2374 <__stack+0x175>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    235a:	85 e8       	ldi	r24, 0x85	; 133
    235c:	80 93 bc 00 	sts	0x00BC, r24
    2360:	09 c0       	rjmp	.+18     	; 0x2374 <__stack+0x175>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2362:	85 ec       	ldi	r24, 0xC5	; 197
    2364:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    2368:	10 92 96 09 	sts	0x0996, r1
      break;
    236c:	03 c0       	rjmp	.+6      	; 0x2374 <__stack+0x175>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    236e:	10 92 29 09 	sts	0x0929, r1
      twi_stop();
    2372:	e6 de       	rcall	.-564    	; 0x2140 <twi_stop>
      break;
  }
}
    2374:	ff 91       	pop	r31
    2376:	ef 91       	pop	r30
    2378:	bf 91       	pop	r27
    237a:	af 91       	pop	r26
    237c:	9f 91       	pop	r25
    237e:	8f 91       	pop	r24
    2380:	7f 91       	pop	r23
    2382:	6f 91       	pop	r22
    2384:	5f 91       	pop	r21
    2386:	4f 91       	pop	r20
    2388:	3f 91       	pop	r19
    238a:	2f 91       	pop	r18
    238c:	0f 90       	pop	r0
    238e:	0b be       	out	0x3b, r0	; 59
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	0f 90       	pop	r0
    2396:	1f 90       	pop	r1
    2398:	18 95       	reti

0000239a <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    239a:	80 91 c7 09 	lds	r24, 0x09C7
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	20 91 c8 09 	lds	r18, 0x09C8
    23a4:	82 1b       	sub	r24, r18
    23a6:	91 09       	sbc	r25, r1
    23a8:	08 95       	ret

000023aa <_ZN7TwoWire4readEv>:
    23aa:	20 91 c8 09 	lds	r18, 0x09C8
    23ae:	80 91 c7 09 	lds	r24, 0x09C7
    23b2:	28 17       	cp	r18, r24
    23b4:	50 f4       	brcc	.+20     	; 0x23ca <_ZN7TwoWire4readEv+0x20>
    23b6:	e2 2f       	mov	r30, r18
    23b8:	f0 e0       	ldi	r31, 0x00	; 0
    23ba:	e7 53       	subi	r30, 0x37	; 55
    23bc:	f6 4f       	sbci	r31, 0xF6	; 246
    23be:	80 81       	ld	r24, Z
    23c0:	90 e0       	ldi	r25, 0x00	; 0
    23c2:	2f 5f       	subi	r18, 0xFF	; 255
    23c4:	20 93 c8 09 	sts	0x09C8, r18
    23c8:	08 95       	ret
    23ca:	8f ef       	ldi	r24, 0xFF	; 255
    23cc:	9f ef       	ldi	r25, 0xFF	; 255
    23ce:	08 95       	ret

000023d0 <_ZN7TwoWire4peekEv>:
    23d0:	e0 91 c8 09 	lds	r30, 0x09C8
    23d4:	80 91 c7 09 	lds	r24, 0x09C7
    23d8:	e8 17       	cp	r30, r24
    23da:	30 f4       	brcc	.+12     	; 0x23e8 <_ZN7TwoWire4peekEv+0x18>
    23dc:	f0 e0       	ldi	r31, 0x00	; 0
    23de:	e7 53       	subi	r30, 0x37	; 55
    23e0:	f6 4f       	sbci	r31, 0xF6	; 246
    23e2:	80 81       	ld	r24, Z
    23e4:	90 e0       	ldi	r25, 0x00	; 0
    23e6:	08 95       	ret
    23e8:	8f ef       	ldi	r24, 0xFF	; 255
    23ea:	9f ef       	ldi	r25, 0xFF	; 255
    23ec:	08 95       	ret

000023ee <_ZN7TwoWire5flushEv>:
    23ee:	08 95       	ret

000023f0 <_ZN7TwoWire5writeEPKhj>:
    23f0:	cf 92       	push	r12
    23f2:	df 92       	push	r13
    23f4:	ef 92       	push	r14
    23f6:	ff 92       	push	r15
    23f8:	0f 93       	push	r16
    23fa:	1f 93       	push	r17
    23fc:	cf 93       	push	r28
    23fe:	df 93       	push	r29
    2400:	8c 01       	movw	r16, r24
    2402:	7b 01       	movw	r14, r22
    2404:	6a 01       	movw	r12, r20
    2406:	80 91 a3 09 	lds	r24, 0x09A3
    240a:	88 23       	and	r24, r24
    240c:	99 f0       	breq	.+38     	; 0x2434 <_ZN7TwoWire5writeEPKhj+0x44>
    240e:	41 15       	cp	r20, r1
    2410:	51 05       	cpc	r21, r1
    2412:	99 f0       	breq	.+38     	; 0x243a <_ZN7TwoWire5writeEPKhj+0x4a>
    2414:	eb 01       	movw	r28, r22
    2416:	e4 0e       	add	r14, r20
    2418:	f5 1e       	adc	r15, r21
    241a:	69 91       	ld	r22, Y+
    241c:	d8 01       	movw	r26, r16
    241e:	ed 91       	ld	r30, X+
    2420:	fc 91       	ld	r31, X
    2422:	01 90       	ld	r0, Z+
    2424:	f0 81       	ld	r31, Z
    2426:	e0 2d       	mov	r30, r0
    2428:	c8 01       	movw	r24, r16
    242a:	19 95       	eicall
    242c:	ce 15       	cp	r28, r14
    242e:	df 05       	cpc	r29, r15
    2430:	a1 f7       	brne	.-24     	; 0x241a <_ZN7TwoWire5writeEPKhj+0x2a>
    2432:	03 c0       	rjmp	.+6      	; 0x243a <_ZN7TwoWire5writeEPKhj+0x4a>
    2434:	64 2f       	mov	r22, r20
    2436:	c7 01       	movw	r24, r14
    2438:	64 de       	rcall	.-824    	; 0x2102 <twi_transmit>
    243a:	c6 01       	movw	r24, r12
    243c:	df 91       	pop	r29
    243e:	cf 91       	pop	r28
    2440:	1f 91       	pop	r17
    2442:	0f 91       	pop	r16
    2444:	ff 90       	pop	r15
    2446:	ef 90       	pop	r14
    2448:	df 90       	pop	r13
    244a:	cf 90       	pop	r12
    244c:	08 95       	ret

0000244e <_ZN7TwoWire5writeEh>:
    244e:	cf 93       	push	r28
    2450:	df 93       	push	r29
    2452:	1f 92       	push	r1
    2454:	cd b7       	in	r28, 0x3d	; 61
    2456:	de b7       	in	r29, 0x3e	; 62
    2458:	69 83       	std	Y+1, r22	; 0x01
    245a:	20 91 a3 09 	lds	r18, 0x09A3
    245e:	22 23       	and	r18, r18
    2460:	e1 f0       	breq	.+56     	; 0x249a <_ZN7TwoWire5writeEh+0x4c>
    2462:	20 91 a4 09 	lds	r18, 0x09A4
    2466:	20 32       	cpi	r18, 0x20	; 32
    2468:	40 f0       	brcs	.+16     	; 0x247a <_ZN7TwoWire5writeEh+0x2c>
    246a:	21 e0       	ldi	r18, 0x01	; 1
    246c:	30 e0       	ldi	r19, 0x00	; 0
    246e:	fc 01       	movw	r30, r24
    2470:	33 83       	std	Z+3, r19	; 0x03
    2472:	22 83       	std	Z+2, r18	; 0x02
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	90 e0       	ldi	r25, 0x00	; 0
    2478:	16 c0       	rjmp	.+44     	; 0x24a6 <_ZN7TwoWire5writeEh+0x58>
    247a:	80 91 a5 09 	lds	r24, 0x09A5
    247e:	e8 2f       	mov	r30, r24
    2480:	f0 e0       	ldi	r31, 0x00	; 0
    2482:	ea 55       	subi	r30, 0x5A	; 90
    2484:	f6 4f       	sbci	r31, 0xF6	; 246
    2486:	99 81       	ldd	r25, Y+1	; 0x01
    2488:	90 83       	st	Z, r25
    248a:	8f 5f       	subi	r24, 0xFF	; 255
    248c:	80 93 a5 09 	sts	0x09A5, r24
    2490:	80 93 a4 09 	sts	0x09A4, r24
    2494:	81 e0       	ldi	r24, 0x01	; 1
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	06 c0       	rjmp	.+12     	; 0x24a6 <_ZN7TwoWire5writeEh+0x58>
    249a:	61 e0       	ldi	r22, 0x01	; 1
    249c:	ce 01       	movw	r24, r28
    249e:	01 96       	adiw	r24, 0x01	; 1
    24a0:	30 de       	rcall	.-928    	; 0x2102 <twi_transmit>
    24a2:	81 e0       	ldi	r24, 0x01	; 1
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	0f 90       	pop	r0
    24a8:	df 91       	pop	r29
    24aa:	cf 91       	pop	r28
    24ac:	08 95       	ret

000024ae <_ZN7TwoWireC1Ev>:
    24ae:	fc 01       	movw	r30, r24
    24b0:	13 82       	std	Z+3, r1	; 0x03
    24b2:	12 82       	std	Z+2, r1	; 0x02
    24b4:	48 ee       	ldi	r20, 0xE8	; 232
    24b6:	53 e0       	ldi	r21, 0x03	; 3
    24b8:	60 e0       	ldi	r22, 0x00	; 0
    24ba:	70 e0       	ldi	r23, 0x00	; 0
    24bc:	44 83       	std	Z+4, r20	; 0x04
    24be:	55 83       	std	Z+5, r21	; 0x05
    24c0:	66 83       	std	Z+6, r22	; 0x06
    24c2:	77 83       	std	Z+7, r23	; 0x07
    24c4:	81 e7       	ldi	r24, 0x71	; 113
    24c6:	92 e0       	ldi	r25, 0x02	; 2
    24c8:	91 83       	std	Z+1, r25	; 0x01
    24ca:	80 83       	st	Z, r24
    24cc:	08 95       	ret

000024ce <_ZN7TwoWire5beginEv>:
    24ce:	10 92 c8 09 	sts	0x09C8, r1
    24d2:	10 92 c7 09 	sts	0x09C7, r1
    24d6:	10 92 a5 09 	sts	0x09A5, r1
    24da:	10 92 a4 09 	sts	0x09A4, r1
    24de:	48 cd       	rjmp	.-1392   	; 0x1f70 <twi_init>
    24e0:	08 95       	ret

000024e2 <_ZN7TwoWire11requestFromEhhh>:
    24e2:	86 2f       	mov	r24, r22
    24e4:	41 32       	cpi	r20, 0x21	; 33
    24e6:	08 f0       	brcs	.+2      	; 0x24ea <_ZN7TwoWire11requestFromEhhh+0x8>
    24e8:	40 e2       	ldi	r20, 0x20	; 32
    24ea:	69 ec       	ldi	r22, 0xC9	; 201
    24ec:	79 e0       	ldi	r23, 0x09	; 9
    24ee:	5e dd       	rcall	.-1348   	; 0x1fac <twi_readFrom>
    24f0:	10 92 c8 09 	sts	0x09C8, r1
    24f4:	80 93 c7 09 	sts	0x09C7, r24
    24f8:	08 95       	ret

000024fa <_ZN7TwoWire11requestFromEhh>:
    24fa:	21 e0       	ldi	r18, 0x01	; 1
    24fc:	f2 cf       	rjmp	.-28     	; 0x24e2 <_ZN7TwoWire11requestFromEhhh>
    24fe:	08 95       	ret

00002500 <_ZN7TwoWire17beginTransmissionEh>:
    2500:	81 e0       	ldi	r24, 0x01	; 1
    2502:	80 93 a3 09 	sts	0x09A3, r24
    2506:	60 93 c6 09 	sts	0x09C6, r22
    250a:	10 92 a5 09 	sts	0x09A5, r1
    250e:	10 92 a4 09 	sts	0x09A4, r1
    2512:	08 95       	ret

00002514 <_ZN7TwoWire15endTransmissionEh>:
    2514:	0f 93       	push	r16
    2516:	06 2f       	mov	r16, r22
    2518:	21 e0       	ldi	r18, 0x01	; 1
    251a:	40 91 a4 09 	lds	r20, 0x09A4
    251e:	66 ea       	ldi	r22, 0xA6	; 166
    2520:	79 e0       	ldi	r23, 0x09	; 9
    2522:	80 91 c6 09 	lds	r24, 0x09C6
    2526:	90 dd       	rcall	.-1248   	; 0x2048 <twi_writeTo>
    2528:	10 92 a5 09 	sts	0x09A5, r1
    252c:	10 92 a4 09 	sts	0x09A4, r1
    2530:	10 92 a3 09 	sts	0x09A3, r1
    2534:	0f 91       	pop	r16
    2536:	08 95       	ret

00002538 <_ZN7TwoWire15endTransmissionEv>:
    2538:	61 e0       	ldi	r22, 0x01	; 1
    253a:	ec cf       	rjmp	.-40     	; 0x2514 <_ZN7TwoWire15endTransmissionEh>
    253c:	08 95       	ret

0000253e <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    253e:	87 e9       	ldi	r24, 0x97	; 151
    2540:	99 e0       	ldi	r25, 0x09	; 9
    2542:	b5 cf       	rjmp	.-150    	; 0x24ae <_ZN7TwoWireC1Ev>
    2544:	08 95       	ret

00002546 <__subsf3>:
    2546:	50 58       	subi	r21, 0x80	; 128

00002548 <__addsf3>:
    2548:	bb 27       	eor	r27, r27
    254a:	aa 27       	eor	r26, r26
    254c:	0e d0       	rcall	.+28     	; 0x256a <__addsf3x>
    254e:	72 c1       	rjmp	.+740    	; 0x2834 <__fp_round>
    2550:	63 d1       	rcall	.+710    	; 0x2818 <__fp_pscA>
    2552:	30 f0       	brcs	.+12     	; 0x2560 <__addsf3+0x18>
    2554:	68 d1       	rcall	.+720    	; 0x2826 <__fp_pscB>
    2556:	20 f0       	brcs	.+8      	; 0x2560 <__addsf3+0x18>
    2558:	31 f4       	brne	.+12     	; 0x2566 <__addsf3+0x1e>
    255a:	9f 3f       	cpi	r25, 0xFF	; 255
    255c:	11 f4       	brne	.+4      	; 0x2562 <__addsf3+0x1a>
    255e:	1e f4       	brtc	.+6      	; 0x2566 <__addsf3+0x1e>
    2560:	33 c1       	rjmp	.+614    	; 0x27c8 <__fp_nan>
    2562:	0e f4       	brtc	.+2      	; 0x2566 <__addsf3+0x1e>
    2564:	e0 95       	com	r30
    2566:	e7 fb       	bst	r30, 7
    2568:	29 c1       	rjmp	.+594    	; 0x27bc <__fp_inf>

0000256a <__addsf3x>:
    256a:	e9 2f       	mov	r30, r25
    256c:	74 d1       	rcall	.+744    	; 0x2856 <__fp_split3>
    256e:	80 f3       	brcs	.-32     	; 0x2550 <__addsf3+0x8>
    2570:	ba 17       	cp	r27, r26
    2572:	62 07       	cpc	r22, r18
    2574:	73 07       	cpc	r23, r19
    2576:	84 07       	cpc	r24, r20
    2578:	95 07       	cpc	r25, r21
    257a:	18 f0       	brcs	.+6      	; 0x2582 <__addsf3x+0x18>
    257c:	71 f4       	brne	.+28     	; 0x259a <__addsf3x+0x30>
    257e:	9e f5       	brtc	.+102    	; 0x25e6 <__addsf3x+0x7c>
    2580:	8c c1       	rjmp	.+792    	; 0x289a <__fp_zero>
    2582:	0e f4       	brtc	.+2      	; 0x2586 <__addsf3x+0x1c>
    2584:	e0 95       	com	r30
    2586:	0b 2e       	mov	r0, r27
    2588:	ba 2f       	mov	r27, r26
    258a:	a0 2d       	mov	r26, r0
    258c:	0b 01       	movw	r0, r22
    258e:	b9 01       	movw	r22, r18
    2590:	90 01       	movw	r18, r0
    2592:	0c 01       	movw	r0, r24
    2594:	ca 01       	movw	r24, r20
    2596:	a0 01       	movw	r20, r0
    2598:	11 24       	eor	r1, r1
    259a:	ff 27       	eor	r31, r31
    259c:	59 1b       	sub	r21, r25
    259e:	99 f0       	breq	.+38     	; 0x25c6 <__addsf3x+0x5c>
    25a0:	59 3f       	cpi	r21, 0xF9	; 249
    25a2:	50 f4       	brcc	.+20     	; 0x25b8 <__addsf3x+0x4e>
    25a4:	50 3e       	cpi	r21, 0xE0	; 224
    25a6:	68 f1       	brcs	.+90     	; 0x2602 <__addsf3x+0x98>
    25a8:	1a 16       	cp	r1, r26
    25aa:	f0 40       	sbci	r31, 0x00	; 0
    25ac:	a2 2f       	mov	r26, r18
    25ae:	23 2f       	mov	r18, r19
    25b0:	34 2f       	mov	r19, r20
    25b2:	44 27       	eor	r20, r20
    25b4:	58 5f       	subi	r21, 0xF8	; 248
    25b6:	f3 cf       	rjmp	.-26     	; 0x259e <__addsf3x+0x34>
    25b8:	46 95       	lsr	r20
    25ba:	37 95       	ror	r19
    25bc:	27 95       	ror	r18
    25be:	a7 95       	ror	r26
    25c0:	f0 40       	sbci	r31, 0x00	; 0
    25c2:	53 95       	inc	r21
    25c4:	c9 f7       	brne	.-14     	; 0x25b8 <__addsf3x+0x4e>
    25c6:	7e f4       	brtc	.+30     	; 0x25e6 <__addsf3x+0x7c>
    25c8:	1f 16       	cp	r1, r31
    25ca:	ba 0b       	sbc	r27, r26
    25cc:	62 0b       	sbc	r22, r18
    25ce:	73 0b       	sbc	r23, r19
    25d0:	84 0b       	sbc	r24, r20
    25d2:	ba f0       	brmi	.+46     	; 0x2602 <__addsf3x+0x98>
    25d4:	91 50       	subi	r25, 0x01	; 1
    25d6:	a1 f0       	breq	.+40     	; 0x2600 <__addsf3x+0x96>
    25d8:	ff 0f       	add	r31, r31
    25da:	bb 1f       	adc	r27, r27
    25dc:	66 1f       	adc	r22, r22
    25de:	77 1f       	adc	r23, r23
    25e0:	88 1f       	adc	r24, r24
    25e2:	c2 f7       	brpl	.-16     	; 0x25d4 <__addsf3x+0x6a>
    25e4:	0e c0       	rjmp	.+28     	; 0x2602 <__addsf3x+0x98>
    25e6:	ba 0f       	add	r27, r26
    25e8:	62 1f       	adc	r22, r18
    25ea:	73 1f       	adc	r23, r19
    25ec:	84 1f       	adc	r24, r20
    25ee:	48 f4       	brcc	.+18     	; 0x2602 <__addsf3x+0x98>
    25f0:	87 95       	ror	r24
    25f2:	77 95       	ror	r23
    25f4:	67 95       	ror	r22
    25f6:	b7 95       	ror	r27
    25f8:	f7 95       	ror	r31
    25fa:	9e 3f       	cpi	r25, 0xFE	; 254
    25fc:	08 f0       	brcs	.+2      	; 0x2600 <__addsf3x+0x96>
    25fe:	b3 cf       	rjmp	.-154    	; 0x2566 <__addsf3+0x1e>
    2600:	93 95       	inc	r25
    2602:	88 0f       	add	r24, r24
    2604:	08 f0       	brcs	.+2      	; 0x2608 <__addsf3x+0x9e>
    2606:	99 27       	eor	r25, r25
    2608:	ee 0f       	add	r30, r30
    260a:	97 95       	ror	r25
    260c:	87 95       	ror	r24
    260e:	08 95       	ret

00002610 <__divsf3>:
    2610:	0c d0       	rcall	.+24     	; 0x262a <__divsf3x>
    2612:	10 c1       	rjmp	.+544    	; 0x2834 <__fp_round>
    2614:	08 d1       	rcall	.+528    	; 0x2826 <__fp_pscB>
    2616:	40 f0       	brcs	.+16     	; 0x2628 <__divsf3+0x18>
    2618:	ff d0       	rcall	.+510    	; 0x2818 <__fp_pscA>
    261a:	30 f0       	brcs	.+12     	; 0x2628 <__divsf3+0x18>
    261c:	21 f4       	brne	.+8      	; 0x2626 <__divsf3+0x16>
    261e:	5f 3f       	cpi	r21, 0xFF	; 255
    2620:	19 f0       	breq	.+6      	; 0x2628 <__divsf3+0x18>
    2622:	cc c0       	rjmp	.+408    	; 0x27bc <__fp_inf>
    2624:	51 11       	cpse	r21, r1
    2626:	3a c1       	rjmp	.+628    	; 0x289c <__fp_szero>
    2628:	cf c0       	rjmp	.+414    	; 0x27c8 <__fp_nan>

0000262a <__divsf3x>:
    262a:	15 d1       	rcall	.+554    	; 0x2856 <__fp_split3>
    262c:	98 f3       	brcs	.-26     	; 0x2614 <__divsf3+0x4>

0000262e <__divsf3_pse>:
    262e:	99 23       	and	r25, r25
    2630:	c9 f3       	breq	.-14     	; 0x2624 <__divsf3+0x14>
    2632:	55 23       	and	r21, r21
    2634:	b1 f3       	breq	.-20     	; 0x2622 <__divsf3+0x12>
    2636:	95 1b       	sub	r25, r21
    2638:	55 0b       	sbc	r21, r21
    263a:	bb 27       	eor	r27, r27
    263c:	aa 27       	eor	r26, r26
    263e:	62 17       	cp	r22, r18
    2640:	73 07       	cpc	r23, r19
    2642:	84 07       	cpc	r24, r20
    2644:	38 f0       	brcs	.+14     	; 0x2654 <__divsf3_pse+0x26>
    2646:	9f 5f       	subi	r25, 0xFF	; 255
    2648:	5f 4f       	sbci	r21, 0xFF	; 255
    264a:	22 0f       	add	r18, r18
    264c:	33 1f       	adc	r19, r19
    264e:	44 1f       	adc	r20, r20
    2650:	aa 1f       	adc	r26, r26
    2652:	a9 f3       	breq	.-22     	; 0x263e <__divsf3_pse+0x10>
    2654:	33 d0       	rcall	.+102    	; 0x26bc <__divsf3_pse+0x8e>
    2656:	0e 2e       	mov	r0, r30
    2658:	3a f0       	brmi	.+14     	; 0x2668 <__divsf3_pse+0x3a>
    265a:	e0 e8       	ldi	r30, 0x80	; 128
    265c:	30 d0       	rcall	.+96     	; 0x26be <__divsf3_pse+0x90>
    265e:	91 50       	subi	r25, 0x01	; 1
    2660:	50 40       	sbci	r21, 0x00	; 0
    2662:	e6 95       	lsr	r30
    2664:	00 1c       	adc	r0, r0
    2666:	ca f7       	brpl	.-14     	; 0x265a <__divsf3_pse+0x2c>
    2668:	29 d0       	rcall	.+82     	; 0x26bc <__divsf3_pse+0x8e>
    266a:	fe 2f       	mov	r31, r30
    266c:	27 d0       	rcall	.+78     	; 0x26bc <__divsf3_pse+0x8e>
    266e:	66 0f       	add	r22, r22
    2670:	77 1f       	adc	r23, r23
    2672:	88 1f       	adc	r24, r24
    2674:	bb 1f       	adc	r27, r27
    2676:	26 17       	cp	r18, r22
    2678:	37 07       	cpc	r19, r23
    267a:	48 07       	cpc	r20, r24
    267c:	ab 07       	cpc	r26, r27
    267e:	b0 e8       	ldi	r27, 0x80	; 128
    2680:	09 f0       	breq	.+2      	; 0x2684 <__divsf3_pse+0x56>
    2682:	bb 0b       	sbc	r27, r27
    2684:	80 2d       	mov	r24, r0
    2686:	bf 01       	movw	r22, r30
    2688:	ff 27       	eor	r31, r31
    268a:	93 58       	subi	r25, 0x83	; 131
    268c:	5f 4f       	sbci	r21, 0xFF	; 255
    268e:	2a f0       	brmi	.+10     	; 0x269a <__divsf3_pse+0x6c>
    2690:	9e 3f       	cpi	r25, 0xFE	; 254
    2692:	51 05       	cpc	r21, r1
    2694:	68 f0       	brcs	.+26     	; 0x26b0 <__divsf3_pse+0x82>
    2696:	92 c0       	rjmp	.+292    	; 0x27bc <__fp_inf>
    2698:	01 c1       	rjmp	.+514    	; 0x289c <__fp_szero>
    269a:	5f 3f       	cpi	r21, 0xFF	; 255
    269c:	ec f3       	brlt	.-6      	; 0x2698 <__divsf3_pse+0x6a>
    269e:	98 3e       	cpi	r25, 0xE8	; 232
    26a0:	dc f3       	brlt	.-10     	; 0x2698 <__divsf3_pse+0x6a>
    26a2:	86 95       	lsr	r24
    26a4:	77 95       	ror	r23
    26a6:	67 95       	ror	r22
    26a8:	b7 95       	ror	r27
    26aa:	f7 95       	ror	r31
    26ac:	9f 5f       	subi	r25, 0xFF	; 255
    26ae:	c9 f7       	brne	.-14     	; 0x26a2 <__divsf3_pse+0x74>
    26b0:	88 0f       	add	r24, r24
    26b2:	91 1d       	adc	r25, r1
    26b4:	96 95       	lsr	r25
    26b6:	87 95       	ror	r24
    26b8:	97 f9       	bld	r25, 7
    26ba:	08 95       	ret
    26bc:	e1 e0       	ldi	r30, 0x01	; 1
    26be:	66 0f       	add	r22, r22
    26c0:	77 1f       	adc	r23, r23
    26c2:	88 1f       	adc	r24, r24
    26c4:	bb 1f       	adc	r27, r27
    26c6:	62 17       	cp	r22, r18
    26c8:	73 07       	cpc	r23, r19
    26ca:	84 07       	cpc	r24, r20
    26cc:	ba 07       	cpc	r27, r26
    26ce:	20 f0       	brcs	.+8      	; 0x26d8 <__divsf3_pse+0xaa>
    26d0:	62 1b       	sub	r22, r18
    26d2:	73 0b       	sbc	r23, r19
    26d4:	84 0b       	sbc	r24, r20
    26d6:	ba 0b       	sbc	r27, r26
    26d8:	ee 1f       	adc	r30, r30
    26da:	88 f7       	brcc	.-30     	; 0x26be <__divsf3_pse+0x90>
    26dc:	e0 95       	com	r30
    26de:	08 95       	ret

000026e0 <__fixsfsi>:
    26e0:	04 d0       	rcall	.+8      	; 0x26ea <__fixunssfsi>
    26e2:	68 94       	set
    26e4:	b1 11       	cpse	r27, r1
    26e6:	da c0       	rjmp	.+436    	; 0x289c <__fp_szero>
    26e8:	08 95       	ret

000026ea <__fixunssfsi>:
    26ea:	bd d0       	rcall	.+378    	; 0x2866 <__fp_splitA>
    26ec:	88 f0       	brcs	.+34     	; 0x2710 <__fixunssfsi+0x26>
    26ee:	9f 57       	subi	r25, 0x7F	; 127
    26f0:	90 f0       	brcs	.+36     	; 0x2716 <__fixunssfsi+0x2c>
    26f2:	b9 2f       	mov	r27, r25
    26f4:	99 27       	eor	r25, r25
    26f6:	b7 51       	subi	r27, 0x17	; 23
    26f8:	a0 f0       	brcs	.+40     	; 0x2722 <__fixunssfsi+0x38>
    26fa:	d1 f0       	breq	.+52     	; 0x2730 <__fixunssfsi+0x46>
    26fc:	66 0f       	add	r22, r22
    26fe:	77 1f       	adc	r23, r23
    2700:	88 1f       	adc	r24, r24
    2702:	99 1f       	adc	r25, r25
    2704:	1a f0       	brmi	.+6      	; 0x270c <__fixunssfsi+0x22>
    2706:	ba 95       	dec	r27
    2708:	c9 f7       	brne	.-14     	; 0x26fc <__fixunssfsi+0x12>
    270a:	12 c0       	rjmp	.+36     	; 0x2730 <__fixunssfsi+0x46>
    270c:	b1 30       	cpi	r27, 0x01	; 1
    270e:	81 f0       	breq	.+32     	; 0x2730 <__fixunssfsi+0x46>
    2710:	c4 d0       	rcall	.+392    	; 0x289a <__fp_zero>
    2712:	b1 e0       	ldi	r27, 0x01	; 1
    2714:	08 95       	ret
    2716:	c1 c0       	rjmp	.+386    	; 0x289a <__fp_zero>
    2718:	67 2f       	mov	r22, r23
    271a:	78 2f       	mov	r23, r24
    271c:	88 27       	eor	r24, r24
    271e:	b8 5f       	subi	r27, 0xF8	; 248
    2720:	39 f0       	breq	.+14     	; 0x2730 <__fixunssfsi+0x46>
    2722:	b9 3f       	cpi	r27, 0xF9	; 249
    2724:	cc f3       	brlt	.-14     	; 0x2718 <__fixunssfsi+0x2e>
    2726:	86 95       	lsr	r24
    2728:	77 95       	ror	r23
    272a:	67 95       	ror	r22
    272c:	b3 95       	inc	r27
    272e:	d9 f7       	brne	.-10     	; 0x2726 <__fixunssfsi+0x3c>
    2730:	3e f4       	brtc	.+14     	; 0x2740 <__fixunssfsi+0x56>
    2732:	90 95       	com	r25
    2734:	80 95       	com	r24
    2736:	70 95       	com	r23
    2738:	61 95       	neg	r22
    273a:	7f 4f       	sbci	r23, 0xFF	; 255
    273c:	8f 4f       	sbci	r24, 0xFF	; 255
    273e:	9f 4f       	sbci	r25, 0xFF	; 255
    2740:	08 95       	ret

00002742 <__floatunsisf>:
    2742:	e8 94       	clt
    2744:	09 c0       	rjmp	.+18     	; 0x2758 <__floatsisf+0x12>

00002746 <__floatsisf>:
    2746:	97 fb       	bst	r25, 7
    2748:	3e f4       	brtc	.+14     	; 0x2758 <__floatsisf+0x12>
    274a:	90 95       	com	r25
    274c:	80 95       	com	r24
    274e:	70 95       	com	r23
    2750:	61 95       	neg	r22
    2752:	7f 4f       	sbci	r23, 0xFF	; 255
    2754:	8f 4f       	sbci	r24, 0xFF	; 255
    2756:	9f 4f       	sbci	r25, 0xFF	; 255
    2758:	99 23       	and	r25, r25
    275a:	a9 f0       	breq	.+42     	; 0x2786 <__floatsisf+0x40>
    275c:	f9 2f       	mov	r31, r25
    275e:	96 e9       	ldi	r25, 0x96	; 150
    2760:	bb 27       	eor	r27, r27
    2762:	93 95       	inc	r25
    2764:	f6 95       	lsr	r31
    2766:	87 95       	ror	r24
    2768:	77 95       	ror	r23
    276a:	67 95       	ror	r22
    276c:	b7 95       	ror	r27
    276e:	f1 11       	cpse	r31, r1
    2770:	f8 cf       	rjmp	.-16     	; 0x2762 <__floatsisf+0x1c>
    2772:	fa f4       	brpl	.+62     	; 0x27b2 <__floatsisf+0x6c>
    2774:	bb 0f       	add	r27, r27
    2776:	11 f4       	brne	.+4      	; 0x277c <__floatsisf+0x36>
    2778:	60 ff       	sbrs	r22, 0
    277a:	1b c0       	rjmp	.+54     	; 0x27b2 <__floatsisf+0x6c>
    277c:	6f 5f       	subi	r22, 0xFF	; 255
    277e:	7f 4f       	sbci	r23, 0xFF	; 255
    2780:	8f 4f       	sbci	r24, 0xFF	; 255
    2782:	9f 4f       	sbci	r25, 0xFF	; 255
    2784:	16 c0       	rjmp	.+44     	; 0x27b2 <__floatsisf+0x6c>
    2786:	88 23       	and	r24, r24
    2788:	11 f0       	breq	.+4      	; 0x278e <__floatsisf+0x48>
    278a:	96 e9       	ldi	r25, 0x96	; 150
    278c:	11 c0       	rjmp	.+34     	; 0x27b0 <__floatsisf+0x6a>
    278e:	77 23       	and	r23, r23
    2790:	21 f0       	breq	.+8      	; 0x279a <__floatsisf+0x54>
    2792:	9e e8       	ldi	r25, 0x8E	; 142
    2794:	87 2f       	mov	r24, r23
    2796:	76 2f       	mov	r23, r22
    2798:	05 c0       	rjmp	.+10     	; 0x27a4 <__floatsisf+0x5e>
    279a:	66 23       	and	r22, r22
    279c:	71 f0       	breq	.+28     	; 0x27ba <__floatsisf+0x74>
    279e:	96 e8       	ldi	r25, 0x86	; 134
    27a0:	86 2f       	mov	r24, r22
    27a2:	70 e0       	ldi	r23, 0x00	; 0
    27a4:	60 e0       	ldi	r22, 0x00	; 0
    27a6:	2a f0       	brmi	.+10     	; 0x27b2 <__floatsisf+0x6c>
    27a8:	9a 95       	dec	r25
    27aa:	66 0f       	add	r22, r22
    27ac:	77 1f       	adc	r23, r23
    27ae:	88 1f       	adc	r24, r24
    27b0:	da f7       	brpl	.-10     	; 0x27a8 <__floatsisf+0x62>
    27b2:	88 0f       	add	r24, r24
    27b4:	96 95       	lsr	r25
    27b6:	87 95       	ror	r24
    27b8:	97 f9       	bld	r25, 7
    27ba:	08 95       	ret

000027bc <__fp_inf>:
    27bc:	97 f9       	bld	r25, 7
    27be:	9f 67       	ori	r25, 0x7F	; 127
    27c0:	80 e8       	ldi	r24, 0x80	; 128
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	60 e0       	ldi	r22, 0x00	; 0
    27c6:	08 95       	ret

000027c8 <__fp_nan>:
    27c8:	9f ef       	ldi	r25, 0xFF	; 255
    27ca:	80 ec       	ldi	r24, 0xC0	; 192
    27cc:	08 95       	ret

000027ce <__fp_powser>:
    27ce:	df 93       	push	r29
    27d0:	cf 93       	push	r28
    27d2:	1f 93       	push	r17
    27d4:	0f 93       	push	r16
    27d6:	ff 92       	push	r15
    27d8:	ef 92       	push	r14
    27da:	df 92       	push	r13
    27dc:	7b 01       	movw	r14, r22
    27de:	8c 01       	movw	r16, r24
    27e0:	68 94       	set
    27e2:	05 c0       	rjmp	.+10     	; 0x27ee <__fp_powser+0x20>
    27e4:	da 2e       	mov	r13, r26
    27e6:	ef 01       	movw	r28, r30
    27e8:	72 d0       	rcall	.+228    	; 0x28ce <__mulsf3x>
    27ea:	fe 01       	movw	r30, r28
    27ec:	e8 94       	clt
    27ee:	a5 91       	lpm	r26, Z+
    27f0:	25 91       	lpm	r18, Z+
    27f2:	35 91       	lpm	r19, Z+
    27f4:	45 91       	lpm	r20, Z+
    27f6:	55 91       	lpm	r21, Z+
    27f8:	ae f3       	brts	.-22     	; 0x27e4 <__fp_powser+0x16>
    27fa:	ef 01       	movw	r28, r30
    27fc:	b6 de       	rcall	.-660    	; 0x256a <__addsf3x>
    27fe:	fe 01       	movw	r30, r28
    2800:	97 01       	movw	r18, r14
    2802:	a8 01       	movw	r20, r16
    2804:	da 94       	dec	r13
    2806:	79 f7       	brne	.-34     	; 0x27e6 <__fp_powser+0x18>
    2808:	df 90       	pop	r13
    280a:	ef 90       	pop	r14
    280c:	ff 90       	pop	r15
    280e:	0f 91       	pop	r16
    2810:	1f 91       	pop	r17
    2812:	cf 91       	pop	r28
    2814:	df 91       	pop	r29
    2816:	08 95       	ret

00002818 <__fp_pscA>:
    2818:	00 24       	eor	r0, r0
    281a:	0a 94       	dec	r0
    281c:	16 16       	cp	r1, r22
    281e:	17 06       	cpc	r1, r23
    2820:	18 06       	cpc	r1, r24
    2822:	09 06       	cpc	r0, r25
    2824:	08 95       	ret

00002826 <__fp_pscB>:
    2826:	00 24       	eor	r0, r0
    2828:	0a 94       	dec	r0
    282a:	12 16       	cp	r1, r18
    282c:	13 06       	cpc	r1, r19
    282e:	14 06       	cpc	r1, r20
    2830:	05 06       	cpc	r0, r21
    2832:	08 95       	ret

00002834 <__fp_round>:
    2834:	09 2e       	mov	r0, r25
    2836:	03 94       	inc	r0
    2838:	00 0c       	add	r0, r0
    283a:	11 f4       	brne	.+4      	; 0x2840 <__fp_round+0xc>
    283c:	88 23       	and	r24, r24
    283e:	52 f0       	brmi	.+20     	; 0x2854 <__fp_round+0x20>
    2840:	bb 0f       	add	r27, r27
    2842:	40 f4       	brcc	.+16     	; 0x2854 <__fp_round+0x20>
    2844:	bf 2b       	or	r27, r31
    2846:	11 f4       	brne	.+4      	; 0x284c <__fp_round+0x18>
    2848:	60 ff       	sbrs	r22, 0
    284a:	04 c0       	rjmp	.+8      	; 0x2854 <__fp_round+0x20>
    284c:	6f 5f       	subi	r22, 0xFF	; 255
    284e:	7f 4f       	sbci	r23, 0xFF	; 255
    2850:	8f 4f       	sbci	r24, 0xFF	; 255
    2852:	9f 4f       	sbci	r25, 0xFF	; 255
    2854:	08 95       	ret

00002856 <__fp_split3>:
    2856:	57 fd       	sbrc	r21, 7
    2858:	90 58       	subi	r25, 0x80	; 128
    285a:	44 0f       	add	r20, r20
    285c:	55 1f       	adc	r21, r21
    285e:	59 f0       	breq	.+22     	; 0x2876 <__fp_splitA+0x10>
    2860:	5f 3f       	cpi	r21, 0xFF	; 255
    2862:	71 f0       	breq	.+28     	; 0x2880 <__fp_splitA+0x1a>
    2864:	47 95       	ror	r20

00002866 <__fp_splitA>:
    2866:	88 0f       	add	r24, r24
    2868:	97 fb       	bst	r25, 7
    286a:	99 1f       	adc	r25, r25
    286c:	61 f0       	breq	.+24     	; 0x2886 <__fp_splitA+0x20>
    286e:	9f 3f       	cpi	r25, 0xFF	; 255
    2870:	79 f0       	breq	.+30     	; 0x2890 <__fp_splitA+0x2a>
    2872:	87 95       	ror	r24
    2874:	08 95       	ret
    2876:	12 16       	cp	r1, r18
    2878:	13 06       	cpc	r1, r19
    287a:	14 06       	cpc	r1, r20
    287c:	55 1f       	adc	r21, r21
    287e:	f2 cf       	rjmp	.-28     	; 0x2864 <__fp_split3+0xe>
    2880:	46 95       	lsr	r20
    2882:	f1 df       	rcall	.-30     	; 0x2866 <__fp_splitA>
    2884:	08 c0       	rjmp	.+16     	; 0x2896 <__fp_splitA+0x30>
    2886:	16 16       	cp	r1, r22
    2888:	17 06       	cpc	r1, r23
    288a:	18 06       	cpc	r1, r24
    288c:	99 1f       	adc	r25, r25
    288e:	f1 cf       	rjmp	.-30     	; 0x2872 <__fp_splitA+0xc>
    2890:	86 95       	lsr	r24
    2892:	71 05       	cpc	r23, r1
    2894:	61 05       	cpc	r22, r1
    2896:	08 94       	sec
    2898:	08 95       	ret

0000289a <__fp_zero>:
    289a:	e8 94       	clt

0000289c <__fp_szero>:
    289c:	bb 27       	eor	r27, r27
    289e:	66 27       	eor	r22, r22
    28a0:	77 27       	eor	r23, r23
    28a2:	cb 01       	movw	r24, r22
    28a4:	97 f9       	bld	r25, 7
    28a6:	08 95       	ret

000028a8 <inverse>:
    28a8:	9b 01       	movw	r18, r22
    28aa:	ac 01       	movw	r20, r24
    28ac:	60 e0       	ldi	r22, 0x00	; 0
    28ae:	70 e0       	ldi	r23, 0x00	; 0
    28b0:	80 e8       	ldi	r24, 0x80	; 128
    28b2:	9f e3       	ldi	r25, 0x3F	; 63
    28b4:	ad ce       	rjmp	.-678    	; 0x2610 <__divsf3>

000028b6 <__mulsf3>:
    28b6:	0b d0       	rcall	.+22     	; 0x28ce <__mulsf3x>
    28b8:	bd cf       	rjmp	.-134    	; 0x2834 <__fp_round>
    28ba:	ae df       	rcall	.-164    	; 0x2818 <__fp_pscA>
    28bc:	28 f0       	brcs	.+10     	; 0x28c8 <__mulsf3+0x12>
    28be:	b3 df       	rcall	.-154    	; 0x2826 <__fp_pscB>
    28c0:	18 f0       	brcs	.+6      	; 0x28c8 <__mulsf3+0x12>
    28c2:	95 23       	and	r25, r21
    28c4:	09 f0       	breq	.+2      	; 0x28c8 <__mulsf3+0x12>
    28c6:	7a cf       	rjmp	.-268    	; 0x27bc <__fp_inf>
    28c8:	7f cf       	rjmp	.-258    	; 0x27c8 <__fp_nan>
    28ca:	11 24       	eor	r1, r1
    28cc:	e7 cf       	rjmp	.-50     	; 0x289c <__fp_szero>

000028ce <__mulsf3x>:
    28ce:	c3 df       	rcall	.-122    	; 0x2856 <__fp_split3>
    28d0:	a0 f3       	brcs	.-24     	; 0x28ba <__mulsf3+0x4>

000028d2 <__mulsf3_pse>:
    28d2:	95 9f       	mul	r25, r21
    28d4:	d1 f3       	breq	.-12     	; 0x28ca <__mulsf3+0x14>
    28d6:	95 0f       	add	r25, r21
    28d8:	50 e0       	ldi	r21, 0x00	; 0
    28da:	55 1f       	adc	r21, r21
    28dc:	62 9f       	mul	r22, r18
    28de:	f0 01       	movw	r30, r0
    28e0:	72 9f       	mul	r23, r18
    28e2:	bb 27       	eor	r27, r27
    28e4:	f0 0d       	add	r31, r0
    28e6:	b1 1d       	adc	r27, r1
    28e8:	63 9f       	mul	r22, r19
    28ea:	aa 27       	eor	r26, r26
    28ec:	f0 0d       	add	r31, r0
    28ee:	b1 1d       	adc	r27, r1
    28f0:	aa 1f       	adc	r26, r26
    28f2:	64 9f       	mul	r22, r20
    28f4:	66 27       	eor	r22, r22
    28f6:	b0 0d       	add	r27, r0
    28f8:	a1 1d       	adc	r26, r1
    28fa:	66 1f       	adc	r22, r22
    28fc:	82 9f       	mul	r24, r18
    28fe:	22 27       	eor	r18, r18
    2900:	b0 0d       	add	r27, r0
    2902:	a1 1d       	adc	r26, r1
    2904:	62 1f       	adc	r22, r18
    2906:	73 9f       	mul	r23, r19
    2908:	b0 0d       	add	r27, r0
    290a:	a1 1d       	adc	r26, r1
    290c:	62 1f       	adc	r22, r18
    290e:	83 9f       	mul	r24, r19
    2910:	a0 0d       	add	r26, r0
    2912:	61 1d       	adc	r22, r1
    2914:	22 1f       	adc	r18, r18
    2916:	74 9f       	mul	r23, r20
    2918:	33 27       	eor	r19, r19
    291a:	a0 0d       	add	r26, r0
    291c:	61 1d       	adc	r22, r1
    291e:	23 1f       	adc	r18, r19
    2920:	84 9f       	mul	r24, r20
    2922:	60 0d       	add	r22, r0
    2924:	21 1d       	adc	r18, r1
    2926:	82 2f       	mov	r24, r18
    2928:	76 2f       	mov	r23, r22
    292a:	6a 2f       	mov	r22, r26
    292c:	11 24       	eor	r1, r1
    292e:	9f 57       	subi	r25, 0x7F	; 127
    2930:	50 40       	sbci	r21, 0x00	; 0
    2932:	8a f0       	brmi	.+34     	; 0x2956 <__mulsf3_pse+0x84>
    2934:	e1 f0       	breq	.+56     	; 0x296e <__mulsf3_pse+0x9c>
    2936:	88 23       	and	r24, r24
    2938:	4a f0       	brmi	.+18     	; 0x294c <__mulsf3_pse+0x7a>
    293a:	ee 0f       	add	r30, r30
    293c:	ff 1f       	adc	r31, r31
    293e:	bb 1f       	adc	r27, r27
    2940:	66 1f       	adc	r22, r22
    2942:	77 1f       	adc	r23, r23
    2944:	88 1f       	adc	r24, r24
    2946:	91 50       	subi	r25, 0x01	; 1
    2948:	50 40       	sbci	r21, 0x00	; 0
    294a:	a9 f7       	brne	.-22     	; 0x2936 <__mulsf3_pse+0x64>
    294c:	9e 3f       	cpi	r25, 0xFE	; 254
    294e:	51 05       	cpc	r21, r1
    2950:	70 f0       	brcs	.+28     	; 0x296e <__mulsf3_pse+0x9c>
    2952:	34 cf       	rjmp	.-408    	; 0x27bc <__fp_inf>
    2954:	a3 cf       	rjmp	.-186    	; 0x289c <__fp_szero>
    2956:	5f 3f       	cpi	r21, 0xFF	; 255
    2958:	ec f3       	brlt	.-6      	; 0x2954 <__mulsf3_pse+0x82>
    295a:	98 3e       	cpi	r25, 0xE8	; 232
    295c:	dc f3       	brlt	.-10     	; 0x2954 <__mulsf3_pse+0x82>
    295e:	86 95       	lsr	r24
    2960:	77 95       	ror	r23
    2962:	67 95       	ror	r22
    2964:	b7 95       	ror	r27
    2966:	f7 95       	ror	r31
    2968:	e7 95       	ror	r30
    296a:	9f 5f       	subi	r25, 0xFF	; 255
    296c:	c1 f7       	brne	.-16     	; 0x295e <__mulsf3_pse+0x8c>
    296e:	fe 2b       	or	r31, r30
    2970:	88 0f       	add	r24, r24
    2972:	91 1d       	adc	r25, r1
    2974:	96 95       	lsr	r25
    2976:	87 95       	ror	r24
    2978:	97 f9       	bld	r25, 7
    297a:	08 95       	ret

0000297c <pow>:
    297c:	fa 01       	movw	r30, r20
    297e:	ee 0f       	add	r30, r30
    2980:	ff 1f       	adc	r31, r31
    2982:	30 96       	adiw	r30, 0x00	; 0
    2984:	21 05       	cpc	r18, r1
    2986:	31 05       	cpc	r19, r1
    2988:	99 f1       	breq	.+102    	; 0x29f0 <pow+0x74>
    298a:	61 15       	cp	r22, r1
    298c:	71 05       	cpc	r23, r1
    298e:	61 f4       	brne	.+24     	; 0x29a8 <pow+0x2c>
    2990:	80 38       	cpi	r24, 0x80	; 128
    2992:	bf e3       	ldi	r27, 0x3F	; 63
    2994:	9b 07       	cpc	r25, r27
    2996:	49 f1       	breq	.+82     	; 0x29ea <pow+0x6e>
    2998:	68 94       	set
    299a:	90 38       	cpi	r25, 0x80	; 128
    299c:	81 05       	cpc	r24, r1
    299e:	61 f0       	breq	.+24     	; 0x29b8 <pow+0x3c>
    29a0:	80 38       	cpi	r24, 0x80	; 128
    29a2:	bf ef       	ldi	r27, 0xFF	; 255
    29a4:	9b 07       	cpc	r25, r27
    29a6:	41 f0       	breq	.+16     	; 0x29b8 <pow+0x3c>
    29a8:	99 23       	and	r25, r25
    29aa:	42 f5       	brpl	.+80     	; 0x29fc <pow+0x80>
    29ac:	ff 3f       	cpi	r31, 0xFF	; 255
    29ae:	e1 05       	cpc	r30, r1
    29b0:	31 05       	cpc	r19, r1
    29b2:	21 05       	cpc	r18, r1
    29b4:	11 f1       	breq	.+68     	; 0x29fa <pow+0x7e>
    29b6:	e8 94       	clt
    29b8:	08 94       	sec
    29ba:	e7 95       	ror	r30
    29bc:	d9 01       	movw	r26, r18
    29be:	aa 23       	and	r26, r26
    29c0:	29 f4       	brne	.+10     	; 0x29cc <pow+0x50>
    29c2:	ab 2f       	mov	r26, r27
    29c4:	be 2f       	mov	r27, r30
    29c6:	f8 5f       	subi	r31, 0xF8	; 248
    29c8:	d0 f3       	brcs	.-12     	; 0x29be <pow+0x42>
    29ca:	10 c0       	rjmp	.+32     	; 0x29ec <pow+0x70>
    29cc:	ff 5f       	subi	r31, 0xFF	; 255
    29ce:	70 f4       	brcc	.+28     	; 0x29ec <pow+0x70>
    29d0:	a6 95       	lsr	r26
    29d2:	e0 f7       	brcc	.-8      	; 0x29cc <pow+0x50>
    29d4:	f7 39       	cpi	r31, 0x97	; 151
    29d6:	50 f0       	brcs	.+20     	; 0x29ec <pow+0x70>
    29d8:	19 f0       	breq	.+6      	; 0x29e0 <pow+0x64>
    29da:	ff 3a       	cpi	r31, 0xAF	; 175
    29dc:	38 f4       	brcc	.+14     	; 0x29ec <pow+0x70>
    29de:	9f 77       	andi	r25, 0x7F	; 127
    29e0:	9f 93       	push	r25
    29e2:	0c d0       	rcall	.+24     	; 0x29fc <pow+0x80>
    29e4:	0f 90       	pop	r0
    29e6:	07 fc       	sbrc	r0, 7
    29e8:	90 58       	subi	r25, 0x80	; 128
    29ea:	08 95       	ret
    29ec:	3e f0       	brts	.+14     	; 0x29fc <pow+0x80>
    29ee:	ec ce       	rjmp	.-552    	; 0x27c8 <__fp_nan>
    29f0:	60 e0       	ldi	r22, 0x00	; 0
    29f2:	70 e0       	ldi	r23, 0x00	; 0
    29f4:	80 e8       	ldi	r24, 0x80	; 128
    29f6:	9f e3       	ldi	r25, 0x3F	; 63
    29f8:	08 95       	ret
    29fa:	4f e7       	ldi	r20, 0x7F	; 127
    29fc:	9f 77       	andi	r25, 0x7F	; 127
    29fe:	5f 93       	push	r21
    2a00:	4f 93       	push	r20
    2a02:	3f 93       	push	r19
    2a04:	2f 93       	push	r18
    2a06:	80 d0       	rcall	.+256    	; 0x2b08 <log>
    2a08:	2f 91       	pop	r18
    2a0a:	3f 91       	pop	r19
    2a0c:	4f 91       	pop	r20
    2a0e:	5f 91       	pop	r21
    2a10:	52 df       	rcall	.-348    	; 0x28b6 <__mulsf3>
    2a12:	05 c0       	rjmp	.+10     	; 0x2a1e <exp>
    2a14:	19 f4       	brne	.+6      	; 0x2a1c <pow+0xa0>
    2a16:	0e f0       	brts	.+2      	; 0x2a1a <pow+0x9e>
    2a18:	d1 ce       	rjmp	.-606    	; 0x27bc <__fp_inf>
    2a1a:	3f cf       	rjmp	.-386    	; 0x289a <__fp_zero>
    2a1c:	d5 ce       	rjmp	.-598    	; 0x27c8 <__fp_nan>

00002a1e <exp>:
    2a1e:	23 df       	rcall	.-442    	; 0x2866 <__fp_splitA>
    2a20:	c8 f3       	brcs	.-14     	; 0x2a14 <pow+0x98>
    2a22:	96 38       	cpi	r25, 0x86	; 134
    2a24:	c0 f7       	brcc	.-16     	; 0x2a16 <pow+0x9a>
    2a26:	07 f8       	bld	r0, 7
    2a28:	0f 92       	push	r0
    2a2a:	e8 94       	clt
    2a2c:	2b e3       	ldi	r18, 0x3B	; 59
    2a2e:	3a ea       	ldi	r19, 0xAA	; 170
    2a30:	48 eb       	ldi	r20, 0xB8	; 184
    2a32:	5f e7       	ldi	r21, 0x7F	; 127
    2a34:	4e df       	rcall	.-356    	; 0x28d2 <__mulsf3_pse>
    2a36:	0f 92       	push	r0
    2a38:	0f 92       	push	r0
    2a3a:	0f 92       	push	r0
    2a3c:	4d b7       	in	r20, 0x3d	; 61
    2a3e:	5e b7       	in	r21, 0x3e	; 62
    2a40:	0f 92       	push	r0
    2a42:	a2 d0       	rcall	.+324    	; 0x2b88 <modf>
    2a44:	e6 e7       	ldi	r30, 0x76	; 118
    2a46:	f2 e0       	ldi	r31, 0x02	; 2
    2a48:	c2 de       	rcall	.-636    	; 0x27ce <__fp_powser>
    2a4a:	4f 91       	pop	r20
    2a4c:	5f 91       	pop	r21
    2a4e:	ef 91       	pop	r30
    2a50:	ff 91       	pop	r31
    2a52:	e5 95       	asr	r30
    2a54:	ee 1f       	adc	r30, r30
    2a56:	ff 1f       	adc	r31, r31
    2a58:	49 f0       	breq	.+18     	; 0x2a6c <exp+0x4e>
    2a5a:	fe 57       	subi	r31, 0x7E	; 126
    2a5c:	e0 68       	ori	r30, 0x80	; 128
    2a5e:	44 27       	eor	r20, r20
    2a60:	ee 0f       	add	r30, r30
    2a62:	44 1f       	adc	r20, r20
    2a64:	fa 95       	dec	r31
    2a66:	e1 f7       	brne	.-8      	; 0x2a60 <exp+0x42>
    2a68:	41 95       	neg	r20
    2a6a:	55 0b       	sbc	r21, r21
    2a6c:	14 d0       	rcall	.+40     	; 0x2a96 <ldexp>
    2a6e:	0f 90       	pop	r0
    2a70:	07 fe       	sbrs	r0, 7
    2a72:	1a cf       	rjmp	.-460    	; 0x28a8 <inverse>
    2a74:	08 95       	ret

00002a76 <__fp_mpack>:
    2a76:	9f 3f       	cpi	r25, 0xFF	; 255
    2a78:	31 f0       	breq	.+12     	; 0x2a86 <__fp_mpack_finite+0xc>

00002a7a <__fp_mpack_finite>:
    2a7a:	91 50       	subi	r25, 0x01	; 1
    2a7c:	20 f4       	brcc	.+8      	; 0x2a86 <__fp_mpack_finite+0xc>
    2a7e:	87 95       	ror	r24
    2a80:	77 95       	ror	r23
    2a82:	67 95       	ror	r22
    2a84:	b7 95       	ror	r27
    2a86:	88 0f       	add	r24, r24
    2a88:	91 1d       	adc	r25, r1
    2a8a:	96 95       	lsr	r25
    2a8c:	87 95       	ror	r24
    2a8e:	97 f9       	bld	r25, 7
    2a90:	08 95       	ret
    2a92:	94 ce       	rjmp	.-728    	; 0x27bc <__fp_inf>
    2a94:	f0 cf       	rjmp	.-32     	; 0x2a76 <__fp_mpack>

00002a96 <ldexp>:
    2a96:	e7 de       	rcall	.-562    	; 0x2866 <__fp_splitA>
    2a98:	e8 f3       	brcs	.-6      	; 0x2a94 <__fp_mpack_finite+0x1a>
    2a9a:	99 23       	and	r25, r25
    2a9c:	d9 f3       	breq	.-10     	; 0x2a94 <__fp_mpack_finite+0x1a>
    2a9e:	94 0f       	add	r25, r20
    2aa0:	51 1d       	adc	r21, r1
    2aa2:	bb f3       	brvs	.-18     	; 0x2a92 <__fp_mpack_finite+0x18>
    2aa4:	91 50       	subi	r25, 0x01	; 1
    2aa6:	50 40       	sbci	r21, 0x00	; 0
    2aa8:	94 f0       	brlt	.+36     	; 0x2ace <ldexp+0x38>
    2aaa:	59 f0       	breq	.+22     	; 0x2ac2 <ldexp+0x2c>
    2aac:	88 23       	and	r24, r24
    2aae:	32 f0       	brmi	.+12     	; 0x2abc <ldexp+0x26>
    2ab0:	66 0f       	add	r22, r22
    2ab2:	77 1f       	adc	r23, r23
    2ab4:	88 1f       	adc	r24, r24
    2ab6:	91 50       	subi	r25, 0x01	; 1
    2ab8:	50 40       	sbci	r21, 0x00	; 0
    2aba:	c1 f7       	brne	.-16     	; 0x2aac <ldexp+0x16>
    2abc:	9e 3f       	cpi	r25, 0xFE	; 254
    2abe:	51 05       	cpc	r21, r1
    2ac0:	44 f7       	brge	.-48     	; 0x2a92 <__fp_mpack_finite+0x18>
    2ac2:	88 0f       	add	r24, r24
    2ac4:	91 1d       	adc	r25, r1
    2ac6:	96 95       	lsr	r25
    2ac8:	87 95       	ror	r24
    2aca:	97 f9       	bld	r25, 7
    2acc:	08 95       	ret
    2ace:	5f 3f       	cpi	r21, 0xFF	; 255
    2ad0:	ac f0       	brlt	.+42     	; 0x2afc <ldexp+0x66>
    2ad2:	98 3e       	cpi	r25, 0xE8	; 232
    2ad4:	9c f0       	brlt	.+38     	; 0x2afc <ldexp+0x66>
    2ad6:	bb 27       	eor	r27, r27
    2ad8:	86 95       	lsr	r24
    2ada:	77 95       	ror	r23
    2adc:	67 95       	ror	r22
    2ade:	b7 95       	ror	r27
    2ae0:	08 f4       	brcc	.+2      	; 0x2ae4 <ldexp+0x4e>
    2ae2:	b1 60       	ori	r27, 0x01	; 1
    2ae4:	93 95       	inc	r25
    2ae6:	c1 f7       	brne	.-16     	; 0x2ad8 <ldexp+0x42>
    2ae8:	bb 0f       	add	r27, r27
    2aea:	58 f7       	brcc	.-42     	; 0x2ac2 <ldexp+0x2c>
    2aec:	11 f4       	brne	.+4      	; 0x2af2 <ldexp+0x5c>
    2aee:	60 ff       	sbrs	r22, 0
    2af0:	e8 cf       	rjmp	.-48     	; 0x2ac2 <ldexp+0x2c>
    2af2:	6f 5f       	subi	r22, 0xFF	; 255
    2af4:	7f 4f       	sbci	r23, 0xFF	; 255
    2af6:	8f 4f       	sbci	r24, 0xFF	; 255
    2af8:	9f 4f       	sbci	r25, 0xFF	; 255
    2afa:	e3 cf       	rjmp	.-58     	; 0x2ac2 <ldexp+0x2c>
    2afc:	cf ce       	rjmp	.-610    	; 0x289c <__fp_szero>
    2afe:	0e f0       	brts	.+2      	; 0x2b02 <ldexp+0x6c>
    2b00:	ba cf       	rjmp	.-140    	; 0x2a76 <__fp_mpack>
    2b02:	62 ce       	rjmp	.-828    	; 0x27c8 <__fp_nan>
    2b04:	68 94       	set
    2b06:	5a ce       	rjmp	.-844    	; 0x27bc <__fp_inf>

00002b08 <log>:
    2b08:	ae de       	rcall	.-676    	; 0x2866 <__fp_splitA>
    2b0a:	c8 f3       	brcs	.-14     	; 0x2afe <ldexp+0x68>
    2b0c:	99 23       	and	r25, r25
    2b0e:	d1 f3       	breq	.-12     	; 0x2b04 <ldexp+0x6e>
    2b10:	c6 f3       	brts	.-16     	; 0x2b02 <ldexp+0x6c>
    2b12:	df 93       	push	r29
    2b14:	cf 93       	push	r28
    2b16:	1f 93       	push	r17
    2b18:	0f 93       	push	r16
    2b1a:	ff 92       	push	r15
    2b1c:	c9 2f       	mov	r28, r25
    2b1e:	dd 27       	eor	r29, r29
    2b20:	88 23       	and	r24, r24
    2b22:	2a f0       	brmi	.+10     	; 0x2b2e <log+0x26>
    2b24:	21 97       	sbiw	r28, 0x01	; 1
    2b26:	66 0f       	add	r22, r22
    2b28:	77 1f       	adc	r23, r23
    2b2a:	88 1f       	adc	r24, r24
    2b2c:	da f7       	brpl	.-10     	; 0x2b24 <log+0x1c>
    2b2e:	20 e0       	ldi	r18, 0x00	; 0
    2b30:	30 e0       	ldi	r19, 0x00	; 0
    2b32:	40 e8       	ldi	r20, 0x80	; 128
    2b34:	5f eb       	ldi	r21, 0xBF	; 191
    2b36:	9f e3       	ldi	r25, 0x3F	; 63
    2b38:	88 39       	cpi	r24, 0x98	; 152
    2b3a:	20 f0       	brcs	.+8      	; 0x2b44 <log+0x3c>
    2b3c:	80 3e       	cpi	r24, 0xE0	; 224
    2b3e:	30 f0       	brcs	.+12     	; 0x2b4c <log+0x44>
    2b40:	21 96       	adiw	r28, 0x01	; 1
    2b42:	8f 77       	andi	r24, 0x7F	; 127
    2b44:	01 dd       	rcall	.-1534   	; 0x2548 <__addsf3>
    2b46:	ee e9       	ldi	r30, 0x9E	; 158
    2b48:	f2 e0       	ldi	r31, 0x02	; 2
    2b4a:	03 c0       	rjmp	.+6      	; 0x2b52 <log+0x4a>
    2b4c:	fd dc       	rcall	.-1542   	; 0x2548 <__addsf3>
    2b4e:	eb ec       	ldi	r30, 0xCB	; 203
    2b50:	f2 e0       	ldi	r31, 0x02	; 2
    2b52:	3d de       	rcall	.-902    	; 0x27ce <__fp_powser>
    2b54:	8b 01       	movw	r16, r22
    2b56:	be 01       	movw	r22, r28
    2b58:	ec 01       	movw	r28, r24
    2b5a:	fb 2e       	mov	r15, r27
    2b5c:	6f 57       	subi	r22, 0x7F	; 127
    2b5e:	71 09       	sbc	r23, r1
    2b60:	75 95       	asr	r23
    2b62:	77 1f       	adc	r23, r23
    2b64:	88 0b       	sbc	r24, r24
    2b66:	99 0b       	sbc	r25, r25
    2b68:	ee dd       	rcall	.-1060   	; 0x2746 <__floatsisf>
    2b6a:	28 e1       	ldi	r18, 0x18	; 24
    2b6c:	32 e7       	ldi	r19, 0x72	; 114
    2b6e:	41 e3       	ldi	r20, 0x31	; 49
    2b70:	5f e3       	ldi	r21, 0x3F	; 63
    2b72:	ad de       	rcall	.-678    	; 0x28ce <__mulsf3x>
    2b74:	af 2d       	mov	r26, r15
    2b76:	98 01       	movw	r18, r16
    2b78:	ae 01       	movw	r20, r28
    2b7a:	ff 90       	pop	r15
    2b7c:	0f 91       	pop	r16
    2b7e:	1f 91       	pop	r17
    2b80:	cf 91       	pop	r28
    2b82:	df 91       	pop	r29
    2b84:	f2 dc       	rcall	.-1564   	; 0x256a <__addsf3x>
    2b86:	56 ce       	rjmp	.-852    	; 0x2834 <__fp_round>

00002b88 <modf>:
    2b88:	fa 01       	movw	r30, r20
    2b8a:	dc 01       	movw	r26, r24
    2b8c:	aa 0f       	add	r26, r26
    2b8e:	bb 1f       	adc	r27, r27
    2b90:	9b 01       	movw	r18, r22
    2b92:	ac 01       	movw	r20, r24
    2b94:	bf 57       	subi	r27, 0x7F	; 127
    2b96:	28 f4       	brcc	.+10     	; 0x2ba2 <modf+0x1a>
    2b98:	22 27       	eor	r18, r18
    2b9a:	33 27       	eor	r19, r19
    2b9c:	44 27       	eor	r20, r20
    2b9e:	50 78       	andi	r21, 0x80	; 128
    2ba0:	1f c0       	rjmp	.+62     	; 0x2be0 <modf+0x58>
    2ba2:	b7 51       	subi	r27, 0x17	; 23
    2ba4:	88 f4       	brcc	.+34     	; 0x2bc8 <modf+0x40>
    2ba6:	ab 2f       	mov	r26, r27
    2ba8:	00 24       	eor	r0, r0
    2baa:	46 95       	lsr	r20
    2bac:	37 95       	ror	r19
    2bae:	27 95       	ror	r18
    2bb0:	01 1c       	adc	r0, r1
    2bb2:	a3 95       	inc	r26
    2bb4:	d2 f3       	brmi	.-12     	; 0x2baa <modf+0x22>
    2bb6:	00 20       	and	r0, r0
    2bb8:	69 f0       	breq	.+26     	; 0x2bd4 <modf+0x4c>
    2bba:	22 0f       	add	r18, r18
    2bbc:	33 1f       	adc	r19, r19
    2bbe:	44 1f       	adc	r20, r20
    2bc0:	b3 95       	inc	r27
    2bc2:	da f3       	brmi	.-10     	; 0x2bba <modf+0x32>
    2bc4:	0d d0       	rcall	.+26     	; 0x2be0 <modf+0x58>
    2bc6:	bf cc       	rjmp	.-1666   	; 0x2546 <__subsf3>
    2bc8:	61 30       	cpi	r22, 0x01	; 1
    2bca:	71 05       	cpc	r23, r1
    2bcc:	a0 e8       	ldi	r26, 0x80	; 128
    2bce:	8a 07       	cpc	r24, r26
    2bd0:	b9 46       	sbci	r27, 0x69	; 105
    2bd2:	30 f4       	brcc	.+12     	; 0x2be0 <modf+0x58>
    2bd4:	9b 01       	movw	r18, r22
    2bd6:	ac 01       	movw	r20, r24
    2bd8:	66 27       	eor	r22, r22
    2bda:	77 27       	eor	r23, r23
    2bdc:	88 27       	eor	r24, r24
    2bde:	90 78       	andi	r25, 0x80	; 128
    2be0:	30 96       	adiw	r30, 0x00	; 0
    2be2:	21 f0       	breq	.+8      	; 0x2bec <modf+0x64>
    2be4:	20 83       	st	Z, r18
    2be6:	31 83       	std	Z+1, r19	; 0x01
    2be8:	42 83       	std	Z+2, r20	; 0x02
    2bea:	53 83       	std	Z+3, r21	; 0x03
    2bec:	08 95       	ret

00002bee <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    2bee:	fc 01       	movw	r30, r24
    2bf0:	81 8d       	ldd	r24, Z+25	; 0x19
    2bf2:	22 8d       	ldd	r18, Z+26	; 0x1a
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	80 5c       	subi	r24, 0xC0	; 192
    2bf8:	9f 4f       	sbci	r25, 0xFF	; 255
    2bfa:	82 1b       	sub	r24, r18
    2bfc:	91 09       	sbc	r25, r1
    2bfe:	8f 73       	andi	r24, 0x3F	; 63
    2c00:	99 27       	eor	r25, r25
    2c02:	08 95       	ret

00002c04 <_ZN14HardwareSerial4peekEv>:
    2c04:	fc 01       	movw	r30, r24
    2c06:	91 8d       	ldd	r25, Z+25	; 0x19
    2c08:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c0a:	98 17       	cp	r25, r24
    2c0c:	31 f0       	breq	.+12     	; 0x2c1a <_ZN14HardwareSerial4peekEv+0x16>
    2c0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c10:	e8 0f       	add	r30, r24
    2c12:	f1 1d       	adc	r31, r1
    2c14:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c16:	90 e0       	ldi	r25, 0x00	; 0
    2c18:	08 95       	ret
    2c1a:	8f ef       	ldi	r24, 0xFF	; 255
    2c1c:	9f ef       	ldi	r25, 0xFF	; 255
    2c1e:	08 95       	ret

00002c20 <_ZN14HardwareSerial4readEv>:
    2c20:	fc 01       	movw	r30, r24
    2c22:	91 8d       	ldd	r25, Z+25	; 0x19
    2c24:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c26:	98 17       	cp	r25, r24
    2c28:	61 f0       	breq	.+24     	; 0x2c42 <_ZN14HardwareSerial4readEv+0x22>
    2c2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c2c:	df 01       	movw	r26, r30
    2c2e:	a8 0f       	add	r26, r24
    2c30:	b1 1d       	adc	r27, r1
    2c32:	5d 96       	adiw	r26, 0x1d	; 29
    2c34:	8c 91       	ld	r24, X
    2c36:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c38:	9f 5f       	subi	r25, 0xFF	; 255
    2c3a:	9f 73       	andi	r25, 0x3F	; 63
    2c3c:	92 8f       	std	Z+26, r25	; 0x1a
    2c3e:	90 e0       	ldi	r25, 0x00	; 0
    2c40:	08 95       	ret
    2c42:	8f ef       	ldi	r24, 0xFF	; 255
    2c44:	9f ef       	ldi	r25, 0xFF	; 255
    2c46:	08 95       	ret

00002c48 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    2c48:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    2c4a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c4c:	df 01       	movw	r26, r30
    2c4e:	a8 0f       	add	r26, r24
    2c50:	b1 1d       	adc	r27, r1
    2c52:	a3 5a       	subi	r26, 0xA3	; 163
    2c54:	bf 4f       	sbci	r27, 0xFF	; 255
    2c56:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    2c58:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c5a:	90 e0       	ldi	r25, 0x00	; 0
    2c5c:	01 96       	adiw	r24, 0x01	; 1
    2c5e:	8f 73       	andi	r24, 0x3F	; 63
    2c60:	90 78       	andi	r25, 0x80	; 128
    2c62:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    2c64:	a6 89       	ldd	r26, Z+22	; 0x16
    2c66:	b7 89       	ldd	r27, Z+23	; 0x17
    2c68:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    2c6a:	a0 89       	ldd	r26, Z+16	; 0x10
    2c6c:	b1 89       	ldd	r27, Z+17	; 0x11
    2c6e:	8c 91       	ld	r24, X
    2c70:	80 64       	ori	r24, 0x40	; 64
    2c72:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    2c74:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c76:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c78:	98 13       	cpse	r25, r24
    2c7a:	06 c0       	rjmp	.+12     	; 0x2c88 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    2c7c:	02 88       	ldd	r0, Z+18	; 0x12
    2c7e:	f3 89       	ldd	r31, Z+19	; 0x13
    2c80:	e0 2d       	mov	r30, r0
    2c82:	80 81       	ld	r24, Z
    2c84:	8f 7d       	andi	r24, 0xDF	; 223
    2c86:	80 83       	st	Z, r24
    2c88:	08 95       	ret

00002c8a <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    2c8a:	cf 93       	push	r28
    2c8c:	df 93       	push	r29
    2c8e:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    2c90:	88 8d       	ldd	r24, Y+24	; 0x18
    2c92:	81 11       	cpse	r24, r1
    2c94:	0a c0       	rjmp	.+20     	; 0x2caa <_ZN14HardwareSerial5flushEv+0x20>
    2c96:	1a c0       	rjmp	.+52     	; 0x2ccc <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    2c98:	0f b6       	in	r0, 0x3f	; 63
    2c9a:	07 fc       	sbrc	r0, 7
    2c9c:	08 c0       	rjmp	.+16     	; 0x2cae <_ZN14HardwareSerial5flushEv+0x24>
    2c9e:	80 81       	ld	r24, Z
    2ca0:	85 ff       	sbrs	r24, 5
    2ca2:	05 c0       	rjmp	.+10     	; 0x2cae <_ZN14HardwareSerial5flushEv+0x24>
    2ca4:	0d c0       	rjmp	.+26     	; 0x2cc0 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    2ca6:	ce 01       	movw	r24, r28
    2ca8:	cf df       	rcall	.-98     	; 0x2c48 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    2caa:	ea 89       	ldd	r30, Y+18	; 0x12
    2cac:	fb 89       	ldd	r31, Y+19	; 0x13
    2cae:	80 81       	ld	r24, Z
    2cb0:	85 fd       	sbrc	r24, 5
    2cb2:	f2 cf       	rjmp	.-28     	; 0x2c98 <_ZN14HardwareSerial5flushEv+0xe>
    2cb4:	a8 89       	ldd	r26, Y+16	; 0x10
    2cb6:	b9 89       	ldd	r27, Y+17	; 0x11
    2cb8:	8c 91       	ld	r24, X
    2cba:	86 ff       	sbrs	r24, 6
    2cbc:	ed cf       	rjmp	.-38     	; 0x2c98 <_ZN14HardwareSerial5flushEv+0xe>
    2cbe:	06 c0       	rjmp	.+12     	; 0x2ccc <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    2cc0:	a8 89       	ldd	r26, Y+16	; 0x10
    2cc2:	b9 89       	ldd	r27, Y+17	; 0x11
    2cc4:	8c 91       	ld	r24, X
    2cc6:	85 ff       	sbrs	r24, 5
    2cc8:	f2 cf       	rjmp	.-28     	; 0x2cae <_ZN14HardwareSerial5flushEv+0x24>
    2cca:	ed cf       	rjmp	.-38     	; 0x2ca6 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    2ccc:	df 91       	pop	r29
    2cce:	cf 91       	pop	r28
    2cd0:	08 95       	ret

00002cd2 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    2cd2:	0f 93       	push	r16
    2cd4:	1f 93       	push	r17
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	ec 01       	movw	r28, r24
    2cdc:	16 2f       	mov	r17, r22
  _written = true;
    2cde:	81 e0       	ldi	r24, 0x01	; 1
    2ce0:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    2ce2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2ce4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2ce6:	98 13       	cpse	r25, r24
    2ce8:	21 c0       	rjmp	.+66     	; 0x2d2c <_ZN14HardwareSerial5writeEh+0x5a>
    2cea:	e8 89       	ldd	r30, Y+16	; 0x10
    2cec:	f9 89       	ldd	r31, Y+17	; 0x11
    2cee:	80 81       	ld	r24, Z
    2cf0:	85 fd       	sbrc	r24, 5
    2cf2:	23 c0       	rjmp	.+70     	; 0x2d3a <_ZN14HardwareSerial5writeEh+0x68>
    2cf4:	1b c0       	rjmp	.+54     	; 0x2d2c <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    2cf6:	0f b6       	in	r0, 0x3f	; 63
    2cf8:	07 fc       	sbrc	r0, 7
    2cfa:	07 c0       	rjmp	.+14     	; 0x2d0a <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    2cfc:	e8 89       	ldd	r30, Y+16	; 0x10
    2cfe:	f9 89       	ldd	r31, Y+17	; 0x11
    2d00:	80 81       	ld	r24, Z
    2d02:	85 ff       	sbrs	r24, 5
    2d04:	02 c0       	rjmp	.+4      	; 0x2d0a <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    2d06:	ce 01       	movw	r24, r28
    2d08:	9f df       	rcall	.-194    	; 0x2c48 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2d0a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2d0c:	09 17       	cp	r16, r25
    2d0e:	99 f3       	breq	.-26     	; 0x2cf6 <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    2d10:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d12:	fe 01       	movw	r30, r28
    2d14:	e8 0f       	add	r30, r24
    2d16:	f1 1d       	adc	r31, r1
    2d18:	e3 5a       	subi	r30, 0xA3	; 163
    2d1a:	ff 4f       	sbci	r31, 0xFF	; 255
    2d1c:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    2d1e:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    2d20:	ea 89       	ldd	r30, Y+18	; 0x12
    2d22:	fb 89       	ldd	r31, Y+19	; 0x13
    2d24:	80 81       	ld	r24, Z
    2d26:	80 62       	ori	r24, 0x20	; 32
    2d28:	80 83       	st	Z, r24
  
  return 1;
    2d2a:	0f c0       	rjmp	.+30     	; 0x2d4a <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    2d2c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d2e:	90 e0       	ldi	r25, 0x00	; 0
    2d30:	01 96       	adiw	r24, 0x01	; 1
    2d32:	8f 73       	andi	r24, 0x3F	; 63
    2d34:	90 78       	andi	r25, 0x80	; 128
    2d36:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2d38:	e8 cf       	rjmp	.-48     	; 0x2d0a <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    2d3a:	ee 89       	ldd	r30, Y+22	; 0x16
    2d3c:	ff 89       	ldd	r31, Y+23	; 0x17
    2d3e:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    2d40:	e8 89       	ldd	r30, Y+16	; 0x10
    2d42:	f9 89       	ldd	r31, Y+17	; 0x11
    2d44:	80 81       	ld	r24, Z
    2d46:	80 64       	ori	r24, 0x40	; 64
    2d48:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	90 e0       	ldi	r25, 0x00	; 0
    2d4e:	df 91       	pop	r29
    2d50:	cf 91       	pop	r28
    2d52:	1f 91       	pop	r17
    2d54:	0f 91       	pop	r16
    2d56:	08 95       	ret

00002d58 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    2d58:	cf 92       	push	r12
    2d5a:	df 92       	push	r13
    2d5c:	ef 92       	push	r14
    2d5e:	ff 92       	push	r15
    2d60:	1f 93       	push	r17
    2d62:	cf 93       	push	r28
    2d64:	df 93       	push	r29
    2d66:	ec 01       	movw	r28, r24
    2d68:	6a 01       	movw	r12, r20
    2d6a:	7b 01       	movw	r14, r22
    2d6c:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    2d6e:	e8 89       	ldd	r30, Y+16	; 0x10
    2d70:	f9 89       	ldd	r31, Y+17	; 0x11
    2d72:	82 e0       	ldi	r24, 0x02	; 2
    2d74:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2d76:	41 15       	cp	r20, r1
    2d78:	81 ee       	ldi	r24, 0xE1	; 225
    2d7a:	58 07       	cpc	r21, r24
    2d7c:	61 05       	cpc	r22, r1
    2d7e:	71 05       	cpc	r23, r1
    2d80:	a9 f0       	breq	.+42     	; 0x2dac <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    2d82:	60 e0       	ldi	r22, 0x00	; 0
    2d84:	79 e0       	ldi	r23, 0x09	; 9
    2d86:	8d e3       	ldi	r24, 0x3D	; 61
    2d88:	90 e0       	ldi	r25, 0x00	; 0
    2d8a:	a7 01       	movw	r20, r14
    2d8c:	96 01       	movw	r18, r12
    2d8e:	4b d4       	rcall	.+2198   	; 0x3626 <__udivmodsi4>
    2d90:	ba 01       	movw	r22, r20
    2d92:	a9 01       	movw	r20, r18
    2d94:	41 50       	subi	r20, 0x01	; 1
    2d96:	51 09       	sbc	r21, r1
    2d98:	61 09       	sbc	r22, r1
    2d9a:	71 09       	sbc	r23, r1
    2d9c:	76 95       	lsr	r23
    2d9e:	67 95       	ror	r22
    2da0:	57 95       	ror	r21
    2da2:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2da4:	41 15       	cp	r20, r1
    2da6:	80 e1       	ldi	r24, 0x10	; 16
    2da8:	58 07       	cpc	r21, r24
    2daa:	a0 f0       	brcs	.+40     	; 0x2dd4 <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    2dac:	e8 89       	ldd	r30, Y+16	; 0x10
    2dae:	f9 89       	ldd	r31, Y+17	; 0x11
    2db0:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    2db2:	60 e8       	ldi	r22, 0x80	; 128
    2db4:	74 e8       	ldi	r23, 0x84	; 132
    2db6:	8e e1       	ldi	r24, 0x1E	; 30
    2db8:	90 e0       	ldi	r25, 0x00	; 0
    2dba:	a7 01       	movw	r20, r14
    2dbc:	96 01       	movw	r18, r12
    2dbe:	33 d4       	rcall	.+2150   	; 0x3626 <__udivmodsi4>
    2dc0:	ba 01       	movw	r22, r20
    2dc2:	a9 01       	movw	r20, r18
    2dc4:	41 50       	subi	r20, 0x01	; 1
    2dc6:	51 09       	sbc	r21, r1
    2dc8:	61 09       	sbc	r22, r1
    2dca:	71 09       	sbc	r23, r1
    2dcc:	76 95       	lsr	r23
    2dce:	67 95       	ror	r22
    2dd0:	57 95       	ror	r21
    2dd2:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    2dd4:	ec 85       	ldd	r30, Y+12	; 0x0c
    2dd6:	fd 85       	ldd	r31, Y+13	; 0x0d
    2dd8:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    2dda:	ee 85       	ldd	r30, Y+14	; 0x0e
    2ddc:	ff 85       	ldd	r31, Y+15	; 0x0f
    2dde:	40 83       	st	Z, r20

  _written = false;
    2de0:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    2de2:	ec 89       	ldd	r30, Y+20	; 0x14
    2de4:	fd 89       	ldd	r31, Y+21	; 0x15
    2de6:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    2de8:	ea 89       	ldd	r30, Y+18	; 0x12
    2dea:	fb 89       	ldd	r31, Y+19	; 0x13
    2dec:	80 81       	ld	r24, Z
    2dee:	80 61       	ori	r24, 0x10	; 16
    2df0:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    2df2:	ea 89       	ldd	r30, Y+18	; 0x12
    2df4:	fb 89       	ldd	r31, Y+19	; 0x13
    2df6:	80 81       	ld	r24, Z
    2df8:	88 60       	ori	r24, 0x08	; 8
    2dfa:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    2dfc:	ea 89       	ldd	r30, Y+18	; 0x12
    2dfe:	fb 89       	ldd	r31, Y+19	; 0x13
    2e00:	80 81       	ld	r24, Z
    2e02:	80 68       	ori	r24, 0x80	; 128
    2e04:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    2e06:	ea 89       	ldd	r30, Y+18	; 0x12
    2e08:	fb 89       	ldd	r31, Y+19	; 0x13
    2e0a:	80 81       	ld	r24, Z
    2e0c:	8f 7d       	andi	r24, 0xDF	; 223
    2e0e:	80 83       	st	Z, r24
}
    2e10:	df 91       	pop	r29
    2e12:	cf 91       	pop	r28
    2e14:	1f 91       	pop	r17
    2e16:	ff 90       	pop	r15
    2e18:	ef 90       	pop	r14
    2e1a:	df 90       	pop	r13
    2e1c:	cf 90       	pop	r12
    2e1e:	08 95       	ret

00002e20 <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    2e20:	1f 92       	push	r1
    2e22:	0f 92       	push	r0
    2e24:	0f b6       	in	r0, 0x3f	; 63
    2e26:	0f 92       	push	r0
    2e28:	11 24       	eor	r1, r1
    2e2a:	0b b6       	in	r0, 0x3b	; 59
    2e2c:	0f 92       	push	r0
    2e2e:	2f 93       	push	r18
    2e30:	8f 93       	push	r24
    2e32:	9f 93       	push	r25
    2e34:	af 93       	push	r26
    2e36:	bf 93       	push	r27
    2e38:	ef 93       	push	r30
    2e3a:	ff 93       	push	r31
    2e3c:	e0 91 f9 09 	lds	r30, 0x09F9
    2e40:	f0 91 fa 09 	lds	r31, 0x09FA
    2e44:	80 81       	ld	r24, Z
    2e46:	82 fd       	sbrc	r24, 2
    2e48:	17 c0       	rjmp	.+46     	; 0x2e78 <__vector_25+0x58>
    2e4a:	e0 91 ff 09 	lds	r30, 0x09FF
    2e4e:	f0 91 00 0a 	lds	r31, 0x0A00
    2e52:	20 81       	ld	r18, Z
    2e54:	80 91 02 0a 	lds	r24, 0x0A02
    2e58:	8f 5f       	subi	r24, 0xFF	; 255
    2e5a:	8f 73       	andi	r24, 0x3F	; 63
    2e5c:	90 91 03 0a 	lds	r25, 0x0A03
    2e60:	89 17       	cp	r24, r25
    2e62:	79 f0       	breq	.+30     	; 0x2e82 <__vector_25+0x62>
    2e64:	e2 e0       	ldi	r30, 0x02	; 2
    2e66:	fa e0       	ldi	r31, 0x0A	; 10
    2e68:	a0 81       	ld	r26, Z
    2e6a:	b0 e0       	ldi	r27, 0x00	; 0
    2e6c:	a7 51       	subi	r26, 0x17	; 23
    2e6e:	b6 4f       	sbci	r27, 0xF6	; 246
    2e70:	5d 96       	adiw	r26, 0x1d	; 29
    2e72:	2c 93       	st	X, r18
    2e74:	80 83       	st	Z, r24
    2e76:	05 c0       	rjmp	.+10     	; 0x2e82 <__vector_25+0x62>
    2e78:	e0 91 ff 09 	lds	r30, 0x09FF
    2e7c:	f0 91 00 0a 	lds	r31, 0x0A00
    2e80:	80 81       	ld	r24, Z
    2e82:	ff 91       	pop	r31
    2e84:	ef 91       	pop	r30
    2e86:	bf 91       	pop	r27
    2e88:	af 91       	pop	r26
    2e8a:	9f 91       	pop	r25
    2e8c:	8f 91       	pop	r24
    2e8e:	2f 91       	pop	r18
    2e90:	0f 90       	pop	r0
    2e92:	0b be       	out	0x3b, r0	; 59
    2e94:	0f 90       	pop	r0
    2e96:	0f be       	out	0x3f, r0	; 63
    2e98:	0f 90       	pop	r0
    2e9a:	1f 90       	pop	r1
    2e9c:	18 95       	reti

00002e9e <__vector_26>:
    2e9e:	1f 92       	push	r1
    2ea0:	0f 92       	push	r0
    2ea2:	0f b6       	in	r0, 0x3f	; 63
    2ea4:	0f 92       	push	r0
    2ea6:	11 24       	eor	r1, r1
    2ea8:	0b b6       	in	r0, 0x3b	; 59
    2eaa:	0f 92       	push	r0
    2eac:	2f 93       	push	r18
    2eae:	3f 93       	push	r19
    2eb0:	4f 93       	push	r20
    2eb2:	5f 93       	push	r21
    2eb4:	6f 93       	push	r22
    2eb6:	7f 93       	push	r23
    2eb8:	8f 93       	push	r24
    2eba:	9f 93       	push	r25
    2ebc:	af 93       	push	r26
    2ebe:	bf 93       	push	r27
    2ec0:	ef 93       	push	r30
    2ec2:	ff 93       	push	r31
    2ec4:	89 ee       	ldi	r24, 0xE9	; 233
    2ec6:	99 e0       	ldi	r25, 0x09	; 9
    2ec8:	bf de       	rcall	.-642    	; 0x2c48 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    2eca:	ff 91       	pop	r31
    2ecc:	ef 91       	pop	r30
    2ece:	bf 91       	pop	r27
    2ed0:	af 91       	pop	r26
    2ed2:	9f 91       	pop	r25
    2ed4:	8f 91       	pop	r24
    2ed6:	7f 91       	pop	r23
    2ed8:	6f 91       	pop	r22
    2eda:	5f 91       	pop	r21
    2edc:	4f 91       	pop	r20
    2ede:	3f 91       	pop	r19
    2ee0:	2f 91       	pop	r18
    2ee2:	0f 90       	pop	r0
    2ee4:	0b be       	out	0x3b, r0	; 59
    2ee6:	0f 90       	pop	r0
    2ee8:	0f be       	out	0x3f, r0	; 63
    2eea:	0f 90       	pop	r0
    2eec:	1f 90       	pop	r1
    2eee:	18 95       	reti

00002ef0 <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2ef0:	10 92 ec 09 	sts	0x09EC, r1
    2ef4:	10 92 eb 09 	sts	0x09EB, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    2ef8:	88 ee       	ldi	r24, 0xE8	; 232
    2efa:	93 e0       	ldi	r25, 0x03	; 3
    2efc:	a0 e0       	ldi	r26, 0x00	; 0
    2efe:	b0 e0       	ldi	r27, 0x00	; 0
    2f00:	80 93 ed 09 	sts	0x09ED, r24
    2f04:	90 93 ee 09 	sts	0x09EE, r25
    2f08:	a0 93 ef 09 	sts	0x09EF, r26
    2f0c:	b0 93 f0 09 	sts	0x09F0, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    2f10:	81 e8       	ldi	r24, 0x81	; 129
    2f12:	92 e0       	ldi	r25, 0x02	; 2
    2f14:	90 93 ea 09 	sts	0x09EA, r25
    2f18:	80 93 e9 09 	sts	0x09E9, r24
    2f1c:	85 ec       	ldi	r24, 0xC5	; 197
    2f1e:	90 e0       	ldi	r25, 0x00	; 0
    2f20:	90 93 f6 09 	sts	0x09F6, r25
    2f24:	80 93 f5 09 	sts	0x09F5, r24
    2f28:	84 ec       	ldi	r24, 0xC4	; 196
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	90 93 f8 09 	sts	0x09F8, r25
    2f30:	80 93 f7 09 	sts	0x09F7, r24
    2f34:	80 ec       	ldi	r24, 0xC0	; 192
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	90 93 fa 09 	sts	0x09FA, r25
    2f3c:	80 93 f9 09 	sts	0x09F9, r24
    2f40:	81 ec       	ldi	r24, 0xC1	; 193
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	90 93 fc 09 	sts	0x09FC, r25
    2f48:	80 93 fb 09 	sts	0x09FB, r24
    2f4c:	82 ec       	ldi	r24, 0xC2	; 194
    2f4e:	90 e0       	ldi	r25, 0x00	; 0
    2f50:	90 93 fe 09 	sts	0x09FE, r25
    2f54:	80 93 fd 09 	sts	0x09FD, r24
    2f58:	86 ec       	ldi	r24, 0xC6	; 198
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	90 93 00 0a 	sts	0x0A00, r25
    2f60:	80 93 ff 09 	sts	0x09FF, r24
    2f64:	10 92 02 0a 	sts	0x0A02, r1
    2f68:	10 92 03 0a 	sts	0x0A03, r1
    2f6c:	10 92 04 0a 	sts	0x0A04, r1
    2f70:	10 92 05 0a 	sts	0x0A05, r1
    2f74:	08 95       	ret

00002f76 <_ZN5Print5writeEPKhj>:
size_t Print::println(long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    2f76:	cf 92       	push	r12
    2f78:	df 92       	push	r13
    2f7a:	ef 92       	push	r14
    2f7c:	ff 92       	push	r15
    2f7e:	0f 93       	push	r16
    2f80:	1f 93       	push	r17
    2f82:	cf 93       	push	r28
    2f84:	df 93       	push	r29
    2f86:	6c 01       	movw	r12, r24
    2f88:	41 15       	cp	r20, r1
    2f8a:	51 05       	cpc	r21, r1
    2f8c:	b1 f0       	breq	.+44     	; 0x2fba <_ZN5Print5writeEPKhj+0x44>
    2f8e:	06 2f       	mov	r16, r22
    2f90:	17 2f       	mov	r17, r23
    2f92:	ea 01       	movw	r28, r20
    2f94:	e1 2c       	mov	r14, r1
    2f96:	f1 2c       	mov	r15, r1
    2f98:	d8 01       	movw	r26, r16
    2f9a:	6d 91       	ld	r22, X+
    2f9c:	8d 01       	movw	r16, r26
    2f9e:	d6 01       	movw	r26, r12
    2fa0:	ed 91       	ld	r30, X+
    2fa2:	fc 91       	ld	r31, X
    2fa4:	01 90       	ld	r0, Z+
    2fa6:	f0 81       	ld	r31, Z
    2fa8:	e0 2d       	mov	r30, r0
    2faa:	c6 01       	movw	r24, r12
    2fac:	19 95       	eicall
    2fae:	e8 0e       	add	r14, r24
    2fb0:	f9 1e       	adc	r15, r25
    2fb2:	21 97       	sbiw	r28, 0x01	; 1
    2fb4:	20 97       	sbiw	r28, 0x00	; 0
    2fb6:	81 f7       	brne	.-32     	; 0x2f98 <_ZN5Print5writeEPKhj+0x22>
    2fb8:	02 c0       	rjmp	.+4      	; 0x2fbe <_ZN5Print5writeEPKhj+0x48>
    2fba:	e1 2c       	mov	r14, r1
    2fbc:	f1 2c       	mov	r15, r1
    2fbe:	c7 01       	movw	r24, r14
    2fc0:	df 91       	pop	r29
    2fc2:	cf 91       	pop	r28
    2fc4:	1f 91       	pop	r17
    2fc6:	0f 91       	pop	r16
    2fc8:	ff 90       	pop	r15
    2fca:	ef 90       	pop	r14
    2fcc:	df 90       	pop	r13
    2fce:	cf 90       	pop	r12
    2fd0:	08 95       	ret

00002fd2 <_ZN5Print5printEc>:
    2fd2:	dc 01       	movw	r26, r24
    2fd4:	ed 91       	ld	r30, X+
    2fd6:	fc 91       	ld	r31, X
    2fd8:	01 90       	ld	r0, Z+
    2fda:	f0 81       	ld	r31, Z
    2fdc:	e0 2d       	mov	r30, r0
    2fde:	19 95       	eicall
    2fe0:	08 95       	ret

00002fe2 <_ZN5Print7printlnEv>:
    2fe2:	dc 01       	movw	r26, r24
    2fe4:	ed 91       	ld	r30, X+
    2fe6:	fc 91       	ld	r31, X
    2fe8:	02 80       	ldd	r0, Z+2	; 0x02
    2fea:	f3 81       	ldd	r31, Z+3	; 0x03
    2fec:	e0 2d       	mov	r30, r0
    2fee:	42 e0       	ldi	r20, 0x02	; 2
    2ff0:	50 e0       	ldi	r21, 0x00	; 0
    2ff2:	6d e8       	ldi	r22, 0x8D	; 141
    2ff4:	72 e0       	ldi	r23, 0x02	; 2
    2ff6:	19 95       	eicall
    2ff8:	08 95       	ret

00002ffa <_ZN5Print11printNumberEmh>:
    2ffa:	6f 92       	push	r6
    2ffc:	7f 92       	push	r7
    2ffe:	8f 92       	push	r8
    3000:	9f 92       	push	r9
    3002:	af 92       	push	r10
    3004:	bf 92       	push	r11
    3006:	cf 92       	push	r12
    3008:	df 92       	push	r13
    300a:	ef 92       	push	r14
    300c:	ff 92       	push	r15
    300e:	0f 93       	push	r16
    3010:	1f 93       	push	r17
    3012:	cf 93       	push	r28
    3014:	df 93       	push	r29
    3016:	cd b7       	in	r28, 0x3d	; 61
    3018:	de b7       	in	r29, 0x3e	; 62
    301a:	a1 97       	sbiw	r28, 0x21	; 33
    301c:	0f b6       	in	r0, 0x3f	; 63
    301e:	f8 94       	cli
    3020:	de bf       	out	0x3e, r29	; 62
    3022:	0f be       	out	0x3f, r0	; 63
    3024:	cd bf       	out	0x3d, r28	; 61
    3026:	6c 01       	movw	r12, r24
    3028:	74 2e       	mov	r7, r20
    302a:	35 2f       	mov	r19, r21
    302c:	86 2f       	mov	r24, r22
    302e:	97 2f       	mov	r25, r23
    3030:	62 2e       	mov	r6, r18
    3032:	19 a2       	std	Y+33, r1	; 0x21
    3034:	21 e0       	ldi	r18, 0x01	; 1
    3036:	26 15       	cp	r18, r6
    3038:	20 f0       	brcs	.+8      	; 0x3042 <_ZN5Print11printNumberEmh+0x48>
    303a:	0f 2e       	mov	r0, r31
    303c:	fa e0       	ldi	r31, 0x0A	; 10
    303e:	6f 2e       	mov	r6, r31
    3040:	f0 2d       	mov	r31, r0
    3042:	7e 01       	movw	r14, r28
    3044:	a1 e2       	ldi	r26, 0x21	; 33
    3046:	ea 0e       	add	r14, r26
    3048:	f1 1c       	adc	r15, r1
    304a:	86 2c       	mov	r8, r6
    304c:	91 2c       	mov	r9, r1
    304e:	a1 2c       	mov	r10, r1
    3050:	b1 2c       	mov	r11, r1
    3052:	67 2d       	mov	r22, r7
    3054:	73 2f       	mov	r23, r19
    3056:	a5 01       	movw	r20, r10
    3058:	94 01       	movw	r18, r8
    305a:	e5 d2       	rcall	.+1482   	; 0x3626 <__udivmodsi4>
    305c:	e2 2f       	mov	r30, r18
    305e:	73 2f       	mov	r23, r19
    3060:	02 2f       	mov	r16, r18
    3062:	13 2f       	mov	r17, r19
    3064:	24 2f       	mov	r18, r20
    3066:	35 2f       	mov	r19, r21
    3068:	f7 2d       	mov	r31, r7
    306a:	6e 9e       	mul	r6, r30
    306c:	f0 19       	sub	r31, r0
    306e:	11 24       	eor	r1, r1
    3070:	b1 e0       	ldi	r27, 0x01	; 1
    3072:	eb 1a       	sub	r14, r27
    3074:	f1 08       	sbc	r15, r1
    3076:	fa 30       	cpi	r31, 0x0A	; 10
    3078:	10 f4       	brcc	.+4      	; 0x307e <_ZN5Print11printNumberEmh+0x84>
    307a:	f0 5d       	subi	r31, 0xD0	; 208
    307c:	01 c0       	rjmp	.+2      	; 0x3080 <_ZN5Print11printNumberEmh+0x86>
    307e:	f9 5c       	subi	r31, 0xC9	; 201
    3080:	d7 01       	movw	r26, r14
    3082:	fc 93       	st	X, r31
    3084:	01 2b       	or	r16, r17
    3086:	02 2b       	or	r16, r18
    3088:	03 2b       	or	r16, r19
    308a:	29 f0       	breq	.+10     	; 0x3096 <_ZN5Print11printNumberEmh+0x9c>
    308c:	7e 2e       	mov	r7, r30
    308e:	37 2f       	mov	r19, r23
    3090:	84 2f       	mov	r24, r20
    3092:	95 2f       	mov	r25, r21
    3094:	de cf       	rjmp	.-68     	; 0x3052 <_ZN5Print11printNumberEmh+0x58>
    3096:	e1 14       	cp	r14, r1
    3098:	f1 04       	cpc	r15, r1
    309a:	91 f0       	breq	.+36     	; 0x30c0 <_ZN5Print11printNumberEmh+0xc6>
    309c:	f7 01       	movw	r30, r14
    309e:	01 90       	ld	r0, Z+
    30a0:	00 20       	and	r0, r0
    30a2:	e9 f7       	brne	.-6      	; 0x309e <_ZN5Print11printNumberEmh+0xa4>
    30a4:	31 97       	sbiw	r30, 0x01	; 1
    30a6:	af 01       	movw	r20, r30
    30a8:	4e 19       	sub	r20, r14
    30aa:	5f 09       	sbc	r21, r15
    30ac:	d6 01       	movw	r26, r12
    30ae:	ed 91       	ld	r30, X+
    30b0:	fc 91       	ld	r31, X
    30b2:	02 80       	ldd	r0, Z+2	; 0x02
    30b4:	f3 81       	ldd	r31, Z+3	; 0x03
    30b6:	e0 2d       	mov	r30, r0
    30b8:	b7 01       	movw	r22, r14
    30ba:	c6 01       	movw	r24, r12
    30bc:	19 95       	eicall
    30be:	02 c0       	rjmp	.+4      	; 0x30c4 <_ZN5Print11printNumberEmh+0xca>
    30c0:	80 e0       	ldi	r24, 0x00	; 0
    30c2:	90 e0       	ldi	r25, 0x00	; 0
    30c4:	a1 96       	adiw	r28, 0x21	; 33
    30c6:	0f b6       	in	r0, 0x3f	; 63
    30c8:	f8 94       	cli
    30ca:	de bf       	out	0x3e, r29	; 62
    30cc:	0f be       	out	0x3f, r0	; 63
    30ce:	cd bf       	out	0x3d, r28	; 61
    30d0:	df 91       	pop	r29
    30d2:	cf 91       	pop	r28
    30d4:	1f 91       	pop	r17
    30d6:	0f 91       	pop	r16
    30d8:	ff 90       	pop	r15
    30da:	ef 90       	pop	r14
    30dc:	df 90       	pop	r13
    30de:	cf 90       	pop	r12
    30e0:	bf 90       	pop	r11
    30e2:	af 90       	pop	r10
    30e4:	9f 90       	pop	r9
    30e6:	8f 90       	pop	r8
    30e8:	7f 90       	pop	r7
    30ea:	6f 90       	pop	r6
    30ec:	08 95       	ret

000030ee <_ZN5Print5printEli>:
    30ee:	cf 92       	push	r12
    30f0:	df 92       	push	r13
    30f2:	ef 92       	push	r14
    30f4:	ff 92       	push	r15
    30f6:	0f 93       	push	r16
    30f8:	1f 93       	push	r17
    30fa:	cf 93       	push	r28
    30fc:	df 93       	push	r29
    30fe:	ec 01       	movw	r28, r24
    3100:	6a 01       	movw	r12, r20
    3102:	7b 01       	movw	r14, r22
    3104:	21 15       	cp	r18, r1
    3106:	31 05       	cpc	r19, r1
    3108:	41 f4       	brne	.+16     	; 0x311a <_ZN5Print5printEli+0x2c>
    310a:	e8 81       	ld	r30, Y
    310c:	f9 81       	ldd	r31, Y+1	; 0x01
    310e:	01 90       	ld	r0, Z+
    3110:	f0 81       	ld	r31, Z
    3112:	e0 2d       	mov	r30, r0
    3114:	64 2f       	mov	r22, r20
    3116:	19 95       	eicall
    3118:	19 c0       	rjmp	.+50     	; 0x314c <_ZN5Print5printEli+0x5e>
    311a:	2a 30       	cpi	r18, 0x0A	; 10
    311c:	31 05       	cpc	r19, r1
    311e:	a9 f4       	brne	.+42     	; 0x314a <_ZN5Print5printEli+0x5c>
    3120:	77 23       	and	r23, r23
    3122:	84 f4       	brge	.+32     	; 0x3144 <_ZN5Print5printEli+0x56>
    3124:	6d e2       	ldi	r22, 0x2D	; 45
    3126:	55 df       	rcall	.-342    	; 0x2fd2 <_ZN5Print5printEc>
    3128:	8c 01       	movw	r16, r24
    312a:	44 27       	eor	r20, r20
    312c:	55 27       	eor	r21, r21
    312e:	ba 01       	movw	r22, r20
    3130:	4c 19       	sub	r20, r12
    3132:	5d 09       	sbc	r21, r13
    3134:	6e 09       	sbc	r22, r14
    3136:	7f 09       	sbc	r23, r15
    3138:	2a e0       	ldi	r18, 0x0A	; 10
    313a:	ce 01       	movw	r24, r28
    313c:	5e df       	rcall	.-324    	; 0x2ffa <_ZN5Print11printNumberEmh>
    313e:	80 0f       	add	r24, r16
    3140:	91 1f       	adc	r25, r17
    3142:	04 c0       	rjmp	.+8      	; 0x314c <_ZN5Print5printEli+0x5e>
    3144:	2a e0       	ldi	r18, 0x0A	; 10
    3146:	59 df       	rcall	.-334    	; 0x2ffa <_ZN5Print11printNumberEmh>
    3148:	01 c0       	rjmp	.+2      	; 0x314c <_ZN5Print5printEli+0x5e>
    314a:	57 df       	rcall	.-338    	; 0x2ffa <_ZN5Print11printNumberEmh>
    314c:	df 91       	pop	r29
    314e:	cf 91       	pop	r28
    3150:	1f 91       	pop	r17
    3152:	0f 91       	pop	r16
    3154:	ff 90       	pop	r15
    3156:	ef 90       	pop	r14
    3158:	df 90       	pop	r13
    315a:	cf 90       	pop	r12
    315c:	08 95       	ret

0000315e <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    315e:	0f 93       	push	r16
    3160:	1f 93       	push	r17
    3162:	cf 93       	push	r28
    3164:	df 93       	push	r29
    3166:	ec 01       	movw	r28, r24
    3168:	9a 01       	movw	r18, r20
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
    316a:	ab 01       	movw	r20, r22
    316c:	66 27       	eor	r22, r22
    316e:	57 fd       	sbrc	r21, 7
    3170:	60 95       	com	r22
    3172:	76 2f       	mov	r23, r22
    3174:	bc df       	rcall	.-136    	; 0x30ee <_ZN5Print5printEli>
    3176:	8c 01       	movw	r16, r24
}

size_t Print::println(int num, int base)
{
  size_t n = print(num, base);
  n += println();
    3178:	ce 01       	movw	r24, r28
    317a:	33 df       	rcall	.-410    	; 0x2fe2 <_ZN5Print7printlnEv>
  return n;
}
    317c:	80 0f       	add	r24, r16
    317e:	91 1f       	adc	r25, r17
    3180:	df 91       	pop	r29
    3182:	cf 91       	pop	r28
    3184:	1f 91       	pop	r17
    3186:	0f 91       	pop	r16
    3188:	08 95       	ret

0000318a <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    318a:	1f 92       	push	r1
    318c:	0f 92       	push	r0
    318e:	0f b6       	in	r0, 0x3f	; 63
    3190:	0f 92       	push	r0
    3192:	11 24       	eor	r1, r1
    3194:	2f 93       	push	r18
    3196:	3f 93       	push	r19
    3198:	8f 93       	push	r24
    319a:	9f 93       	push	r25
    319c:	af 93       	push	r26
    319e:	bf 93       	push	r27
    31a0:	80 91 87 0a 	lds	r24, 0x0A87
    31a4:	90 91 88 0a 	lds	r25, 0x0A88
    31a8:	a0 91 89 0a 	lds	r26, 0x0A89
    31ac:	b0 91 8a 0a 	lds	r27, 0x0A8A
    31b0:	30 91 86 0a 	lds	r19, 0x0A86
    31b4:	23 e0       	ldi	r18, 0x03	; 3
    31b6:	23 0f       	add	r18, r19
    31b8:	2d 37       	cpi	r18, 0x7D	; 125
    31ba:	20 f4       	brcc	.+8      	; 0x31c4 <__vector_23+0x3a>
    31bc:	01 96       	adiw	r24, 0x01	; 1
    31be:	a1 1d       	adc	r26, r1
    31c0:	b1 1d       	adc	r27, r1
    31c2:	05 c0       	rjmp	.+10     	; 0x31ce <__vector_23+0x44>
    31c4:	26 e8       	ldi	r18, 0x86	; 134
    31c6:	23 0f       	add	r18, r19
    31c8:	02 96       	adiw	r24, 0x02	; 2
    31ca:	a1 1d       	adc	r26, r1
    31cc:	b1 1d       	adc	r27, r1
    31ce:	20 93 86 0a 	sts	0x0A86, r18
    31d2:	80 93 87 0a 	sts	0x0A87, r24
    31d6:	90 93 88 0a 	sts	0x0A88, r25
    31da:	a0 93 89 0a 	sts	0x0A89, r26
    31de:	b0 93 8a 0a 	sts	0x0A8A, r27
    31e2:	80 91 8b 0a 	lds	r24, 0x0A8B
    31e6:	90 91 8c 0a 	lds	r25, 0x0A8C
    31ea:	a0 91 8d 0a 	lds	r26, 0x0A8D
    31ee:	b0 91 8e 0a 	lds	r27, 0x0A8E
    31f2:	01 96       	adiw	r24, 0x01	; 1
    31f4:	a1 1d       	adc	r26, r1
    31f6:	b1 1d       	adc	r27, r1
    31f8:	80 93 8b 0a 	sts	0x0A8B, r24
    31fc:	90 93 8c 0a 	sts	0x0A8C, r25
    3200:	a0 93 8d 0a 	sts	0x0A8D, r26
    3204:	b0 93 8e 0a 	sts	0x0A8E, r27
    3208:	bf 91       	pop	r27
    320a:	af 91       	pop	r26
    320c:	9f 91       	pop	r25
    320e:	8f 91       	pop	r24
    3210:	3f 91       	pop	r19
    3212:	2f 91       	pop	r18
    3214:	0f 90       	pop	r0
    3216:	0f be       	out	0x3f, r0	; 63
    3218:	0f 90       	pop	r0
    321a:	1f 90       	pop	r1
    321c:	18 95       	reti

0000321e <millis>:
    321e:	2f b7       	in	r18, 0x3f	; 63
    3220:	f8 94       	cli
    3222:	60 91 87 0a 	lds	r22, 0x0A87
    3226:	70 91 88 0a 	lds	r23, 0x0A88
    322a:	80 91 89 0a 	lds	r24, 0x0A89
    322e:	90 91 8a 0a 	lds	r25, 0x0A8A
    3232:	2f bf       	out	0x3f, r18	; 63
    3234:	08 95       	ret

00003236 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    3236:	82 30       	cpi	r24, 0x02	; 2
    3238:	91 05       	cpc	r25, r1
    323a:	38 f0       	brcs	.+14     	; 0x324a <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    323c:	88 0f       	add	r24, r24
    323e:	99 1f       	adc	r25, r25
    3240:	88 0f       	add	r24, r24
    3242:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    3244:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    3246:	01 97       	sbiw	r24, 0x01	; 1
    3248:	f1 f7       	brne	.-4      	; 0x3246 <delayMicroseconds+0x10>
    324a:	08 95       	ret

0000324c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    324c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    324e:	84 b5       	in	r24, 0x24	; 36
    3250:	82 60       	ori	r24, 0x02	; 2
    3252:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    3254:	84 b5       	in	r24, 0x24	; 36
    3256:	81 60       	ori	r24, 0x01	; 1
    3258:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    325a:	85 b5       	in	r24, 0x25	; 37
    325c:	82 60       	ori	r24, 0x02	; 2
    325e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    3260:	85 b5       	in	r24, 0x25	; 37
    3262:	81 60       	ori	r24, 0x01	; 1
    3264:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    3266:	ee e6       	ldi	r30, 0x6E	; 110
    3268:	f0 e0       	ldi	r31, 0x00	; 0
    326a:	80 81       	ld	r24, Z
    326c:	81 60       	ori	r24, 0x01	; 1
    326e:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    3270:	e1 e8       	ldi	r30, 0x81	; 129
    3272:	f0 e0       	ldi	r31, 0x00	; 0
    3274:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    3276:	80 81       	ld	r24, Z
    3278:	82 60       	ori	r24, 0x02	; 2
    327a:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    327c:	80 81       	ld	r24, Z
    327e:	81 60       	ori	r24, 0x01	; 1
    3280:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    3282:	e0 e8       	ldi	r30, 0x80	; 128
    3284:	f0 e0       	ldi	r31, 0x00	; 0
    3286:	80 81       	ld	r24, Z
    3288:	81 60       	ori	r24, 0x01	; 1
    328a:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    328c:	e1 eb       	ldi	r30, 0xB1	; 177
    328e:	f0 e0       	ldi	r31, 0x00	; 0
    3290:	80 81       	ld	r24, Z
    3292:	84 60       	ori	r24, 0x04	; 4
    3294:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    3296:	e0 eb       	ldi	r30, 0xB0	; 176
    3298:	f0 e0       	ldi	r31, 0x00	; 0
    329a:	80 81       	ld	r24, Z
    329c:	81 60       	ori	r24, 0x01	; 1
    329e:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    32a0:	e1 e9       	ldi	r30, 0x91	; 145
    32a2:	f0 e0       	ldi	r31, 0x00	; 0
    32a4:	80 81       	ld	r24, Z
    32a6:	82 60       	ori	r24, 0x02	; 2
    32a8:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    32aa:	80 81       	ld	r24, Z
    32ac:	81 60       	ori	r24, 0x01	; 1
    32ae:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    32b0:	e0 e9       	ldi	r30, 0x90	; 144
    32b2:	f0 e0       	ldi	r31, 0x00	; 0
    32b4:	80 81       	ld	r24, Z
    32b6:	81 60       	ori	r24, 0x01	; 1
    32b8:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    32ba:	e1 ea       	ldi	r30, 0xA1	; 161
    32bc:	f0 e0       	ldi	r31, 0x00	; 0
    32be:	80 81       	ld	r24, Z
    32c0:	82 60       	ori	r24, 0x02	; 2
    32c2:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    32c4:	80 81       	ld	r24, Z
    32c6:	81 60       	ori	r24, 0x01	; 1
    32c8:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    32ca:	e0 ea       	ldi	r30, 0xA0	; 160
    32cc:	f0 e0       	ldi	r31, 0x00	; 0
    32ce:	80 81       	ld	r24, Z
    32d0:	81 60       	ori	r24, 0x01	; 1
    32d2:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    32d4:	e1 e2       	ldi	r30, 0x21	; 33
    32d6:	f1 e0       	ldi	r31, 0x01	; 1
    32d8:	80 81       	ld	r24, Z
    32da:	82 60       	ori	r24, 0x02	; 2
    32dc:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    32de:	80 81       	ld	r24, Z
    32e0:	81 60       	ori	r24, 0x01	; 1
    32e2:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    32e4:	e0 e2       	ldi	r30, 0x20	; 32
    32e6:	f1 e0       	ldi	r31, 0x01	; 1
    32e8:	80 81       	ld	r24, Z
    32ea:	81 60       	ori	r24, 0x01	; 1
    32ec:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    32ee:	ea e7       	ldi	r30, 0x7A	; 122
    32f0:	f0 e0       	ldi	r31, 0x00	; 0
    32f2:	80 81       	ld	r24, Z
    32f4:	84 60       	ori	r24, 0x04	; 4
    32f6:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    32f8:	80 81       	ld	r24, Z
    32fa:	82 60       	ori	r24, 0x02	; 2
    32fc:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    32fe:	80 81       	ld	r24, Z
    3300:	81 60       	ori	r24, 0x01	; 1
    3302:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    3304:	80 81       	ld	r24, Z
    3306:	80 68       	ori	r24, 0x80	; 128
    3308:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    330a:	10 92 c1 00 	sts	0x00C1, r1
    330e:	08 95       	ret

00003310 <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
    3310:	80 93 08 02 	sts	0x0208, r24
    3314:	08 95       	ret

00003316 <analogRead>:
#if defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#endif
	pin = analogPinToChannel(pin);
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
    3316:	86 33       	cpi	r24, 0x36	; 54
    3318:	08 f0       	brcs	.+2      	; 0x331c <analogRead+0x6>
    331a:	86 53       	subi	r24, 0x36	; 54
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
    331c:	eb e7       	ldi	r30, 0x7B	; 123
    331e:	f0 e0       	ldi	r31, 0x00	; 0
    3320:	90 81       	ld	r25, Z
    3322:	28 2f       	mov	r18, r24
    3324:	28 70       	andi	r18, 0x08	; 8
    3326:	97 7f       	andi	r25, 0xF7	; 247
    3328:	92 2b       	or	r25, r18
    332a:	90 83       	st	Z, r25
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    332c:	87 70       	andi	r24, 0x07	; 7
    332e:	20 91 08 02 	lds	r18, 0x0208
    3332:	90 e4       	ldi	r25, 0x40	; 64
    3334:	29 9f       	mul	r18, r25
    3336:	90 01       	movw	r18, r0
    3338:	11 24       	eor	r1, r1
    333a:	28 2b       	or	r18, r24
    333c:	20 93 7c 00 	sts	0x007C, r18
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    3340:	ea e7       	ldi	r30, 0x7A	; 122
    3342:	f0 e0       	ldi	r31, 0x00	; 0
    3344:	80 81       	ld	r24, Z
    3346:	80 64       	ori	r24, 0x40	; 64
    3348:	80 83       	st	Z, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    334a:	80 81       	ld	r24, Z
    334c:	86 fd       	sbrc	r24, 6
    334e:	fd cf       	rjmp	.-6      	; 0x334a <analogRead+0x34>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    3350:	80 91 78 00 	lds	r24, 0x0078
	high = ADCH;
    3354:	20 91 79 00 	lds	r18, 0x0079
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    3358:	90 e0       	ldi	r25, 0x00	; 0
}
    335a:	92 2b       	or	r25, r18
    335c:	08 95       	ret

0000335e <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	fc 01       	movw	r30, r24
    3362:	31 97       	sbiw	r30, 0x01	; 1
    3364:	e2 31       	cpi	r30, 0x12	; 18
    3366:	f1 05       	cpc	r31, r1
    3368:	08 f0       	brcs	.+2      	; 0x336c <turnOffPWM+0xe>
    336a:	5e c0       	rjmp	.+188    	; 0x3428 <turnOffPWM+0xca>
    336c:	e4 58       	subi	r30, 0x84	; 132
    336e:	fe 4f       	sbci	r31, 0xFE	; 254
    3370:	98 c1       	rjmp	.+816    	; 0x36a2 <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    3372:	e0 e8       	ldi	r30, 0x80	; 128
    3374:	f0 e0       	ldi	r31, 0x00	; 0
    3376:	80 81       	ld	r24, Z
    3378:	8f 77       	andi	r24, 0x7F	; 127
    337a:	80 83       	st	Z, r24
    337c:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    337e:	e0 e8       	ldi	r30, 0x80	; 128
    3380:	f0 e0       	ldi	r31, 0x00	; 0
    3382:	80 81       	ld	r24, Z
    3384:	8f 7d       	andi	r24, 0xDF	; 223
    3386:	80 83       	st	Z, r24
    3388:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    338a:	e0 e8       	ldi	r30, 0x80	; 128
    338c:	f0 e0       	ldi	r31, 0x00	; 0
    338e:	80 81       	ld	r24, Z
    3390:	87 7f       	andi	r24, 0xF7	; 247
    3392:	80 83       	st	Z, r24
    3394:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    3396:	84 b5       	in	r24, 0x24	; 36
    3398:	8f 77       	andi	r24, 0x7F	; 127
    339a:	84 bd       	out	0x24, r24	; 36
    339c:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    339e:	84 b5       	in	r24, 0x24	; 36
    33a0:	8f 7d       	andi	r24, 0xDF	; 223
    33a2:	84 bd       	out	0x24, r24	; 36
    33a4:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    33a6:	e0 eb       	ldi	r30, 0xB0	; 176
    33a8:	f0 e0       	ldi	r31, 0x00	; 0
    33aa:	80 81       	ld	r24, Z
    33ac:	8f 77       	andi	r24, 0x7F	; 127
    33ae:	80 83       	st	Z, r24
    33b0:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    33b2:	e0 eb       	ldi	r30, 0xB0	; 176
    33b4:	f0 e0       	ldi	r31, 0x00	; 0
    33b6:	80 81       	ld	r24, Z
    33b8:	8f 7d       	andi	r24, 0xDF	; 223
    33ba:	80 83       	st	Z, r24
    33bc:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    33be:	e0 e9       	ldi	r30, 0x90	; 144
    33c0:	f0 e0       	ldi	r31, 0x00	; 0
    33c2:	80 81       	ld	r24, Z
    33c4:	8f 77       	andi	r24, 0x7F	; 127
    33c6:	80 83       	st	Z, r24
    33c8:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    33ca:	e0 e9       	ldi	r30, 0x90	; 144
    33cc:	f0 e0       	ldi	r31, 0x00	; 0
    33ce:	80 81       	ld	r24, Z
    33d0:	8f 7d       	andi	r24, 0xDF	; 223
    33d2:	80 83       	st	Z, r24
    33d4:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    33d6:	e0 e9       	ldi	r30, 0x90	; 144
    33d8:	f0 e0       	ldi	r31, 0x00	; 0
    33da:	80 81       	ld	r24, Z
    33dc:	87 7f       	andi	r24, 0xF7	; 247
    33de:	80 83       	st	Z, r24
    33e0:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    33e2:	e0 ea       	ldi	r30, 0xA0	; 160
    33e4:	f0 e0       	ldi	r31, 0x00	; 0
    33e6:	80 81       	ld	r24, Z
    33e8:	8f 77       	andi	r24, 0x7F	; 127
    33ea:	80 83       	st	Z, r24
    33ec:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    33ee:	e0 ea       	ldi	r30, 0xA0	; 160
    33f0:	f0 e0       	ldi	r31, 0x00	; 0
    33f2:	80 81       	ld	r24, Z
    33f4:	8f 7d       	andi	r24, 0xDF	; 223
    33f6:	80 83       	st	Z, r24
    33f8:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    33fa:	e0 ea       	ldi	r30, 0xA0	; 160
    33fc:	f0 e0       	ldi	r31, 0x00	; 0
    33fe:	80 81       	ld	r24, Z
    3400:	87 7f       	andi	r24, 0xF7	; 247
    3402:	80 83       	st	Z, r24
    3404:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3406:	e0 e2       	ldi	r30, 0x20	; 32
    3408:	f1 e0       	ldi	r31, 0x01	; 1
    340a:	80 81       	ld	r24, Z
    340c:	8f 77       	andi	r24, 0x7F	; 127
    340e:	80 83       	st	Z, r24
    3410:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    3412:	e0 e2       	ldi	r30, 0x20	; 32
    3414:	f1 e0       	ldi	r31, 0x01	; 1
    3416:	80 81       	ld	r24, Z
    3418:	8f 7d       	andi	r24, 0xDF	; 223
    341a:	80 83       	st	Z, r24
    341c:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    341e:	e0 e2       	ldi	r30, 0x20	; 32
    3420:	f1 e0       	ldi	r31, 0x01	; 1
    3422:	80 81       	ld	r24, Z
    3424:	87 7f       	andi	r24, 0xF7	; 247
    3426:	80 83       	st	Z, r24
    3428:	08 95       	ret

0000342a <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    342a:	cf 93       	push	r28
    342c:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    342e:	90 e0       	ldi	r25, 0x00	; 0
    3430:	fc 01       	movw	r30, r24
    3432:	ee 59       	subi	r30, 0x9E	; 158
    3434:	fc 4f       	sbci	r31, 0xFC	; 252
    3436:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    3438:	fc 01       	movw	r30, r24
    343a:	e8 55       	subi	r30, 0x58	; 88
    343c:	fc 4f       	sbci	r31, 0xFC	; 252
    343e:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    3440:	88 23       	and	r24, r24
    3442:	71 f1       	breq	.+92     	; 0x34a0 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3444:	90 e0       	ldi	r25, 0x00	; 0
    3446:	88 0f       	add	r24, r24
    3448:	99 1f       	adc	r25, r25
    344a:	fc 01       	movw	r30, r24
    344c:	ee 5d       	subi	r30, 0xDE	; 222
    344e:	fb 4f       	sbci	r31, 0xFB	; 251
    3450:	a5 91       	lpm	r26, Z+
    3452:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    3454:	88 5f       	subi	r24, 0xF8	; 248
    3456:	9b 4f       	sbci	r25, 0xFB	; 251
    3458:	fc 01       	movw	r30, r24
    345a:	c5 91       	lpm	r28, Z+
    345c:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    345e:	61 11       	cpse	r22, r1
    3460:	0b c0       	rjmp	.+22     	; 0x3478 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    3462:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3464:	f8 94       	cli
		*reg &= ~bit;
    3466:	9c 91       	ld	r25, X
    3468:	20 95       	com	r18
    346a:	92 23       	and	r25, r18
    346c:	9c 93       	st	X, r25
		*out &= ~bit;
    346e:	e8 81       	ld	r30, Y
    3470:	2e 23       	and	r18, r30
    3472:	28 83       	st	Y, r18
		SREG = oldSREG;
    3474:	8f bf       	out	0x3f, r24	; 63
    3476:	14 c0       	rjmp	.+40     	; 0x34a0 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    3478:	62 30       	cpi	r22, 0x02	; 2
    347a:	61 f4       	brne	.+24     	; 0x3494 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    347c:	8f b7       	in	r24, 0x3f	; 63
                cli();
    347e:	f8 94       	cli
		*reg &= ~bit;
    3480:	3c 91       	ld	r19, X
    3482:	92 2f       	mov	r25, r18
    3484:	90 95       	com	r25
    3486:	93 23       	and	r25, r19
    3488:	9c 93       	st	X, r25
		*out |= bit;
    348a:	e8 81       	ld	r30, Y
    348c:	2e 2b       	or	r18, r30
    348e:	28 83       	st	Y, r18
		SREG = oldSREG;
    3490:	8f bf       	out	0x3f, r24	; 63
    3492:	06 c0       	rjmp	.+12     	; 0x34a0 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    3494:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3496:	f8 94       	cli
		*reg |= bit;
    3498:	ec 91       	ld	r30, X
    349a:	2e 2b       	or	r18, r30
    349c:	2c 93       	st	X, r18
		SREG = oldSREG;
    349e:	8f bf       	out	0x3f, r24	; 63
	}
}
    34a0:	df 91       	pop	r29
    34a2:	cf 91       	pop	r28
    34a4:	08 95       	ret

000034a6 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    34a6:	1f 93       	push	r17
    34a8:	cf 93       	push	r28
    34aa:	df 93       	push	r29
    34ac:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    34ae:	28 2f       	mov	r18, r24
    34b0:	30 e0       	ldi	r19, 0x00	; 0
    34b2:	f9 01       	movw	r30, r18
    34b4:	e4 5e       	subi	r30, 0xE4	; 228
    34b6:	fc 4f       	sbci	r31, 0xFC	; 252
    34b8:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    34ba:	f9 01       	movw	r30, r18
    34bc:	ee 59       	subi	r30, 0x9E	; 158
    34be:	fc 4f       	sbci	r31, 0xFC	; 252
    34c0:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    34c2:	f9 01       	movw	r30, r18
    34c4:	e8 55       	subi	r30, 0x58	; 88
    34c6:	fc 4f       	sbci	r31, 0xFC	; 252
    34c8:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    34ca:	dd 23       	and	r29, r29
    34cc:	c1 f0       	breq	.+48     	; 0x34fe <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    34ce:	81 11       	cpse	r24, r1
    34d0:	46 df       	rcall	.-372    	; 0x335e <turnOffPWM>

	out = portOutputRegister(port);
    34d2:	2d 2f       	mov	r18, r29
    34d4:	30 e0       	ldi	r19, 0x00	; 0
    34d6:	f9 01       	movw	r30, r18
    34d8:	ee 0f       	add	r30, r30
    34da:	ff 1f       	adc	r31, r31
    34dc:	e8 5f       	subi	r30, 0xF8	; 248
    34de:	fb 4f       	sbci	r31, 0xFB	; 251
    34e0:	a5 91       	lpm	r26, Z+
    34e2:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    34e4:	8f b7       	in	r24, 0x3f	; 63
	cli();
    34e6:	f8 94       	cli

	if (val == LOW) {
    34e8:	c1 11       	cpse	r28, r1
    34ea:	05 c0       	rjmp	.+10     	; 0x34f6 <digitalWrite+0x50>
		*out &= ~bit;
    34ec:	ec 91       	ld	r30, X
    34ee:	10 95       	com	r17
    34f0:	1e 23       	and	r17, r30
    34f2:	1c 93       	st	X, r17
    34f4:	03 c0       	rjmp	.+6      	; 0x34fc <digitalWrite+0x56>
	} else {
		*out |= bit;
    34f6:	ec 91       	ld	r30, X
    34f8:	1e 2b       	or	r17, r30
    34fa:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    34fc:	8f bf       	out	0x3f, r24	; 63
}
    34fe:	df 91       	pop	r29
    3500:	cf 91       	pop	r28
    3502:	1f 91       	pop	r17
    3504:	08 95       	ret

00003506 <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3506:	0f 93       	push	r16
    3508:	1f 93       	push	r17
    350a:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    350c:	90 e0       	ldi	r25, 0x00	; 0
    350e:	fc 01       	movw	r30, r24
    3510:	ee 59       	subi	r30, 0x9E	; 158
    3512:	fc 4f       	sbci	r31, 0xFC	; 252
    3514:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    3516:	fc 01       	movw	r30, r24
    3518:	e8 55       	subi	r30, 0x58	; 88
    351a:	fc 4f       	sbci	r31, 0xFC	; 252
    351c:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    351e:	71 11       	cpse	r23, r1
    3520:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3522:	f0 e0       	ldi	r31, 0x00	; 0
    3524:	ee 0f       	add	r30, r30
    3526:	ff 1f       	adc	r31, r31
    3528:	e2 51       	subi	r30, 0x12	; 18
    352a:	fc 4f       	sbci	r31, 0xFC	; 252
    352c:	85 91       	lpm	r24, Z+
    352e:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    3530:	89 01       	movw	r16, r18
    3532:	9a 01       	movw	r18, r20
    3534:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3536:	47 2f       	mov	r20, r23
    3538:	0e 94 53 02 	call	0x4a6	; 0x4a6 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    353c:	61 15       	cp	r22, r1
    353e:	71 05       	cpc	r23, r1
    3540:	81 05       	cpc	r24, r1
    3542:	91 05       	cpc	r25, r1
    3544:	49 f0       	breq	.+18     	; 0x3558 <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    3546:	dc 01       	movw	r26, r24
    3548:	cb 01       	movw	r24, r22
    354a:	01 96       	adiw	r24, 0x01	; 1
    354c:	a1 1d       	adc	r26, r1
    354e:	b1 1d       	adc	r27, r1
    3550:	bc 01       	movw	r22, r24
    3552:	cd 01       	movw	r24, r26
    3554:	9f 70       	andi	r25, 0x0F	; 15
    3556:	03 c0       	rjmp	.+6      	; 0x355e <pulseIn+0x58>
	else
		return 0;
    3558:	60 e0       	ldi	r22, 0x00	; 0
    355a:	70 e0       	ldi	r23, 0x00	; 0
    355c:	cb 01       	movw	r24, r22
}
    355e:	1f 91       	pop	r17
    3560:	0f 91       	pop	r16
    3562:	08 95       	ret

00003564 <_Z3maplllll>:
  long diff = howbig - howsmall;
  return random(diff) + howsmall;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
    3564:	4f 92       	push	r4
    3566:	5f 92       	push	r5
    3568:	6f 92       	push	r6
    356a:	7f 92       	push	r7
    356c:	af 92       	push	r10
    356e:	bf 92       	push	r11
    3570:	cf 92       	push	r12
    3572:	df 92       	push	r13
    3574:	ef 92       	push	r14
    3576:	ff 92       	push	r15
    3578:	0f 93       	push	r16
    357a:	1f 93       	push	r17
    357c:	cf 93       	push	r28
    357e:	df 93       	push	r29
    3580:	cd b7       	in	r28, 0x3d	; 61
    3582:	de b7       	in	r29, 0x3e	; 62
    3584:	29 01       	movw	r4, r18
    3586:	3a 01       	movw	r6, r20
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    3588:	9b 01       	movw	r18, r22
    358a:	ac 01       	movw	r20, r24
    358c:	24 19       	sub	r18, r4
    358e:	35 09       	sbc	r19, r5
    3590:	46 09       	sbc	r20, r6
    3592:	57 09       	sbc	r21, r7
    3594:	8a 89       	ldd	r24, Y+18	; 0x12
    3596:	9b 89       	ldd	r25, Y+19	; 0x13
    3598:	ac 89       	ldd	r26, Y+20	; 0x14
    359a:	bd 89       	ldd	r27, Y+21	; 0x15
    359c:	bc 01       	movw	r22, r24
    359e:	cd 01       	movw	r24, r26
    35a0:	6a 19       	sub	r22, r10
    35a2:	7b 09       	sbc	r23, r11
    35a4:	8c 09       	sbc	r24, r12
    35a6:	9d 09       	sbc	r25, r13
    35a8:	1c d0       	rcall	.+56     	; 0x35e2 <__mulsi3>
    35aa:	a8 01       	movw	r20, r16
    35ac:	97 01       	movw	r18, r14
    35ae:	24 19       	sub	r18, r4
    35b0:	35 09       	sbc	r19, r5
    35b2:	46 09       	sbc	r20, r6
    35b4:	57 09       	sbc	r21, r7
    35b6:	59 d0       	rcall	.+178    	; 0x366a <__divmodsi4>
    35b8:	ca 01       	movw	r24, r20
    35ba:	b9 01       	movw	r22, r18
    35bc:	6a 0d       	add	r22, r10
    35be:	7b 1d       	adc	r23, r11
    35c0:	8c 1d       	adc	r24, r12
    35c2:	9d 1d       	adc	r25, r13
}
    35c4:	df 91       	pop	r29
    35c6:	cf 91       	pop	r28
    35c8:	1f 91       	pop	r17
    35ca:	0f 91       	pop	r16
    35cc:	ff 90       	pop	r15
    35ce:	ef 90       	pop	r14
    35d0:	df 90       	pop	r13
    35d2:	cf 90       	pop	r12
    35d4:	bf 90       	pop	r11
    35d6:	af 90       	pop	r10
    35d8:	7f 90       	pop	r7
    35da:	6f 90       	pop	r6
    35dc:	5f 90       	pop	r5
    35de:	4f 90       	pop	r4
    35e0:	08 95       	ret

000035e2 <__mulsi3>:
    35e2:	db 01       	movw	r26, r22
    35e4:	8f 93       	push	r24
    35e6:	9f 93       	push	r25
    35e8:	62 d0       	rcall	.+196    	; 0x36ae <__muluhisi3>
    35ea:	bf 91       	pop	r27
    35ec:	af 91       	pop	r26
    35ee:	a2 9f       	mul	r26, r18
    35f0:	80 0d       	add	r24, r0
    35f2:	91 1d       	adc	r25, r1
    35f4:	a3 9f       	mul	r26, r19
    35f6:	90 0d       	add	r25, r0
    35f8:	b2 9f       	mul	r27, r18
    35fa:	90 0d       	add	r25, r0
    35fc:	11 24       	eor	r1, r1
    35fe:	08 95       	ret

00003600 <__divmodhi4>:
    3600:	97 fb       	bst	r25, 7
    3602:	07 2e       	mov	r0, r23
    3604:	16 f4       	brtc	.+4      	; 0x360a <__divmodhi4+0xa>
    3606:	00 94       	com	r0
    3608:	06 d0       	rcall	.+12     	; 0x3616 <__divmodhi4_neg1>
    360a:	77 fd       	sbrc	r23, 7
    360c:	08 d0       	rcall	.+16     	; 0x361e <__divmodhi4_neg2>
    360e:	5d d0       	rcall	.+186    	; 0x36ca <__udivmodhi4>
    3610:	07 fc       	sbrc	r0, 7
    3612:	05 d0       	rcall	.+10     	; 0x361e <__divmodhi4_neg2>
    3614:	3e f4       	brtc	.+14     	; 0x3624 <__divmodhi4_exit>

00003616 <__divmodhi4_neg1>:
    3616:	90 95       	com	r25
    3618:	81 95       	neg	r24
    361a:	9f 4f       	sbci	r25, 0xFF	; 255
    361c:	08 95       	ret

0000361e <__divmodhi4_neg2>:
    361e:	70 95       	com	r23
    3620:	61 95       	neg	r22
    3622:	7f 4f       	sbci	r23, 0xFF	; 255

00003624 <__divmodhi4_exit>:
    3624:	08 95       	ret

00003626 <__udivmodsi4>:
    3626:	a1 e2       	ldi	r26, 0x21	; 33
    3628:	1a 2e       	mov	r1, r26
    362a:	aa 1b       	sub	r26, r26
    362c:	bb 1b       	sub	r27, r27
    362e:	fd 01       	movw	r30, r26
    3630:	0d c0       	rjmp	.+26     	; 0x364c <__udivmodsi4_ep>

00003632 <__udivmodsi4_loop>:
    3632:	aa 1f       	adc	r26, r26
    3634:	bb 1f       	adc	r27, r27
    3636:	ee 1f       	adc	r30, r30
    3638:	ff 1f       	adc	r31, r31
    363a:	a2 17       	cp	r26, r18
    363c:	b3 07       	cpc	r27, r19
    363e:	e4 07       	cpc	r30, r20
    3640:	f5 07       	cpc	r31, r21
    3642:	20 f0       	brcs	.+8      	; 0x364c <__udivmodsi4_ep>
    3644:	a2 1b       	sub	r26, r18
    3646:	b3 0b       	sbc	r27, r19
    3648:	e4 0b       	sbc	r30, r20
    364a:	f5 0b       	sbc	r31, r21

0000364c <__udivmodsi4_ep>:
    364c:	66 1f       	adc	r22, r22
    364e:	77 1f       	adc	r23, r23
    3650:	88 1f       	adc	r24, r24
    3652:	99 1f       	adc	r25, r25
    3654:	1a 94       	dec	r1
    3656:	69 f7       	brne	.-38     	; 0x3632 <__udivmodsi4_loop>
    3658:	60 95       	com	r22
    365a:	70 95       	com	r23
    365c:	80 95       	com	r24
    365e:	90 95       	com	r25
    3660:	9b 01       	movw	r18, r22
    3662:	ac 01       	movw	r20, r24
    3664:	bd 01       	movw	r22, r26
    3666:	cf 01       	movw	r24, r30
    3668:	08 95       	ret

0000366a <__divmodsi4>:
    366a:	05 2e       	mov	r0, r21
    366c:	97 fb       	bst	r25, 7
    366e:	16 f4       	brtc	.+4      	; 0x3674 <__divmodsi4+0xa>
    3670:	00 94       	com	r0
    3672:	0f d0       	rcall	.+30     	; 0x3692 <__negsi2>
    3674:	57 fd       	sbrc	r21, 7
    3676:	05 d0       	rcall	.+10     	; 0x3682 <__divmodsi4_neg2>
    3678:	d6 df       	rcall	.-84     	; 0x3626 <__udivmodsi4>
    367a:	07 fc       	sbrc	r0, 7
    367c:	02 d0       	rcall	.+4      	; 0x3682 <__divmodsi4_neg2>
    367e:	46 f4       	brtc	.+16     	; 0x3690 <__divmodsi4_exit>
    3680:	08 c0       	rjmp	.+16     	; 0x3692 <__negsi2>

00003682 <__divmodsi4_neg2>:
    3682:	50 95       	com	r21
    3684:	40 95       	com	r20
    3686:	30 95       	com	r19
    3688:	21 95       	neg	r18
    368a:	3f 4f       	sbci	r19, 0xFF	; 255
    368c:	4f 4f       	sbci	r20, 0xFF	; 255
    368e:	5f 4f       	sbci	r21, 0xFF	; 255

00003690 <__divmodsi4_exit>:
    3690:	08 95       	ret

00003692 <__negsi2>:
    3692:	90 95       	com	r25
    3694:	80 95       	com	r24
    3696:	70 95       	com	r23
    3698:	61 95       	neg	r22
    369a:	7f 4f       	sbci	r23, 0xFF	; 255
    369c:	8f 4f       	sbci	r24, 0xFF	; 255
    369e:	9f 4f       	sbci	r25, 0xFF	; 255
    36a0:	08 95       	ret

000036a2 <__tablejump2__>:
    36a2:	ee 0f       	add	r30, r30
    36a4:	ff 1f       	adc	r31, r31

000036a6 <__tablejump__>:
    36a6:	05 90       	lpm	r0, Z+
    36a8:	f4 91       	lpm	r31, Z
    36aa:	e0 2d       	mov	r30, r0
    36ac:	19 94       	eijmp

000036ae <__muluhisi3>:
    36ae:	21 d0       	rcall	.+66     	; 0x36f2 <__umulhisi3>
    36b0:	a5 9f       	mul	r26, r21
    36b2:	90 0d       	add	r25, r0
    36b4:	b4 9f       	mul	r27, r20
    36b6:	90 0d       	add	r25, r0
    36b8:	a4 9f       	mul	r26, r20
    36ba:	80 0d       	add	r24, r0
    36bc:	91 1d       	adc	r25, r1
    36be:	11 24       	eor	r1, r1
    36c0:	08 95       	ret

000036c2 <__tablejump_elpm__>:
    36c2:	07 90       	elpm	r0, Z+
    36c4:	f6 91       	elpm	r31, Z
    36c6:	e0 2d       	mov	r30, r0
    36c8:	19 94       	eijmp

000036ca <__udivmodhi4>:
    36ca:	aa 1b       	sub	r26, r26
    36cc:	bb 1b       	sub	r27, r27
    36ce:	51 e1       	ldi	r21, 0x11	; 17
    36d0:	07 c0       	rjmp	.+14     	; 0x36e0 <__udivmodhi4_ep>

000036d2 <__udivmodhi4_loop>:
    36d2:	aa 1f       	adc	r26, r26
    36d4:	bb 1f       	adc	r27, r27
    36d6:	a6 17       	cp	r26, r22
    36d8:	b7 07       	cpc	r27, r23
    36da:	10 f0       	brcs	.+4      	; 0x36e0 <__udivmodhi4_ep>
    36dc:	a6 1b       	sub	r26, r22
    36de:	b7 0b       	sbc	r27, r23

000036e0 <__udivmodhi4_ep>:
    36e0:	88 1f       	adc	r24, r24
    36e2:	99 1f       	adc	r25, r25
    36e4:	5a 95       	dec	r21
    36e6:	a9 f7       	brne	.-22     	; 0x36d2 <__udivmodhi4_loop>
    36e8:	80 95       	com	r24
    36ea:	90 95       	com	r25
    36ec:	bc 01       	movw	r22, r24
    36ee:	cd 01       	movw	r24, r26
    36f0:	08 95       	ret

000036f2 <__umulhisi3>:
    36f2:	a2 9f       	mul	r26, r18
    36f4:	b0 01       	movw	r22, r0
    36f6:	b3 9f       	mul	r27, r19
    36f8:	c0 01       	movw	r24, r0
    36fa:	a3 9f       	mul	r26, r19
    36fc:	70 0d       	add	r23, r0
    36fe:	81 1d       	adc	r24, r1
    3700:	11 24       	eor	r1, r1
    3702:	91 1d       	adc	r25, r1
    3704:	b2 9f       	mul	r27, r18
    3706:	70 0d       	add	r23, r0
    3708:	81 1d       	adc	r24, r1
    370a:	11 24       	eor	r1, r1
    370c:	91 1d       	adc	r25, r1
    370e:	08 95       	ret

00003710 <_exit>:
    3710:	f8 94       	cli

00003712 <__stop_program>:
    3712:	ff cf       	rjmp	.-2      	; 0x3712 <__stop_program>
