
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007c  00800200  000038ae  00003942  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000038ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000086e  0080027c  0080027c  000039be  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000039be  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000668  00000000  00000000  000039f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000f053  00000000  00000000  00004058  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002824  00000000  00000000  000130ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000481d  00000000  00000000  000158cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000012cc  00000000  00000000  0001a0ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003263  00000000  00000000  0001b3b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00006a54  00000000  00000000  0001e61b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000658  00000000  00000000  0002506f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f7 c1       	rjmp	.+1006   	; 0x3f0 <__ctors_end>
       2:	00 00       	nop
       4:	26 c2       	rjmp	.+1100   	; 0x452 <__bad_interrupt>
       6:	00 00       	nop
       8:	24 c2       	rjmp	.+1096   	; 0x452 <__bad_interrupt>
       a:	00 00       	nop
       c:	22 c2       	rjmp	.+1092   	; 0x452 <__bad_interrupt>
       e:	00 00       	nop
      10:	20 c2       	rjmp	.+1088   	; 0x452 <__bad_interrupt>
      12:	00 00       	nop
      14:	1e c2       	rjmp	.+1084   	; 0x452 <__bad_interrupt>
      16:	00 00       	nop
      18:	1c c2       	rjmp	.+1080   	; 0x452 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	1a c2       	rjmp	.+1076   	; 0x452 <__bad_interrupt>
      1e:	00 00       	nop
      20:	18 c2       	rjmp	.+1072   	; 0x452 <__bad_interrupt>
      22:	00 00       	nop
      24:	16 c2       	rjmp	.+1068   	; 0x452 <__bad_interrupt>
      26:	00 00       	nop
      28:	14 c2       	rjmp	.+1064   	; 0x452 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	12 c2       	rjmp	.+1060   	; 0x452 <__bad_interrupt>
      2e:	00 00       	nop
      30:	10 c2       	rjmp	.+1056   	; 0x452 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 c5 0a 	jmp	0x158a	; 0x158a <__vector_13>
      38:	0c c2       	rjmp	.+1048   	; 0x452 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	0a c2       	rjmp	.+1044   	; 0x452 <__bad_interrupt>
      3e:	00 00       	nop
      40:	08 c2       	rjmp	.+1040   	; 0x452 <__bad_interrupt>
      42:	00 00       	nop
      44:	06 c2       	rjmp	.+1036   	; 0x452 <__bad_interrupt>
      46:	00 00       	nop
      48:	04 c2       	rjmp	.+1032   	; 0x452 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	02 c2       	rjmp	.+1028   	; 0x452 <__bad_interrupt>
      4e:	00 00       	nop
      50:	00 c2       	rjmp	.+1024   	; 0x452 <__bad_interrupt>
      52:	00 00       	nop
      54:	fe c1       	rjmp	.+1020   	; 0x452 <__bad_interrupt>
      56:	00 00       	nop
      58:	fc c1       	rjmp	.+1016   	; 0x452 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 14 1a 	jmp	0x3428	; 0x3428 <__vector_23>
      60:	f8 c1       	rjmp	.+1008   	; 0x452 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 ce 17 	jmp	0x2f9c	; 0x2f9c <__vector_25>
      68:	0c 94 0d 18 	jmp	0x301a	; 0x301a <__vector_26>
      6c:	f2 c1       	rjmp	.+996    	; 0x452 <__bad_interrupt>
      6e:	00 00       	nop
      70:	f0 c1       	rjmp	.+992    	; 0x452 <__bad_interrupt>
      72:	00 00       	nop
      74:	ee c1       	rjmp	.+988    	; 0x452 <__bad_interrupt>
      76:	00 00       	nop
      78:	ec c1       	rjmp	.+984    	; 0x452 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	ea c1       	rjmp	.+980    	; 0x452 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e8 c1       	rjmp	.+976    	; 0x452 <__bad_interrupt>
      82:	00 00       	nop
      84:	e6 c1       	rjmp	.+972    	; 0x452 <__bad_interrupt>
      86:	00 00       	nop
      88:	e4 c1       	rjmp	.+968    	; 0x452 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e2 c1       	rjmp	.+964    	; 0x452 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 79 18 	jmp	0x30f2	; 0x30f2 <__vector_36>
      94:	0c 94 b8 18 	jmp	0x3170	; 0x3170 <__vector_37>
      98:	dc c1       	rjmp	.+952    	; 0x452 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 c4 11 	jmp	0x2388	; 0x2388 <__vector_39>
      a0:	d8 c1       	rjmp	.+944    	; 0x452 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	d6 c1       	rjmp	.+940    	; 0x452 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	d4 c1       	rjmp	.+936    	; 0x452 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	d2 c1       	rjmp	.+932    	; 0x452 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	d0 c1       	rjmp	.+928    	; 0x452 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	ce c1       	rjmp	.+924    	; 0x452 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	cc c1       	rjmp	.+920    	; 0x452 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	ca c1       	rjmp	.+916    	; 0x452 <__bad_interrupt>
      be:	00 00       	nop
      c0:	c8 c1       	rjmp	.+912    	; 0x452 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	c6 c1       	rjmp	.+908    	; 0x452 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	c4 c1       	rjmp	.+904    	; 0x452 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	c2 c1       	rjmp	.+900    	; 0x452 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	c0 c1       	rjmp	.+896    	; 0x452 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	be c1       	rjmp	.+892    	; 0x452 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	bc c1       	rjmp	.+888    	; 0x452 <__bad_interrupt>
      da:	00 00       	nop
      dc:	ba c1       	rjmp	.+884    	; 0x452 <__bad_interrupt>
      de:	00 00       	nop
      e0:	b8 c1       	rjmp	.+880    	; 0x452 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ca 12       	cpse	r12, r26
      e6:	cd 12       	cpse	r12, r29
      e8:	cd 12       	cpse	r12, r29
      ea:	cd 12       	cpse	r12, r29
      ec:	cd 12       	cpse	r12, r29
      ee:	cd 12       	cpse	r12, r29
      f0:	cd 12       	cpse	r12, r29
      f2:	cd 12       	cpse	r12, r29
      f4:	e4 11       	cpse	r30, r4
      f6:	cd 12       	cpse	r12, r29
      f8:	cd 12       	cpse	r12, r29
      fa:	cd 12       	cpse	r12, r29
      fc:	cd 12       	cpse	r12, r29
      fe:	cd 12       	cpse	r12, r29
     100:	cd 12       	cpse	r12, r29
     102:	cd 12       	cpse	r12, r29
     104:	e4 11       	cpse	r30, r4
     106:	cd 12       	cpse	r12, r29
     108:	cd 12       	cpse	r12, r29
     10a:	cd 12       	cpse	r12, r29
     10c:	cd 12       	cpse	r12, r29
     10e:	cd 12       	cpse	r12, r29
     110:	cd 12       	cpse	r12, r29
     112:	cd 12       	cpse	r12, r29
     114:	ec 11       	cpse	r30, r12
     116:	cd 12       	cpse	r12, r29
     118:	cd 12       	cpse	r12, r29
     11a:	cd 12       	cpse	r12, r29
     11c:	cd 12       	cpse	r12, r29
     11e:	cd 12       	cpse	r12, r29
     120:	cd 12       	cpse	r12, r29
     122:	cd 12       	cpse	r12, r29
     124:	11 12       	cpse	r1, r17
     126:	cd 12       	cpse	r12, r29
     128:	cd 12       	cpse	r12, r29
     12a:	cd 12       	cpse	r12, r29
     12c:	cd 12       	cpse	r12, r29
     12e:	cd 12       	cpse	r12, r29
     130:	cd 12       	cpse	r12, r29
     132:	cd 12       	cpse	r12, r29
     134:	ec 11       	cpse	r30, r12
     136:	cd 12       	cpse	r12, r29
     138:	cd 12       	cpse	r12, r29
     13a:	cd 12       	cpse	r12, r29
     13c:	cd 12       	cpse	r12, r29
     13e:	cd 12       	cpse	r12, r29
     140:	cd 12       	cpse	r12, r29
     142:	cd 12       	cpse	r12, r29
     144:	16 12       	cpse	r1, r22
     146:	cd 12       	cpse	r12, r29
     148:	cd 12       	cpse	r12, r29
     14a:	cd 12       	cpse	r12, r29
     14c:	cd 12       	cpse	r12, r29
     14e:	cd 12       	cpse	r12, r29
     150:	cd 12       	cpse	r12, r29
     152:	cd 12       	cpse	r12, r29
     154:	1b 12       	cpse	r1, r27
     156:	cd 12       	cpse	r12, r29
     158:	cd 12       	cpse	r12, r29
     15a:	cd 12       	cpse	r12, r29
     15c:	cd 12       	cpse	r12, r29
     15e:	cd 12       	cpse	r12, r29
     160:	cd 12       	cpse	r12, r29
     162:	cd 12       	cpse	r12, r29
     164:	2c 12       	cpse	r2, r28
     166:	cd 12       	cpse	r12, r29
     168:	cd 12       	cpse	r12, r29
     16a:	cd 12       	cpse	r12, r29
     16c:	cd 12       	cpse	r12, r29
     16e:	cd 12       	cpse	r12, r29
     170:	cd 12       	cpse	r12, r29
     172:	cd 12       	cpse	r12, r29
     174:	55 12       	cpse	r5, r21
     176:	cd 12       	cpse	r12, r29
     178:	cd 12       	cpse	r12, r29
     17a:	cd 12       	cpse	r12, r29
     17c:	cd 12       	cpse	r12, r29
     17e:	cd 12       	cpse	r12, r29
     180:	cd 12       	cpse	r12, r29
     182:	cd 12       	cpse	r12, r29
     184:	20 12       	cpse	r2, r16
     186:	cd 12       	cpse	r12, r29
     188:	cd 12       	cpse	r12, r29
     18a:	cd 12       	cpse	r12, r29
     18c:	cd 12       	cpse	r12, r29
     18e:	cd 12       	cpse	r12, r29
     190:	cd 12       	cpse	r12, r29
     192:	cd 12       	cpse	r12, r29
     194:	3a 12       	cpse	r3, r26
     196:	cd 12       	cpse	r12, r29
     198:	cd 12       	cpse	r12, r29
     19a:	cd 12       	cpse	r12, r29
     19c:	cd 12       	cpse	r12, r29
     19e:	cd 12       	cpse	r12, r29
     1a0:	cd 12       	cpse	r12, r29
     1a2:	cd 12       	cpse	r12, r29
     1a4:	57 12       	cpse	r5, r23
     1a6:	cd 12       	cpse	r12, r29
     1a8:	cd 12       	cpse	r12, r29
     1aa:	cd 12       	cpse	r12, r29
     1ac:	cd 12       	cpse	r12, r29
     1ae:	cd 12       	cpse	r12, r29
     1b0:	cd 12       	cpse	r12, r29
     1b2:	cd 12       	cpse	r12, r29
     1b4:	57 12       	cpse	r5, r23
     1b6:	cd 12       	cpse	r12, r29
     1b8:	cd 12       	cpse	r12, r29
     1ba:	cd 12       	cpse	r12, r29
     1bc:	cd 12       	cpse	r12, r29
     1be:	cd 12       	cpse	r12, r29
     1c0:	cd 12       	cpse	r12, r29
     1c2:	cd 12       	cpse	r12, r29
     1c4:	57 12       	cpse	r5, r23
     1c6:	cd 12       	cpse	r12, r29
     1c8:	cd 12       	cpse	r12, r29
     1ca:	cd 12       	cpse	r12, r29
     1cc:	cd 12       	cpse	r12, r29
     1ce:	cd 12       	cpse	r12, r29
     1d0:	cd 12       	cpse	r12, r29
     1d2:	cd 12       	cpse	r12, r29
     1d4:	57 12       	cpse	r5, r23
     1d6:	cd 12       	cpse	r12, r29
     1d8:	cd 12       	cpse	r12, r29
     1da:	cd 12       	cpse	r12, r29
     1dc:	cd 12       	cpse	r12, r29
     1de:	cd 12       	cpse	r12, r29
     1e0:	cd 12       	cpse	r12, r29
     1e2:	cd 12       	cpse	r12, r29
     1e4:	60 12       	cpse	r6, r16
     1e6:	cd 12       	cpse	r12, r29
     1e8:	cd 12       	cpse	r12, r29
     1ea:	cd 12       	cpse	r12, r29
     1ec:	cd 12       	cpse	r12, r29
     1ee:	cd 12       	cpse	r12, r29
     1f0:	cd 12       	cpse	r12, r29
     1f2:	cd 12       	cpse	r12, r29
     1f4:	91 12       	cpse	r9, r17
     1f6:	cd 12       	cpse	r12, r29
     1f8:	cd 12       	cpse	r12, r29
     1fa:	cd 12       	cpse	r12, r29
     1fc:	cd 12       	cpse	r12, r29
     1fe:	cd 12       	cpse	r12, r29
     200:	cd 12       	cpse	r12, r29
     202:	cd 12       	cpse	r12, r29
     204:	60 12       	cpse	r6, r16
     206:	cd 12       	cpse	r12, r29
     208:	cd 12       	cpse	r12, r29
     20a:	cd 12       	cpse	r12, r29
     20c:	cd 12       	cpse	r12, r29
     20e:	cd 12       	cpse	r12, r29
     210:	cd 12       	cpse	r12, r29
     212:	cd 12       	cpse	r12, r29
     214:	91 12       	cpse	r9, r17
     216:	cd 12       	cpse	r12, r29
     218:	cd 12       	cpse	r12, r29
     21a:	cd 12       	cpse	r12, r29
     21c:	cd 12       	cpse	r12, r29
     21e:	cd 12       	cpse	r12, r29
     220:	cd 12       	cpse	r12, r29
     222:	cd 12       	cpse	r12, r29
     224:	78 12       	cpse	r7, r24
     226:	cd 12       	cpse	r12, r29
     228:	cd 12       	cpse	r12, r29
     22a:	cd 12       	cpse	r12, r29
     22c:	cd 12       	cpse	r12, r29
     22e:	cd 12       	cpse	r12, r29
     230:	cd 12       	cpse	r12, r29
     232:	cd 12       	cpse	r12, r29
     234:	95 12       	cpse	r9, r21
     236:	cd 12       	cpse	r12, r29
     238:	cd 12       	cpse	r12, r29
     23a:	cd 12       	cpse	r12, r29
     23c:	cd 12       	cpse	r12, r29
     23e:	cd 12       	cpse	r12, r29
     240:	cd 12       	cpse	r12, r29
     242:	cd 12       	cpse	r12, r29
     244:	95 12       	cpse	r9, r21
     246:	cd 12       	cpse	r12, r29
     248:	cd 12       	cpse	r12, r29
     24a:	cd 12       	cpse	r12, r29
     24c:	cd 12       	cpse	r12, r29
     24e:	cd 12       	cpse	r12, r29
     250:	cd 12       	cpse	r12, r29
     252:	cd 12       	cpse	r12, r29
     254:	aa 12       	cpse	r10, r26
     256:	cd 12       	cpse	r12, r29
     258:	cd 12       	cpse	r12, r29
     25a:	cd 12       	cpse	r12, r29
     25c:	cd 12       	cpse	r12, r29
     25e:	cd 12       	cpse	r12, r29
     260:	cd 12       	cpse	r12, r29
     262:	cd 12       	cpse	r12, r29
     264:	c4 12       	cpse	r12, r20
     266:	cd 12       	cpse	r12, r29
     268:	cd 12       	cpse	r12, r29
     26a:	cd 12       	cpse	r12, r29
     26c:	cd 12       	cpse	r12, r29
     26e:	cd 12       	cpse	r12, r29
     270:	cd 12       	cpse	r12, r29
     272:	cd 12       	cpse	r12, r29
     274:	c4 12       	cpse	r12, r20
     276:	08 4a       	sbci	r16, 0xA8	; 168
     278:	d7 3b       	cpi	r29, 0xB7	; 183
     27a:	3b ce       	rjmp	.-906    	; 0xfffffef2 <__eeprom_end+0xff7efef2>
     27c:	01 6e       	ori	r16, 0xE1	; 225
     27e:	84 bc       	out	0x24, r8	; 36
     280:	bf fd       	.word	0xfdbf	; ????
     282:	c1 2f       	mov	r28, r17
     284:	3d 6c       	ori	r19, 0xCD	; 205
     286:	74 31       	cpi	r23, 0x14	; 20
     288:	9a bd       	out	0x2a, r25	; 42
     28a:	56 83       	std	Z+6, r21	; 0x06
     28c:	3d da       	rcall	.-2950   	; 0xfffff708 <__eeprom_end+0xff7ef708>
     28e:	3d 00       	.word	0x003d	; ????
     290:	c7 7f       	andi	r28, 0xF7	; 247
     292:	11 be       	out	0x31, r1	; 49
     294:	d9 e4       	ldi	r29, 0x49	; 73
     296:	bb 4c       	sbci	r27, 0xCB	; 203
     298:	3e 91       	ld	r19, -X
     29a:	6b aa       	std	Y+51, r6	; 0x33
     29c:	aa be       	out	0x3a, r10	; 58
     29e:	00 00       	nop
     2a0:	00 80       	ld	r0, Z
     2a2:	3f 00       	.word	0x003f	; ????
     2a4:	f3 1a       	sub	r15, r19
     2a6:	f7 1a       	sub	r15, r23
     2a8:	e1 1a       	sub	r14, r17
     2aa:	e7 1a       	sub	r14, r23
     2ac:	ed 1a       	sub	r14, r29
     2ae:	3c 1b       	sub	r19, r28
     2b0:	fb 1a       	sub	r15, r27
     2b2:	01 1b       	sub	r16, r17
     2b4:	07 1b       	sub	r16, r23
     2b6:	0d 1b       	sub	r16, r29
     2b8:	13 1b       	sub	r17, r19
     2ba:	19 1b       	sub	r17, r25
     2bc:	1f 1b       	sub	r17, r31
     2be:	25 1b       	sub	r18, r21
     2c0:	3c 1b       	sub	r19, r28
     2c2:	2b 1b       	sub	r18, r27
     2c4:	31 1b       	sub	r19, r17
     2c6:	37 1b       	sub	r19, r23

000002c8 <__trampolines_end>:
     2c8:	00 00       	nop
     2ca:	0a 0b       	sbc	r16, r26
     2cc:	02 09       	sbc	r16, r2
     2ce:	0c 0d       	add	r16, r12
     2d0:	0e 08       	sbc	r0, r14
     2d2:	07 03       	mulsu	r16, r23
     2d4:	04 01       	movw	r0, r8
	...
     2f2:	00 00       	nop
     2f4:	12 11       	cpse	r17, r2
     2f6:	10 00       	.word	0x0010	; ????
	...

0000030e <digital_pin_to_bit_mask_PGM>:
     30e:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     31e:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     32e:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     33e:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     34e:	04 08 10 20 40 80                                   ... @.

00000354 <digital_pin_to_port_PGM>:
     354:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     364:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     374:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     384:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     394:	0b 0b 0b 0b 0b 0b                                   ......

0000039a <port_to_input_PGM>:
     39a:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     3aa:	00 01 00 00 03 01 06 01 09 01                       ..........

000003b4 <port_to_output_PGM>:
     3b4:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     3c4:	02 01 00 00 05 01 08 01 0b 01                       ..........

000003ce <port_to_mode_PGM>:
     3ce:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     3de:	01 01 00 00 04 01 07 01 0a 01                       ..........

000003e8 <__ctors_start>:
     3e8:	c2 0c       	add	r12, r2
     3ea:	b2 13       	cpse	r27, r18
     3ec:	36 18       	sub	r3, r6
     3ee:	e1 18       	sub	r14, r1

000003f0 <__ctors_end>:
     3f0:	11 24       	eor	r1, r1
     3f2:	1f be       	out	0x3f, r1	; 63
     3f4:	cf ef       	ldi	r28, 0xFF	; 255
     3f6:	d1 e2       	ldi	r29, 0x21	; 33
     3f8:	de bf       	out	0x3e, r29	; 62
     3fa:	cd bf       	out	0x3d, r28	; 61
     3fc:	00 e0       	ldi	r16, 0x00	; 0
     3fe:	0c bf       	out	0x3c, r16	; 60

00000400 <__do_copy_data>:
     400:	12 e0       	ldi	r17, 0x02	; 2
     402:	a0 e0       	ldi	r26, 0x00	; 0
     404:	b2 e0       	ldi	r27, 0x02	; 2
     406:	ee ea       	ldi	r30, 0xAE	; 174
     408:	f8 e3       	ldi	r31, 0x38	; 56
     40a:	00 e0       	ldi	r16, 0x00	; 0
     40c:	0b bf       	out	0x3b, r16	; 59
     40e:	02 c0       	rjmp	.+4      	; 0x414 <__do_copy_data+0x14>
     410:	07 90       	elpm	r0, Z+
     412:	0d 92       	st	X+, r0
     414:	ac 37       	cpi	r26, 0x7C	; 124
     416:	b1 07       	cpc	r27, r17
     418:	d9 f7       	brne	.-10     	; 0x410 <__do_copy_data+0x10>

0000041a <__do_clear_bss>:
     41a:	2a e0       	ldi	r18, 0x0A	; 10
     41c:	ac e7       	ldi	r26, 0x7C	; 124
     41e:	b2 e0       	ldi	r27, 0x02	; 2
     420:	01 c0       	rjmp	.+2      	; 0x424 <.do_clear_bss_start>

00000422 <.do_clear_bss_loop>:
     422:	1d 92       	st	X+, r1

00000424 <.do_clear_bss_start>:
     424:	aa 3e       	cpi	r26, 0xEA	; 234
     426:	b2 07       	cpc	r27, r18
     428:	e1 f7       	brne	.-8      	; 0x422 <.do_clear_bss_loop>

0000042a <__do_global_ctors>:
     42a:	13 e0       	ldi	r17, 0x03	; 3
     42c:	c0 ef       	ldi	r28, 0xF0	; 240
     42e:	d3 e0       	ldi	r29, 0x03	; 3
     430:	00 e0       	ldi	r16, 0x00	; 0
     432:	06 c0       	rjmp	.+12     	; 0x440 <__do_global_ctors+0x16>
     434:	22 97       	sbiw	r28, 0x02	; 2
     436:	01 09       	sbc	r16, r1
     438:	fe 01       	movw	r30, r28
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	0e 94 2e 1c 	call	0x385c	; 0x385c <__tablejump_elpm__>
     440:	c8 3e       	cpi	r28, 0xE8	; 232
     442:	d1 07       	cpc	r29, r17
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	08 07       	cpc	r16, r24
     448:	a9 f7       	brne	.-22     	; 0x434 <__do_global_ctors+0xa>
     44a:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <main>
     44e:	0c 94 55 1c 	jmp	0x38aa	; 0x38aa <_exit>

00000452 <__bad_interrupt>:
     452:	d6 cd       	rjmp	.-1108   	; 0x0 <__vectors>

00000454 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     454:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     456:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     458:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     45a:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     45c:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     45e:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     460:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     462:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     464:	05 c0       	rjmp	.+10     	; 0x470 <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     466:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     468:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     46a:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     46c:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     46e:	61 f1       	breq	.+88     	; 0x4c8 <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     470:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     472:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     474:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     476:	b9 f3       	breq	.-18     	; 0x466 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     478:	05 c0       	rjmp	.+10     	; 0x484 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     47a:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     47c:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     47e:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     480:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     482:	11 f1       	breq	.+68     	; 0x4c8 <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     484:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     486:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     488:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     48a:	f7 cf       	rjmp	.-18     	; 0x47a <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     48c:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     48e:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     490:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     492:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     494:	0a c0       	rjmp	.+20     	; 0x4aa <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     496:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     498:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     49a:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     49c:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     49e:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     4a0:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     4a2:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     4a4:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     4a6:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     4a8:	79 f0       	breq	.+30     	; 0x4c8 <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     4aa:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     4ac:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     4ae:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     4b0:	91 f3       	breq	.-28     	; 0x496 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     4b2:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     4b4:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     4b6:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     4b8:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     4ba:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     4bc:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     4be:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     4c0:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     4c2:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     4c4:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     4c6:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     4c8:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     4ca:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     4cc:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     4ce:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     4d0:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     4d2:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     4d4:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     4d6:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     4d8:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     4da:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     4dc:	08 95       	ret

000004de <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4e4:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     4e8:	80 91 7c 02 	lds	r24, 0x027C
     4ec:	90 91 7d 02 	lds	r25, 0x027D
     4f0:	89 2b       	or	r24, r25
     4f2:	31 f4       	brne	.+12     	; 0x500 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     4f4:	81 e8       	ldi	r24, 0x81	; 129
     4f6:	92 e0       	ldi	r25, 0x02	; 2
     4f8:	90 93 7d 02 	sts	0x027D, r25
     4fc:	80 93 7c 02 	sts	0x027C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     500:	40 91 7e 02 	lds	r20, 0x027E
     504:	50 91 7f 02 	lds	r21, 0x027F
     508:	9e 01       	movw	r18, r28
     50a:	24 0f       	add	r18, r20
     50c:	35 1f       	adc	r19, r21
     50e:	2b 3d       	cpi	r18, 0xDB	; 219
     510:	85 e0       	ldi	r24, 0x05	; 5
     512:	38 07       	cpc	r19, r24
     514:	70 f4       	brcc	.+28     	; 0x532 <pvPortMalloc+0x54>
     516:	42 17       	cp	r20, r18
     518:	53 07       	cpc	r21, r19
     51a:	70 f4       	brcc	.+28     	; 0x538 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     51c:	c0 91 7c 02 	lds	r28, 0x027C
     520:	d0 91 7d 02 	lds	r29, 0x027D
     524:	c4 0f       	add	r28, r20
     526:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     528:	30 93 7f 02 	sts	0x027F, r19
     52c:	20 93 7e 02 	sts	0x027E, r18
     530:	05 c0       	rjmp	.+10     	; 0x53c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     532:	c0 e0       	ldi	r28, 0x00	; 0
     534:	d0 e0       	ldi	r29, 0x00	; 0
     536:	02 c0       	rjmp	.+4      	; 0x53c <pvPortMalloc+0x5e>
     538:	c0 e0       	ldi	r28, 0x00	; 0
     53a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     53c:	0e 94 97 0f 	call	0x1f2e	; 0x1f2e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     540:	ce 01       	movw	r24, r28
     542:	df 91       	pop	r29
     544:	cf 91       	pop	r28
     546:	08 95       	ret

00000548 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     548:	08 95       	ret

0000054a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     54a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     54c:	03 96       	adiw	r24, 0x03	; 3
     54e:	92 83       	std	Z+2, r25	; 0x02
     550:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     552:	2f ef       	ldi	r18, 0xFF	; 255
     554:	3f ef       	ldi	r19, 0xFF	; 255
     556:	34 83       	std	Z+4, r19	; 0x04
     558:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     55a:	96 83       	std	Z+6, r25	; 0x06
     55c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     55e:	90 87       	std	Z+8, r25	; 0x08
     560:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     562:	10 82       	st	Z, r1
     564:	08 95       	ret

00000566 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     566:	fc 01       	movw	r30, r24
     568:	11 86       	std	Z+9, r1	; 0x09
     56a:	10 86       	std	Z+8, r1	; 0x08
     56c:	08 95       	ret

0000056e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     56e:	cf 93       	push	r28
     570:	df 93       	push	r29
     572:	9c 01       	movw	r18, r24
     574:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     576:	dc 01       	movw	r26, r24
     578:	11 96       	adiw	r26, 0x01	; 1
     57a:	cd 91       	ld	r28, X+
     57c:	dc 91       	ld	r29, X
     57e:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     580:	d3 83       	std	Z+3, r29	; 0x03
     582:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     584:	8c 81       	ldd	r24, Y+4	; 0x04
     586:	9d 81       	ldd	r25, Y+5	; 0x05
     588:	95 83       	std	Z+5, r25	; 0x05
     58a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     58c:	8c 81       	ldd	r24, Y+4	; 0x04
     58e:	9d 81       	ldd	r25, Y+5	; 0x05
     590:	dc 01       	movw	r26, r24
     592:	13 96       	adiw	r26, 0x03	; 3
     594:	7c 93       	st	X, r23
     596:	6e 93       	st	-X, r22
     598:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     59a:	7d 83       	std	Y+5, r23	; 0x05
     59c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     59e:	31 87       	std	Z+9, r19	; 0x09
     5a0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     5a2:	f9 01       	movw	r30, r18
     5a4:	80 81       	ld	r24, Z
     5a6:	8f 5f       	subi	r24, 0xFF	; 255
     5a8:	80 83       	st	Z, r24
}
     5aa:	df 91       	pop	r29
     5ac:	cf 91       	pop	r28
     5ae:	08 95       	ret

000005b0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5b0:	cf 93       	push	r28
     5b2:	df 93       	push	r29
     5b4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     5b6:	48 81       	ld	r20, Y
     5b8:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5ba:	4f 3f       	cpi	r20, 0xFF	; 255
     5bc:	2f ef       	ldi	r18, 0xFF	; 255
     5be:	52 07       	cpc	r21, r18
     5c0:	21 f4       	brne	.+8      	; 0x5ca <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5c2:	fc 01       	movw	r30, r24
     5c4:	a7 81       	ldd	r26, Z+7	; 0x07
     5c6:	b0 85       	ldd	r27, Z+8	; 0x08
     5c8:	0d c0       	rjmp	.+26     	; 0x5e4 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ca:	dc 01       	movw	r26, r24
     5cc:	13 96       	adiw	r26, 0x03	; 3
     5ce:	12 96       	adiw	r26, 0x02	; 2
     5d0:	ed 91       	ld	r30, X+
     5d2:	fc 91       	ld	r31, X
     5d4:	13 97       	sbiw	r26, 0x03	; 3
     5d6:	20 81       	ld	r18, Z
     5d8:	31 81       	ldd	r19, Z+1	; 0x01
     5da:	42 17       	cp	r20, r18
     5dc:	53 07       	cpc	r21, r19
     5de:	10 f0       	brcs	.+4      	; 0x5e4 <vListInsert+0x34>
     5e0:	df 01       	movw	r26, r30
     5e2:	f5 cf       	rjmp	.-22     	; 0x5ce <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5e4:	12 96       	adiw	r26, 0x02	; 2
     5e6:	ed 91       	ld	r30, X+
     5e8:	fc 91       	ld	r31, X
     5ea:	13 97       	sbiw	r26, 0x03	; 3
     5ec:	fb 83       	std	Y+3, r31	; 0x03
     5ee:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5f0:	d5 83       	std	Z+5, r29	; 0x05
     5f2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5f4:	bd 83       	std	Y+5, r27	; 0x05
     5f6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5f8:	13 96       	adiw	r26, 0x03	; 3
     5fa:	dc 93       	st	X, r29
     5fc:	ce 93       	st	-X, r28
     5fe:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     600:	99 87       	std	Y+9, r25	; 0x09
     602:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     604:	fc 01       	movw	r30, r24
     606:	20 81       	ld	r18, Z
     608:	2f 5f       	subi	r18, 0xFF	; 255
     60a:	20 83       	st	Z, r18
}
     60c:	df 91       	pop	r29
     60e:	cf 91       	pop	r28
     610:	08 95       	ret

00000612 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     618:	a0 85       	ldd	r26, Z+8	; 0x08
     61a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     61c:	c2 81       	ldd	r28, Z+2	; 0x02
     61e:	d3 81       	ldd	r29, Z+3	; 0x03
     620:	84 81       	ldd	r24, Z+4	; 0x04
     622:	95 81       	ldd	r25, Z+5	; 0x05
     624:	9d 83       	std	Y+5, r25	; 0x05
     626:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     628:	c4 81       	ldd	r28, Z+4	; 0x04
     62a:	d5 81       	ldd	r29, Z+5	; 0x05
     62c:	82 81       	ldd	r24, Z+2	; 0x02
     62e:	93 81       	ldd	r25, Z+3	; 0x03
     630:	9b 83       	std	Y+3, r25	; 0x03
     632:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     634:	11 96       	adiw	r26, 0x01	; 1
     636:	cd 91       	ld	r28, X+
     638:	dc 91       	ld	r29, X
     63a:	12 97       	sbiw	r26, 0x02	; 2
     63c:	ce 17       	cp	r28, r30
     63e:	df 07       	cpc	r29, r31
     640:	31 f4       	brne	.+12     	; 0x64e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     642:	8c 81       	ldd	r24, Y+4	; 0x04
     644:	9d 81       	ldd	r25, Y+5	; 0x05
     646:	12 96       	adiw	r26, 0x02	; 2
     648:	9c 93       	st	X, r25
     64a:	8e 93       	st	-X, r24
     64c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     64e:	11 86       	std	Z+9, r1	; 0x09
     650:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     652:	8c 91       	ld	r24, X
     654:	81 50       	subi	r24, 0x01	; 1
     656:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     658:	df 91       	pop	r29
     65a:	cf 91       	pop	r28
     65c:	08 95       	ret

0000065e <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
     662:	ec 01       	movw	r28, r24
     664:	86 e0       	ldi	r24, 0x06	; 6
     666:	e1 e1       	ldi	r30, 0x11	; 17
     668:	f2 e0       	ldi	r31, 0x02	; 2
     66a:	de 01       	movw	r26, r28
     66c:	52 96       	adiw	r26, 0x12	; 18
     66e:	01 90       	ld	r0, Z+
     670:	0d 92       	st	X+, r0
     672:	8a 95       	dec	r24
     674:	e1 f7       	brne	.-8      	; 0x66e <_ZN6LSM303C1Ev+0x10>
     676:	86 e0       	ldi	r24, 0x06	; 6
     678:	e7 e1       	ldi	r30, 0x17	; 23
     67a:	f2 e0       	ldi	r31, 0x02	; 2
     67c:	de 01       	movw	r26, r28
     67e:	1c 96       	adiw	r26, 0x0c	; 12
     680:	01 90       	ld	r0, Z+
     682:	0d 92       	st	X+, r0
     684:	8a 95       	dec	r24
     686:	e1 f7       	brne	.-8      	; 0x680 <_ZN6LSM303C1Ev+0x22>
     688:	84 e0       	ldi	r24, 0x04	; 4
     68a:	89 8f       	std	Y+25, r24	; 0x19
     68c:	1c a2       	std	Y+36, r1	; 0x24
     68e:	1b a2       	std	Y+35, r1	; 0x23
     690:	1d a2       	std	Y+37, r1	; 0x25
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	08 95       	ret

00000698 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>:
     698:	4f 92       	push	r4
     69a:	5f 92       	push	r5
     69c:	6f 92       	push	r6
     69e:	7f 92       	push	r7
     6a0:	8f 92       	push	r8
     6a2:	9f 92       	push	r9
     6a4:	af 92       	push	r10
     6a6:	bf 92       	push	r11
     6a8:	cf 92       	push	r12
     6aa:	df 92       	push	r13
     6ac:	ef 92       	push	r14
     6ae:	ff 92       	push	r15
     6b0:	0f 93       	push	r16
     6b2:	1f 93       	push	r17
     6b4:	cf 93       	push	r28
     6b6:	df 93       	push	r29
     6b8:	00 d0       	rcall	.+0      	; 0x6ba <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE+0x22>
     6ba:	1f 92       	push	r1
     6bc:	cd b7       	in	r28, 0x3d	; 61
     6be:	de b7       	in	r29, 0x3e	; 62
     6c0:	8c 01       	movw	r16, r24
     6c2:	dc 01       	movw	r26, r24
     6c4:	4d 90       	ld	r4, X+
     6c6:	5d 90       	ld	r5, X+
     6c8:	6d 90       	ld	r6, X+
     6ca:	7c 90       	ld	r7, X
     6cc:	13 97       	sbiw	r26, 0x03	; 3
     6ce:	14 96       	adiw	r26, 0x04	; 4
     6d0:	8d 90       	ld	r8, X+
     6d2:	9d 90       	ld	r9, X+
     6d4:	ad 90       	ld	r10, X+
     6d6:	bc 90       	ld	r11, X
     6d8:	17 97       	sbiw	r26, 0x07	; 7
     6da:	18 96       	adiw	r26, 0x08	; 8
     6dc:	8d 91       	ld	r24, X+
     6de:	9d 91       	ld	r25, X+
     6e0:	0d 90       	ld	r0, X+
     6e2:	bc 91       	ld	r27, X
     6e4:	a0 2d       	mov	r26, r0
     6e6:	89 83       	std	Y+1, r24	; 0x01
     6e8:	9a 83       	std	Y+2, r25	; 0x02
     6ea:	ab 83       	std	Y+3, r26	; 0x03
     6ec:	bc 83       	std	Y+4, r27	; 0x04
     6ee:	a3 01       	movw	r20, r6
     6f0:	92 01       	movw	r18, r4
     6f2:	c3 01       	movw	r24, r6
     6f4:	b2 01       	movw	r22, r4
     6f6:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     6fa:	6b 01       	movw	r12, r22
     6fc:	7c 01       	movw	r14, r24
     6fe:	a5 01       	movw	r20, r10
     700:	94 01       	movw	r18, r8
     702:	c5 01       	movw	r24, r10
     704:	b4 01       	movw	r22, r8
     706:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     70a:	9b 01       	movw	r18, r22
     70c:	ac 01       	movw	r20, r24
     70e:	c7 01       	movw	r24, r14
     710:	b6 01       	movw	r22, r12
     712:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     716:	6b 01       	movw	r12, r22
     718:	7c 01       	movw	r14, r24
     71a:	29 81       	ldd	r18, Y+1	; 0x01
     71c:	3a 81       	ldd	r19, Y+2	; 0x02
     71e:	4b 81       	ldd	r20, Y+3	; 0x03
     720:	5c 81       	ldd	r21, Y+4	; 0x04
     722:	ca 01       	movw	r24, r20
     724:	b9 01       	movw	r22, r18
     726:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     72a:	9b 01       	movw	r18, r22
     72c:	ac 01       	movw	r20, r24
     72e:	c7 01       	movw	r24, r14
     730:	b6 01       	movw	r22, r12
     732:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     736:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <sqrt>
     73a:	6b 01       	movw	r12, r22
     73c:	7c 01       	movw	r14, r24
     73e:	9b 01       	movw	r18, r22
     740:	ac 01       	movw	r20, r24
     742:	c3 01       	movw	r24, r6
     744:	b2 01       	movw	r22, r4
     746:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
     74a:	f8 01       	movw	r30, r16
     74c:	60 83       	st	Z, r22
     74e:	71 83       	std	Z+1, r23	; 0x01
     750:	82 83       	std	Z+2, r24	; 0x02
     752:	93 83       	std	Z+3, r25	; 0x03
     754:	a7 01       	movw	r20, r14
     756:	96 01       	movw	r18, r12
     758:	c5 01       	movw	r24, r10
     75a:	b4 01       	movw	r22, r8
     75c:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
     760:	d8 01       	movw	r26, r16
     762:	14 96       	adiw	r26, 0x04	; 4
     764:	6d 93       	st	X+, r22
     766:	7d 93       	st	X+, r23
     768:	8d 93       	st	X+, r24
     76a:	9c 93       	st	X, r25
     76c:	17 97       	sbiw	r26, 0x07	; 7
     76e:	a7 01       	movw	r20, r14
     770:	96 01       	movw	r18, r12
     772:	69 81       	ldd	r22, Y+1	; 0x01
     774:	7a 81       	ldd	r23, Y+2	; 0x02
     776:	8b 81       	ldd	r24, Y+3	; 0x03
     778:	9c 81       	ldd	r25, Y+4	; 0x04
     77a:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
     77e:	f8 01       	movw	r30, r16
     780:	60 87       	std	Z+8, r22	; 0x08
     782:	71 87       	std	Z+9, r23	; 0x09
     784:	82 87       	std	Z+10, r24	; 0x0a
     786:	93 87       	std	Z+11, r25	; 0x0b
     788:	0f 90       	pop	r0
     78a:	0f 90       	pop	r0
     78c:	0f 90       	pop	r0
     78e:	0f 90       	pop	r0
     790:	df 91       	pop	r29
     792:	cf 91       	pop	r28
     794:	1f 91       	pop	r17
     796:	0f 91       	pop	r16
     798:	ff 90       	pop	r15
     79a:	ef 90       	pop	r14
     79c:	df 90       	pop	r13
     79e:	cf 90       	pop	r12
     7a0:	bf 90       	pop	r11
     7a2:	af 90       	pop	r10
     7a4:	9f 90       	pop	r9
     7a6:	8f 90       	pop	r8
     7a8:	7f 90       	pop	r7
     7aa:	6f 90       	pop	r6
     7ac:	5f 90       	pop	r5
     7ae:	4f 90       	pop	r4
     7b0:	08 95       	ret

000007b2 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>:
     7b2:	4f 92       	push	r4
     7b4:	5f 92       	push	r5
     7b6:	6f 92       	push	r6
     7b8:	7f 92       	push	r7
     7ba:	8f 92       	push	r8
     7bc:	9f 92       	push	r9
     7be:	af 92       	push	r10
     7c0:	bf 92       	push	r11
     7c2:	cf 92       	push	r12
     7c4:	df 92       	push	r13
     7c6:	ef 92       	push	r14
     7c8:	ff 92       	push	r15
     7ca:	0f 93       	push	r16
     7cc:	1f 93       	push	r17
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
     7d2:	cd b7       	in	r28, 0x3d	; 61
     7d4:	de b7       	in	r29, 0x3e	; 62
     7d6:	aa 97       	sbiw	r28, 0x2a	; 42
     7d8:	0f b6       	in	r0, 0x3f	; 63
     7da:	f8 94       	cli
     7dc:	de bf       	out	0x3e, r29	; 62
     7de:	0f be       	out	0x3f, r0	; 63
     7e0:	cd bf       	out	0x3d, r28	; 61
     7e2:	8c 01       	movw	r16, r24
     7e4:	29 8f       	std	Y+25, r18	; 0x19
     7e6:	3a 8f       	std	Y+26, r19	; 0x1a
     7e8:	4b 8f       	std	Y+27, r20	; 0x1b
     7ea:	5c 8f       	std	Y+28, r21	; 0x1c
     7ec:	6d 8f       	std	Y+29, r22	; 0x1d
     7ee:	7e 8f       	std	Y+30, r23	; 0x1e
     7f0:	dc 01       	movw	r26, r24
     7f2:	16 96       	adiw	r26, 0x06	; 6
     7f4:	cd 90       	ld	r12, X+
     7f6:	dc 90       	ld	r13, X
     7f8:	17 97       	sbiw	r26, 0x07	; 7
     7fa:	ee 24       	eor	r14, r14
     7fc:	d7 fc       	sbrc	r13, 7
     7fe:	e0 94       	com	r14
     800:	fe 2c       	mov	r15, r14
     802:	52 96       	adiw	r26, 0x12	; 18
     804:	4d 91       	ld	r20, X+
     806:	5c 91       	ld	r21, X
     808:	53 97       	sbiw	r26, 0x13	; 19
     80a:	66 27       	eor	r22, r22
     80c:	57 fd       	sbrc	r21, 7
     80e:	60 95       	com	r22
     810:	76 2f       	mov	r23, r22
     812:	1c 96       	adiw	r26, 0x0c	; 12
     814:	8d 91       	ld	r24, X+
     816:	9c 91       	ld	r25, X
     818:	1d 97       	sbiw	r26, 0x0d	; 13
     81a:	aa 27       	eor	r26, r26
     81c:	97 fd       	sbrc	r25, 7
     81e:	a0 95       	com	r26
     820:	ba 2f       	mov	r27, r26
     822:	48 0f       	add	r20, r24
     824:	59 1f       	adc	r21, r25
     826:	6a 1f       	adc	r22, r26
     828:	7b 1f       	adc	r23, r27
     82a:	db 01       	movw	r26, r22
     82c:	ca 01       	movw	r24, r20
     82e:	77 23       	and	r23, r23
     830:	1c f4       	brge	.+6      	; 0x838 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x86>
     832:	01 96       	adiw	r24, 0x01	; 1
     834:	a1 1d       	adc	r26, r1
     836:	b1 1d       	adc	r27, r1
     838:	b5 95       	asr	r27
     83a:	a7 95       	ror	r26
     83c:	97 95       	ror	r25
     83e:	87 95       	ror	r24
     840:	a7 01       	movw	r20, r14
     842:	96 01       	movw	r18, r12
     844:	28 1b       	sub	r18, r24
     846:	39 0b       	sbc	r19, r25
     848:	4a 0b       	sbc	r20, r26
     84a:	5b 0b       	sbc	r21, r27
     84c:	2f 8f       	std	Y+31, r18	; 0x1f
     84e:	38 a3       	std	Y+32, r19	; 0x20
     850:	49 a3       	std	Y+33, r20	; 0x21
     852:	5a a3       	std	Y+34, r21	; 0x22
     854:	d8 01       	movw	r26, r16
     856:	18 96       	adiw	r26, 0x08	; 8
     858:	cd 90       	ld	r12, X+
     85a:	dc 90       	ld	r13, X
     85c:	19 97       	sbiw	r26, 0x09	; 9
     85e:	ee 24       	eor	r14, r14
     860:	d7 fc       	sbrc	r13, 7
     862:	e0 94       	com	r14
     864:	fe 2c       	mov	r15, r14
     866:	54 96       	adiw	r26, 0x14	; 20
     868:	4d 91       	ld	r20, X+
     86a:	5c 91       	ld	r21, X
     86c:	55 97       	sbiw	r26, 0x15	; 21
     86e:	66 27       	eor	r22, r22
     870:	57 fd       	sbrc	r21, 7
     872:	60 95       	com	r22
     874:	76 2f       	mov	r23, r22
     876:	1e 96       	adiw	r26, 0x0e	; 14
     878:	8d 91       	ld	r24, X+
     87a:	9c 91       	ld	r25, X
     87c:	1f 97       	sbiw	r26, 0x0f	; 15
     87e:	aa 27       	eor	r26, r26
     880:	97 fd       	sbrc	r25, 7
     882:	a0 95       	com	r26
     884:	ba 2f       	mov	r27, r26
     886:	48 0f       	add	r20, r24
     888:	59 1f       	adc	r21, r25
     88a:	6a 1f       	adc	r22, r26
     88c:	7b 1f       	adc	r23, r27
     88e:	db 01       	movw	r26, r22
     890:	ca 01       	movw	r24, r20
     892:	77 23       	and	r23, r23
     894:	1c f4       	brge	.+6      	; 0x89c <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0xea>
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	a1 1d       	adc	r26, r1
     89a:	b1 1d       	adc	r27, r1
     89c:	b5 95       	asr	r27
     89e:	a7 95       	ror	r26
     8a0:	97 95       	ror	r25
     8a2:	87 95       	ror	r24
     8a4:	a7 01       	movw	r20, r14
     8a6:	96 01       	movw	r18, r12
     8a8:	28 1b       	sub	r18, r24
     8aa:	39 0b       	sbc	r19, r25
     8ac:	4a 0b       	sbc	r20, r26
     8ae:	5b 0b       	sbc	r21, r27
     8b0:	2b a3       	std	Y+35, r18	; 0x23
     8b2:	3c a3       	std	Y+36, r19	; 0x24
     8b4:	4d a3       	std	Y+37, r20	; 0x25
     8b6:	5e a3       	std	Y+38, r21	; 0x26
     8b8:	d8 01       	movw	r26, r16
     8ba:	1a 96       	adiw	r26, 0x0a	; 10
     8bc:	4d 90       	ld	r4, X+
     8be:	5c 90       	ld	r5, X
     8c0:	1b 97       	sbiw	r26, 0x0b	; 11
     8c2:	66 24       	eor	r6, r6
     8c4:	57 fc       	sbrc	r5, 7
     8c6:	60 94       	com	r6
     8c8:	76 2c       	mov	r7, r6
     8ca:	56 96       	adiw	r26, 0x16	; 22
     8cc:	4d 91       	ld	r20, X+
     8ce:	5c 91       	ld	r21, X
     8d0:	57 97       	sbiw	r26, 0x17	; 23
     8d2:	66 27       	eor	r22, r22
     8d4:	57 fd       	sbrc	r21, 7
     8d6:	60 95       	com	r22
     8d8:	76 2f       	mov	r23, r22
     8da:	50 96       	adiw	r26, 0x10	; 16
     8dc:	8d 91       	ld	r24, X+
     8de:	9c 91       	ld	r25, X
     8e0:	51 97       	sbiw	r26, 0x11	; 17
     8e2:	aa 27       	eor	r26, r26
     8e4:	97 fd       	sbrc	r25, 7
     8e6:	a0 95       	com	r26
     8e8:	ba 2f       	mov	r27, r26
     8ea:	48 0f       	add	r20, r24
     8ec:	59 1f       	adc	r21, r25
     8ee:	6a 1f       	adc	r22, r26
     8f0:	7b 1f       	adc	r23, r27
     8f2:	db 01       	movw	r26, r22
     8f4:	ca 01       	movw	r24, r20
     8f6:	77 23       	and	r23, r23
     8f8:	1c f4       	brge	.+6      	; 0x900 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x14e>
     8fa:	01 96       	adiw	r24, 0x01	; 1
     8fc:	a1 1d       	adc	r26, r1
     8fe:	b1 1d       	adc	r27, r1
     900:	b5 95       	asr	r27
     902:	a7 95       	ror	r26
     904:	97 95       	ror	r25
     906:	87 95       	ror	r24
     908:	48 1a       	sub	r4, r24
     90a:	59 0a       	sbc	r5, r25
     90c:	6a 0a       	sbc	r6, r26
     90e:	7b 0a       	sbc	r7, r27
     910:	f8 01       	movw	r30, r16
     912:	84 80       	ldd	r8, Z+4	; 0x04
     914:	95 80       	ldd	r9, Z+5	; 0x05
     916:	aa 24       	eor	r10, r10
     918:	97 fc       	sbrc	r9, 7
     91a:	a0 94       	com	r10
     91c:	ba 2c       	mov	r11, r10
     91e:	82 81       	ldd	r24, Z+2	; 0x02
     920:	93 81       	ldd	r25, Z+3	; 0x03
     922:	9c 01       	movw	r18, r24
     924:	44 27       	eor	r20, r20
     926:	37 fd       	sbrc	r19, 7
     928:	40 95       	com	r20
     92a:	54 2f       	mov	r21, r20
     92c:	2f a3       	std	Y+39, r18	; 0x27
     92e:	38 a7       	std	Y+40, r19	; 0x28
     930:	49 a7       	std	Y+41, r20	; 0x29
     932:	5a a7       	std	Y+42, r21	; 0x2a
     934:	2b a1       	ldd	r18, Y+35	; 0x23
     936:	3c a1       	ldd	r19, Y+36	; 0x24
     938:	4d a1       	ldd	r20, Y+37	; 0x25
     93a:	5e a1       	ldd	r21, Y+38	; 0x26
     93c:	c5 01       	movw	r24, r10
     93e:	b4 01       	movw	r22, r8
     940:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulsi3>
     944:	6b 01       	movw	r12, r22
     946:	7c 01       	movw	r14, r24
     948:	a3 01       	movw	r20, r6
     94a:	92 01       	movw	r18, r4
     94c:	6f a1       	ldd	r22, Y+39	; 0x27
     94e:	78 a5       	ldd	r23, Y+40	; 0x28
     950:	89 a5       	ldd	r24, Y+41	; 0x29
     952:	9a a5       	ldd	r25, Y+42	; 0x2a
     954:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulsi3>
     958:	a7 01       	movw	r20, r14
     95a:	96 01       	movw	r18, r12
     95c:	26 1b       	sub	r18, r22
     95e:	37 0b       	sbc	r19, r23
     960:	48 0b       	sbc	r20, r24
     962:	59 0b       	sbc	r21, r25
     964:	ca 01       	movw	r24, r20
     966:	b9 01       	movw	r22, r18
     968:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     96c:	6d 87       	std	Y+13, r22	; 0x0d
     96e:	7e 87       	std	Y+14, r23	; 0x0e
     970:	8f 87       	std	Y+15, r24	; 0x0f
     972:	98 8b       	std	Y+16, r25	; 0x10
     974:	d8 01       	movw	r26, r16
     976:	cd 90       	ld	r12, X+
     978:	dc 90       	ld	r13, X
     97a:	ee 24       	eor	r14, r14
     97c:	d7 fc       	sbrc	r13, 7
     97e:	e0 94       	com	r14
     980:	fe 2c       	mov	r15, r14
     982:	a3 01       	movw	r20, r6
     984:	92 01       	movw	r18, r4
     986:	c7 01       	movw	r24, r14
     988:	b6 01       	movw	r22, r12
     98a:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulsi3>
     98e:	2b 01       	movw	r4, r22
     990:	3c 01       	movw	r6, r24
     992:	2f 8d       	ldd	r18, Y+31	; 0x1f
     994:	38 a1       	ldd	r19, Y+32	; 0x20
     996:	49 a1       	ldd	r20, Y+33	; 0x21
     998:	5a a1       	ldd	r21, Y+34	; 0x22
     99a:	c5 01       	movw	r24, r10
     99c:	b4 01       	movw	r22, r8
     99e:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulsi3>
     9a2:	a3 01       	movw	r20, r6
     9a4:	92 01       	movw	r18, r4
     9a6:	26 1b       	sub	r18, r22
     9a8:	37 0b       	sbc	r19, r23
     9aa:	48 0b       	sbc	r20, r24
     9ac:	59 0b       	sbc	r21, r25
     9ae:	ca 01       	movw	r24, r20
     9b0:	b9 01       	movw	r22, r18
     9b2:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     9b6:	69 8b       	std	Y+17, r22	; 0x11
     9b8:	7a 8b       	std	Y+18, r23	; 0x12
     9ba:	8b 8b       	std	Y+19, r24	; 0x13
     9bc:	9c 8b       	std	Y+20, r25	; 0x14
     9be:	2f 8d       	ldd	r18, Y+31	; 0x1f
     9c0:	38 a1       	ldd	r19, Y+32	; 0x20
     9c2:	49 a1       	ldd	r20, Y+33	; 0x21
     9c4:	5a a1       	ldd	r21, Y+34	; 0x22
     9c6:	6f a1       	ldd	r22, Y+39	; 0x27
     9c8:	78 a5       	ldd	r23, Y+40	; 0x28
     9ca:	89 a5       	ldd	r24, Y+41	; 0x29
     9cc:	9a a5       	ldd	r25, Y+42	; 0x2a
     9ce:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulsi3>
     9d2:	4b 01       	movw	r8, r22
     9d4:	5c 01       	movw	r10, r24
     9d6:	2b a1       	ldd	r18, Y+35	; 0x23
     9d8:	3c a1       	ldd	r19, Y+36	; 0x24
     9da:	4d a1       	ldd	r20, Y+37	; 0x25
     9dc:	5e a1       	ldd	r21, Y+38	; 0x26
     9de:	c7 01       	movw	r24, r14
     9e0:	b6 01       	movw	r22, r12
     9e2:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulsi3>
     9e6:	a5 01       	movw	r20, r10
     9e8:	94 01       	movw	r18, r8
     9ea:	26 1b       	sub	r18, r22
     9ec:	37 0b       	sbc	r19, r23
     9ee:	48 0b       	sbc	r20, r24
     9f0:	59 0b       	sbc	r21, r25
     9f2:	ca 01       	movw	r24, r20
     9f4:	b9 01       	movw	r22, r18
     9f6:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     9fa:	6d 8b       	std	Y+21, r22	; 0x15
     9fc:	7e 8b       	std	Y+22, r23	; 0x16
     9fe:	8f 8b       	std	Y+23, r24	; 0x17
     a00:	98 8f       	std	Y+24, r25	; 0x18
     a02:	ce 01       	movw	r24, r28
     a04:	0d 96       	adiw	r24, 0x0d	; 13
     a06:	48 de       	rcall	.-880    	; 0x698 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     a08:	d8 01       	movw	r26, r16
     a0a:	12 96       	adiw	r26, 0x02	; 2
     a0c:	6d 91       	ld	r22, X+
     a0e:	7c 91       	ld	r23, X
     a10:	13 97       	sbiw	r26, 0x03	; 3
     a12:	88 27       	eor	r24, r24
     a14:	77 fd       	sbrc	r23, 7
     a16:	80 95       	com	r24
     a18:	98 2f       	mov	r25, r24
     a1a:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     a1e:	6b 01       	movw	r12, r22
     a20:	7c 01       	movw	r14, r24
     a22:	2d 89       	ldd	r18, Y+21	; 0x15
     a24:	3e 89       	ldd	r19, Y+22	; 0x16
     a26:	4f 89       	ldd	r20, Y+23	; 0x17
     a28:	58 8d       	ldd	r21, Y+24	; 0x18
     a2a:	2f 8f       	std	Y+31, r18	; 0x1f
     a2c:	38 a3       	std	Y+32, r19	; 0x20
     a2e:	49 a3       	std	Y+33, r20	; 0x21
     a30:	5a a3       	std	Y+34, r21	; 0x22
     a32:	d8 01       	movw	r26, r16
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	6d 91       	ld	r22, X+
     a38:	7c 91       	ld	r23, X
     a3a:	15 97       	sbiw	r26, 0x05	; 5
     a3c:	88 27       	eor	r24, r24
     a3e:	77 fd       	sbrc	r23, 7
     a40:	80 95       	com	r24
     a42:	98 2f       	mov	r25, r24
     a44:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     a48:	2b 01       	movw	r4, r22
     a4a:	3c 01       	movw	r6, r24
     a4c:	29 89       	ldd	r18, Y+17	; 0x11
     a4e:	3a 89       	ldd	r19, Y+18	; 0x12
     a50:	4b 89       	ldd	r20, Y+19	; 0x13
     a52:	5c 89       	ldd	r21, Y+20	; 0x14
     a54:	2b a3       	std	Y+35, r18	; 0x23
     a56:	3c a3       	std	Y+36, r19	; 0x24
     a58:	4d a3       	std	Y+37, r20	; 0x25
     a5a:	5e a3       	std	Y+38, r21	; 0x26
     a5c:	2f 8d       	ldd	r18, Y+31	; 0x1f
     a5e:	38 a1       	ldd	r19, Y+32	; 0x20
     a60:	49 a1       	ldd	r20, Y+33	; 0x21
     a62:	5a a1       	ldd	r21, Y+34	; 0x22
     a64:	c7 01       	movw	r24, r14
     a66:	b6 01       	movw	r22, r12
     a68:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     a6c:	4b 01       	movw	r8, r22
     a6e:	5c 01       	movw	r10, r24
     a70:	2b a1       	ldd	r18, Y+35	; 0x23
     a72:	3c a1       	ldd	r19, Y+36	; 0x24
     a74:	4d a1       	ldd	r20, Y+37	; 0x25
     a76:	5e a1       	ldd	r21, Y+38	; 0x26
     a78:	c3 01       	movw	r24, r6
     a7a:	b2 01       	movw	r22, r4
     a7c:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     a80:	9b 01       	movw	r18, r22
     a82:	ac 01       	movw	r20, r24
     a84:	c5 01       	movw	r24, r10
     a86:	b4 01       	movw	r22, r8
     a88:	0e 94 b6 13 	call	0x276c	; 0x276c <__subsf3>
     a8c:	69 83       	std	Y+1, r22	; 0x01
     a8e:	7a 83       	std	Y+2, r23	; 0x02
     a90:	8b 83       	std	Y+3, r24	; 0x03
     a92:	9c 83       	std	Y+4, r25	; 0x04
     a94:	8d 85       	ldd	r24, Y+13	; 0x0d
     a96:	9e 85       	ldd	r25, Y+14	; 0x0e
     a98:	af 85       	ldd	r26, Y+15	; 0x0f
     a9a:	b8 89       	ldd	r27, Y+16	; 0x10
     a9c:	8f a3       	std	Y+39, r24	; 0x27
     a9e:	98 a7       	std	Y+40, r25	; 0x28
     aa0:	a9 a7       	std	Y+41, r26	; 0x29
     aa2:	ba a7       	std	Y+42, r27	; 0x2a
     aa4:	d8 01       	movw	r26, r16
     aa6:	6d 91       	ld	r22, X+
     aa8:	7c 91       	ld	r23, X
     aaa:	88 27       	eor	r24, r24
     aac:	77 fd       	sbrc	r23, 7
     aae:	80 95       	com	r24
     ab0:	98 2f       	mov	r25, r24
     ab2:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     ab6:	4b 01       	movw	r8, r22
     ab8:	5c 01       	movw	r10, r24
     aba:	2f a1       	ldd	r18, Y+39	; 0x27
     abc:	38 a5       	ldd	r19, Y+40	; 0x28
     abe:	49 a5       	ldd	r20, Y+41	; 0x29
     ac0:	5a a5       	ldd	r21, Y+42	; 0x2a
     ac2:	c3 01       	movw	r24, r6
     ac4:	b2 01       	movw	r22, r4
     ac6:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     aca:	2b 01       	movw	r4, r22
     acc:	3c 01       	movw	r6, r24
     ace:	a5 01       	movw	r20, r10
     ad0:	94 01       	movw	r18, r8
     ad2:	6f 8d       	ldd	r22, Y+31	; 0x1f
     ad4:	78 a1       	ldd	r23, Y+32	; 0x20
     ad6:	89 a1       	ldd	r24, Y+33	; 0x21
     ad8:	9a a1       	ldd	r25, Y+34	; 0x22
     ada:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     ade:	9b 01       	movw	r18, r22
     ae0:	ac 01       	movw	r20, r24
     ae2:	c3 01       	movw	r24, r6
     ae4:	b2 01       	movw	r22, r4
     ae6:	0e 94 b6 13 	call	0x276c	; 0x276c <__subsf3>
     aea:	6d 83       	std	Y+5, r22	; 0x05
     aec:	7e 83       	std	Y+6, r23	; 0x06
     aee:	8f 83       	std	Y+7, r24	; 0x07
     af0:	98 87       	std	Y+8, r25	; 0x08
     af2:	a5 01       	movw	r20, r10
     af4:	94 01       	movw	r18, r8
     af6:	6b a1       	ldd	r22, Y+35	; 0x23
     af8:	7c a1       	ldd	r23, Y+36	; 0x24
     afa:	8d a1       	ldd	r24, Y+37	; 0x25
     afc:	9e a1       	ldd	r25, Y+38	; 0x26
     afe:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     b02:	4b 01       	movw	r8, r22
     b04:	5c 01       	movw	r10, r24
     b06:	2f a1       	ldd	r18, Y+39	; 0x27
     b08:	38 a5       	ldd	r19, Y+40	; 0x28
     b0a:	49 a5       	ldd	r20, Y+41	; 0x29
     b0c:	5a a5       	ldd	r21, Y+42	; 0x2a
     b0e:	c7 01       	movw	r24, r14
     b10:	b6 01       	movw	r22, r12
     b12:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     b16:	9b 01       	movw	r18, r22
     b18:	ac 01       	movw	r20, r24
     b1a:	c5 01       	movw	r24, r10
     b1c:	b4 01       	movw	r22, r8
     b1e:	0e 94 b6 13 	call	0x276c	; 0x276c <__subsf3>
     b22:	69 87       	std	Y+9, r22	; 0x09
     b24:	7a 87       	std	Y+10, r23	; 0x0a
     b26:	8b 87       	std	Y+11, r24	; 0x0b
     b28:	9c 87       	std	Y+12, r25	; 0x0c
     b2a:	ce 01       	movw	r24, r28
     b2c:	01 96       	adiw	r24, 0x01	; 1
     b2e:	b4 dd       	rcall	.-1176   	; 0x698 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     b30:	69 8d       	ldd	r22, Y+25	; 0x19
     b32:	7a 8d       	ldd	r23, Y+26	; 0x1a
     b34:	88 27       	eor	r24, r24
     b36:	77 fd       	sbrc	r23, 7
     b38:	80 95       	com	r24
     b3a:	98 2f       	mov	r25, r24
     b3c:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     b40:	2b 01       	movw	r4, r22
     b42:	3c 01       	movw	r6, r24
     b44:	6b 8d       	ldd	r22, Y+27	; 0x1b
     b46:	7c 8d       	ldd	r23, Y+28	; 0x1c
     b48:	88 27       	eor	r24, r24
     b4a:	77 fd       	sbrc	r23, 7
     b4c:	80 95       	com	r24
     b4e:	98 2f       	mov	r25, r24
     b50:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     b54:	4b 01       	movw	r8, r22
     b56:	5c 01       	movw	r10, r24
     b58:	6d 8d       	ldd	r22, Y+29	; 0x1d
     b5a:	7e 8d       	ldd	r23, Y+30	; 0x1e
     b5c:	88 27       	eor	r24, r24
     b5e:	77 fd       	sbrc	r23, 7
     b60:	80 95       	com	r24
     b62:	98 2f       	mov	r25, r24
     b64:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
     b68:	6b 01       	movw	r12, r22
     b6a:	7c 01       	movw	r14, r24
     b6c:	29 81       	ldd	r18, Y+1	; 0x01
     b6e:	3a 81       	ldd	r19, Y+2	; 0x02
     b70:	4b 81       	ldd	r20, Y+3	; 0x03
     b72:	5c 81       	ldd	r21, Y+4	; 0x04
     b74:	c3 01       	movw	r24, r6
     b76:	b2 01       	movw	r22, r4
     b78:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     b7c:	6f 8f       	std	Y+31, r22	; 0x1f
     b7e:	78 a3       	std	Y+32, r23	; 0x20
     b80:	89 a3       	std	Y+33, r24	; 0x21
     b82:	9a a3       	std	Y+34, r25	; 0x22
     b84:	2d 81       	ldd	r18, Y+5	; 0x05
     b86:	3e 81       	ldd	r19, Y+6	; 0x06
     b88:	4f 81       	ldd	r20, Y+7	; 0x07
     b8a:	58 85       	ldd	r21, Y+8	; 0x08
     b8c:	c5 01       	movw	r24, r10
     b8e:	b4 01       	movw	r22, r8
     b90:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     b94:	9b 01       	movw	r18, r22
     b96:	ac 01       	movw	r20, r24
     b98:	6f 8d       	ldd	r22, Y+31	; 0x1f
     b9a:	78 a1       	ldd	r23, Y+32	; 0x20
     b9c:	89 a1       	ldd	r24, Y+33	; 0x21
     b9e:	9a a1       	ldd	r25, Y+34	; 0x22
     ba0:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     ba4:	6f 8f       	std	Y+31, r22	; 0x1f
     ba6:	78 a3       	std	Y+32, r23	; 0x20
     ba8:	89 a3       	std	Y+33, r24	; 0x21
     baa:	9a a3       	std	Y+34, r25	; 0x22
     bac:	29 85       	ldd	r18, Y+9	; 0x09
     bae:	3a 85       	ldd	r19, Y+10	; 0x0a
     bb0:	4b 85       	ldd	r20, Y+11	; 0x0b
     bb2:	5c 85       	ldd	r21, Y+12	; 0x0c
     bb4:	c7 01       	movw	r24, r14
     bb6:	b6 01       	movw	r22, r12
     bb8:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     bbc:	9b 01       	movw	r18, r22
     bbe:	ac 01       	movw	r20, r24
     bc0:	6f 8d       	ldd	r22, Y+31	; 0x1f
     bc2:	78 a1       	ldd	r23, Y+32	; 0x20
     bc4:	89 a1       	ldd	r24, Y+33	; 0x21
     bc6:	9a a1       	ldd	r25, Y+34	; 0x22
     bc8:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     bcc:	6f 8f       	std	Y+31, r22	; 0x1f
     bce:	78 a3       	std	Y+32, r23	; 0x20
     bd0:	89 a3       	std	Y+33, r24	; 0x21
     bd2:	9a a3       	std	Y+34, r25	; 0x22
     bd4:	2d 85       	ldd	r18, Y+13	; 0x0d
     bd6:	3e 85       	ldd	r19, Y+14	; 0x0e
     bd8:	4f 85       	ldd	r20, Y+15	; 0x0f
     bda:	58 89       	ldd	r21, Y+16	; 0x10
     bdc:	c3 01       	movw	r24, r6
     bde:	b2 01       	movw	r22, r4
     be0:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     be4:	2b 01       	movw	r4, r22
     be6:	3c 01       	movw	r6, r24
     be8:	29 89       	ldd	r18, Y+17	; 0x11
     bea:	3a 89       	ldd	r19, Y+18	; 0x12
     bec:	4b 89       	ldd	r20, Y+19	; 0x13
     bee:	5c 89       	ldd	r21, Y+20	; 0x14
     bf0:	c5 01       	movw	r24, r10
     bf2:	b4 01       	movw	r22, r8
     bf4:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     bf8:	9b 01       	movw	r18, r22
     bfa:	ac 01       	movw	r20, r24
     bfc:	c3 01       	movw	r24, r6
     bfe:	b2 01       	movw	r22, r4
     c00:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     c04:	4b 01       	movw	r8, r22
     c06:	5c 01       	movw	r10, r24
     c08:	2d 89       	ldd	r18, Y+21	; 0x15
     c0a:	3e 89       	ldd	r19, Y+22	; 0x16
     c0c:	4f 89       	ldd	r20, Y+23	; 0x17
     c0e:	58 8d       	ldd	r21, Y+24	; 0x18
     c10:	c7 01       	movw	r24, r14
     c12:	b6 01       	movw	r22, r12
     c14:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     c18:	9b 01       	movw	r18, r22
     c1a:	ac 01       	movw	r20, r24
     c1c:	c5 01       	movw	r24, r10
     c1e:	b4 01       	movw	r22, r8
     c20:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     c24:	2f 8d       	ldd	r18, Y+31	; 0x1f
     c26:	38 a1       	ldd	r19, Y+32	; 0x20
     c28:	49 a1       	ldd	r20, Y+33	; 0x21
     c2a:	5a a1       	ldd	r21, Y+34	; 0x22
     c2c:	0e 94 2a 14 	call	0x2854	; 0x2854 <atan2>
     c30:	20 e0       	ldi	r18, 0x00	; 0
     c32:	30 e0       	ldi	r19, 0x00	; 0
     c34:	44 e3       	ldi	r20, 0x34	; 52
     c36:	53 e4       	ldi	r21, 0x43	; 67
     c38:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <__mulsf3>
     c3c:	2b ed       	ldi	r18, 0xDB	; 219
     c3e:	3f e0       	ldi	r19, 0x0F	; 15
     c40:	49 e4       	ldi	r20, 0x49	; 73
     c42:	50 e4       	ldi	r21, 0x40	; 64
     c44:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
     c48:	6b 01       	movw	r12, r22
     c4a:	7c 01       	movw	r14, r24
     c4c:	20 e0       	ldi	r18, 0x00	; 0
     c4e:	30 e0       	ldi	r19, 0x00	; 0
     c50:	a9 01       	movw	r20, r18
     c52:	0e 94 7d 14 	call	0x28fa	; 0x28fa <__cmpsf2>
     c56:	88 23       	and	r24, r24
     c58:	54 f4       	brge	.+20     	; 0xc6e <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x4bc>
     c5a:	20 e0       	ldi	r18, 0x00	; 0
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	44 eb       	ldi	r20, 0xB4	; 180
     c60:	53 e4       	ldi	r21, 0x43	; 67
     c62:	c7 01       	movw	r24, r14
     c64:	b6 01       	movw	r22, r12
     c66:	0e 94 b7 13 	call	0x276e	; 0x276e <__addsf3>
     c6a:	6b 01       	movw	r12, r22
     c6c:	7c 01       	movw	r14, r24
     c6e:	c7 01       	movw	r24, r14
     c70:	b6 01       	movw	r22, r12
     c72:	aa 96       	adiw	r28, 0x2a	; 42
     c74:	0f b6       	in	r0, 0x3f	; 63
     c76:	f8 94       	cli
     c78:	de bf       	out	0x3e, r29	; 62
     c7a:	0f be       	out	0x3f, r0	; 63
     c7c:	cd bf       	out	0x3d, r28	; 61
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	1f 91       	pop	r17
     c84:	0f 91       	pop	r16
     c86:	ff 90       	pop	r15
     c88:	ef 90       	pop	r14
     c8a:	df 90       	pop	r13
     c8c:	cf 90       	pop	r12
     c8e:	bf 90       	pop	r11
     c90:	af 90       	pop	r10
     c92:	9f 90       	pop	r9
     c94:	8f 90       	pop	r8
     c96:	7f 90       	pop	r7
     c98:	6f 90       	pop	r6
     c9a:	5f 90       	pop	r5
     c9c:	4f 90       	pop	r4
     c9e:	08 95       	ret

00000ca0 <_ZN6LSM3037headingEv>:
     ca0:	cf 93       	push	r28
     ca2:	df 93       	push	r29
     ca4:	cd b7       	in	r28, 0x3d	; 61
     ca6:	de b7       	in	r29, 0x3e	; 62
     ca8:	2c 97       	sbiw	r28, 0x0c	; 12
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	de bf       	out	0x3e, r29	; 62
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	cd bf       	out	0x3d, r28	; 61
     cb4:	fc 01       	movw	r30, r24
     cb6:	21 8d       	ldd	r18, Z+25	; 0x19
     cb8:	23 30       	cpi	r18, 0x03	; 3
     cba:	79 f4       	brne	.+30     	; 0xcda <_ZN6LSM3037headingEv+0x3a>
     cbc:	31 e0       	ldi	r19, 0x01	; 1
     cbe:	23 2f       	mov	r18, r19
     cc0:	3f 83       	std	Y+7, r19	; 0x07
     cc2:	18 86       	std	Y+8, r1	; 0x08
     cc4:	1a 86       	std	Y+10, r1	; 0x0a
     cc6:	19 86       	std	Y+9, r1	; 0x09
     cc8:	1c 86       	std	Y+12, r1	; 0x0c
     cca:	1b 86       	std	Y+11, r1	; 0x0b
     ccc:	30 e0       	ldi	r19, 0x00	; 0
     cce:	40 e0       	ldi	r20, 0x00	; 0
     cd0:	5a 85       	ldd	r21, Y+10	; 0x0a
     cd2:	60 e0       	ldi	r22, 0x00	; 0
     cd4:	7c 85       	ldd	r23, Y+12	; 0x0c
     cd6:	6d dd       	rcall	.-1318   	; 0x7b2 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
     cd8:	0e c0       	rjmp	.+28     	; 0xcf6 <_ZN6LSM3037headingEv+0x56>
     cda:	1a 82       	std	Y+2, r1	; 0x02
     cdc:	19 82       	std	Y+1, r1	; 0x01
     cde:	2f ef       	ldi	r18, 0xFF	; 255
     ce0:	42 2f       	mov	r20, r18
     ce2:	2b 83       	std	Y+3, r18	; 0x03
     ce4:	2c 83       	std	Y+4, r18	; 0x04
     ce6:	1e 82       	std	Y+6, r1	; 0x06
     ce8:	1d 82       	std	Y+5, r1	; 0x05
     cea:	20 e0       	ldi	r18, 0x00	; 0
     cec:	3a 81       	ldd	r19, Y+2	; 0x02
     cee:	5f ef       	ldi	r21, 0xFF	; 255
     cf0:	60 e0       	ldi	r22, 0x00	; 0
     cf2:	7e 81       	ldd	r23, Y+6	; 0x06
     cf4:	5e dd       	rcall	.-1348   	; 0x7b2 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
     cf6:	2c 96       	adiw	r28, 0x0c	; 12
     cf8:	0f b6       	in	r0, 0x3f	; 63
     cfa:	f8 94       	cli
     cfc:	de bf       	out	0x3e, r29	; 62
     cfe:	0f be       	out	0x3f, r0	; 63
     d00:	cd bf       	out	0x3d, r28	; 61
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	08 95       	ret

00000d08 <_ZN6LSM30311writeAccRegEhh>:
     d08:	0f 93       	push	r16
     d0a:	1f 93       	push	r17
     d0c:	cf 93       	push	r28
     d0e:	df 93       	push	r29
     d10:	ec 01       	movw	r28, r24
     d12:	06 2f       	mov	r16, r22
     d14:	14 2f       	mov	r17, r20
     d16:	6a 8d       	ldd	r22, Y+26	; 0x1a
     d18:	85 e5       	ldi	r24, 0x55	; 85
     d1a:	99 e0       	ldi	r25, 0x09	; 9
     d1c:	0e 94 93 13 	call	0x2726	; 0x2726 <_ZN7TwoWire17beginTransmissionEh>
     d20:	60 2f       	mov	r22, r16
     d22:	85 e5       	ldi	r24, 0x55	; 85
     d24:	99 e0       	ldi	r25, 0x09	; 9
     d26:	0e 94 3a 13 	call	0x2674	; 0x2674 <_ZN7TwoWire5writeEh>
     d2a:	61 2f       	mov	r22, r17
     d2c:	85 e5       	ldi	r24, 0x55	; 85
     d2e:	99 e0       	ldi	r25, 0x09	; 9
     d30:	0e 94 3a 13 	call	0x2674	; 0x2674 <_ZN7TwoWire5writeEh>
     d34:	85 e5       	ldi	r24, 0x55	; 85
     d36:	99 e0       	ldi	r25, 0x09	; 9
     d38:	0e 94 af 13 	call	0x275e	; 0x275e <_ZN7TwoWire15endTransmissionEv>
     d3c:	88 8f       	std	Y+24, r24	; 0x18
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	08 95       	ret

00000d48 <_ZN6LSM30311writeMagRegEhh>:
     d48:	0f 93       	push	r16
     d4a:	1f 93       	push	r17
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	ec 01       	movw	r28, r24
     d52:	06 2f       	mov	r16, r22
     d54:	14 2f       	mov	r17, r20
     d56:	6b 8d       	ldd	r22, Y+27	; 0x1b
     d58:	85 e5       	ldi	r24, 0x55	; 85
     d5a:	99 e0       	ldi	r25, 0x09	; 9
     d5c:	0e 94 93 13 	call	0x2726	; 0x2726 <_ZN7TwoWire17beginTransmissionEh>
     d60:	60 2f       	mov	r22, r16
     d62:	85 e5       	ldi	r24, 0x55	; 85
     d64:	99 e0       	ldi	r25, 0x09	; 9
     d66:	0e 94 3a 13 	call	0x2674	; 0x2674 <_ZN7TwoWire5writeEh>
     d6a:	61 2f       	mov	r22, r17
     d6c:	85 e5       	ldi	r24, 0x55	; 85
     d6e:	99 e0       	ldi	r25, 0x09	; 9
     d70:	0e 94 3a 13 	call	0x2674	; 0x2674 <_ZN7TwoWire5writeEh>
     d74:	85 e5       	ldi	r24, 0x55	; 85
     d76:	99 e0       	ldi	r25, 0x09	; 9
     d78:	0e 94 af 13 	call	0x275e	; 0x275e <_ZN7TwoWire15endTransmissionEv>
     d7c:	88 8f       	std	Y+24, r24	; 0x18
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	1f 91       	pop	r17
     d84:	0f 91       	pop	r16
     d86:	08 95       	ret

00000d88 <_ZN6LSM3038writeRegEhh>:
     d88:	fc 01       	movw	r30, r24
     d8a:	21 8d       	ldd	r18, Z+25	; 0x19
     d8c:	23 30       	cpi	r18, 0x03	; 3
     d8e:	11 f0       	breq	.+4      	; 0xd94 <_ZN6LSM3038writeRegEhh+0xc>
     d90:	60 32       	cpi	r22, 0x20	; 32
     d92:	10 f4       	brcc	.+4      	; 0xd98 <_ZN6LSM3038writeRegEhh+0x10>
     d94:	d9 cf       	rjmp	.-78     	; 0xd48 <_ZN6LSM30311writeMagRegEhh>
     d96:	08 95       	ret
     d98:	b7 cf       	rjmp	.-146    	; 0xd08 <_ZN6LSM30311writeAccRegEhh>
     d9a:	08 95       	ret

00000d9c <_ZN6LSM30313enableDefaultEv>:
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	ec 01       	movw	r28, r24
     da2:	89 8d       	ldd	r24, Y+25	; 0x19
     da4:	83 30       	cpi	r24, 0x03	; 3
     da6:	a9 f4       	brne	.+42     	; 0xdd2 <_ZN6LSM30313enableDefaultEv+0x36>
     da8:	40 e0       	ldi	r20, 0x00	; 0
     daa:	61 e2       	ldi	r22, 0x21	; 33
     dac:	ce 01       	movw	r24, r28
     dae:	ec df       	rcall	.-40     	; 0xd88 <_ZN6LSM3038writeRegEhh>
     db0:	47 e5       	ldi	r20, 0x57	; 87
     db2:	60 e2       	ldi	r22, 0x20	; 32
     db4:	ce 01       	movw	r24, r28
     db6:	e8 df       	rcall	.-48     	; 0xd88 <_ZN6LSM3038writeRegEhh>
     db8:	44 e6       	ldi	r20, 0x64	; 100
     dba:	64 e2       	ldi	r22, 0x24	; 36
     dbc:	ce 01       	movw	r24, r28
     dbe:	e4 df       	rcall	.-56     	; 0xd88 <_ZN6LSM3038writeRegEhh>
     dc0:	40 e2       	ldi	r20, 0x20	; 32
     dc2:	65 e2       	ldi	r22, 0x25	; 37
     dc4:	ce 01       	movw	r24, r28
     dc6:	e0 df       	rcall	.-64     	; 0xd88 <_ZN6LSM3038writeRegEhh>
     dc8:	40 e0       	ldi	r20, 0x00	; 0
     dca:	66 e2       	ldi	r22, 0x26	; 38
     dcc:	ce 01       	movw	r24, r28
     dce:	dc df       	rcall	.-72     	; 0xd88 <_ZN6LSM3038writeRegEhh>
     dd0:	1f c0       	rjmp	.+62     	; 0xe10 <_ZN6LSM30313enableDefaultEv+0x74>
     dd2:	82 30       	cpi	r24, 0x02	; 2
     dd4:	49 f4       	brne	.+18     	; 0xde8 <_ZN6LSM30313enableDefaultEv+0x4c>
     dd6:	48 e0       	ldi	r20, 0x08	; 8
     dd8:	63 e2       	ldi	r22, 0x23	; 35
     dda:	ce 01       	movw	r24, r28
     ddc:	95 df       	rcall	.-214    	; 0xd08 <_ZN6LSM30311writeAccRegEhh>
     dde:	47 e4       	ldi	r20, 0x47	; 71
     de0:	60 e2       	ldi	r22, 0x20	; 32
     de2:	ce 01       	movw	r24, r28
     de4:	91 df       	rcall	.-222    	; 0xd08 <_ZN6LSM30311writeAccRegEhh>
     de6:	08 c0       	rjmp	.+16     	; 0xdf8 <_ZN6LSM30313enableDefaultEv+0x5c>
     de8:	40 e0       	ldi	r20, 0x00	; 0
     dea:	63 e2       	ldi	r22, 0x23	; 35
     dec:	ce 01       	movw	r24, r28
     dee:	8c df       	rcall	.-232    	; 0xd08 <_ZN6LSM30311writeAccRegEhh>
     df0:	47 e2       	ldi	r20, 0x27	; 39
     df2:	60 e2       	ldi	r22, 0x20	; 32
     df4:	ce 01       	movw	r24, r28
     df6:	88 df       	rcall	.-240    	; 0xd08 <_ZN6LSM30311writeAccRegEhh>
     df8:	4c e0       	ldi	r20, 0x0C	; 12
     dfa:	60 e0       	ldi	r22, 0x00	; 0
     dfc:	ce 01       	movw	r24, r28
     dfe:	a4 df       	rcall	.-184    	; 0xd48 <_ZN6LSM30311writeMagRegEhh>
     e00:	40 e2       	ldi	r20, 0x20	; 32
     e02:	61 e0       	ldi	r22, 0x01	; 1
     e04:	ce 01       	movw	r24, r28
     e06:	a0 df       	rcall	.-192    	; 0xd48 <_ZN6LSM30311writeMagRegEhh>
     e08:	40 e0       	ldi	r20, 0x00	; 0
     e0a:	62 e0       	ldi	r22, 0x02	; 2
     e0c:	ce 01       	movw	r24, r28
     e0e:	9c df       	rcall	.-200    	; 0xd48 <_ZN6LSM30311writeMagRegEhh>
     e10:	df 91       	pop	r29
     e12:	cf 91       	pop	r28
     e14:	08 95       	ret

00000e16 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
     e16:	9f 92       	push	r9
     e18:	af 92       	push	r10
     e1a:	bf 92       	push	r11
     e1c:	cf 92       	push	r12
     e1e:	df 92       	push	r13
     e20:	ef 92       	push	r14
     e22:	ff 92       	push	r15
     e24:	0f 93       	push	r16
     e26:	1f 93       	push	r17
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
     e2e:	6a 8d       	ldd	r22, Y+26	; 0x1a
     e30:	85 e5       	ldi	r24, 0x55	; 85
     e32:	99 e0       	ldi	r25, 0x09	; 9
     e34:	0e 94 93 13 	call	0x2726	; 0x2726 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     e38:	e0 91 55 09 	lds	r30, 0x0955
     e3c:	f0 91 56 09 	lds	r31, 0x0956
     e40:	01 90       	ld	r0, Z+
     e42:	f0 81       	ld	r31, Z
     e44:	e0 2d       	mov	r30, r0
     e46:	68 ea       	ldi	r22, 0xA8	; 168
     e48:	85 e5       	ldi	r24, 0x55	; 85
     e4a:	99 e0       	ldi	r25, 0x09	; 9
     e4c:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
     e4e:	85 e5       	ldi	r24, 0x55	; 85
     e50:	99 e0       	ldi	r25, 0x09	; 9
     e52:	0e 94 af 13 	call	0x275e	; 0x275e <_ZN7TwoWire15endTransmissionEv>
     e56:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
     e58:	46 e0       	ldi	r20, 0x06	; 6
     e5a:	6a 8d       	ldd	r22, Y+26	; 0x1a
     e5c:	85 e5       	ldi	r24, 0x55	; 85
     e5e:	99 e0       	ldi	r25, 0x09	; 9
     e60:	0e 94 90 13 	call	0x2720	; 0x2720 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     e64:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <millis>
     e68:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     e6a:	10 c0       	rjmp	.+32     	; 0xe8c <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     e6c:	8b a1       	ldd	r24, Y+35	; 0x23
     e6e:	9c a1       	ldd	r25, Y+36	; 0x24
     e70:	89 2b       	or	r24, r25
     e72:	61 f0       	breq	.+24     	; 0xe8c <_ZN6LSM3037readAccEv+0x76>
     e74:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <millis>
     e78:	60 1b       	sub	r22, r16
     e7a:	71 0b       	sbc	r23, r17
     e7c:	8b a1       	ldd	r24, Y+35	; 0x23
     e7e:	9c a1       	ldd	r25, Y+36	; 0x24
     e80:	86 17       	cp	r24, r22
     e82:	97 07       	cpc	r25, r23
     e84:	18 f4       	brcc	.+6      	; 0xe8c <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
     e86:	81 e0       	ldi	r24, 0x01	; 1
     e88:	8d a3       	std	Y+37, r24	; 0x25
      return;
     e8a:	32 c0       	rjmp	.+100    	; 0xef0 <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     e8c:	85 e5       	ldi	r24, 0x55	; 85
     e8e:	99 e0       	ldi	r25, 0x09	; 9
     e90:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <_ZN7TwoWire9availableEv>
     e94:	06 97       	sbiw	r24, 0x06	; 6
     e96:	54 f3       	brlt	.-44     	; 0xe6c <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
     e98:	85 e5       	ldi	r24, 0x55	; 85
     e9a:	99 e0       	ldi	r25, 0x09	; 9
     e9c:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     ea0:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
     ea2:	85 e5       	ldi	r24, 0x55	; 85
     ea4:	99 e0       	ldi	r25, 0x09	; 9
     ea6:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     eaa:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
     eac:	85 e5       	ldi	r24, 0x55	; 85
     eae:	99 e0       	ldi	r25, 0x09	; 9
     eb0:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     eb4:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
     eb6:	85 e5       	ldi	r24, 0x55	; 85
     eb8:	99 e0       	ldi	r25, 0x09	; 9
     eba:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     ebe:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
     ec0:	85 e5       	ldi	r24, 0x55	; 85
     ec2:	99 e0       	ldi	r25, 0x09	; 9
     ec4:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     ec8:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
     eca:	85 e5       	ldi	r24, 0x55	; 85
     ecc:	99 e0       	ldi	r25, 0x09	; 9
     ece:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
     ed2:	d9 2c       	mov	r13, r9
     ed4:	c1 2c       	mov	r12, r1
     ed6:	ca 28       	or	r12, r10
     ed8:	d9 82       	std	Y+1, r13	; 0x01
     eda:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
     edc:	fb 2c       	mov	r15, r11
     ede:	e1 2c       	mov	r14, r1
     ee0:	e0 2a       	or	r14, r16
     ee2:	fb 82       	std	Y+3, r15	; 0x03
     ee4:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
     ee6:	98 2f       	mov	r25, r24
     ee8:	88 27       	eor	r24, r24
     eea:	81 2b       	or	r24, r17
     eec:	9d 83       	std	Y+5, r25	; 0x05
     eee:	8c 83       	std	Y+4, r24	; 0x04
}
     ef0:	df 91       	pop	r29
     ef2:	cf 91       	pop	r28
     ef4:	1f 91       	pop	r17
     ef6:	0f 91       	pop	r16
     ef8:	ff 90       	pop	r15
     efa:	ef 90       	pop	r14
     efc:	df 90       	pop	r13
     efe:	cf 90       	pop	r12
     f00:	bf 90       	pop	r11
     f02:	af 90       	pop	r10
     f04:	9f 90       	pop	r9
     f06:	08 95       	ret

00000f08 <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
     f08:	cf 92       	push	r12
     f0a:	df 92       	push	r13
     f0c:	ef 92       	push	r14
     f0e:	ff 92       	push	r15
     f10:	0f 93       	push	r16
     f12:	1f 93       	push	r17
     f14:	cf 93       	push	r28
     f16:	df 93       	push	r29
     f18:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
     f1a:	6b 8d       	ldd	r22, Y+27	; 0x1b
     f1c:	85 e5       	ldi	r24, 0x55	; 85
     f1e:	99 e0       	ldi	r25, 0x09	; 9
     f20:	0e 94 93 13 	call	0x2726	; 0x2726 <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
     f24:	89 8d       	ldd	r24, Y+25	; 0x19
     f26:	83 30       	cpi	r24, 0x03	; 3
     f28:	31 f4       	brne	.+12     	; 0xf36 <_ZN6LSM3037readMagEv+0x2e>
     f2a:	6e 8d       	ldd	r22, Y+30	; 0x1e
     f2c:	77 27       	eor	r23, r23
     f2e:	67 fd       	sbrc	r22, 7
     f30:	70 95       	com	r23
     f32:	60 68       	ori	r22, 0x80	; 128
     f34:	04 c0       	rjmp	.+8      	; 0xf3e <_ZN6LSM3037readMagEv+0x36>
     f36:	6d 8d       	ldd	r22, Y+29	; 0x1d
     f38:	77 27       	eor	r23, r23
     f3a:	67 fd       	sbrc	r22, 7
     f3c:	70 95       	com	r23
     f3e:	e0 91 55 09 	lds	r30, 0x0955
     f42:	f0 91 56 09 	lds	r31, 0x0956
     f46:	01 90       	ld	r0, Z+
     f48:	f0 81       	ld	r31, Z
     f4a:	e0 2d       	mov	r30, r0
     f4c:	85 e5       	ldi	r24, 0x55	; 85
     f4e:	99 e0       	ldi	r25, 0x09	; 9
     f50:	19 95       	eicall
  last_status = Wire.endTransmission();
     f52:	85 e5       	ldi	r24, 0x55	; 85
     f54:	99 e0       	ldi	r25, 0x09	; 9
     f56:	0e 94 af 13 	call	0x275e	; 0x275e <_ZN7TwoWire15endTransmissionEv>
     f5a:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
     f5c:	46 e0       	ldi	r20, 0x06	; 6
     f5e:	6b 8d       	ldd	r22, Y+27	; 0x1b
     f60:	85 e5       	ldi	r24, 0x55	; 85
     f62:	99 e0       	ldi	r25, 0x09	; 9
     f64:	0e 94 90 13 	call	0x2720	; 0x2720 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     f68:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <millis>
     f6c:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     f6e:	10 c0       	rjmp	.+32     	; 0xf90 <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     f70:	8b a1       	ldd	r24, Y+35	; 0x23
     f72:	9c a1       	ldd	r25, Y+36	; 0x24
     f74:	89 2b       	or	r24, r25
     f76:	61 f0       	breq	.+24     	; 0xf90 <_ZN6LSM3037readMagEv+0x88>
     f78:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <millis>
     f7c:	60 1b       	sub	r22, r16
     f7e:	71 0b       	sbc	r23, r17
     f80:	8b a1       	ldd	r24, Y+35	; 0x23
     f82:	9c a1       	ldd	r25, Y+36	; 0x24
     f84:	86 17       	cp	r24, r22
     f86:	97 07       	cpc	r25, r23
     f88:	18 f4       	brcc	.+6      	; 0xf90 <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	8d a3       	std	Y+37, r24	; 0x25
      return;
     f8e:	6e c0       	rjmp	.+220    	; 0x106c <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     f90:	85 e5       	ldi	r24, 0x55	; 85
     f92:	99 e0       	ldi	r25, 0x09	; 9
     f94:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <_ZN7TwoWire9availableEv>
     f98:	06 97       	sbiw	r24, 0x06	; 6
     f9a:	54 f3       	brlt	.-44     	; 0xf70 <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
     f9c:	89 8d       	ldd	r24, Y+25	; 0x19
     f9e:	83 30       	cpi	r24, 0x03	; 3
     fa0:	f9 f4       	brne	.+62     	; 0xfe0 <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
     fa2:	85 e5       	ldi	r24, 0x55	; 85
     fa4:	99 e0       	ldi	r25, 0x09	; 9
     fa6:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     faa:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
     fac:	85 e5       	ldi	r24, 0x55	; 85
     fae:	99 e0       	ldi	r25, 0x09	; 9
     fb0:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     fb4:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
     fb6:	85 e5       	ldi	r24, 0x55	; 85
     fb8:	99 e0       	ldi	r25, 0x09	; 9
     fba:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     fbe:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
     fc0:	85 e5       	ldi	r24, 0x55	; 85
     fc2:	99 e0       	ldi	r25, 0x09	; 9
     fc4:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     fc8:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
     fca:	85 e5       	ldi	r24, 0x55	; 85
     fcc:	99 e0       	ldi	r25, 0x09	; 9
     fce:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     fd2:	08 2f       	mov	r16, r24
    zhm = Wire.read();
     fd4:	85 e5       	ldi	r24, 0x55	; 85
     fd6:	99 e0       	ldi	r25, 0x09	; 9
     fd8:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     fdc:	18 2f       	mov	r17, r24
     fde:	36 c0       	rjmp	.+108    	; 0x104c <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
     fe0:	85 e5       	ldi	r24, 0x55	; 85
     fe2:	99 e0       	ldi	r25, 0x09	; 9
     fe4:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     fe8:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
     fea:	85 e5       	ldi	r24, 0x55	; 85
     fec:	99 e0       	ldi	r25, 0x09	; 9
     fee:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
     ff2:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
     ff4:	89 8d       	ldd	r24, Y+25	; 0x19
     ff6:	81 11       	cpse	r24, r1
     ff8:	15 c0       	rjmp	.+42     	; 0x1024 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
     ffa:	85 e5       	ldi	r24, 0x55	; 85
     ffc:	99 e0       	ldi	r25, 0x09	; 9
     ffe:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    1002:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    1004:	85 e5       	ldi	r24, 0x55	; 85
    1006:	99 e0       	ldi	r25, 0x09	; 9
    1008:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    100c:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
    100e:	85 e5       	ldi	r24, 0x55	; 85
    1010:	99 e0       	ldi	r25, 0x09	; 9
    1012:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    1016:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    1018:	85 e5       	ldi	r24, 0x55	; 85
    101a:	99 e0       	ldi	r25, 0x09	; 9
    101c:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    1020:	08 2f       	mov	r16, r24
    1022:	14 c0       	rjmp	.+40     	; 0x104c <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
    1024:	85 e5       	ldi	r24, 0x55	; 85
    1026:	99 e0       	ldi	r25, 0x09	; 9
    1028:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    102c:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    102e:	85 e5       	ldi	r24, 0x55	; 85
    1030:	99 e0       	ldi	r25, 0x09	; 9
    1032:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    1036:	08 2f       	mov	r16, r24
      yhm = Wire.read();
    1038:	85 e5       	ldi	r24, 0x55	; 85
    103a:	99 e0       	ldi	r25, 0x09	; 9
    103c:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    1040:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    1042:	85 e5       	ldi	r24, 0x55	; 85
    1044:	99 e0       	ldi	r25, 0x09	; 9
    1046:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    104a:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
    104c:	6c 2d       	mov	r22, r12
    104e:	70 e0       	ldi	r23, 0x00	; 0
    1050:	7d 29       	or	r23, r13
    1052:	7f 83       	std	Y+7, r23	; 0x07
    1054:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
    1056:	4e 2d       	mov	r20, r14
    1058:	50 e0       	ldi	r21, 0x00	; 0
    105a:	5f 29       	or	r21, r15
    105c:	59 87       	std	Y+9, r21	; 0x09
    105e:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
    1060:	20 2f       	mov	r18, r16
    1062:	30 e0       	ldi	r19, 0x00	; 0
    1064:	c9 01       	movw	r24, r18
    1066:	91 2b       	or	r25, r17
    1068:	9b 87       	std	Y+11, r25	; 0x0b
    106a:	8a 87       	std	Y+10, r24	; 0x0a
}
    106c:	df 91       	pop	r29
    106e:	cf 91       	pop	r28
    1070:	1f 91       	pop	r17
    1072:	0f 91       	pop	r16
    1074:	ff 90       	pop	r15
    1076:	ef 90       	pop	r14
    1078:	df 90       	pop	r13
    107a:	cf 90       	pop	r12
    107c:	08 95       	ret

0000107e <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	ec 01       	movw	r28, r24
  readAcc();
    1084:	c8 de       	rcall	.-624    	; 0xe16 <_ZN6LSM3037readAccEv>
  readMag();
    1086:	ce 01       	movw	r24, r28
    1088:	3f df       	rcall	.-386    	; 0xf08 <_ZN6LSM3037readMagEv>
}
    108a:	df 91       	pop	r29
    108c:	cf 91       	pop	r28
    108e:	08 95       	ret

00001090 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
    1090:	cf 93       	push	r28
    1092:	df 93       	push	r29
    1094:	c6 2f       	mov	r28, r22
    1096:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
    1098:	85 e5       	ldi	r24, 0x55	; 85
    109a:	99 e0       	ldi	r25, 0x09	; 9
    109c:	0e 94 93 13 	call	0x2726	; 0x2726 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
    10a0:	6d 2f       	mov	r22, r29
    10a2:	85 e5       	ldi	r24, 0x55	; 85
    10a4:	99 e0       	ldi	r25, 0x09	; 9
    10a6:	0e 94 3a 13 	call	0x2674	; 0x2674 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
    10aa:	85 e5       	ldi	r24, 0x55	; 85
    10ac:	99 e0       	ldi	r25, 0x09	; 9
    10ae:	0e 94 af 13 	call	0x275e	; 0x275e <_ZN7TwoWire15endTransmissionEv>
    10b2:	81 11       	cpse	r24, r1
    10b4:	11 c0       	rjmp	.+34     	; 0x10d8 <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
    10b6:	41 e0       	ldi	r20, 0x01	; 1
    10b8:	6c 2f       	mov	r22, r28
    10ba:	85 e5       	ldi	r24, 0x55	; 85
    10bc:	99 e0       	ldi	r25, 0x09	; 9
    10be:	0e 94 90 13 	call	0x2720	; 0x2720 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
    10c2:	85 e5       	ldi	r24, 0x55	; 85
    10c4:	99 e0       	ldi	r25, 0x09	; 9
    10c6:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <_ZN7TwoWire9availableEv>
    10ca:	89 2b       	or	r24, r25
    10cc:	41 f0       	breq	.+16     	; 0x10de <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
    10ce:	85 e5       	ldi	r24, 0x55	; 85
    10d0:	99 e0       	ldi	r25, 0x09	; 9
    10d2:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <_ZN7TwoWire4readEv>
    10d6:	05 c0       	rjmp	.+10     	; 0x10e2 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
    10d8:	8f ef       	ldi	r24, 0xFF	; 255
    10da:	9f ef       	ldi	r25, 0xFF	; 255
    10dc:	02 c0       	rjmp	.+4      	; 0x10e2 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
    10de:	8f ef       	ldi	r24, 0xFF	; 255
    10e0:	9f ef       	ldi	r25, 0xFF	; 255
  }
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	08 95       	ret

000010e8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
    10f0:	ec 01       	movw	r28, r24
    10f2:	16 2f       	mov	r17, r22
    10f4:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
    10f6:	64 30       	cpi	r22, 0x04	; 4
    10f8:	09 f4       	brne	.+2      	; 0x10fc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
    10fa:	ad c0       	rjmp	.+346    	; 0x1256 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
    10fc:	42 30       	cpi	r20, 0x02	; 2
    10fe:	09 f0       	breq	.+2      	; 0x1102 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
    1100:	47 c0       	rjmp	.+142    	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    1102:	ad c0       	rjmp	.+346    	; 0x125e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1104:	4f e0       	ldi	r20, 0x0F	; 15
    1106:	6d e1       	ldi	r22, 0x1D	; 29
    1108:	ce 01       	movw	r24, r28
    110a:	c2 df       	rcall	.-124    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    110c:	89 34       	cpi	r24, 0x49	; 73
    110e:	91 05       	cpc	r25, r1
    1110:	09 f4       	brne	.+2      	; 0x1114 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
    1112:	ab c0       	rjmp	.+342    	; 0x126a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1114:	01 30       	cpi	r16, 0x01	; 1
    1116:	41 f0       	breq	.+16     	; 0x1128 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1118:	4f e0       	ldi	r20, 0x0F	; 15
    111a:	6e e1       	ldi	r22, 0x1E	; 30
    111c:	ce 01       	movw	r24, r28
    111e:	b8 df       	rcall	.-144    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1120:	89 34       	cpi	r24, 0x49	; 73
    1122:	91 05       	cpc	r25, r1
    1124:	09 f4       	brne	.+2      	; 0x1128 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1126:	a3 c0       	rjmp	.+326    	; 0x126e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
    1128:	14 30       	cpi	r17, 0x04	; 4
    112a:	11 f0       	breq	.+4      	; 0x1130 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
    112c:	13 30       	cpi	r17, 0x03	; 3
    112e:	68 f5       	brcc	.+90     	; 0x118a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    1130:	00 23       	and	r16, r16
    1132:	a9 f0       	breq	.+42     	; 0x115e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
    1134:	40 e2       	ldi	r20, 0x20	; 32
    1136:	69 e1       	ldi	r22, 0x19	; 25
    1138:	ce 01       	movw	r24, r28
    113a:	aa df       	rcall	.-172    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    113c:	01 96       	adiw	r24, 0x01	; 1
    113e:	69 f0       	breq	.+26     	; 0x115a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
    1140:	14 30       	cpi	r17, 0x04	; 4
    1142:	09 f0       	breq	.+2      	; 0x1146 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
    1144:	99 c0       	rjmp	.+306    	; 0x1278 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1146:	4f e0       	ldi	r20, 0x0F	; 15
    1148:	6e e1       	ldi	r22, 0x1E	; 30
    114a:	ce 01       	movw	r24, r28
    114c:	a1 df       	rcall	.-190    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    114e:	cc 97       	sbiw	r24, 0x3c	; 60
    1150:	09 f0       	breq	.+2      	; 0x1154 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
    1152:	94 c0       	rjmp	.+296    	; 0x127c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    1154:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1156:	12 e0       	ldi	r17, 0x02	; 2
    1158:	1b c0       	rjmp	.+54     	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    115a:	01 30       	cpi	r16, 0x01	; 1
    115c:	99 f0       	breq	.+38     	; 0x1184 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
    115e:	40 e2       	ldi	r20, 0x20	; 32
    1160:	68 e1       	ldi	r22, 0x18	; 24
    1162:	ce 01       	movw	r24, r28
    1164:	95 df       	rcall	.-214    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1166:	01 96       	adiw	r24, 0x01	; 1
    1168:	69 f0       	breq	.+26     	; 0x1184 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
    116a:	14 30       	cpi	r17, 0x04	; 4
    116c:	09 f0       	breq	.+2      	; 0x1170 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
    116e:	89 c0       	rjmp	.+274    	; 0x1282 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
    1170:	4f e0       	ldi	r20, 0x0F	; 15
    1172:	6e e1       	ldi	r22, 0x1E	; 30
    1174:	ce 01       	movw	r24, r28
    1176:	8c df       	rcall	.-232    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1178:	11 e0       	ldi	r17, 0x01	; 1
    117a:	cc 97       	sbiw	r24, 0x3c	; 60
    117c:	09 f0       	breq	.+2      	; 0x1180 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
    117e:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    1180:	00 e0       	ldi	r16, 0x00	; 0
    1182:	06 c0       	rjmp	.+12     	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    1184:	14 30       	cpi	r17, 0x04	; 4
    1186:	09 f4       	brne	.+2      	; 0x118a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    1188:	60 c0       	rjmp	.+192    	; 0x124a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
    118a:	02 30       	cpi	r16, 0x02	; 2
    118c:	09 f4       	brne	.+2      	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    118e:	5f c0       	rjmp	.+190    	; 0x124e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
    1190:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
    1192:	11 30       	cpi	r17, 0x01	; 1
    1194:	71 f1       	breq	.+92     	; 0x11f2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
    1196:	08 f4       	brcc	.+2      	; 0x119a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
    1198:	42 c0       	rjmp	.+132    	; 0x121e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
    119a:	12 30       	cpi	r17, 0x02	; 2
    119c:	c1 f0       	breq	.+48     	; 0x11ce <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
    119e:	13 30       	cpi	r17, 0x03	; 3
    11a0:	09 f0       	breq	.+2      	; 0x11a4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
    11a2:	57 c0       	rjmp	.+174    	; 0x1252 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
    11a4:	01 30       	cpi	r16, 0x01	; 1
    11a6:	11 f4       	brne	.+4      	; 0x11ac <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
    11a8:	8d e1       	ldi	r24, 0x1D	; 29
    11aa:	01 c0       	rjmp	.+2      	; 0x11ae <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
    11ac:	8e e1       	ldi	r24, 0x1E	; 30
    11ae:	8b 8f       	std	Y+27, r24	; 0x1b
    11b0:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
    11b2:	88 e0       	ldi	r24, 0x08	; 8
    11b4:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
    11b6:	89 e0       	ldi	r24, 0x09	; 9
    11b8:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
    11ba:	8a e0       	ldi	r24, 0x0A	; 10
    11bc:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
    11be:	8b e0       	ldi	r24, 0x0B	; 11
    11c0:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
    11c2:	8c e0       	ldi	r24, 0x0C	; 12
    11c4:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
    11c6:	8d e0       	ldi	r24, 0x0D	; 13
    11c8:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
    11cc:	64 c0       	rjmp	.+200    	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
    11ce:	89 e1       	ldi	r24, 0x19	; 25
    11d0:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    11d2:	8e e1       	ldi	r24, 0x1E	; 30
    11d4:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
    11d6:	83 e0       	ldi	r24, 0x03	; 3
    11d8:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
    11da:	84 e0       	ldi	r24, 0x04	; 4
    11dc:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
    11de:	87 e0       	ldi	r24, 0x07	; 7
    11e0:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
    11e2:	88 e0       	ldi	r24, 0x08	; 8
    11e4:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
    11e6:	85 e0       	ldi	r24, 0x05	; 5
    11e8:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
    11ea:	86 e0       	ldi	r24, 0x06	; 6
    11ec:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    11ee:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
    11f0:	52 c0       	rjmp	.+164    	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    11f2:	01 30       	cpi	r16, 0x01	; 1
    11f4:	11 f4       	brne	.+4      	; 0x11fa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
    11f6:	89 e1       	ldi	r24, 0x19	; 25
    11f8:	01 c0       	rjmp	.+2      	; 0x11fc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
    11fa:	88 e1       	ldi	r24, 0x18	; 24
    11fc:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    11fe:	8e e1       	ldi	r24, 0x1E	; 30
    1200:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
    1202:	83 e0       	ldi	r24, 0x03	; 3
    1204:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
    1206:	84 e0       	ldi	r24, 0x04	; 4
    1208:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
    120a:	87 e0       	ldi	r24, 0x07	; 7
    120c:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
    120e:	88 e0       	ldi	r24, 0x08	; 8
    1210:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
    1212:	85 e0       	ldi	r24, 0x05	; 5
    1214:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
    1216:	86 e0       	ldi	r24, 0x06	; 6
    1218:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    121a:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
    121c:	3c c0       	rjmp	.+120    	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    121e:	01 30       	cpi	r16, 0x01	; 1
    1220:	11 f4       	brne	.+4      	; 0x1226 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
    1222:	89 e1       	ldi	r24, 0x19	; 25
    1224:	01 c0       	rjmp	.+2      	; 0x1228 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
    1226:	88 e1       	ldi	r24, 0x18	; 24
    1228:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    122a:	8e e1       	ldi	r24, 0x1E	; 30
    122c:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
    122e:	83 e0       	ldi	r24, 0x03	; 3
    1230:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
    1232:	84 e0       	ldi	r24, 0x04	; 4
    1234:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
    1236:	85 e0       	ldi	r24, 0x05	; 5
    1238:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
    123a:	86 e0       	ldi	r24, 0x06	; 6
    123c:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
    123e:	87 e0       	ldi	r24, 0x07	; 7
    1240:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
    1242:	88 e0       	ldi	r24, 0x08	; 8
    1244:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
    1246:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
    1248:	26 c0       	rjmp	.+76     	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	24 c0       	rjmp	.+72     	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    124e:	80 e0       	ldi	r24, 0x00	; 0
    1250:	22 c0       	rjmp	.+68     	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    1252:	81 e0       	ldi	r24, 0x01	; 1
    1254:	20 c0       	rjmp	.+64     	; 0x1296 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1256:	44 23       	and	r20, r20
    1258:	09 f4       	brne	.+2      	; 0x125c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
    125a:	5e cf       	rjmp	.-324    	; 0x1118 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
    125c:	53 cf       	rjmp	.-346    	; 0x1104 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    125e:	8d ef       	ldi	r24, 0xFD	; 253
    1260:	86 0f       	add	r24, r22
    1262:	82 30       	cpi	r24, 0x02	; 2
    1264:	08 f0       	brcs	.+2      	; 0x1268 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
    1266:	62 cf       	rjmp	.-316    	; 0x112c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
    1268:	0e c0       	rjmp	.+28     	; 0x1286 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    126a:	01 e0       	ldi	r16, 0x01	; 1
    126c:	03 c0       	rjmp	.+6      	; 0x1274 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
    126e:	00 e0       	ldi	r16, 0x00	; 0
    1270:	01 c0       	rjmp	.+2      	; 0x1274 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    1272:	01 e0       	ldi	r16, 0x01	; 1
    1274:	13 e0       	ldi	r17, 0x03	; 3
    1276:	89 cf       	rjmp	.-238    	; 0x118a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    1278:	01 e0       	ldi	r16, 0x01	; 1
    127a:	8a cf       	rjmp	.-236    	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    127c:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    127e:	10 e0       	ldi	r17, 0x00	; 0
    1280:	87 cf       	rjmp	.-242    	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    1282:	00 e0       	ldi	r16, 0x00	; 0
    1284:	85 cf       	rjmp	.-246    	; 0x1190 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1286:	4f e0       	ldi	r20, 0x0F	; 15
    1288:	6d e1       	ldi	r22, 0x1D	; 29
    128a:	ce 01       	movw	r24, r28
    128c:	01 df       	rcall	.-510    	; 0x1090 <_ZN6LSM3037testRegEhNS_7regAddrE>
    128e:	89 34       	cpi	r24, 0x49	; 73
    1290:	91 05       	cpc	r25, r1
    1292:	79 f3       	breq	.-34     	; 0x1272 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
    1294:	41 cf       	rjmp	.-382    	; 0x1118 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
    1296:	df 91       	pop	r29
    1298:	cf 91       	pop	r28
    129a:	1f 91       	pop	r17
    129c:	0f 91       	pop	r16
    129e:	08 95       	ret

000012a0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12a0:	31 e1       	ldi	r19, 0x11	; 17
    12a2:	fc 01       	movw	r30, r24
    12a4:	30 83       	st	Z, r19
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	22 e2       	ldi	r18, 0x22	; 34
    12aa:	20 83       	st	Z, r18
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	a3 e3       	ldi	r26, 0x33	; 51
    12b0:	a0 83       	st	Z, r26
    12b2:	31 97       	sbiw	r30, 0x01	; 1
    12b4:	60 83       	st	Z, r22
    12b6:	31 97       	sbiw	r30, 0x01	; 1
    12b8:	70 83       	st	Z, r23
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	10 82       	st	Z, r1
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	10 82       	st	Z, r1
    12c2:	31 97       	sbiw	r30, 0x01	; 1
    12c4:	60 e8       	ldi	r22, 0x80	; 128
    12c6:	60 83       	st	Z, r22
    12c8:	31 97       	sbiw	r30, 0x01	; 1
    12ca:	10 82       	st	Z, r1
    12cc:	31 97       	sbiw	r30, 0x01	; 1
    12ce:	10 82       	st	Z, r1
    12d0:	31 97       	sbiw	r30, 0x01	; 1
    12d2:	10 82       	st	Z, r1
    12d4:	31 97       	sbiw	r30, 0x01	; 1
    12d6:	62 e0       	ldi	r22, 0x02	; 2
    12d8:	60 83       	st	Z, r22
    12da:	31 97       	sbiw	r30, 0x01	; 1
    12dc:	63 e0       	ldi	r22, 0x03	; 3
    12de:	60 83       	st	Z, r22
    12e0:	31 97       	sbiw	r30, 0x01	; 1
    12e2:	64 e0       	ldi	r22, 0x04	; 4
    12e4:	60 83       	st	Z, r22
    12e6:	31 97       	sbiw	r30, 0x01	; 1
    12e8:	65 e0       	ldi	r22, 0x05	; 5
    12ea:	60 83       	st	Z, r22
    12ec:	31 97       	sbiw	r30, 0x01	; 1
    12ee:	66 e0       	ldi	r22, 0x06	; 6
    12f0:	60 83       	st	Z, r22
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	67 e0       	ldi	r22, 0x07	; 7
    12f6:	60 83       	st	Z, r22
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	68 e0       	ldi	r22, 0x08	; 8
    12fc:	60 83       	st	Z, r22
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	69 e0       	ldi	r22, 0x09	; 9
    1302:	60 83       	st	Z, r22
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	60 e1       	ldi	r22, 0x10	; 16
    1308:	60 83       	st	Z, r22
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	30 83       	st	Z, r19
    130e:	31 97       	sbiw	r30, 0x01	; 1
    1310:	32 e1       	ldi	r19, 0x12	; 18
    1312:	30 83       	st	Z, r19
    1314:	31 97       	sbiw	r30, 0x01	; 1
    1316:	33 e1       	ldi	r19, 0x13	; 19
    1318:	30 83       	st	Z, r19
    131a:	31 97       	sbiw	r30, 0x01	; 1
    131c:	34 e1       	ldi	r19, 0x14	; 20
    131e:	30 83       	st	Z, r19
    1320:	31 97       	sbiw	r30, 0x01	; 1
    1322:	35 e1       	ldi	r19, 0x15	; 21
    1324:	30 83       	st	Z, r19
    1326:	31 97       	sbiw	r30, 0x01	; 1
    1328:	36 e1       	ldi	r19, 0x16	; 22
    132a:	30 83       	st	Z, r19
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	37 e1       	ldi	r19, 0x17	; 23
    1330:	30 83       	st	Z, r19
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	38 e1       	ldi	r19, 0x18	; 24
    1336:	30 83       	st	Z, r19
    1338:	31 97       	sbiw	r30, 0x01	; 1
    133a:	39 e1       	ldi	r19, 0x19	; 25
    133c:	30 83       	st	Z, r19
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	30 e2       	ldi	r19, 0x20	; 32
    1342:	30 83       	st	Z, r19
    1344:	31 97       	sbiw	r30, 0x01	; 1
    1346:	31 e2       	ldi	r19, 0x21	; 33
    1348:	30 83       	st	Z, r19
    134a:	31 97       	sbiw	r30, 0x01	; 1
    134c:	20 83       	st	Z, r18
    134e:	31 97       	sbiw	r30, 0x01	; 1
    1350:	23 e2       	ldi	r18, 0x23	; 35
    1352:	20 83       	st	Z, r18
    1354:	31 97       	sbiw	r30, 0x01	; 1
    1356:	40 83       	st	Z, r20
    1358:	31 97       	sbiw	r30, 0x01	; 1
    135a:	50 83       	st	Z, r21
    135c:	31 97       	sbiw	r30, 0x01	; 1
    135e:	26 e2       	ldi	r18, 0x26	; 38
    1360:	20 83       	st	Z, r18
    1362:	31 97       	sbiw	r30, 0x01	; 1
    1364:	27 e2       	ldi	r18, 0x27	; 39
    1366:	20 83       	st	Z, r18
    1368:	31 97       	sbiw	r30, 0x01	; 1
    136a:	28 e2       	ldi	r18, 0x28	; 40
    136c:	20 83       	st	Z, r18
    136e:	31 97       	sbiw	r30, 0x01	; 1
    1370:	29 e2       	ldi	r18, 0x29	; 41
    1372:	20 83       	st	Z, r18
    1374:	31 97       	sbiw	r30, 0x01	; 1
    1376:	20 e3       	ldi	r18, 0x30	; 48
    1378:	20 83       	st	Z, r18
    137a:	31 97       	sbiw	r30, 0x01	; 1
    137c:	21 e3       	ldi	r18, 0x31	; 49
    137e:	20 83       	st	Z, r18
    1380:	89 97       	sbiw	r24, 0x29	; 41
    1382:	08 95       	ret

00001384 <xPortStartScheduler>:
    1384:	82 e0       	ldi	r24, 0x02	; 2
    1386:	80 93 b0 00 	sts	0x00B0, r24
    138a:	10 92 b2 00 	sts	0x00B2, r1
    138e:	8a ef       	ldi	r24, 0xFA	; 250
    1390:	80 93 b3 00 	sts	0x00B3, r24
    1394:	e0 e7       	ldi	r30, 0x70	; 112
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	80 81       	ld	r24, Z
    139a:	82 60       	ori	r24, 0x02	; 2
    139c:	80 83       	st	Z, r24
    139e:	84 e0       	ldi	r24, 0x04	; 4
    13a0:	80 93 b1 00 	sts	0x00B1, r24
    13a4:	a0 91 e5 08 	lds	r26, 0x08E5
    13a8:	b0 91 e6 08 	lds	r27, 0x08E6
    13ac:	cd 91       	ld	r28, X+
    13ae:	cd bf       	out	0x3d, r28	; 61
    13b0:	dd 91       	ld	r29, X+
    13b2:	de bf       	out	0x3e, r29	; 62
    13b4:	ff 91       	pop	r31
    13b6:	ef 91       	pop	r30
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	bf 91       	pop	r27
    13be:	af 91       	pop	r26
    13c0:	9f 91       	pop	r25
    13c2:	8f 91       	pop	r24
    13c4:	7f 91       	pop	r23
    13c6:	6f 91       	pop	r22
    13c8:	5f 91       	pop	r21
    13ca:	4f 91       	pop	r20
    13cc:	3f 91       	pop	r19
    13ce:	2f 91       	pop	r18
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	ff 90       	pop	r15
    13d6:	ef 90       	pop	r14
    13d8:	df 90       	pop	r13
    13da:	cf 90       	pop	r12
    13dc:	bf 90       	pop	r11
    13de:	af 90       	pop	r10
    13e0:	9f 90       	pop	r9
    13e2:	8f 90       	pop	r8
    13e4:	7f 90       	pop	r7
    13e6:	6f 90       	pop	r6
    13e8:	5f 90       	pop	r5
    13ea:	4f 90       	pop	r4
    13ec:	3f 90       	pop	r3
    13ee:	2f 90       	pop	r2
    13f0:	1f 90       	pop	r1
    13f2:	0f 90       	pop	r0
    13f4:	0c be       	out	0x3c, r0	; 60
    13f6:	0f 90       	pop	r0
    13f8:	0b be       	out	0x3b, r0	; 59
    13fa:	0f 90       	pop	r0
    13fc:	0f be       	out	0x3f, r0	; 63
    13fe:	0f 90       	pop	r0
    1400:	08 95       	ret
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	08 95       	ret

00001406 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1406:	0f 92       	push	r0
    1408:	0f b6       	in	r0, 0x3f	; 63
    140a:	f8 94       	cli
    140c:	0f 92       	push	r0
    140e:	0c b6       	in	r0, 0x3c	; 60
    1410:	0f 92       	push	r0
    1412:	0b b6       	in	r0, 0x3b	; 59
    1414:	0f 92       	push	r0
    1416:	1f 92       	push	r1
    1418:	11 24       	eor	r1, r1
    141a:	2f 92       	push	r2
    141c:	3f 92       	push	r3
    141e:	4f 92       	push	r4
    1420:	5f 92       	push	r5
    1422:	6f 92       	push	r6
    1424:	7f 92       	push	r7
    1426:	8f 92       	push	r8
    1428:	9f 92       	push	r9
    142a:	af 92       	push	r10
    142c:	bf 92       	push	r11
    142e:	cf 92       	push	r12
    1430:	df 92       	push	r13
    1432:	ef 92       	push	r14
    1434:	ff 92       	push	r15
    1436:	0f 93       	push	r16
    1438:	1f 93       	push	r17
    143a:	2f 93       	push	r18
    143c:	3f 93       	push	r19
    143e:	4f 93       	push	r20
    1440:	5f 93       	push	r21
    1442:	6f 93       	push	r22
    1444:	7f 93       	push	r23
    1446:	8f 93       	push	r24
    1448:	9f 93       	push	r25
    144a:	af 93       	push	r26
    144c:	bf 93       	push	r27
    144e:	cf 93       	push	r28
    1450:	df 93       	push	r29
    1452:	ef 93       	push	r30
    1454:	ff 93       	push	r31
    1456:	a0 91 e5 08 	lds	r26, 0x08E5
    145a:	b0 91 e6 08 	lds	r27, 0x08E6
    145e:	0d b6       	in	r0, 0x3d	; 61
    1460:	0d 92       	st	X+, r0
    1462:	0e b6       	in	r0, 0x3e	; 62
    1464:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1466:	39 d6       	rcall	.+3186   	; 0x20da <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1468:	a0 91 e5 08 	lds	r26, 0x08E5
    146c:	b0 91 e6 08 	lds	r27, 0x08E6
    1470:	cd 91       	ld	r28, X+
    1472:	cd bf       	out	0x3d, r28	; 61
    1474:	dd 91       	ld	r29, X+
    1476:	de bf       	out	0x3e, r29	; 62
    1478:	ff 91       	pop	r31
    147a:	ef 91       	pop	r30
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	bf 91       	pop	r27
    1482:	af 91       	pop	r26
    1484:	9f 91       	pop	r25
    1486:	8f 91       	pop	r24
    1488:	7f 91       	pop	r23
    148a:	6f 91       	pop	r22
    148c:	5f 91       	pop	r21
    148e:	4f 91       	pop	r20
    1490:	3f 91       	pop	r19
    1492:	2f 91       	pop	r18
    1494:	1f 91       	pop	r17
    1496:	0f 91       	pop	r16
    1498:	ff 90       	pop	r15
    149a:	ef 90       	pop	r14
    149c:	df 90       	pop	r13
    149e:	cf 90       	pop	r12
    14a0:	bf 90       	pop	r11
    14a2:	af 90       	pop	r10
    14a4:	9f 90       	pop	r9
    14a6:	8f 90       	pop	r8
    14a8:	7f 90       	pop	r7
    14aa:	6f 90       	pop	r6
    14ac:	5f 90       	pop	r5
    14ae:	4f 90       	pop	r4
    14b0:	3f 90       	pop	r3
    14b2:	2f 90       	pop	r2
    14b4:	1f 90       	pop	r1
    14b6:	0f 90       	pop	r0
    14b8:	0c be       	out	0x3c, r0	; 60
    14ba:	0f 90       	pop	r0
    14bc:	0b be       	out	0x3b, r0	; 59
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
    14c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14c4:	08 95       	ret

000014c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14c6:	0f 92       	push	r0
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	0f 92       	push	r0
    14ce:	0c b6       	in	r0, 0x3c	; 60
    14d0:	0f 92       	push	r0
    14d2:	0b b6       	in	r0, 0x3b	; 59
    14d4:	0f 92       	push	r0
    14d6:	1f 92       	push	r1
    14d8:	11 24       	eor	r1, r1
    14da:	2f 92       	push	r2
    14dc:	3f 92       	push	r3
    14de:	4f 92       	push	r4
    14e0:	5f 92       	push	r5
    14e2:	6f 92       	push	r6
    14e4:	7f 92       	push	r7
    14e6:	8f 92       	push	r8
    14e8:	9f 92       	push	r9
    14ea:	af 92       	push	r10
    14ec:	bf 92       	push	r11
    14ee:	cf 92       	push	r12
    14f0:	df 92       	push	r13
    14f2:	ef 92       	push	r14
    14f4:	ff 92       	push	r15
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	2f 93       	push	r18
    14fc:	3f 93       	push	r19
    14fe:	4f 93       	push	r20
    1500:	5f 93       	push	r21
    1502:	6f 93       	push	r22
    1504:	7f 93       	push	r23
    1506:	8f 93       	push	r24
    1508:	9f 93       	push	r25
    150a:	af 93       	push	r26
    150c:	bf 93       	push	r27
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	ef 93       	push	r30
    1514:	ff 93       	push	r31
    1516:	a0 91 e5 08 	lds	r26, 0x08E5
    151a:	b0 91 e6 08 	lds	r27, 0x08E6
    151e:	0d b6       	in	r0, 0x3d	; 61
    1520:	0d 92       	st	X+, r0
    1522:	0e b6       	in	r0, 0x3e	; 62
    1524:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1526:	45 d4       	rcall	.+2186   	; 0x1db2 <xTaskIncrementTick>
    1528:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    152a:	d7 d5       	rcall	.+2990   	; 0x20da <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    152c:	a0 91 e5 08 	lds	r26, 0x08E5
    1530:	b0 91 e6 08 	lds	r27, 0x08E6
    1534:	cd 91       	ld	r28, X+
    1536:	cd bf       	out	0x3d, r28	; 61
    1538:	dd 91       	ld	r29, X+
    153a:	de bf       	out	0x3e, r29	; 62
    153c:	ff 91       	pop	r31
    153e:	ef 91       	pop	r30
    1540:	df 91       	pop	r29
    1542:	cf 91       	pop	r28
    1544:	bf 91       	pop	r27
    1546:	af 91       	pop	r26
    1548:	9f 91       	pop	r25
    154a:	8f 91       	pop	r24
    154c:	7f 91       	pop	r23
    154e:	6f 91       	pop	r22
    1550:	5f 91       	pop	r21
    1552:	4f 91       	pop	r20
    1554:	3f 91       	pop	r19
    1556:	2f 91       	pop	r18
    1558:	1f 91       	pop	r17
    155a:	0f 91       	pop	r16
    155c:	ff 90       	pop	r15
    155e:	ef 90       	pop	r14
    1560:	df 90       	pop	r13
    1562:	cf 90       	pop	r12
    1564:	bf 90       	pop	r11
    1566:	af 90       	pop	r10
    1568:	9f 90       	pop	r9
    156a:	8f 90       	pop	r8
    156c:	7f 90       	pop	r7
    156e:	6f 90       	pop	r6
    1570:	5f 90       	pop	r5
    1572:	4f 90       	pop	r4
    1574:	3f 90       	pop	r3
    1576:	2f 90       	pop	r2
    1578:	1f 90       	pop	r1
    157a:	0f 90       	pop	r0
    157c:	0c be       	out	0x3c, r0	; 60
    157e:	0f 90       	pop	r0
    1580:	0b be       	out	0x3b, r0	; 59
    1582:	0f 90       	pop	r0
    1584:	0f be       	out	0x3f, r0	; 63
    1586:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1588:	08 95       	ret

0000158a <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    158a:	9d df       	rcall	.-198    	; 0x14c6 <vPortYieldFromTick>
	asm volatile ( "reti" );
    158c:	18 95       	reti

0000158e <_Z13taskReadSonarPv>:
			Serial.println(data[i]);
		}
		
		vTaskDelay(1000);
		
	}
    158e:	0f 2e       	mov	r0, r31
    1590:	fb e0       	ldi	r31, 0x0B	; 11
    1592:	ef 2e       	mov	r14, r31
    1594:	f2 e0       	ldi	r31, 0x02	; 2
    1596:	ff 2e       	mov	r15, r31
    1598:	f0 2d       	mov	r31, r0
    159a:	0f 2e       	mov	r0, r31
    159c:	fd e0       	ldi	r31, 0x0D	; 13
    159e:	cf 2e       	mov	r12, r31
    15a0:	f2 e0       	ldi	r31, 0x02	; 2
    15a2:	df 2e       	mov	r13, r31
    15a4:	f0 2d       	mov	r31, r0
    15a6:	0f 2e       	mov	r0, r31
    15a8:	fc e5       	ldi	r31, 0x5C	; 92
    15aa:	8f 2e       	mov	r8, r31
    15ac:	f8 e0       	ldi	r31, 0x08	; 8
    15ae:	9f 2e       	mov	r9, r31
    15b0:	f0 2d       	mov	r31, r0
    15b2:	07 e0       	ldi	r16, 0x07	; 7
    15b4:	12 e0       	ldi	r17, 0x02	; 2
    15b6:	0f 2e       	mov	r0, r31
    15b8:	f9 e0       	ldi	r31, 0x09	; 9
    15ba:	af 2e       	mov	r10, r31
    15bc:	f2 e0       	ldi	r31, 0x02	; 2
    15be:	bf 2e       	mov	r11, r31
    15c0:	f0 2d       	mov	r31, r0
    15c2:	0f 2e       	mov	r0, r31
    15c4:	fe e5       	ldi	r31, 0x5E	; 94
    15c6:	6f 2e       	mov	r6, r31
    15c8:	f8 e0       	ldi	r31, 0x08	; 8
    15ca:	7f 2e       	mov	r7, r31
    15cc:	f0 2d       	mov	r31, r0
    15ce:	c3 e0       	ldi	r28, 0x03	; 3
    15d0:	d2 e0       	ldi	r29, 0x02	; 2
    15d2:	0f 2e       	mov	r0, r31
    15d4:	f5 e0       	ldi	r31, 0x05	; 5
    15d6:	4f 2e       	mov	r4, r31
    15d8:	f2 e0       	ldi	r31, 0x02	; 2
    15da:	5f 2e       	mov	r5, r31
    15dc:	f0 2d       	mov	r31, r0
    15de:	0f 2e       	mov	r0, r31
    15e0:	f0 e6       	ldi	r31, 0x60	; 96
    15e2:	2f 2e       	mov	r2, r31
    15e4:	f8 e0       	ldi	r31, 0x08	; 8
    15e6:	3f 2e       	mov	r3, r31
    15e8:	f0 2d       	mov	r31, r0
    15ea:	dd d3       	rcall	.+1978   	; 0x1da6 <vTaskSuspendAll>
    15ec:	60 e0       	ldi	r22, 0x00	; 0
    15ee:	f7 01       	movw	r30, r14
    15f0:	80 81       	ld	r24, Z
    15f2:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    15f6:	85 e0       	ldi	r24, 0x05	; 5
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <delayMicroseconds>
    15fe:	61 e0       	ldi	r22, 0x01	; 1
    1600:	f7 01       	movw	r30, r14
    1602:	80 81       	ld	r24, Z
    1604:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    1608:	8a e0       	ldi	r24, 0x0A	; 10
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <delayMicroseconds>
    1610:	60 e0       	ldi	r22, 0x00	; 0
    1612:	f7 01       	movw	r30, r14
    1614:	80 81       	ld	r24, Z
    1616:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    161a:	60 e0       	ldi	r22, 0x00	; 0
    161c:	f6 01       	movw	r30, r12
    161e:	80 81       	ld	r24, Z
    1620:	0e 94 3d 1b 	call	0x367a	; 0x367a <pinMode>
    1624:	20 e4       	ldi	r18, 0x40	; 64
    1626:	32 e4       	ldi	r19, 0x42	; 66
    1628:	4f e0       	ldi	r20, 0x0F	; 15
    162a:	50 e0       	ldi	r21, 0x00	; 0
    162c:	61 e0       	ldi	r22, 0x01	; 1
    162e:	f6 01       	movw	r30, r12
    1630:	80 81       	ld	r24, Z
    1632:	0e 94 ab 1b 	call	0x3756	; 0x3756 <pulseIn>
    1636:	9b 01       	movw	r18, r22
    1638:	77 23       	and	r23, r23
    163a:	14 f4       	brge	.+4      	; 0x1640 <_Z13taskReadSonarPv+0xb2>
    163c:	2f 5f       	subi	r18, 0xFF	; 255
    163e:	3f 4f       	sbci	r19, 0xFF	; 255
    1640:	b9 01       	movw	r22, r18
    1642:	75 95       	asr	r23
    1644:	67 95       	ror	r22
    1646:	88 27       	eor	r24, r24
    1648:	77 fd       	sbrc	r23, 7
    164a:	80 95       	com	r24
    164c:	98 2f       	mov	r25, r24
    164e:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
    1652:	2d ec       	ldi	r18, 0xCD	; 205
    1654:	3c ec       	ldi	r19, 0xCC	; 204
    1656:	48 ee       	ldi	r20, 0xE8	; 232
    1658:	51 e4       	ldi	r21, 0x41	; 65
    165a:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
    165e:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fixsfsi>
    1662:	f4 01       	movw	r30, r8
    1664:	71 83       	std	Z+1, r23	; 0x01
    1666:	60 83       	st	Z, r22
    1668:	60 e0       	ldi	r22, 0x00	; 0
    166a:	f8 01       	movw	r30, r16
    166c:	80 81       	ld	r24, Z
    166e:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    1672:	85 e0       	ldi	r24, 0x05	; 5
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <delayMicroseconds>
    167a:	61 e0       	ldi	r22, 0x01	; 1
    167c:	f8 01       	movw	r30, r16
    167e:	80 81       	ld	r24, Z
    1680:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    1684:	8a e0       	ldi	r24, 0x0A	; 10
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <delayMicroseconds>
    168c:	60 e0       	ldi	r22, 0x00	; 0
    168e:	f8 01       	movw	r30, r16
    1690:	80 81       	ld	r24, Z
    1692:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    1696:	20 e4       	ldi	r18, 0x40	; 64
    1698:	32 e4       	ldi	r19, 0x42	; 66
    169a:	4f e0       	ldi	r20, 0x0F	; 15
    169c:	50 e0       	ldi	r21, 0x00	; 0
    169e:	61 e0       	ldi	r22, 0x01	; 1
    16a0:	f5 01       	movw	r30, r10
    16a2:	80 81       	ld	r24, Z
    16a4:	0e 94 ab 1b 	call	0x3756	; 0x3756 <pulseIn>
    16a8:	9b 01       	movw	r18, r22
    16aa:	77 23       	and	r23, r23
    16ac:	14 f4       	brge	.+4      	; 0x16b2 <_Z13taskReadSonarPv+0x124>
    16ae:	2f 5f       	subi	r18, 0xFF	; 255
    16b0:	3f 4f       	sbci	r19, 0xFF	; 255
    16b2:	b9 01       	movw	r22, r18
    16b4:	75 95       	asr	r23
    16b6:	67 95       	ror	r22
    16b8:	88 27       	eor	r24, r24
    16ba:	77 fd       	sbrc	r23, 7
    16bc:	80 95       	com	r24
    16be:	98 2f       	mov	r25, r24
    16c0:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
    16c4:	2d ec       	ldi	r18, 0xCD	; 205
    16c6:	3c ec       	ldi	r19, 0xCC	; 204
    16c8:	48 ee       	ldi	r20, 0xE8	; 232
    16ca:	51 e4       	ldi	r21, 0x41	; 65
    16cc:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
    16d0:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fixsfsi>
    16d4:	f3 01       	movw	r30, r6
    16d6:	71 83       	std	Z+1, r23	; 0x01
    16d8:	60 83       	st	Z, r22
    16da:	60 e0       	ldi	r22, 0x00	; 0
    16dc:	88 81       	ld	r24, Y
    16de:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    16e2:	85 e0       	ldi	r24, 0x05	; 5
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <delayMicroseconds>
    16ea:	61 e0       	ldi	r22, 0x01	; 1
    16ec:	88 81       	ld	r24, Y
    16ee:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    16f2:	8a e0       	ldi	r24, 0x0A	; 10
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <delayMicroseconds>
    16fa:	60 e0       	ldi	r22, 0x00	; 0
    16fc:	88 81       	ld	r24, Y
    16fe:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    1702:	20 e4       	ldi	r18, 0x40	; 64
    1704:	32 e4       	ldi	r19, 0x42	; 66
    1706:	4f e0       	ldi	r20, 0x0F	; 15
    1708:	50 e0       	ldi	r21, 0x00	; 0
    170a:	61 e0       	ldi	r22, 0x01	; 1
    170c:	f2 01       	movw	r30, r4
    170e:	80 81       	ld	r24, Z
    1710:	0e 94 ab 1b 	call	0x3756	; 0x3756 <pulseIn>
    1714:	9b 01       	movw	r18, r22
    1716:	77 23       	and	r23, r23
    1718:	14 f4       	brge	.+4      	; 0x171e <_Z13taskReadSonarPv+0x190>
    171a:	2f 5f       	subi	r18, 0xFF	; 255
    171c:	3f 4f       	sbci	r19, 0xFF	; 255
    171e:	b9 01       	movw	r22, r18
    1720:	75 95       	asr	r23
    1722:	67 95       	ror	r22
    1724:	88 27       	eor	r24, r24
    1726:	77 fd       	sbrc	r23, 7
    1728:	80 95       	com	r24
    172a:	98 2f       	mov	r25, r24
    172c:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
    1730:	2d ec       	ldi	r18, 0xCD	; 205
    1732:	3c ec       	ldi	r19, 0xCC	; 204
    1734:	48 ee       	ldi	r20, 0xE8	; 232
    1736:	51 e4       	ldi	r21, 0x41	; 65
    1738:	0e 94 81 14 	call	0x2902	; 0x2902 <__divsf3>
    173c:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fixsfsi>
    1740:	f1 01       	movw	r30, r2
    1742:	71 83       	std	Z+1, r23	; 0x01
    1744:	60 83       	st	Z, r22
    1746:	f3 d3       	rcall	.+2022   	; 0x1f2e <xTaskResumeAll>
    1748:	84 ef       	ldi	r24, 0xF4	; 244
    174a:	91 e0       	ldi	r25, 0x01	; 1
    174c:	71 d4       	rcall	.+2274   	; 0x2030 <vTaskDelay>
    174e:	4d cf       	rjmp	.-358    	; 0x15ea <_Z13taskReadSonarPv+0x5c>

00001750 <_Z11taskReadAccPv>:
    1750:	c1 2c       	mov	r12, r1
    1752:	d1 2c       	mov	r13, r1
    1754:	76 01       	movw	r14, r12
    1756:	00 e0       	ldi	r16, 0x00	; 0
    1758:	10 e0       	ldi	r17, 0x00	; 0
    175a:	c8 ee       	ldi	r28, 0xE8	; 232
    175c:	d3 e0       	ldi	r29, 0x03	; 3
    175e:	0f 2e       	mov	r0, r31
    1760:	f8 e6       	ldi	r31, 0x68	; 104
    1762:	af 2e       	mov	r10, r31
    1764:	f8 e0       	ldi	r31, 0x08	; 8
    1766:	bf 2e       	mov	r11, r31
    1768:	f0 2d       	mov	r31, r0
    176a:	0f 2e       	mov	r0, r31
    176c:	fa e6       	ldi	r31, 0x6A	; 106
    176e:	8f 2e       	mov	r8, r31
    1770:	f8 e0       	ldi	r31, 0x08	; 8
    1772:	9f 2e       	mov	r9, r31
    1774:	f0 2d       	mov	r31, r0
    1776:	55 24       	eor	r5, r5
    1778:	53 94       	inc	r5
    177a:	41 2c       	mov	r4, r1
    177c:	0f 2e       	mov	r0, r31
    177e:	f2 e6       	ldi	r31, 0x62	; 98
    1780:	2f 2e       	mov	r2, r31
    1782:	f8 e0       	ldi	r31, 0x08	; 8
    1784:	3f 2e       	mov	r3, r31
    1786:	f0 2d       	mov	r31, r0
    1788:	0f 2e       	mov	r0, r31
    178a:	f4 e6       	ldi	r31, 0x64	; 100
    178c:	6f 2e       	mov	r6, r31
    178e:	f8 e0       	ldi	r31, 0x08	; 8
    1790:	7f 2e       	mov	r7, r31
    1792:	f0 2d       	mov	r31, r0
    1794:	08 d3       	rcall	.+1552   	; 0x1da6 <vTaskSuspendAll>
    1796:	86 e6       	ldi	r24, 0x66	; 102
    1798:	98 e0       	ldi	r25, 0x08	; 8
    179a:	71 dc       	rcall	.-1822   	; 0x107e <_ZN6LSM3034readEv>
    179c:	c8 d3       	rcall	.+1936   	; 0x1f2e <xTaskResumeAll>
    179e:	80 91 66 08 	lds	r24, 0x0866
    17a2:	90 91 67 08 	lds	r25, 0x0867
    17a6:	be 01       	movw	r22, r28
    17a8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__divmodhi4>
    17ac:	fb 01       	movw	r30, r22
    17ae:	d5 01       	movw	r26, r10
    17b0:	8d 91       	ld	r24, X+
    17b2:	9c 91       	ld	r25, X
    17b4:	be 01       	movw	r22, r28
    17b6:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__divmodhi4>
    17ba:	9b 01       	movw	r18, r22
    17bc:	d4 01       	movw	r26, r8
    17be:	8d 91       	ld	r24, X+
    17c0:	9c 91       	ld	r25, X
    17c2:	be 01       	movw	r22, r28
    17c4:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__divmodhi4>
    17c8:	ee 9f       	mul	r30, r30
    17ca:	c0 01       	movw	r24, r0
    17cc:	ef 9f       	mul	r30, r31
    17ce:	90 0d       	add	r25, r0
    17d0:	90 0d       	add	r25, r0
    17d2:	11 24       	eor	r1, r1
    17d4:	22 9f       	mul	r18, r18
    17d6:	a0 01       	movw	r20, r0
    17d8:	23 9f       	mul	r18, r19
    17da:	50 0d       	add	r21, r0
    17dc:	50 0d       	add	r21, r0
    17de:	11 24       	eor	r1, r1
    17e0:	84 0f       	add	r24, r20
    17e2:	95 1f       	adc	r25, r21
    17e4:	66 9f       	mul	r22, r22
    17e6:	90 01       	movw	r18, r0
    17e8:	67 9f       	mul	r22, r23
    17ea:	30 0d       	add	r19, r0
    17ec:	30 0d       	add	r19, r0
    17ee:	11 24       	eor	r1, r1
    17f0:	82 0f       	add	r24, r18
    17f2:	93 1f       	adc	r25, r19
    17f4:	bc 01       	movw	r22, r24
    17f6:	88 27       	eor	r24, r24
    17f8:	77 fd       	sbrc	r23, 7
    17fa:	80 95       	com	r24
    17fc:	98 2f       	mov	r25, r24
    17fe:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <__floatsisf>
    1802:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <sqrt>
    1806:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fixsfsi>
    180a:	01 15       	cp	r16, r1
    180c:	11 05       	cpc	r17, r1
    180e:	11 f4       	brne	.+4      	; 0x1814 <_Z11taskReadAccPv+0xc4>
    1810:	05 2d       	mov	r16, r5
    1812:	14 2d       	mov	r17, r4
    1814:	cb 01       	movw	r24, r22
    1816:	0d 97       	sbiw	r24, 0x0d	; 13
    1818:	06 97       	sbiw	r24, 0x06	; 6
    181a:	a8 f0       	brcs	.+42     	; 0x1846 <_Z11taskReadAccPv+0xf6>
    181c:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <millis>
    1820:	dc 01       	movw	r26, r24
    1822:	cb 01       	movw	r24, r22
    1824:	8c 19       	sub	r24, r12
    1826:	9d 09       	sbc	r25, r13
    1828:	ae 09       	sbc	r26, r14
    182a:	bf 09       	sbc	r27, r15
    182c:	89 3e       	cpi	r24, 0xE9	; 233
    182e:	93 40       	sbci	r25, 0x03	; 3
    1830:	a1 05       	cpc	r26, r1
    1832:	b1 05       	cpc	r27, r1
    1834:	40 f0       	brcs	.+16     	; 0x1846 <_Z11taskReadAccPv+0xf6>
    1836:	d1 01       	movw	r26, r2
    1838:	5c 92       	st	X, r5
    183a:	11 96       	adiw	r26, 0x01	; 1
    183c:	4c 92       	st	X, r4
    183e:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <millis>
    1842:	6b 01       	movw	r12, r22
    1844:	7c 01       	movw	r14, r24
    1846:	86 e6       	ldi	r24, 0x66	; 102
    1848:	98 e0       	ldi	r25, 0x08	; 8
    184a:	2a da       	rcall	.-2988   	; 0xca0 <_ZN6LSM3037headingEv>
    184c:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__fixsfsi>
    1850:	f3 01       	movw	r30, r6
    1852:	71 83       	std	Z+1, r23	; 0x01
    1854:	60 83       	st	Z, r22
    1856:	88 ec       	ldi	r24, 0xC8	; 200
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	ea d3       	rcall	.+2004   	; 0x2030 <vTaskDelay>
    185c:	9b cf       	rjmp	.-202    	; 0x1794 <_Z11taskReadAccPv+0x44>

0000185e <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    185e:	26 e0       	ldi	r18, 0x06	; 6
    1860:	40 e8       	ldi	r20, 0x80	; 128
    1862:	55 e2       	ldi	r21, 0x25	; 37
    1864:	60 e0       	ldi	r22, 0x00	; 0
    1866:	70 e0       	ldi	r23, 0x00	; 0
    1868:	84 e4       	ldi	r24, 0x44	; 68
    186a:	9a e0       	ldi	r25, 0x0A	; 10
    186c:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <_ZN14HardwareSerial5beginEmh>
{
	// Starting up serial monitor
	Serial1.begin(9600);
	//Serial1.begin(9600);
	// Setting up compass
	Wire.begin();
    1870:	85 e5       	ldi	r24, 0x55	; 85
    1872:	99 e0       	ldi	r25, 0x09	; 9
    1874:	3f d7       	rcall	.+3710   	; 0x26f4 <_ZN7TwoWire5beginEv>
	compass.init();
    1876:	42 e0       	ldi	r20, 0x02	; 2
    1878:	64 e0       	ldi	r22, 0x04	; 4
    187a:	86 e6       	ldi	r24, 0x66	; 102
    187c:	98 e0       	ldi	r25, 0x08	; 8
    187e:	34 dc       	rcall	.-1944   	; 0x10e8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    1880:	86 e6       	ldi	r24, 0x66	; 102
    1882:	98 e0       	ldi	r25, 0x08	; 8
    1884:	8b da       	rcall	.-2794   	; 0xd9c <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    1886:	86 e0       	ldi	r24, 0x06	; 6
    1888:	ed e1       	ldi	r30, 0x1D	; 29
    188a:	f2 e0       	ldi	r31, 0x02	; 2
    188c:	a8 e7       	ldi	r26, 0x78	; 120
    188e:	b8 e0       	ldi	r27, 0x08	; 8
    1890:	01 90       	ld	r0, Z+
    1892:	0d 92       	st	X+, r0
    1894:	8a 95       	dec	r24
    1896:	e1 f7       	brne	.-8      	; 0x1890 <setup+0x32>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    1898:	86 e0       	ldi	r24, 0x06	; 6
    189a:	e3 e2       	ldi	r30, 0x23	; 35
    189c:	f2 e0       	ldi	r31, 0x02	; 2
    189e:	a2 e7       	ldi	r26, 0x72	; 114
    18a0:	b8 e0       	ldi	r27, 0x08	; 8
    18a2:	01 90       	ld	r0, Z+
    18a4:	0d 92       	st	X+, r0
    18a6:	8a 95       	dec	r24
    18a8:	e1 f7       	brne	.-8      	; 0x18a2 <setup+0x44>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    18aa:	61 e0       	ldi	r22, 0x01	; 1
    18ac:	80 91 0b 02 	lds	r24, 0x020B
    18b0:	0e 94 3d 1b 	call	0x367a	; 0x367a <pinMode>
	pinMode(echo_1, INPUT);
    18b4:	60 e0       	ldi	r22, 0x00	; 0
    18b6:	80 91 0d 02 	lds	r24, 0x020D
    18ba:	0e 94 3d 1b 	call	0x367a	; 0x367a <pinMode>
	pinMode(echo_2, INPUT);
    18be:	60 e0       	ldi	r22, 0x00	; 0
    18c0:	80 91 09 02 	lds	r24, 0x0209
    18c4:	0e 94 3d 1b 	call	0x367a	; 0x367a <pinMode>
	pinMode(trigger_2, OUTPUT);
    18c8:	61 e0       	ldi	r22, 0x01	; 1
    18ca:	80 91 07 02 	lds	r24, 0x0207
    18ce:	0e 94 3d 1b 	call	0x367a	; 0x367a <pinMode>
	pinMode(echo_3, INPUT);
    18d2:	60 e0       	ldi	r22, 0x00	; 0
    18d4:	80 91 05 02 	lds	r24, 0x0205
    18d8:	0e 94 3d 1b 	call	0x367a	; 0x367a <pinMode>
	pinMode(trigger_3, OUTPUT);
    18dc:	61 e0       	ldi	r22, 0x01	; 1
    18de:	80 91 03 02 	lds	r24, 0x0203
    18e2:	0c 94 3d 1b 	jmp	0x367a	; 0x367a <pinMode>
    18e6:	08 95       	ret

000018e8 <main>:
}

int main(void)
{
    18e8:	af 92       	push	r10
    18ea:	bf 92       	push	r11
    18ec:	cf 92       	push	r12
    18ee:	df 92       	push	r13
    18f0:	ef 92       	push	r14
    18f2:	ff 92       	push	r15
    18f4:	0f 93       	push	r16
    18f6:	cf 93       	push	r28
    18f8:	df 93       	push	r29
    18fa:	00 d0       	rcall	.+0      	; 0x18fc <main+0x14>
    18fc:	00 d0       	rcall	.+0      	; 0x18fe <main+0x16>
    18fe:	cd b7       	in	r28, 0x3d	; 61
    1900:	de b7       	in	r29, 0x3e	; 62
	init();
    1902:	0e 94 75 1a 	call	0x34ea	; 0x34ea <init>
	setup();
    1906:	ab df       	rcall	.-170    	; 0x185e <setup>
	TaskHandle_t t1, t2, t3;
	// Create tasks
	xTaskCreate(handShake, "Handshake", STACK_DEPTH, NULL, 10, &t1);
    1908:	a1 2c       	mov	r10, r1
    190a:	b1 2c       	mov	r11, r1
    190c:	c1 2c       	mov	r12, r1
    190e:	d1 2c       	mov	r13, r1
    1910:	ce 01       	movw	r24, r28
    1912:	05 96       	adiw	r24, 0x05	; 5
    1914:	7c 01       	movw	r14, r24
    1916:	0a e0       	ldi	r16, 0x0A	; 10
    1918:	20 e0       	ldi	r18, 0x00	; 0
    191a:	30 e0       	ldi	r19, 0x00	; 0
    191c:	40 ea       	ldi	r20, 0xA0	; 160
    191e:	50 e0       	ldi	r21, 0x00	; 0
    1920:	69 e2       	ldi	r22, 0x29	; 41
    1922:	72 e0       	ldi	r23, 0x02	; 2
    1924:	87 ec       	ldi	r24, 0xC7	; 199
    1926:	9c e0       	ldi	r25, 0x0C	; 12
    1928:	0d d1       	rcall	.+538    	; 0x1b44 <xTaskGenericCreate>
	//xTaskCreate(printArray, "printA", STACK_DEPTH, NULL, 10, &t1);
	xTaskCreate(taskReadAcc, "Read Accelerometer", 250, NULL, 9, &t2);
    192a:	ce 01       	movw	r24, r28
    192c:	03 96       	adiw	r24, 0x03	; 3
    192e:	7c 01       	movw	r14, r24
    1930:	09 e0       	ldi	r16, 0x09	; 9
    1932:	20 e0       	ldi	r18, 0x00	; 0
    1934:	30 e0       	ldi	r19, 0x00	; 0
    1936:	4a ef       	ldi	r20, 0xFA	; 250
    1938:	50 e0       	ldi	r21, 0x00	; 0
    193a:	63 e3       	ldi	r22, 0x33	; 51
    193c:	72 e0       	ldi	r23, 0x02	; 2
    193e:	88 ea       	ldi	r24, 0xA8	; 168
    1940:	9b e0       	ldi	r25, 0x0B	; 11
    1942:	00 d1       	rcall	.+512    	; 0x1b44 <xTaskGenericCreate>
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 7, &t3);
    1944:	ce 01       	movw	r24, r28
    1946:	01 96       	adiw	r24, 0x01	; 1
    1948:	7c 01       	movw	r14, r24
    194a:	07 e0       	ldi	r16, 0x07	; 7
    194c:	20 e0       	ldi	r18, 0x00	; 0
    194e:	30 e0       	ldi	r19, 0x00	; 0
    1950:	40 ea       	ldi	r20, 0xA0	; 160
    1952:	50 e0       	ldi	r21, 0x00	; 0
    1954:	66 e4       	ldi	r22, 0x46	; 70
    1956:	72 e0       	ldi	r23, 0x02	; 2
    1958:	87 ec       	ldi	r24, 0xC7	; 199
    195a:	9a e0       	ldi	r25, 0x0A	; 10
    195c:	f3 d0       	rcall	.+486    	; 0x1b44 <xTaskGenericCreate>
	vTaskStartScheduler();
    195e:	fa d1       	rcall	.+1012   	; 0x1d54 <vTaskStartScheduler>
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	26 96       	adiw	r28, 0x06	; 6
    1966:	0f b6       	in	r0, 0x3f	; 63
    1968:	f8 94       	cli
    196a:	de bf       	out	0x3e, r29	; 62
    196c:	0f be       	out	0x3f, r0	; 63
    196e:	cd bf       	out	0x3d, r28	; 61
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	0f 91       	pop	r16
    1976:	ff 90       	pop	r15
    1978:	ef 90       	pop	r14
    197a:	df 90       	pop	r13
    197c:	cf 90       	pop	r12
    197e:	bf 90       	pop	r11
    1980:	af 90       	pop	r10
    1982:	08 95       	ret

00001984 <_GLOBAL__sub_I_echo_1>:
int echo_3 = 7;
int trigger_3 = 8;
int checkSum = 0;
int numOfData = 5;
char canRead = '0';
LSM303 compass;
    1984:	86 e6       	ldi	r24, 0x66	; 102
    1986:	98 e0       	ldi	r25, 0x08	; 8
    1988:	0c 94 2f 03 	jmp	0x65e	; 0x65e <_ZN6LSM303C1Ev>
    198c:	08 95       	ret

0000198e <_Z9handShakePv>:
			}
			else {
				Serial1.print('N');
				Serial1.print('\r');
			}
			canRead = '0';
    198e:	0f 2e       	mov	r0, r31
    1990:	f0 e3       	ldi	r31, 0x30	; 48
    1992:	bf 2e       	mov	r11, r31
    1994:	f0 2d       	mov	r31, r0
			data[3] = 0;
    1996:	0f 2e       	mov	r0, r31
    1998:	f2 e6       	ldi	r31, 0x62	; 98
    199a:	ef 2e       	mov	r14, r31
    199c:	f8 e0       	ldi	r31, 0x08	; 8
    199e:	ff 2e       	mov	r15, r31
    19a0:	f0 2d       	mov	r31, r0
    19a2:	0f 2e       	mov	r0, r31
    19a4:	fc e5       	ldi	r31, 0x5C	; 92
    19a6:	cf 2e       	mov	r12, r31
    19a8:	f8 e0       	ldi	r31, 0x08	; 8
    19aa:	df 2e       	mov	r13, r31
    19ac:	f0 2d       	mov	r31, r0
    19ae:	06 e6       	ldi	r16, 0x66	; 102
    19b0:	18 e0       	ldi	r17, 0x08	; 8
int data[5];

void handShake(void *p) {
	int i;
	while(1) {
		if(Serial1.available()) {
    19b2:	84 e4       	ldi	r24, 0x44	; 68
    19b4:	9a e0       	ldi	r25, 0x0A	; 10
    19b6:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <_ZN14HardwareSerial9availableEv>
    19ba:	89 2b       	or	r24, r25
    19bc:	09 f4       	brne	.+2      	; 0x19c0 <_Z9handShakePv+0x32>
    19be:	68 c0       	rjmp	.+208    	; 0x1a90 <_Z9handShakePv+0x102>
			canRead = Serial1.read();
    19c0:	84 e4       	ldi	r24, 0x44	; 68
    19c2:	9a e0       	ldi	r25, 0x0A	; 10
    19c4:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <_ZN14HardwareSerial4readEv>
    19c8:	80 93 00 02 	sts	0x0200, r24
			if(canRead == 'H') {
    19cc:	88 34       	cpi	r24, 0x48	; 72
    19ce:	59 f4       	brne	.+22     	; 0x19e6 <_Z9handShakePv+0x58>
				Serial1.print('A');
    19d0:	61 e4       	ldi	r22, 0x41	; 65
    19d2:	84 e4       	ldi	r24, 0x44	; 68
    19d4:	9a e0       	ldi	r25, 0x0A	; 10
    19d6:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
				Serial1.print('\r');
    19da:	6d e0       	ldi	r22, 0x0D	; 13
    19dc:	84 e4       	ldi	r24, 0x44	; 68
    19de:	9a e0       	ldi	r25, 0x0A	; 10
    19e0:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
    19e4:	50 c0       	rjmp	.+160    	; 0x1a86 <_Z9handShakePv+0xf8>
			}
			else if(canRead == 'P') {
    19e6:	80 35       	cpi	r24, 0x50	; 80
    19e8:	09 f0       	breq	.+2      	; 0x19ec <_Z9handShakePv+0x5e>
    19ea:	43 c0       	rjmp	.+134    	; 0x1a72 <_Z9handShakePv+0xe4>
				checkSum = numOfData;
    19ec:	60 91 01 02 	lds	r22, 0x0201
    19f0:	70 91 02 02 	lds	r23, 0x0202
    19f4:	70 93 8d 08 	sts	0x088D, r23
    19f8:	60 93 8c 08 	sts	0x088C, r22
				Serial1.print(numOfData);
    19fc:	4a e0       	ldi	r20, 0x0A	; 10
    19fe:	50 e0       	ldi	r21, 0x00	; 0
    1a00:	84 e4       	ldi	r24, 0x44	; 68
    1a02:	9a e0       	ldi	r25, 0x0A	; 10
    1a04:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN5Print5printEii>
				Serial1.print('\n');
    1a08:	6a e0       	ldi	r22, 0x0A	; 10
    1a0a:	84 e4       	ldi	r24, 0x44	; 68
    1a0c:	9a e0       	ldi	r25, 0x0A	; 10
    1a0e:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
    1a12:	e6 01       	movw	r28, r12
				for(i = 0; i < 5; i++) {
					checkSum += data[i];
    1a14:	69 91       	ld	r22, Y+
    1a16:	79 91       	ld	r23, Y+
    1a18:	80 91 8c 08 	lds	r24, 0x088C
    1a1c:	90 91 8d 08 	lds	r25, 0x088D
    1a20:	86 0f       	add	r24, r22
    1a22:	97 1f       	adc	r25, r23
    1a24:	90 93 8d 08 	sts	0x088D, r25
    1a28:	80 93 8c 08 	sts	0x088C, r24
					Serial1.print(data[i]);
    1a2c:	4a e0       	ldi	r20, 0x0A	; 10
    1a2e:	50 e0       	ldi	r21, 0x00	; 0
    1a30:	84 e4       	ldi	r24, 0x44	; 68
    1a32:	9a e0       	ldi	r25, 0x0A	; 10
    1a34:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN5Print5printEii>
					Serial1.print('\n');
    1a38:	6a e0       	ldi	r22, 0x0A	; 10
    1a3a:	84 e4       	ldi	r24, 0x44	; 68
    1a3c:	9a e0       	ldi	r25, 0x0A	; 10
    1a3e:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
			}
			else if(canRead == 'P') {
				checkSum = numOfData;
				Serial1.print(numOfData);
				Serial1.print('\n');
				for(i = 0; i < 5; i++) {
    1a42:	c0 17       	cp	r28, r16
    1a44:	d1 07       	cpc	r29, r17
    1a46:	31 f7       	brne	.-52     	; 0x1a14 <_Z9handShakePv+0x86>
					checkSum += data[i];
					Serial1.print(data[i]);
					Serial1.print('\n');
				}
				Serial1.print(checkSum);
    1a48:	60 91 8c 08 	lds	r22, 0x088C
    1a4c:	70 91 8d 08 	lds	r23, 0x088D
    1a50:	4a e0       	ldi	r20, 0x0A	; 10
    1a52:	50 e0       	ldi	r21, 0x00	; 0
    1a54:	84 e4       	ldi	r24, 0x44	; 68
    1a56:	9a e0       	ldi	r25, 0x0A	; 10
    1a58:	0e 94 0c 1a 	call	0x3418	; 0x3418 <_ZN5Print5printEii>
				Serial1.print('\n');
    1a5c:	6a e0       	ldi	r22, 0x0A	; 10
    1a5e:	84 e4       	ldi	r24, 0x44	; 68
    1a60:	9a e0       	ldi	r25, 0x0A	; 10
    1a62:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
				Serial1.print('\r');
    1a66:	6d e0       	ldi	r22, 0x0D	; 13
    1a68:	84 e4       	ldi	r24, 0x44	; 68
    1a6a:	9a e0       	ldi	r25, 0x0A	; 10
    1a6c:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
    1a70:	0a c0       	rjmp	.+20     	; 0x1a86 <_Z9handShakePv+0xf8>
			}
			else {
				Serial1.print('N');
    1a72:	6e e4       	ldi	r22, 0x4E	; 78
    1a74:	84 e4       	ldi	r24, 0x44	; 68
    1a76:	9a e0       	ldi	r25, 0x0A	; 10
    1a78:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
				Serial1.print('\r');
    1a7c:	6d e0       	ldi	r22, 0x0D	; 13
    1a7e:	84 e4       	ldi	r24, 0x44	; 68
    1a80:	9a e0       	ldi	r25, 0x0A	; 10
    1a82:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN5Print5printEc>
			}
			canRead = '0';
    1a86:	b0 92 00 02 	sts	0x0200, r11
			data[3] = 0;
    1a8a:	f7 01       	movw	r30, r14
    1a8c:	11 82       	std	Z+1, r1	; 0x01
    1a8e:	10 82       	st	Z, r1
		}
		vTaskDelay(100);
    1a90:	84 e6       	ldi	r24, 0x64	; 100
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	cd d2       	rcall	.+1434   	; 0x2030 <vTaskDelay>
	}
    1a96:	8d cf       	rjmp	.-230    	; 0x19b2 <_Z9handShakePv+0x24>

00001a98 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1a98:	e0 91 ad 08 	lds	r30, 0x08AD
    1a9c:	f0 91 ae 08 	lds	r31, 0x08AE
    1aa0:	80 81       	ld	r24, Z
    1aa2:	81 11       	cpse	r24, r1
    1aa4:	07 c0       	rjmp	.+14     	; 0x1ab4 <prvResetNextTaskUnblockTime+0x1c>
    1aa6:	8f ef       	ldi	r24, 0xFF	; 255
    1aa8:	9f ef       	ldi	r25, 0xFF	; 255
    1aaa:	90 93 10 02 	sts	0x0210, r25
    1aae:	80 93 0f 02 	sts	0x020F, r24
    1ab2:	08 95       	ret
    1ab4:	e0 91 ad 08 	lds	r30, 0x08AD
    1ab8:	f0 91 ae 08 	lds	r31, 0x08AE
    1abc:	05 80       	ldd	r0, Z+5	; 0x05
    1abe:	f6 81       	ldd	r31, Z+6	; 0x06
    1ac0:	e0 2d       	mov	r30, r0
    1ac2:	06 80       	ldd	r0, Z+6	; 0x06
    1ac4:	f7 81       	ldd	r31, Z+7	; 0x07
    1ac6:	e0 2d       	mov	r30, r0
    1ac8:	82 81       	ldd	r24, Z+2	; 0x02
    1aca:	93 81       	ldd	r25, Z+3	; 0x03
    1acc:	90 93 10 02 	sts	0x0210, r25
    1ad0:	80 93 0f 02 	sts	0x020F, r24
    1ad4:	08 95       	ret

00001ad6 <prvAddCurrentTaskToDelayedList>:
    1ad6:	cf 93       	push	r28
    1ad8:	df 93       	push	r29
    1ada:	ec 01       	movw	r28, r24
    1adc:	e0 91 e5 08 	lds	r30, 0x08E5
    1ae0:	f0 91 e6 08 	lds	r31, 0x08E6
    1ae4:	93 83       	std	Z+3, r25	; 0x03
    1ae6:	82 83       	std	Z+2, r24	; 0x02
    1ae8:	80 91 95 08 	lds	r24, 0x0895
    1aec:	90 91 96 08 	lds	r25, 0x0896
    1af0:	c8 17       	cp	r28, r24
    1af2:	d9 07       	cpc	r29, r25
    1af4:	68 f4       	brcc	.+26     	; 0x1b10 <prvAddCurrentTaskToDelayedList+0x3a>
    1af6:	60 91 e5 08 	lds	r22, 0x08E5
    1afa:	70 91 e6 08 	lds	r23, 0x08E6
    1afe:	80 91 ab 08 	lds	r24, 0x08AB
    1b02:	90 91 ac 08 	lds	r25, 0x08AC
    1b06:	6e 5f       	subi	r22, 0xFE	; 254
    1b08:	7f 4f       	sbci	r23, 0xFF	; 255
    1b0a:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <vListInsert>
    1b0e:	17 c0       	rjmp	.+46     	; 0x1b3e <prvAddCurrentTaskToDelayedList+0x68>
    1b10:	60 91 e5 08 	lds	r22, 0x08E5
    1b14:	70 91 e6 08 	lds	r23, 0x08E6
    1b18:	80 91 ad 08 	lds	r24, 0x08AD
    1b1c:	90 91 ae 08 	lds	r25, 0x08AE
    1b20:	6e 5f       	subi	r22, 0xFE	; 254
    1b22:	7f 4f       	sbci	r23, 0xFF	; 255
    1b24:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <vListInsert>
    1b28:	80 91 0f 02 	lds	r24, 0x020F
    1b2c:	90 91 10 02 	lds	r25, 0x0210
    1b30:	c8 17       	cp	r28, r24
    1b32:	d9 07       	cpc	r29, r25
    1b34:	20 f4       	brcc	.+8      	; 0x1b3e <prvAddCurrentTaskToDelayedList+0x68>
    1b36:	d0 93 10 02 	sts	0x0210, r29
    1b3a:	c0 93 0f 02 	sts	0x020F, r28
    1b3e:	df 91       	pop	r29
    1b40:	cf 91       	pop	r28
    1b42:	08 95       	ret

00001b44 <xTaskGenericCreate>:
    1b44:	4f 92       	push	r4
    1b46:	5f 92       	push	r5
    1b48:	6f 92       	push	r6
    1b4a:	7f 92       	push	r7
    1b4c:	8f 92       	push	r8
    1b4e:	9f 92       	push	r9
    1b50:	af 92       	push	r10
    1b52:	bf 92       	push	r11
    1b54:	cf 92       	push	r12
    1b56:	df 92       	push	r13
    1b58:	ef 92       	push	r14
    1b5a:	ff 92       	push	r15
    1b5c:	0f 93       	push	r16
    1b5e:	1f 93       	push	r17
    1b60:	cf 93       	push	r28
    1b62:	df 93       	push	r29
    1b64:	4c 01       	movw	r8, r24
    1b66:	5b 01       	movw	r10, r22
    1b68:	2a 01       	movw	r4, r20
    1b6a:	39 01       	movw	r6, r18
    1b6c:	81 e2       	ldi	r24, 0x21	; 33
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	0e 94 6f 02 	call	0x4de	; 0x4de <pvPortMalloc>
    1b74:	ec 01       	movw	r28, r24
    1b76:	00 97       	sbiw	r24, 0x00	; 0
    1b78:	09 f4       	brne	.+2      	; 0x1b7c <xTaskGenericCreate+0x38>
    1b7a:	da c0       	rjmp	.+436    	; 0x1d30 <xTaskGenericCreate+0x1ec>
    1b7c:	c1 14       	cp	r12, r1
    1b7e:	d1 04       	cpc	r13, r1
    1b80:	09 f0       	breq	.+2      	; 0x1b84 <xTaskGenericCreate+0x40>
    1b82:	bf c0       	rjmp	.+382    	; 0x1d02 <xTaskGenericCreate+0x1be>
    1b84:	c2 01       	movw	r24, r4
    1b86:	0e 94 6f 02 	call	0x4de	; 0x4de <pvPortMalloc>
    1b8a:	98 8f       	std	Y+24, r25	; 0x18
    1b8c:	8f 8b       	std	Y+23, r24	; 0x17
    1b8e:	89 2b       	or	r24, r25
    1b90:	09 f0       	breq	.+2      	; 0x1b94 <xTaskGenericCreate+0x50>
    1b92:	b9 c0       	rjmp	.+370    	; 0x1d06 <xTaskGenericCreate+0x1c2>
    1b94:	ce 01       	movw	r24, r28
    1b96:	0e 94 a4 02 	call	0x548	; 0x548 <vPortFree>
    1b9a:	ca c0       	rjmp	.+404    	; 0x1d30 <xTaskGenericCreate+0x1ec>
    1b9c:	cf 01       	movw	r24, r30
    1b9e:	31 91       	ld	r19, Z+
    1ba0:	da 01       	movw	r26, r20
    1ba2:	3d 93       	st	X+, r19
    1ba4:	ad 01       	movw	r20, r26
    1ba6:	dc 01       	movw	r26, r24
    1ba8:	8c 91       	ld	r24, X
    1baa:	88 23       	and	r24, r24
    1bac:	11 f0       	breq	.+4      	; 0x1bb2 <xTaskGenericCreate+0x6e>
    1bae:	21 50       	subi	r18, 0x01	; 1
    1bb0:	a9 f7       	brne	.-22     	; 0x1b9c <xTaskGenericCreate+0x58>
    1bb2:	18 a2       	std	Y+32, r1	; 0x20
    1bb4:	10 2f       	mov	r17, r16
    1bb6:	04 30       	cpi	r16, 0x04	; 4
    1bb8:	08 f0       	brcs	.+2      	; 0x1bbc <xTaskGenericCreate+0x78>
    1bba:	13 e0       	ldi	r17, 0x03	; 3
    1bbc:	1e 8b       	std	Y+22, r17	; 0x16
    1bbe:	5e 01       	movw	r10, r28
    1bc0:	b2 e0       	ldi	r27, 0x02	; 2
    1bc2:	ab 0e       	add	r10, r27
    1bc4:	b1 1c       	adc	r11, r1
    1bc6:	c5 01       	movw	r24, r10
    1bc8:	0e 94 b3 02 	call	0x566	; 0x566 <vListInitialiseItem>
    1bcc:	ce 01       	movw	r24, r28
    1bce:	0c 96       	adiw	r24, 0x0c	; 12
    1bd0:	0e 94 b3 02 	call	0x566	; 0x566 <vListInitialiseItem>
    1bd4:	d9 87       	std	Y+9, r29	; 0x09
    1bd6:	c8 87       	std	Y+8, r28	; 0x08
    1bd8:	84 e0       	ldi	r24, 0x04	; 4
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	81 1b       	sub	r24, r17
    1bde:	91 09       	sbc	r25, r1
    1be0:	9d 87       	std	Y+13, r25	; 0x0d
    1be2:	8c 87       	std	Y+12, r24	; 0x0c
    1be4:	db 8b       	std	Y+19, r29	; 0x13
    1be6:	ca 8b       	std	Y+18, r28	; 0x12
    1be8:	a3 01       	movw	r20, r6
    1bea:	b4 01       	movw	r22, r8
    1bec:	c6 01       	movw	r24, r12
    1bee:	58 db       	rcall	.-2384   	; 0x12a0 <pxPortInitialiseStack>
    1bf0:	99 83       	std	Y+1, r25	; 0x01
    1bf2:	88 83       	st	Y, r24
    1bf4:	e1 14       	cp	r14, r1
    1bf6:	f1 04       	cpc	r15, r1
    1bf8:	19 f0       	breq	.+6      	; 0x1c00 <xTaskGenericCreate+0xbc>
    1bfa:	f7 01       	movw	r30, r14
    1bfc:	d1 83       	std	Z+1, r29	; 0x01
    1bfe:	c0 83       	st	Z, r28
    1c00:	0f b6       	in	r0, 0x3f	; 63
    1c02:	f8 94       	cli
    1c04:	0f 92       	push	r0
    1c06:	80 91 97 08 	lds	r24, 0x0897
    1c0a:	8f 5f       	subi	r24, 0xFF	; 255
    1c0c:	80 93 97 08 	sts	0x0897, r24
    1c10:	80 91 e5 08 	lds	r24, 0x08E5
    1c14:	90 91 e6 08 	lds	r25, 0x08E6
    1c18:	89 2b       	or	r24, r25
    1c1a:	a9 f5       	brne	.+106    	; 0x1c86 <xTaskGenericCreate+0x142>
    1c1c:	d0 93 e6 08 	sts	0x08E6, r29
    1c20:	c0 93 e5 08 	sts	0x08E5, r28
    1c24:	80 91 97 08 	lds	r24, 0x0897
    1c28:	81 30       	cpi	r24, 0x01	; 1
    1c2a:	e1 f5       	brne	.+120    	; 0x1ca4 <xTaskGenericCreate+0x160>
    1c2c:	81 ec       	ldi	r24, 0xC1	; 193
    1c2e:	98 e0       	ldi	r25, 0x08	; 8
    1c30:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c34:	8a ec       	ldi	r24, 0xCA	; 202
    1c36:	98 e0       	ldi	r25, 0x08	; 8
    1c38:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c3c:	83 ed       	ldi	r24, 0xD3	; 211
    1c3e:	98 e0       	ldi	r25, 0x08	; 8
    1c40:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c44:	8c ed       	ldi	r24, 0xDC	; 220
    1c46:	98 e0       	ldi	r25, 0x08	; 8
    1c48:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c4c:	88 eb       	ldi	r24, 0xB8	; 184
    1c4e:	98 e0       	ldi	r25, 0x08	; 8
    1c50:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c54:	8f ea       	ldi	r24, 0xAF	; 175
    1c56:	98 e0       	ldi	r25, 0x08	; 8
    1c58:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c5c:	82 ea       	ldi	r24, 0xA2	; 162
    1c5e:	98 e0       	ldi	r25, 0x08	; 8
    1c60:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c64:	89 e9       	ldi	r24, 0x99	; 153
    1c66:	98 e0       	ldi	r25, 0x08	; 8
    1c68:	0e 94 a5 02 	call	0x54a	; 0x54a <vListInitialise>
    1c6c:	88 eb       	ldi	r24, 0xB8	; 184
    1c6e:	98 e0       	ldi	r25, 0x08	; 8
    1c70:	90 93 ae 08 	sts	0x08AE, r25
    1c74:	80 93 ad 08 	sts	0x08AD, r24
    1c78:	8f ea       	ldi	r24, 0xAF	; 175
    1c7a:	98 e0       	ldi	r25, 0x08	; 8
    1c7c:	90 93 ac 08 	sts	0x08AC, r25
    1c80:	80 93 ab 08 	sts	0x08AB, r24
    1c84:	0f c0       	rjmp	.+30     	; 0x1ca4 <xTaskGenericCreate+0x160>
    1c86:	80 91 93 08 	lds	r24, 0x0893
    1c8a:	81 11       	cpse	r24, r1
    1c8c:	0b c0       	rjmp	.+22     	; 0x1ca4 <xTaskGenericCreate+0x160>
    1c8e:	e0 91 e5 08 	lds	r30, 0x08E5
    1c92:	f0 91 e6 08 	lds	r31, 0x08E6
    1c96:	86 89       	ldd	r24, Z+22	; 0x16
    1c98:	08 17       	cp	r16, r24
    1c9a:	20 f0       	brcs	.+8      	; 0x1ca4 <xTaskGenericCreate+0x160>
    1c9c:	d0 93 e6 08 	sts	0x08E6, r29
    1ca0:	c0 93 e5 08 	sts	0x08E5, r28
    1ca4:	80 91 8f 08 	lds	r24, 0x088F
    1ca8:	8f 5f       	subi	r24, 0xFF	; 255
    1caa:	80 93 8f 08 	sts	0x088F, r24
    1cae:	8e 89       	ldd	r24, Y+22	; 0x16
    1cb0:	90 91 94 08 	lds	r25, 0x0894
    1cb4:	98 17       	cp	r25, r24
    1cb6:	10 f4       	brcc	.+4      	; 0x1cbc <xTaskGenericCreate+0x178>
    1cb8:	80 93 94 08 	sts	0x0894, r24
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	9c 01       	movw	r18, r24
    1cc0:	22 0f       	add	r18, r18
    1cc2:	33 1f       	adc	r19, r19
    1cc4:	22 0f       	add	r18, r18
    1cc6:	33 1f       	adc	r19, r19
    1cc8:	22 0f       	add	r18, r18
    1cca:	33 1f       	adc	r19, r19
    1ccc:	82 0f       	add	r24, r18
    1cce:	93 1f       	adc	r25, r19
    1cd0:	b5 01       	movw	r22, r10
    1cd2:	8f 53       	subi	r24, 0x3F	; 63
    1cd4:	97 4f       	sbci	r25, 0xF7	; 247
    1cd6:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1cda:	0f 90       	pop	r0
    1cdc:	0f be       	out	0x3f, r0	; 63
    1cde:	80 91 93 08 	lds	r24, 0x0893
    1ce2:	88 23       	and	r24, r24
    1ce4:	51 f0       	breq	.+20     	; 0x1cfa <xTaskGenericCreate+0x1b6>
    1ce6:	e0 91 e5 08 	lds	r30, 0x08E5
    1cea:	f0 91 e6 08 	lds	r31, 0x08E6
    1cee:	86 89       	ldd	r24, Z+22	; 0x16
    1cf0:	80 17       	cp	r24, r16
    1cf2:	28 f4       	brcc	.+10     	; 0x1cfe <xTaskGenericCreate+0x1ba>
    1cf4:	88 db       	rcall	.-2288   	; 0x1406 <vPortYield>
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	1c c0       	rjmp	.+56     	; 0x1d32 <xTaskGenericCreate+0x1ee>
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	1a c0       	rjmp	.+52     	; 0x1d32 <xTaskGenericCreate+0x1ee>
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	18 c0       	rjmp	.+48     	; 0x1d32 <xTaskGenericCreate+0x1ee>
    1d02:	d8 8e       	std	Y+24, r13	; 0x18
    1d04:	cf 8a       	std	Y+23, r12	; 0x17
    1d06:	f1 e0       	ldi	r31, 0x01	; 1
    1d08:	4f 1a       	sub	r4, r31
    1d0a:	51 08       	sbc	r5, r1
    1d0c:	cf 88       	ldd	r12, Y+23	; 0x17
    1d0e:	d8 8c       	ldd	r13, Y+24	; 0x18
    1d10:	c4 0c       	add	r12, r4
    1d12:	d5 1c       	adc	r13, r5
    1d14:	d5 01       	movw	r26, r10
    1d16:	8c 91       	ld	r24, X
    1d18:	89 8f       	std	Y+25, r24	; 0x19
    1d1a:	8c 91       	ld	r24, X
    1d1c:	88 23       	and	r24, r24
    1d1e:	09 f4       	brne	.+2      	; 0x1d22 <xTaskGenericCreate+0x1de>
    1d20:	48 cf       	rjmp	.-368    	; 0x1bb2 <xTaskGenericCreate+0x6e>
    1d22:	ae 01       	movw	r20, r28
    1d24:	46 5e       	subi	r20, 0xE6	; 230
    1d26:	5f 4f       	sbci	r21, 0xFF	; 255
    1d28:	f5 01       	movw	r30, r10
    1d2a:	31 96       	adiw	r30, 0x01	; 1
    1d2c:	27 e0       	ldi	r18, 0x07	; 7
    1d2e:	36 cf       	rjmp	.-404    	; 0x1b9c <xTaskGenericCreate+0x58>
    1d30:	8f ef       	ldi	r24, 0xFF	; 255
    1d32:	df 91       	pop	r29
    1d34:	cf 91       	pop	r28
    1d36:	1f 91       	pop	r17
    1d38:	0f 91       	pop	r16
    1d3a:	ff 90       	pop	r15
    1d3c:	ef 90       	pop	r14
    1d3e:	df 90       	pop	r13
    1d40:	cf 90       	pop	r12
    1d42:	bf 90       	pop	r11
    1d44:	af 90       	pop	r10
    1d46:	9f 90       	pop	r9
    1d48:	8f 90       	pop	r8
    1d4a:	7f 90       	pop	r7
    1d4c:	6f 90       	pop	r6
    1d4e:	5f 90       	pop	r5
    1d50:	4f 90       	pop	r4
    1d52:	08 95       	ret

00001d54 <vTaskStartScheduler>:
    1d54:	af 92       	push	r10
    1d56:	bf 92       	push	r11
    1d58:	cf 92       	push	r12
    1d5a:	df 92       	push	r13
    1d5c:	ef 92       	push	r14
    1d5e:	ff 92       	push	r15
    1d60:	0f 93       	push	r16
    1d62:	a1 2c       	mov	r10, r1
    1d64:	b1 2c       	mov	r11, r1
    1d66:	c1 2c       	mov	r12, r1
    1d68:	d1 2c       	mov	r13, r1
    1d6a:	e1 2c       	mov	r14, r1
    1d6c:	f1 2c       	mov	r15, r1
    1d6e:	00 e0       	ldi	r16, 0x00	; 0
    1d70:	20 e0       	ldi	r18, 0x00	; 0
    1d72:	30 e0       	ldi	r19, 0x00	; 0
    1d74:	45 e5       	ldi	r20, 0x55	; 85
    1d76:	50 e0       	ldi	r21, 0x00	; 0
    1d78:	66 e5       	ldi	r22, 0x56	; 86
    1d7a:	72 e0       	ldi	r23, 0x02	; 2
    1d7c:	84 e3       	ldi	r24, 0x34	; 52
    1d7e:	90 e1       	ldi	r25, 0x10	; 16
    1d80:	e1 de       	rcall	.-574    	; 0x1b44 <xTaskGenericCreate>
    1d82:	81 30       	cpi	r24, 0x01	; 1
    1d84:	41 f4       	brne	.+16     	; 0x1d96 <vTaskStartScheduler+0x42>
    1d86:	f8 94       	cli
    1d88:	80 93 93 08 	sts	0x0893, r24
    1d8c:	10 92 96 08 	sts	0x0896, r1
    1d90:	10 92 95 08 	sts	0x0895, r1
    1d94:	f7 da       	rcall	.-2578   	; 0x1384 <xPortStartScheduler>
    1d96:	0f 91       	pop	r16
    1d98:	ff 90       	pop	r15
    1d9a:	ef 90       	pop	r14
    1d9c:	df 90       	pop	r13
    1d9e:	cf 90       	pop	r12
    1da0:	bf 90       	pop	r11
    1da2:	af 90       	pop	r10
    1da4:	08 95       	ret

00001da6 <vTaskSuspendAll>:
    1da6:	80 91 8e 08 	lds	r24, 0x088E
    1daa:	8f 5f       	subi	r24, 0xFF	; 255
    1dac:	80 93 8e 08 	sts	0x088E, r24
    1db0:	08 95       	ret

00001db2 <xTaskIncrementTick>:
    1db2:	cf 92       	push	r12
    1db4:	df 92       	push	r13
    1db6:	ef 92       	push	r14
    1db8:	ff 92       	push	r15
    1dba:	0f 93       	push	r16
    1dbc:	1f 93       	push	r17
    1dbe:	cf 93       	push	r28
    1dc0:	df 93       	push	r29
    1dc2:	80 91 8e 08 	lds	r24, 0x088E
    1dc6:	81 11       	cpse	r24, r1
    1dc8:	99 c0       	rjmp	.+306    	; 0x1efc <xTaskIncrementTick+0x14a>
    1dca:	80 91 95 08 	lds	r24, 0x0895
    1dce:	90 91 96 08 	lds	r25, 0x0896
    1dd2:	01 96       	adiw	r24, 0x01	; 1
    1dd4:	90 93 96 08 	sts	0x0896, r25
    1dd8:	80 93 95 08 	sts	0x0895, r24
    1ddc:	e0 90 95 08 	lds	r14, 0x0895
    1de0:	f0 90 96 08 	lds	r15, 0x0896
    1de4:	e1 14       	cp	r14, r1
    1de6:	f1 04       	cpc	r15, r1
    1de8:	b1 f4       	brne	.+44     	; 0x1e16 <xTaskIncrementTick+0x64>
    1dea:	80 91 ad 08 	lds	r24, 0x08AD
    1dee:	90 91 ae 08 	lds	r25, 0x08AE
    1df2:	20 91 ab 08 	lds	r18, 0x08AB
    1df6:	30 91 ac 08 	lds	r19, 0x08AC
    1dfa:	30 93 ae 08 	sts	0x08AE, r19
    1dfe:	20 93 ad 08 	sts	0x08AD, r18
    1e02:	90 93 ac 08 	sts	0x08AC, r25
    1e06:	80 93 ab 08 	sts	0x08AB, r24
    1e0a:	80 91 90 08 	lds	r24, 0x0890
    1e0e:	8f 5f       	subi	r24, 0xFF	; 255
    1e10:	80 93 90 08 	sts	0x0890, r24
    1e14:	41 de       	rcall	.-894    	; 0x1a98 <prvResetNextTaskUnblockTime>
    1e16:	80 91 0f 02 	lds	r24, 0x020F
    1e1a:	90 91 10 02 	lds	r25, 0x0210
    1e1e:	e8 16       	cp	r14, r24
    1e20:	f9 06       	cpc	r15, r25
    1e22:	08 f4       	brcc	.+2      	; 0x1e26 <xTaskIncrementTick+0x74>
    1e24:	54 c0       	rjmp	.+168    	; 0x1ece <xTaskIncrementTick+0x11c>
    1e26:	d1 2c       	mov	r13, r1
    1e28:	cc 24       	eor	r12, r12
    1e2a:	c3 94       	inc	r12
    1e2c:	01 c0       	rjmp	.+2      	; 0x1e30 <xTaskIncrementTick+0x7e>
    1e2e:	dc 2c       	mov	r13, r12
    1e30:	e0 91 ad 08 	lds	r30, 0x08AD
    1e34:	f0 91 ae 08 	lds	r31, 0x08AE
    1e38:	80 81       	ld	r24, Z
    1e3a:	81 11       	cpse	r24, r1
    1e3c:	07 c0       	rjmp	.+14     	; 0x1e4c <xTaskIncrementTick+0x9a>
    1e3e:	8f ef       	ldi	r24, 0xFF	; 255
    1e40:	9f ef       	ldi	r25, 0xFF	; 255
    1e42:	90 93 10 02 	sts	0x0210, r25
    1e46:	80 93 0f 02 	sts	0x020F, r24
    1e4a:	42 c0       	rjmp	.+132    	; 0x1ed0 <xTaskIncrementTick+0x11e>
    1e4c:	e0 91 ad 08 	lds	r30, 0x08AD
    1e50:	f0 91 ae 08 	lds	r31, 0x08AE
    1e54:	05 80       	ldd	r0, Z+5	; 0x05
    1e56:	f6 81       	ldd	r31, Z+6	; 0x06
    1e58:	e0 2d       	mov	r30, r0
    1e5a:	c6 81       	ldd	r28, Z+6	; 0x06
    1e5c:	d7 81       	ldd	r29, Z+7	; 0x07
    1e5e:	2a 81       	ldd	r18, Y+2	; 0x02
    1e60:	3b 81       	ldd	r19, Y+3	; 0x03
    1e62:	e2 16       	cp	r14, r18
    1e64:	f3 06       	cpc	r15, r19
    1e66:	28 f4       	brcc	.+10     	; 0x1e72 <xTaskIncrementTick+0xc0>
    1e68:	30 93 10 02 	sts	0x0210, r19
    1e6c:	20 93 0f 02 	sts	0x020F, r18
    1e70:	2f c0       	rjmp	.+94     	; 0x1ed0 <xTaskIncrementTick+0x11e>
    1e72:	8e 01       	movw	r16, r28
    1e74:	0e 5f       	subi	r16, 0xFE	; 254
    1e76:	1f 4f       	sbci	r17, 0xFF	; 255
    1e78:	c8 01       	movw	r24, r16
    1e7a:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1e7e:	8c 89       	ldd	r24, Y+20	; 0x14
    1e80:	9d 89       	ldd	r25, Y+21	; 0x15
    1e82:	89 2b       	or	r24, r25
    1e84:	21 f0       	breq	.+8      	; 0x1e8e <xTaskIncrementTick+0xdc>
    1e86:	ce 01       	movw	r24, r28
    1e88:	0c 96       	adiw	r24, 0x0c	; 12
    1e8a:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1e8e:	2e 89       	ldd	r18, Y+22	; 0x16
    1e90:	80 91 94 08 	lds	r24, 0x0894
    1e94:	82 17       	cp	r24, r18
    1e96:	10 f4       	brcc	.+4      	; 0x1e9c <xTaskIncrementTick+0xea>
    1e98:	20 93 94 08 	sts	0x0894, r18
    1e9c:	30 e0       	ldi	r19, 0x00	; 0
    1e9e:	c9 01       	movw	r24, r18
    1ea0:	88 0f       	add	r24, r24
    1ea2:	99 1f       	adc	r25, r25
    1ea4:	88 0f       	add	r24, r24
    1ea6:	99 1f       	adc	r25, r25
    1ea8:	88 0f       	add	r24, r24
    1eaa:	99 1f       	adc	r25, r25
    1eac:	82 0f       	add	r24, r18
    1eae:	93 1f       	adc	r25, r19
    1eb0:	b8 01       	movw	r22, r16
    1eb2:	8f 53       	subi	r24, 0x3F	; 63
    1eb4:	97 4f       	sbci	r25, 0xF7	; 247
    1eb6:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1eba:	e0 91 e5 08 	lds	r30, 0x08E5
    1ebe:	f0 91 e6 08 	lds	r31, 0x08E6
    1ec2:	9e 89       	ldd	r25, Y+22	; 0x16
    1ec4:	86 89       	ldd	r24, Z+22	; 0x16
    1ec6:	98 17       	cp	r25, r24
    1ec8:	08 f0       	brcs	.+2      	; 0x1ecc <xTaskIncrementTick+0x11a>
    1eca:	b1 cf       	rjmp	.-158    	; 0x1e2e <xTaskIncrementTick+0x7c>
    1ecc:	b1 cf       	rjmp	.-158    	; 0x1e30 <xTaskIncrementTick+0x7e>
    1ece:	d1 2c       	mov	r13, r1
    1ed0:	e0 91 e5 08 	lds	r30, 0x08E5
    1ed4:	f0 91 e6 08 	lds	r31, 0x08E6
    1ed8:	86 89       	ldd	r24, Z+22	; 0x16
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	fc 01       	movw	r30, r24
    1ede:	ee 0f       	add	r30, r30
    1ee0:	ff 1f       	adc	r31, r31
    1ee2:	ee 0f       	add	r30, r30
    1ee4:	ff 1f       	adc	r31, r31
    1ee6:	ee 0f       	add	r30, r30
    1ee8:	ff 1f       	adc	r31, r31
    1eea:	8e 0f       	add	r24, r30
    1eec:	9f 1f       	adc	r25, r31
    1eee:	fc 01       	movw	r30, r24
    1ef0:	ef 53       	subi	r30, 0x3F	; 63
    1ef2:	f7 4f       	sbci	r31, 0xF7	; 247
    1ef4:	80 81       	ld	r24, Z
    1ef6:	82 30       	cpi	r24, 0x02	; 2
    1ef8:	40 f4       	brcc	.+16     	; 0x1f0a <xTaskIncrementTick+0x158>
    1efa:	09 c0       	rjmp	.+18     	; 0x1f0e <xTaskIncrementTick+0x15c>
    1efc:	80 91 92 08 	lds	r24, 0x0892
    1f00:	8f 5f       	subi	r24, 0xFF	; 255
    1f02:	80 93 92 08 	sts	0x0892, r24
    1f06:	d1 2c       	mov	r13, r1
    1f08:	02 c0       	rjmp	.+4      	; 0x1f0e <xTaskIncrementTick+0x15c>
    1f0a:	dd 24       	eor	r13, r13
    1f0c:	d3 94       	inc	r13
    1f0e:	80 91 91 08 	lds	r24, 0x0891
    1f12:	88 23       	and	r24, r24
    1f14:	11 f0       	breq	.+4      	; 0x1f1a <xTaskIncrementTick+0x168>
    1f16:	dd 24       	eor	r13, r13
    1f18:	d3 94       	inc	r13
    1f1a:	8d 2d       	mov	r24, r13
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	1f 91       	pop	r17
    1f22:	0f 91       	pop	r16
    1f24:	ff 90       	pop	r15
    1f26:	ef 90       	pop	r14
    1f28:	df 90       	pop	r13
    1f2a:	cf 90       	pop	r12
    1f2c:	08 95       	ret

00001f2e <xTaskResumeAll>:
    1f2e:	df 92       	push	r13
    1f30:	ef 92       	push	r14
    1f32:	ff 92       	push	r15
    1f34:	0f 93       	push	r16
    1f36:	1f 93       	push	r17
    1f38:	cf 93       	push	r28
    1f3a:	df 93       	push	r29
    1f3c:	0f b6       	in	r0, 0x3f	; 63
    1f3e:	f8 94       	cli
    1f40:	0f 92       	push	r0
    1f42:	80 91 8e 08 	lds	r24, 0x088E
    1f46:	81 50       	subi	r24, 0x01	; 1
    1f48:	80 93 8e 08 	sts	0x088E, r24
    1f4c:	80 91 8e 08 	lds	r24, 0x088E
    1f50:	81 11       	cpse	r24, r1
    1f52:	5f c0       	rjmp	.+190    	; 0x2012 <xTaskResumeAll+0xe4>
    1f54:	80 91 97 08 	lds	r24, 0x0897
    1f58:	88 23       	and	r24, r24
    1f5a:	09 f4       	brne	.+2      	; 0x1f5e <xTaskResumeAll+0x30>
    1f5c:	5c c0       	rjmp	.+184    	; 0x2016 <xTaskResumeAll+0xe8>
    1f5e:	0f 2e       	mov	r0, r31
    1f60:	f2 ea       	ldi	r31, 0xA2	; 162
    1f62:	ef 2e       	mov	r14, r31
    1f64:	f8 e0       	ldi	r31, 0x08	; 8
    1f66:	ff 2e       	mov	r15, r31
    1f68:	f0 2d       	mov	r31, r0
    1f6a:	dd 24       	eor	r13, r13
    1f6c:	d3 94       	inc	r13
    1f6e:	30 c0       	rjmp	.+96     	; 0x1fd0 <xTaskResumeAll+0xa2>
    1f70:	e0 91 a7 08 	lds	r30, 0x08A7
    1f74:	f0 91 a8 08 	lds	r31, 0x08A8
    1f78:	c6 81       	ldd	r28, Z+6	; 0x06
    1f7a:	d7 81       	ldd	r29, Z+7	; 0x07
    1f7c:	ce 01       	movw	r24, r28
    1f7e:	0c 96       	adiw	r24, 0x0c	; 12
    1f80:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1f84:	8e 01       	movw	r16, r28
    1f86:	0e 5f       	subi	r16, 0xFE	; 254
    1f88:	1f 4f       	sbci	r17, 0xFF	; 255
    1f8a:	c8 01       	movw	r24, r16
    1f8c:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
    1f90:	8e 89       	ldd	r24, Y+22	; 0x16
    1f92:	90 91 94 08 	lds	r25, 0x0894
    1f96:	98 17       	cp	r25, r24
    1f98:	10 f4       	brcc	.+4      	; 0x1f9e <xTaskResumeAll+0x70>
    1f9a:	80 93 94 08 	sts	0x0894, r24
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	9c 01       	movw	r18, r24
    1fa2:	22 0f       	add	r18, r18
    1fa4:	33 1f       	adc	r19, r19
    1fa6:	22 0f       	add	r18, r18
    1fa8:	33 1f       	adc	r19, r19
    1faa:	22 0f       	add	r18, r18
    1fac:	33 1f       	adc	r19, r19
    1fae:	82 0f       	add	r24, r18
    1fb0:	93 1f       	adc	r25, r19
    1fb2:	b8 01       	movw	r22, r16
    1fb4:	8f 53       	subi	r24, 0x3F	; 63
    1fb6:	97 4f       	sbci	r25, 0xF7	; 247
    1fb8:	0e 94 b7 02 	call	0x56e	; 0x56e <vListInsertEnd>
    1fbc:	e0 91 e5 08 	lds	r30, 0x08E5
    1fc0:	f0 91 e6 08 	lds	r31, 0x08E6
    1fc4:	9e 89       	ldd	r25, Y+22	; 0x16
    1fc6:	86 89       	ldd	r24, Z+22	; 0x16
    1fc8:	98 17       	cp	r25, r24
    1fca:	10 f0       	brcs	.+4      	; 0x1fd0 <xTaskResumeAll+0xa2>
    1fcc:	d0 92 91 08 	sts	0x0891, r13
    1fd0:	f7 01       	movw	r30, r14
    1fd2:	80 81       	ld	r24, Z
    1fd4:	81 11       	cpse	r24, r1
    1fd6:	cc cf       	rjmp	.-104    	; 0x1f70 <xTaskResumeAll+0x42>
    1fd8:	80 91 92 08 	lds	r24, 0x0892
    1fdc:	88 23       	and	r24, r24
    1fde:	91 f0       	breq	.+36     	; 0x2004 <xTaskResumeAll+0xd6>
    1fe0:	80 91 92 08 	lds	r24, 0x0892
    1fe4:	88 23       	and	r24, r24
    1fe6:	71 f0       	breq	.+28     	; 0x2004 <xTaskResumeAll+0xd6>
    1fe8:	c1 e0       	ldi	r28, 0x01	; 1
    1fea:	e3 de       	rcall	.-570    	; 0x1db2 <xTaskIncrementTick>
    1fec:	81 11       	cpse	r24, r1
    1fee:	c0 93 91 08 	sts	0x0891, r28
    1ff2:	80 91 92 08 	lds	r24, 0x0892
    1ff6:	81 50       	subi	r24, 0x01	; 1
    1ff8:	80 93 92 08 	sts	0x0892, r24
    1ffc:	80 91 92 08 	lds	r24, 0x0892
    2000:	81 11       	cpse	r24, r1
    2002:	f3 cf       	rjmp	.-26     	; 0x1fea <xTaskResumeAll+0xbc>
    2004:	80 91 91 08 	lds	r24, 0x0891
    2008:	81 30       	cpi	r24, 0x01	; 1
    200a:	39 f4       	brne	.+14     	; 0x201a <xTaskResumeAll+0xec>
    200c:	fc d9       	rcall	.-3080   	; 0x1406 <vPortYield>
    200e:	81 e0       	ldi	r24, 0x01	; 1
    2010:	05 c0       	rjmp	.+10     	; 0x201c <xTaskResumeAll+0xee>
    2012:	80 e0       	ldi	r24, 0x00	; 0
    2014:	03 c0       	rjmp	.+6      	; 0x201c <xTaskResumeAll+0xee>
    2016:	80 e0       	ldi	r24, 0x00	; 0
    2018:	01 c0       	rjmp	.+2      	; 0x201c <xTaskResumeAll+0xee>
    201a:	80 e0       	ldi	r24, 0x00	; 0
    201c:	0f 90       	pop	r0
    201e:	0f be       	out	0x3f, r0	; 63
    2020:	df 91       	pop	r29
    2022:	cf 91       	pop	r28
    2024:	1f 91       	pop	r17
    2026:	0f 91       	pop	r16
    2028:	ff 90       	pop	r15
    202a:	ef 90       	pop	r14
    202c:	df 90       	pop	r13
    202e:	08 95       	ret

00002030 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2030:	cf 93       	push	r28
    2032:	df 93       	push	r29
    2034:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2036:	00 97       	sbiw	r24, 0x00	; 0
    2038:	99 f0       	breq	.+38     	; 0x2060 <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    203a:	b5 de       	rcall	.-662    	; 0x1da6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    203c:	80 91 95 08 	lds	r24, 0x0895
    2040:	90 91 96 08 	lds	r25, 0x0896
    2044:	c8 0f       	add	r28, r24
    2046:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2048:	80 91 e5 08 	lds	r24, 0x08E5
    204c:	90 91 e6 08 	lds	r25, 0x08E6
    2050:	02 96       	adiw	r24, 0x02	; 2
    2052:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2056:	ce 01       	movw	r24, r28
    2058:	3e dd       	rcall	.-1412   	; 0x1ad6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    205a:	69 df       	rcall	.-302    	; 0x1f2e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    205c:	81 11       	cpse	r24, r1
    205e:	01 c0       	rjmp	.+2      	; 0x2062 <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    2060:	d2 d9       	rcall	.-3164   	; 0x1406 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	08 95       	ret

00002068 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2068:	0f 2e       	mov	r0, r31
    206a:	f1 ec       	ldi	r31, 0xC1	; 193
    206c:	ef 2e       	mov	r14, r31
    206e:	f8 e0       	ldi	r31, 0x08	; 8
    2070:	ff 2e       	mov	r15, r31
    2072:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2074:	c9 e9       	ldi	r28, 0x99	; 153
    2076:	d8 e0       	ldi	r29, 0x08	; 8
    2078:	26 c0       	rjmp	.+76     	; 0x20c6 <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    207a:	95 de       	rcall	.-726    	; 0x1da6 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    207c:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    207e:	57 df       	rcall	.-338    	; 0x1f2e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2080:	11 23       	and	r17, r17
    2082:	09 f1       	breq	.+66     	; 0x20c6 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2084:	0f b6       	in	r0, 0x3f	; 63
    2086:	f8 94       	cli
    2088:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    208a:	e0 91 9e 08 	lds	r30, 0x089E
    208e:	f0 91 9f 08 	lds	r31, 0x089F
    2092:	06 81       	ldd	r16, Z+6	; 0x06
    2094:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2096:	c8 01       	movw	r24, r16
    2098:	02 96       	adiw	r24, 0x02	; 2
    209a:	0e 94 09 03 	call	0x612	; 0x612 <uxListRemove>
					--uxCurrentNumberOfTasks;
    209e:	80 91 97 08 	lds	r24, 0x0897
    20a2:	81 50       	subi	r24, 0x01	; 1
    20a4:	80 93 97 08 	sts	0x0897, r24
					--uxTasksDeleted;
    20a8:	80 91 98 08 	lds	r24, 0x0898
    20ac:	81 50       	subi	r24, 0x01	; 1
    20ae:	80 93 98 08 	sts	0x0898, r24
				}
				taskEXIT_CRITICAL();
    20b2:	0f 90       	pop	r0
    20b4:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    20b6:	f8 01       	movw	r30, r16
    20b8:	87 89       	ldd	r24, Z+23	; 0x17
    20ba:	90 8d       	ldd	r25, Z+24	; 0x18
    20bc:	0e 94 a4 02 	call	0x548	; 0x548 <vPortFree>
		vPortFree( pxTCB );
    20c0:	c8 01       	movw	r24, r16
    20c2:	0e 94 a4 02 	call	0x548	; 0x548 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    20c6:	80 91 98 08 	lds	r24, 0x0898
    20ca:	81 11       	cpse	r24, r1
    20cc:	d6 cf       	rjmp	.-84     	; 0x207a <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    20ce:	f7 01       	movw	r30, r14
    20d0:	80 81       	ld	r24, Z
    20d2:	82 30       	cpi	r24, 0x02	; 2
    20d4:	c0 f3       	brcs	.-16     	; 0x20c6 <prvIdleTask+0x5e>
			{
				taskYIELD();
    20d6:	97 d9       	rcall	.-3282   	; 0x1406 <vPortYield>
    20d8:	f6 cf       	rjmp	.-20     	; 0x20c6 <prvIdleTask+0x5e>

000020da <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    20da:	80 91 8e 08 	lds	r24, 0x088E
    20de:	88 23       	and	r24, r24
    20e0:	21 f0       	breq	.+8      	; 0x20ea <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	80 93 91 08 	sts	0x0891, r24
    20e8:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    20ea:	10 92 91 08 	sts	0x0891, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    20ee:	80 91 94 08 	lds	r24, 0x0894
    20f2:	90 e0       	ldi	r25, 0x00	; 0
    20f4:	fc 01       	movw	r30, r24
    20f6:	ee 0f       	add	r30, r30
    20f8:	ff 1f       	adc	r31, r31
    20fa:	ee 0f       	add	r30, r30
    20fc:	ff 1f       	adc	r31, r31
    20fe:	ee 0f       	add	r30, r30
    2100:	ff 1f       	adc	r31, r31
    2102:	8e 0f       	add	r24, r30
    2104:	9f 1f       	adc	r25, r31
    2106:	fc 01       	movw	r30, r24
    2108:	ef 53       	subi	r30, 0x3F	; 63
    210a:	f7 4f       	sbci	r31, 0xF7	; 247
    210c:	80 81       	ld	r24, Z
    210e:	81 11       	cpse	r24, r1
    2110:	17 c0       	rjmp	.+46     	; 0x2140 <vTaskSwitchContext+0x66>
    2112:	80 91 94 08 	lds	r24, 0x0894
    2116:	81 50       	subi	r24, 0x01	; 1
    2118:	80 93 94 08 	sts	0x0894, r24
    211c:	80 91 94 08 	lds	r24, 0x0894
    2120:	90 e0       	ldi	r25, 0x00	; 0
    2122:	fc 01       	movw	r30, r24
    2124:	ee 0f       	add	r30, r30
    2126:	ff 1f       	adc	r31, r31
    2128:	ee 0f       	add	r30, r30
    212a:	ff 1f       	adc	r31, r31
    212c:	ee 0f       	add	r30, r30
    212e:	ff 1f       	adc	r31, r31
    2130:	8e 0f       	add	r24, r30
    2132:	9f 1f       	adc	r25, r31
    2134:	fc 01       	movw	r30, r24
    2136:	ef 53       	subi	r30, 0x3F	; 63
    2138:	f7 4f       	sbci	r31, 0xF7	; 247
    213a:	80 81       	ld	r24, Z
    213c:	88 23       	and	r24, r24
    213e:	49 f3       	breq	.-46     	; 0x2112 <vTaskSwitchContext+0x38>
    2140:	e0 91 94 08 	lds	r30, 0x0894
    2144:	f0 e0       	ldi	r31, 0x00	; 0
    2146:	cf 01       	movw	r24, r30
    2148:	88 0f       	add	r24, r24
    214a:	99 1f       	adc	r25, r25
    214c:	88 0f       	add	r24, r24
    214e:	99 1f       	adc	r25, r25
    2150:	88 0f       	add	r24, r24
    2152:	99 1f       	adc	r25, r25
    2154:	e8 0f       	add	r30, r24
    2156:	f9 1f       	adc	r31, r25
    2158:	ef 53       	subi	r30, 0x3F	; 63
    215a:	f7 4f       	sbci	r31, 0xF7	; 247
    215c:	a1 81       	ldd	r26, Z+1	; 0x01
    215e:	b2 81       	ldd	r27, Z+2	; 0x02
    2160:	12 96       	adiw	r26, 0x02	; 2
    2162:	0d 90       	ld	r0, X+
    2164:	bc 91       	ld	r27, X
    2166:	a0 2d       	mov	r26, r0
    2168:	b2 83       	std	Z+2, r27	; 0x02
    216a:	a1 83       	std	Z+1, r26	; 0x01
    216c:	cf 01       	movw	r24, r30
    216e:	03 96       	adiw	r24, 0x03	; 3
    2170:	a8 17       	cp	r26, r24
    2172:	b9 07       	cpc	r27, r25
    2174:	31 f4       	brne	.+12     	; 0x2182 <vTaskSwitchContext+0xa8>
    2176:	12 96       	adiw	r26, 0x02	; 2
    2178:	8d 91       	ld	r24, X+
    217a:	9c 91       	ld	r25, X
    217c:	13 97       	sbiw	r26, 0x03	; 3
    217e:	92 83       	std	Z+2, r25	; 0x02
    2180:	81 83       	std	Z+1, r24	; 0x01
    2182:	01 80       	ldd	r0, Z+1	; 0x01
    2184:	f2 81       	ldd	r31, Z+2	; 0x02
    2186:	e0 2d       	mov	r30, r0
    2188:	86 81       	ldd	r24, Z+6	; 0x06
    218a:	97 81       	ldd	r25, Z+7	; 0x07
    218c:	90 93 e6 08 	sts	0x08E6, r25
    2190:	80 93 e5 08 	sts	0x08E5, r24
    2194:	08 95       	ret

00002196 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2196:	10 92 54 09 	sts	0x0954, r1
    219a:	81 e0       	ldi	r24, 0x01	; 1
    219c:	80 93 52 09 	sts	0x0952, r24
    21a0:	10 92 51 09 	sts	0x0951, r1
    21a4:	61 e0       	ldi	r22, 0x01	; 1
    21a6:	84 e1       	ldi	r24, 0x14	; 20
    21a8:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    21ac:	61 e0       	ldi	r22, 0x01	; 1
    21ae:	85 e1       	ldi	r24, 0x15	; 21
    21b0:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <digitalWrite>
    21b4:	e9 eb       	ldi	r30, 0xB9	; 185
    21b6:	f0 e0       	ldi	r31, 0x00	; 0
    21b8:	80 81       	ld	r24, Z
    21ba:	8e 7f       	andi	r24, 0xFE	; 254
    21bc:	80 83       	st	Z, r24
    21be:	80 81       	ld	r24, Z
    21c0:	8d 7f       	andi	r24, 0xFD	; 253
    21c2:	80 83       	st	Z, r24
    21c4:	8d ef       	ldi	r24, 0xFD	; 253
    21c6:	80 93 b8 00 	sts	0x00B8, r24
    21ca:	85 e4       	ldi	r24, 0x45	; 69
    21cc:	80 93 bc 00 	sts	0x00BC, r24
    21d0:	08 95       	ret

000021d2 <twi_readFrom>:
    21d2:	41 32       	cpi	r20, 0x21	; 33
    21d4:	08 f0       	brcs	.+2      	; 0x21d8 <twi_readFrom+0x6>
    21d6:	45 c0       	rjmp	.+138    	; 0x2262 <__stack+0x63>
    21d8:	90 91 54 09 	lds	r25, 0x0954
    21dc:	91 11       	cpse	r25, r1
    21de:	fc cf       	rjmp	.-8      	; 0x21d8 <twi_readFrom+0x6>
    21e0:	91 e0       	ldi	r25, 0x01	; 1
    21e2:	90 93 54 09 	sts	0x0954, r25
    21e6:	20 93 52 09 	sts	0x0952, r18
    21ea:	2f ef       	ldi	r18, 0xFF	; 255
    21ec:	20 93 e7 08 	sts	0x08E7, r18
    21f0:	10 92 2c 09 	sts	0x092C, r1
    21f4:	24 0f       	add	r18, r20
    21f6:	20 93 2b 09 	sts	0x092B, r18
    21fa:	90 93 53 09 	sts	0x0953, r25
    21fe:	90 91 53 09 	lds	r25, 0x0953
    2202:	88 0f       	add	r24, r24
    2204:	89 2b       	or	r24, r25
    2206:	80 93 53 09 	sts	0x0953, r24
    220a:	80 91 51 09 	lds	r24, 0x0951
    220e:	81 30       	cpi	r24, 0x01	; 1
    2210:	51 f4       	brne	.+20     	; 0x2226 <__stack+0x27>
    2212:	10 92 51 09 	sts	0x0951, r1
    2216:	80 91 53 09 	lds	r24, 0x0953
    221a:	80 93 bb 00 	sts	0x00BB, r24
    221e:	85 ec       	ldi	r24, 0xC5	; 197
    2220:	80 93 bc 00 	sts	0x00BC, r24
    2224:	03 c0       	rjmp	.+6      	; 0x222c <__stack+0x2d>
    2226:	85 ee       	ldi	r24, 0xE5	; 229
    2228:	80 93 bc 00 	sts	0x00BC, r24
    222c:	80 91 54 09 	lds	r24, 0x0954
    2230:	81 30       	cpi	r24, 0x01	; 1
    2232:	e1 f3       	breq	.-8      	; 0x222c <__stack+0x2d>
    2234:	80 91 2c 09 	lds	r24, 0x092C
    2238:	84 17       	cp	r24, r20
    223a:	10 f4       	brcc	.+4      	; 0x2240 <__stack+0x41>
    223c:	40 91 2c 09 	lds	r20, 0x092C
    2240:	44 23       	and	r20, r20
    2242:	89 f0       	breq	.+34     	; 0x2266 <__stack+0x67>
    2244:	ed e2       	ldi	r30, 0x2D	; 45
    2246:	f9 e0       	ldi	r31, 0x09	; 9
    2248:	a6 2f       	mov	r26, r22
    224a:	b7 2f       	mov	r27, r23
    224c:	2f ef       	ldi	r18, 0xFF	; 255
    224e:	24 0f       	add	r18, r20
    2250:	30 e0       	ldi	r19, 0x00	; 0
    2252:	22 5d       	subi	r18, 0xD2	; 210
    2254:	36 4f       	sbci	r19, 0xF6	; 246
    2256:	91 91       	ld	r25, Z+
    2258:	9d 93       	st	X+, r25
    225a:	e2 17       	cp	r30, r18
    225c:	f3 07       	cpc	r31, r19
    225e:	d9 f7       	brne	.-10     	; 0x2256 <__stack+0x57>
    2260:	04 c0       	rjmp	.+8      	; 0x226a <__stack+0x6b>
    2262:	80 e0       	ldi	r24, 0x00	; 0
    2264:	08 95       	ret
    2266:	84 2f       	mov	r24, r20
    2268:	08 95       	ret
    226a:	84 2f       	mov	r24, r20
    226c:	08 95       	ret

0000226e <twi_writeTo>:
    226e:	0f 93       	push	r16
    2270:	41 32       	cpi	r20, 0x21	; 33
    2272:	08 f0       	brcs	.+2      	; 0x2276 <twi_writeTo+0x8>
    2274:	50 c0       	rjmp	.+160    	; 0x2316 <twi_writeTo+0xa8>
    2276:	90 91 54 09 	lds	r25, 0x0954
    227a:	91 11       	cpse	r25, r1
    227c:	fc cf       	rjmp	.-8      	; 0x2276 <twi_writeTo+0x8>
    227e:	92 e0       	ldi	r25, 0x02	; 2
    2280:	90 93 54 09 	sts	0x0954, r25
    2284:	00 93 52 09 	sts	0x0952, r16
    2288:	9f ef       	ldi	r25, 0xFF	; 255
    228a:	90 93 e7 08 	sts	0x08E7, r25
    228e:	10 92 2c 09 	sts	0x092C, r1
    2292:	40 93 2b 09 	sts	0x092B, r20
    2296:	44 23       	and	r20, r20
    2298:	69 f0       	breq	.+26     	; 0x22b4 <twi_writeTo+0x46>
    229a:	fb 01       	movw	r30, r22
    229c:	ad e2       	ldi	r26, 0x2D	; 45
    229e:	b9 e0       	ldi	r27, 0x09	; 9
    22a0:	6f 5f       	subi	r22, 0xFF	; 255
    22a2:	7f 4f       	sbci	r23, 0xFF	; 255
    22a4:	41 50       	subi	r20, 0x01	; 1
    22a6:	64 0f       	add	r22, r20
    22a8:	71 1d       	adc	r23, r1
    22aa:	91 91       	ld	r25, Z+
    22ac:	9d 93       	st	X+, r25
    22ae:	e6 17       	cp	r30, r22
    22b0:	f7 07       	cpc	r31, r23
    22b2:	d9 f7       	brne	.-10     	; 0x22aa <twi_writeTo+0x3c>
    22b4:	10 92 53 09 	sts	0x0953, r1
    22b8:	90 91 53 09 	lds	r25, 0x0953
    22bc:	88 0f       	add	r24, r24
    22be:	89 2b       	or	r24, r25
    22c0:	80 93 53 09 	sts	0x0953, r24
    22c4:	80 91 51 09 	lds	r24, 0x0951
    22c8:	81 30       	cpi	r24, 0x01	; 1
    22ca:	51 f4       	brne	.+20     	; 0x22e0 <twi_writeTo+0x72>
    22cc:	10 92 51 09 	sts	0x0951, r1
    22d0:	80 91 53 09 	lds	r24, 0x0953
    22d4:	80 93 bb 00 	sts	0x00BB, r24
    22d8:	85 ec       	ldi	r24, 0xC5	; 197
    22da:	80 93 bc 00 	sts	0x00BC, r24
    22de:	03 c0       	rjmp	.+6      	; 0x22e6 <twi_writeTo+0x78>
    22e0:	85 ee       	ldi	r24, 0xE5	; 229
    22e2:	80 93 bc 00 	sts	0x00BC, r24
    22e6:	22 23       	and	r18, r18
    22e8:	41 f0       	breq	.+16     	; 0x22fa <twi_writeTo+0x8c>
    22ea:	80 91 54 09 	lds	r24, 0x0954
    22ee:	82 30       	cpi	r24, 0x02	; 2
    22f0:	21 f4       	brne	.+8      	; 0x22fa <twi_writeTo+0x8c>
    22f2:	80 91 54 09 	lds	r24, 0x0954
    22f6:	82 30       	cpi	r24, 0x02	; 2
    22f8:	e1 f3       	breq	.-8      	; 0x22f2 <twi_writeTo+0x84>
    22fa:	80 91 e7 08 	lds	r24, 0x08E7
    22fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2300:	61 f0       	breq	.+24     	; 0x231a <twi_writeTo+0xac>
    2302:	80 91 e7 08 	lds	r24, 0x08E7
    2306:	80 32       	cpi	r24, 0x20	; 32
    2308:	51 f0       	breq	.+20     	; 0x231e <twi_writeTo+0xb0>
    230a:	80 91 e7 08 	lds	r24, 0x08E7
    230e:	80 33       	cpi	r24, 0x30	; 48
    2310:	41 f4       	brne	.+16     	; 0x2322 <twi_writeTo+0xb4>
    2312:	83 e0       	ldi	r24, 0x03	; 3
    2314:	07 c0       	rjmp	.+14     	; 0x2324 <twi_writeTo+0xb6>
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	05 c0       	rjmp	.+10     	; 0x2324 <twi_writeTo+0xb6>
    231a:	80 e0       	ldi	r24, 0x00	; 0
    231c:	03 c0       	rjmp	.+6      	; 0x2324 <twi_writeTo+0xb6>
    231e:	82 e0       	ldi	r24, 0x02	; 2
    2320:	01 c0       	rjmp	.+2      	; 0x2324 <twi_writeTo+0xb6>
    2322:	84 e0       	ldi	r24, 0x04	; 4
    2324:	0f 91       	pop	r16
    2326:	08 95       	ret

00002328 <twi_transmit>:
    2328:	61 32       	cpi	r22, 0x21	; 33
    232a:	a8 f4       	brcc	.+42     	; 0x2356 <twi_transmit+0x2e>
    232c:	20 91 54 09 	lds	r18, 0x0954
    2330:	24 30       	cpi	r18, 0x04	; 4
    2332:	99 f4       	brne	.+38     	; 0x235a <twi_transmit+0x32>
    2334:	60 93 09 09 	sts	0x0909, r22
    2338:	66 23       	and	r22, r22
    233a:	89 f0       	breq	.+34     	; 0x235e <twi_transmit+0x36>
    233c:	fc 01       	movw	r30, r24
    233e:	ab e0       	ldi	r26, 0x0B	; 11
    2340:	b9 e0       	ldi	r27, 0x09	; 9
    2342:	01 96       	adiw	r24, 0x01	; 1
    2344:	61 50       	subi	r22, 0x01	; 1
    2346:	86 0f       	add	r24, r22
    2348:	91 1d       	adc	r25, r1
    234a:	21 91       	ld	r18, Z+
    234c:	2d 93       	st	X+, r18
    234e:	e8 17       	cp	r30, r24
    2350:	f9 07       	cpc	r31, r25
    2352:	d9 f7       	brne	.-10     	; 0x234a <twi_transmit+0x22>
    2354:	06 c0       	rjmp	.+12     	; 0x2362 <twi_transmit+0x3a>
    2356:	81 e0       	ldi	r24, 0x01	; 1
    2358:	08 95       	ret
    235a:	82 e0       	ldi	r24, 0x02	; 2
    235c:	08 95       	ret
    235e:	80 e0       	ldi	r24, 0x00	; 0
    2360:	08 95       	ret
    2362:	80 e0       	ldi	r24, 0x00	; 0
    2364:	08 95       	ret

00002366 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    2366:	85 ed       	ldi	r24, 0xD5	; 213
    2368:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    236c:	ec eb       	ldi	r30, 0xBC	; 188
    236e:	f0 e0       	ldi	r31, 0x00	; 0
    2370:	80 81       	ld	r24, Z
    2372:	84 fd       	sbrc	r24, 4
    2374:	fd cf       	rjmp	.-6      	; 0x2370 <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    2376:	10 92 54 09 	sts	0x0954, r1
    237a:	08 95       	ret

0000237c <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    237c:	85 ec       	ldi	r24, 0xC5	; 197
    237e:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2382:	10 92 54 09 	sts	0x0954, r1
    2386:	08 95       	ret

00002388 <__vector_39>:
}

ISR(TWI_vect)
{
    2388:	1f 92       	push	r1
    238a:	0f 92       	push	r0
    238c:	0f b6       	in	r0, 0x3f	; 63
    238e:	0f 92       	push	r0
    2390:	11 24       	eor	r1, r1
    2392:	0b b6       	in	r0, 0x3b	; 59
    2394:	0f 92       	push	r0
    2396:	2f 93       	push	r18
    2398:	3f 93       	push	r19
    239a:	4f 93       	push	r20
    239c:	5f 93       	push	r21
    239e:	6f 93       	push	r22
    23a0:	7f 93       	push	r23
    23a2:	8f 93       	push	r24
    23a4:	9f 93       	push	r25
    23a6:	af 93       	push	r26
    23a8:	bf 93       	push	r27
    23aa:	ef 93       	push	r30
    23ac:	ff 93       	push	r31
  switch(TW_STATUS){
    23ae:	80 91 b9 00 	lds	r24, 0x00B9
    23b2:	88 7f       	andi	r24, 0xF8	; 248
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	89 3c       	cpi	r24, 0xC9	; 201
    23b8:	91 05       	cpc	r25, r1
    23ba:	08 f0       	brcs	.+2      	; 0x23be <__vector_39+0x36>
    23bc:	ee c0       	rjmp	.+476    	; 0x259a <__vector_39+0x212>
    23be:	fc 01       	movw	r30, r24
    23c0:	ee 58       	subi	r30, 0x8E	; 142
    23c2:	ff 4f       	sbci	r31, 0xFF	; 255
    23c4:	0c 94 1e 1c 	jmp	0x383c	; 0x383c <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    23c8:	80 91 53 09 	lds	r24, 0x0953
    23cc:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    23d0:	85 ec       	ldi	r24, 0xC5	; 197
    23d2:	80 93 bc 00 	sts	0x00BC, r24
    23d6:	e1 c0       	rjmp	.+450    	; 0x259a <__vector_39+0x212>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    23d8:	90 91 2c 09 	lds	r25, 0x092C
    23dc:	80 91 2b 09 	lds	r24, 0x092B
    23e0:	98 17       	cp	r25, r24
    23e2:	80 f4       	brcc	.+32     	; 0x2404 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    23e4:	e0 91 2c 09 	lds	r30, 0x092C
    23e8:	81 e0       	ldi	r24, 0x01	; 1
    23ea:	8e 0f       	add	r24, r30
    23ec:	80 93 2c 09 	sts	0x092C, r24
    23f0:	f0 e0       	ldi	r31, 0x00	; 0
    23f2:	e3 5d       	subi	r30, 0xD3	; 211
    23f4:	f6 4f       	sbci	r31, 0xF6	; 246
    23f6:	80 81       	ld	r24, Z
    23f8:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    23fc:	85 ec       	ldi	r24, 0xC5	; 197
    23fe:	80 93 bc 00 	sts	0x00BC, r24
    2402:	cb c0       	rjmp	.+406    	; 0x259a <__vector_39+0x212>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    2404:	80 91 52 09 	lds	r24, 0x0952
    2408:	88 23       	and	r24, r24
    240a:	11 f0       	breq	.+4      	; 0x2410 <__vector_39+0x88>
          twi_stop();
    240c:	ac df       	rcall	.-168    	; 0x2366 <twi_stop>
    240e:	c5 c0       	rjmp	.+394    	; 0x259a <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2410:	81 e0       	ldi	r24, 0x01	; 1
    2412:	80 93 51 09 	sts	0x0951, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2416:	84 ea       	ldi	r24, 0xA4	; 164
    2418:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    241c:	10 92 54 09 	sts	0x0954, r1
    2420:	bc c0       	rjmp	.+376    	; 0x259a <__vector_39+0x212>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    2422:	80 e2       	ldi	r24, 0x20	; 32
    2424:	80 93 e7 08 	sts	0x08E7, r24
      twi_stop();
    2428:	9e df       	rcall	.-196    	; 0x2366 <twi_stop>
      break;
    242a:	b7 c0       	rjmp	.+366    	; 0x259a <__vector_39+0x212>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    242c:	80 e3       	ldi	r24, 0x30	; 48
    242e:	80 93 e7 08 	sts	0x08E7, r24
      twi_stop();
    2432:	99 df       	rcall	.-206    	; 0x2366 <twi_stop>
      break;
    2434:	b2 c0       	rjmp	.+356    	; 0x259a <__vector_39+0x212>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    2436:	88 e3       	ldi	r24, 0x38	; 56
    2438:	80 93 e7 08 	sts	0x08E7, r24
      twi_releaseBus();
    243c:	9f df       	rcall	.-194    	; 0x237c <twi_releaseBus>
      break;
    243e:	ad c0       	rjmp	.+346    	; 0x259a <__vector_39+0x212>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2440:	e0 91 2c 09 	lds	r30, 0x092C
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	8e 0f       	add	r24, r30
    2448:	80 93 2c 09 	sts	0x092C, r24
    244c:	80 91 bb 00 	lds	r24, 0x00BB
    2450:	f0 e0       	ldi	r31, 0x00	; 0
    2452:	e3 5d       	subi	r30, 0xD3	; 211
    2454:	f6 4f       	sbci	r31, 0xF6	; 246
    2456:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2458:	90 91 2c 09 	lds	r25, 0x092C
    245c:	80 91 2b 09 	lds	r24, 0x092B
    2460:	98 17       	cp	r25, r24
    2462:	20 f4       	brcc	.+8      	; 0x246c <__vector_39+0xe4>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2464:	85 ec       	ldi	r24, 0xC5	; 197
    2466:	80 93 bc 00 	sts	0x00BC, r24
    246a:	97 c0       	rjmp	.+302    	; 0x259a <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    246c:	85 e8       	ldi	r24, 0x85	; 133
    246e:	80 93 bc 00 	sts	0x00BC, r24
    2472:	93 c0       	rjmp	.+294    	; 0x259a <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2474:	e0 91 2c 09 	lds	r30, 0x092C
    2478:	81 e0       	ldi	r24, 0x01	; 1
    247a:	8e 0f       	add	r24, r30
    247c:	80 93 2c 09 	sts	0x092C, r24
    2480:	80 91 bb 00 	lds	r24, 0x00BB
    2484:	f0 e0       	ldi	r31, 0x00	; 0
    2486:	e3 5d       	subi	r30, 0xD3	; 211
    2488:	f6 4f       	sbci	r31, 0xF6	; 246
    248a:	80 83       	st	Z, r24
	if (twi_sendStop)
    248c:	80 91 52 09 	lds	r24, 0x0952
    2490:	88 23       	and	r24, r24
    2492:	11 f0       	breq	.+4      	; 0x2498 <__vector_39+0x110>
          twi_stop();
    2494:	68 df       	rcall	.-304    	; 0x2366 <twi_stop>
    2496:	81 c0       	rjmp	.+258    	; 0x259a <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	80 93 51 09 	sts	0x0951, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    249e:	84 ea       	ldi	r24, 0xA4	; 164
    24a0:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    24a4:	10 92 54 09 	sts	0x0954, r1
    24a8:	78 c0       	rjmp	.+240    	; 0x259a <__vector_39+0x212>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    24aa:	5d df       	rcall	.-326    	; 0x2366 <twi_stop>
      break;
    24ac:	76 c0       	rjmp	.+236    	; 0x259a <__vector_39+0x212>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    24ae:	83 e0       	ldi	r24, 0x03	; 3
    24b0:	80 93 54 09 	sts	0x0954, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    24b4:	10 92 e8 08 	sts	0x08E8, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    24b8:	85 ec       	ldi	r24, 0xC5	; 197
    24ba:	80 93 bc 00 	sts	0x00BC, r24
    24be:	6d c0       	rjmp	.+218    	; 0x259a <__vector_39+0x212>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    24c0:	80 91 e8 08 	lds	r24, 0x08E8
    24c4:	80 32       	cpi	r24, 0x20	; 32
    24c6:	80 f4       	brcc	.+32     	; 0x24e8 <__vector_39+0x160>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    24c8:	e0 91 e8 08 	lds	r30, 0x08E8
    24cc:	81 e0       	ldi	r24, 0x01	; 1
    24ce:	8e 0f       	add	r24, r30
    24d0:	80 93 e8 08 	sts	0x08E8, r24
    24d4:	80 91 bb 00 	lds	r24, 0x00BB
    24d8:	f0 e0       	ldi	r31, 0x00	; 0
    24da:	e7 51       	subi	r30, 0x17	; 23
    24dc:	f7 4f       	sbci	r31, 0xF7	; 247
    24de:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    24e0:	85 ec       	ldi	r24, 0xC5	; 197
    24e2:	80 93 bc 00 	sts	0x00BC, r24
    24e6:	59 c0       	rjmp	.+178    	; 0x259a <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    24e8:	85 e8       	ldi	r24, 0x85	; 133
    24ea:	80 93 bc 00 	sts	0x00BC, r24
    24ee:	55 c0       	rjmp	.+170    	; 0x259a <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    24f0:	80 91 e8 08 	lds	r24, 0x08E8
    24f4:	80 32       	cpi	r24, 0x20	; 32
    24f6:	30 f4       	brcc	.+12     	; 0x2504 <__vector_39+0x17c>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    24f8:	e0 91 e8 08 	lds	r30, 0x08E8
    24fc:	f0 e0       	ldi	r31, 0x00	; 0
    24fe:	e7 51       	subi	r30, 0x17	; 23
    2500:	f7 4f       	sbci	r31, 0xF7	; 247
    2502:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    2504:	30 df       	rcall	.-416    	; 0x2366 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    2506:	60 91 e8 08 	lds	r22, 0x08E8
    250a:	70 e0       	ldi	r23, 0x00	; 0
    250c:	e0 91 4d 09 	lds	r30, 0x094D
    2510:	f0 91 4e 09 	lds	r31, 0x094E
    2514:	89 ee       	ldi	r24, 0xE9	; 233
    2516:	98 e0       	ldi	r25, 0x08	; 8
    2518:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    251a:	10 92 e8 08 	sts	0x08E8, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    251e:	2e df       	rcall	.-420    	; 0x237c <twi_releaseBus>
      break;
    2520:	3c c0       	rjmp	.+120    	; 0x259a <__vector_39+0x212>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2522:	85 e8       	ldi	r24, 0x85	; 133
    2524:	80 93 bc 00 	sts	0x00BC, r24
    2528:	38 c0       	rjmp	.+112    	; 0x259a <__vector_39+0x212>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    252a:	84 e0       	ldi	r24, 0x04	; 4
    252c:	80 93 54 09 	sts	0x0954, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    2530:	10 92 0a 09 	sts	0x090A, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2534:	10 92 09 09 	sts	0x0909, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    2538:	e0 91 4f 09 	lds	r30, 0x094F
    253c:	f0 91 50 09 	lds	r31, 0x0950
    2540:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2542:	80 91 09 09 	lds	r24, 0x0909
    2546:	81 11       	cpse	r24, r1
    2548:	05 c0       	rjmp	.+10     	; 0x2554 <__vector_39+0x1cc>
        twi_txBufferLength = 1;
    254a:	81 e0       	ldi	r24, 0x01	; 1
    254c:	80 93 09 09 	sts	0x0909, r24
        twi_txBuffer[0] = 0x00;
    2550:	10 92 0b 09 	sts	0x090B, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2554:	e0 91 0a 09 	lds	r30, 0x090A
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	8e 0f       	add	r24, r30
    255c:	80 93 0a 09 	sts	0x090A, r24
    2560:	f0 e0       	ldi	r31, 0x00	; 0
    2562:	e5 5f       	subi	r30, 0xF5	; 245
    2564:	f6 4f       	sbci	r31, 0xF6	; 246
    2566:	80 81       	ld	r24, Z
    2568:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    256c:	90 91 0a 09 	lds	r25, 0x090A
    2570:	80 91 09 09 	lds	r24, 0x0909
    2574:	98 17       	cp	r25, r24
    2576:	20 f4       	brcc	.+8      	; 0x2580 <__vector_39+0x1f8>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2578:	85 ec       	ldi	r24, 0xC5	; 197
    257a:	80 93 bc 00 	sts	0x00BC, r24
    257e:	0d c0       	rjmp	.+26     	; 0x259a <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2580:	85 e8       	ldi	r24, 0x85	; 133
    2582:	80 93 bc 00 	sts	0x00BC, r24
    2586:	09 c0       	rjmp	.+18     	; 0x259a <__vector_39+0x212>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2588:	85 ec       	ldi	r24, 0xC5	; 197
    258a:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    258e:	10 92 54 09 	sts	0x0954, r1
      break;
    2592:	03 c0       	rjmp	.+6      	; 0x259a <__vector_39+0x212>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    2594:	10 92 e7 08 	sts	0x08E7, r1
      twi_stop();
    2598:	e6 de       	rcall	.-564    	; 0x2366 <twi_stop>
      break;
  }
}
    259a:	ff 91       	pop	r31
    259c:	ef 91       	pop	r30
    259e:	bf 91       	pop	r27
    25a0:	af 91       	pop	r26
    25a2:	9f 91       	pop	r25
    25a4:	8f 91       	pop	r24
    25a6:	7f 91       	pop	r23
    25a8:	6f 91       	pop	r22
    25aa:	5f 91       	pop	r21
    25ac:	4f 91       	pop	r20
    25ae:	3f 91       	pop	r19
    25b0:	2f 91       	pop	r18
    25b2:	0f 90       	pop	r0
    25b4:	0b be       	out	0x3b, r0	; 59
    25b6:	0f 90       	pop	r0
    25b8:	0f be       	out	0x3f, r0	; 63
    25ba:	0f 90       	pop	r0
    25bc:	1f 90       	pop	r1
    25be:	18 95       	reti

000025c0 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    25c0:	80 91 85 09 	lds	r24, 0x0985
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	20 91 86 09 	lds	r18, 0x0986
    25ca:	82 1b       	sub	r24, r18
    25cc:	91 09       	sbc	r25, r1
    25ce:	08 95       	ret

000025d0 <_ZN7TwoWire4readEv>:
    25d0:	20 91 86 09 	lds	r18, 0x0986
    25d4:	80 91 85 09 	lds	r24, 0x0985
    25d8:	28 17       	cp	r18, r24
    25da:	50 f4       	brcc	.+20     	; 0x25f0 <_ZN7TwoWire4readEv+0x20>
    25dc:	e2 2f       	mov	r30, r18
    25de:	f0 e0       	ldi	r31, 0x00	; 0
    25e0:	e9 57       	subi	r30, 0x79	; 121
    25e2:	f6 4f       	sbci	r31, 0xF6	; 246
    25e4:	80 81       	ld	r24, Z
    25e6:	90 e0       	ldi	r25, 0x00	; 0
    25e8:	2f 5f       	subi	r18, 0xFF	; 255
    25ea:	20 93 86 09 	sts	0x0986, r18
    25ee:	08 95       	ret
    25f0:	8f ef       	ldi	r24, 0xFF	; 255
    25f2:	9f ef       	ldi	r25, 0xFF	; 255
    25f4:	08 95       	ret

000025f6 <_ZN7TwoWire4peekEv>:
    25f6:	e0 91 86 09 	lds	r30, 0x0986
    25fa:	80 91 85 09 	lds	r24, 0x0985
    25fe:	e8 17       	cp	r30, r24
    2600:	30 f4       	brcc	.+12     	; 0x260e <_ZN7TwoWire4peekEv+0x18>
    2602:	f0 e0       	ldi	r31, 0x00	; 0
    2604:	e9 57       	subi	r30, 0x79	; 121
    2606:	f6 4f       	sbci	r31, 0xF6	; 246
    2608:	80 81       	ld	r24, Z
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	08 95       	ret
    260e:	8f ef       	ldi	r24, 0xFF	; 255
    2610:	9f ef       	ldi	r25, 0xFF	; 255
    2612:	08 95       	ret

00002614 <_ZN7TwoWire5flushEv>:
    2614:	08 95       	ret

00002616 <_ZN7TwoWire5writeEPKhj>:
    2616:	cf 92       	push	r12
    2618:	df 92       	push	r13
    261a:	ef 92       	push	r14
    261c:	ff 92       	push	r15
    261e:	0f 93       	push	r16
    2620:	1f 93       	push	r17
    2622:	cf 93       	push	r28
    2624:	df 93       	push	r29
    2626:	8c 01       	movw	r16, r24
    2628:	7b 01       	movw	r14, r22
    262a:	6a 01       	movw	r12, r20
    262c:	80 91 61 09 	lds	r24, 0x0961
    2630:	88 23       	and	r24, r24
    2632:	99 f0       	breq	.+38     	; 0x265a <_ZN7TwoWire5writeEPKhj+0x44>
    2634:	41 15       	cp	r20, r1
    2636:	51 05       	cpc	r21, r1
    2638:	99 f0       	breq	.+38     	; 0x2660 <_ZN7TwoWire5writeEPKhj+0x4a>
    263a:	eb 01       	movw	r28, r22
    263c:	e4 0e       	add	r14, r20
    263e:	f5 1e       	adc	r15, r21
    2640:	69 91       	ld	r22, Y+
    2642:	d8 01       	movw	r26, r16
    2644:	ed 91       	ld	r30, X+
    2646:	fc 91       	ld	r31, X
    2648:	01 90       	ld	r0, Z+
    264a:	f0 81       	ld	r31, Z
    264c:	e0 2d       	mov	r30, r0
    264e:	c8 01       	movw	r24, r16
    2650:	19 95       	eicall
    2652:	ce 15       	cp	r28, r14
    2654:	df 05       	cpc	r29, r15
    2656:	a1 f7       	brne	.-24     	; 0x2640 <_ZN7TwoWire5writeEPKhj+0x2a>
    2658:	03 c0       	rjmp	.+6      	; 0x2660 <_ZN7TwoWire5writeEPKhj+0x4a>
    265a:	64 2f       	mov	r22, r20
    265c:	c7 01       	movw	r24, r14
    265e:	64 de       	rcall	.-824    	; 0x2328 <twi_transmit>
    2660:	c6 01       	movw	r24, r12
    2662:	df 91       	pop	r29
    2664:	cf 91       	pop	r28
    2666:	1f 91       	pop	r17
    2668:	0f 91       	pop	r16
    266a:	ff 90       	pop	r15
    266c:	ef 90       	pop	r14
    266e:	df 90       	pop	r13
    2670:	cf 90       	pop	r12
    2672:	08 95       	ret

00002674 <_ZN7TwoWire5writeEh>:
    2674:	cf 93       	push	r28
    2676:	df 93       	push	r29
    2678:	1f 92       	push	r1
    267a:	cd b7       	in	r28, 0x3d	; 61
    267c:	de b7       	in	r29, 0x3e	; 62
    267e:	69 83       	std	Y+1, r22	; 0x01
    2680:	20 91 61 09 	lds	r18, 0x0961
    2684:	22 23       	and	r18, r18
    2686:	e1 f0       	breq	.+56     	; 0x26c0 <_ZN7TwoWire5writeEh+0x4c>
    2688:	20 91 62 09 	lds	r18, 0x0962
    268c:	20 32       	cpi	r18, 0x20	; 32
    268e:	40 f0       	brcs	.+16     	; 0x26a0 <_ZN7TwoWire5writeEh+0x2c>
    2690:	21 e0       	ldi	r18, 0x01	; 1
    2692:	30 e0       	ldi	r19, 0x00	; 0
    2694:	fc 01       	movw	r30, r24
    2696:	33 83       	std	Z+3, r19	; 0x03
    2698:	22 83       	std	Z+2, r18	; 0x02
    269a:	80 e0       	ldi	r24, 0x00	; 0
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	16 c0       	rjmp	.+44     	; 0x26cc <_ZN7TwoWire5writeEh+0x58>
    26a0:	80 91 63 09 	lds	r24, 0x0963
    26a4:	e8 2f       	mov	r30, r24
    26a6:	f0 e0       	ldi	r31, 0x00	; 0
    26a8:	ec 59       	subi	r30, 0x9C	; 156
    26aa:	f6 4f       	sbci	r31, 0xF6	; 246
    26ac:	99 81       	ldd	r25, Y+1	; 0x01
    26ae:	90 83       	st	Z, r25
    26b0:	8f 5f       	subi	r24, 0xFF	; 255
    26b2:	80 93 63 09 	sts	0x0963, r24
    26b6:	80 93 62 09 	sts	0x0962, r24
    26ba:	81 e0       	ldi	r24, 0x01	; 1
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	06 c0       	rjmp	.+12     	; 0x26cc <_ZN7TwoWire5writeEh+0x58>
    26c0:	61 e0       	ldi	r22, 0x01	; 1
    26c2:	ce 01       	movw	r24, r28
    26c4:	01 96       	adiw	r24, 0x01	; 1
    26c6:	30 de       	rcall	.-928    	; 0x2328 <twi_transmit>
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	90 e0       	ldi	r25, 0x00	; 0
    26cc:	0f 90       	pop	r0
    26ce:	df 91       	pop	r29
    26d0:	cf 91       	pop	r28
    26d2:	08 95       	ret

000026d4 <_ZN7TwoWireC1Ev>:
    26d4:	fc 01       	movw	r30, r24
    26d6:	13 82       	std	Z+3, r1	; 0x03
    26d8:	12 82       	std	Z+2, r1	; 0x02
    26da:	48 ee       	ldi	r20, 0xE8	; 232
    26dc:	53 e0       	ldi	r21, 0x03	; 3
    26de:	60 e0       	ldi	r22, 0x00	; 0
    26e0:	70 e0       	ldi	r23, 0x00	; 0
    26e2:	44 83       	std	Z+4, r20	; 0x04
    26e4:	55 83       	std	Z+5, r21	; 0x05
    26e6:	66 83       	std	Z+6, r22	; 0x06
    26e8:	77 83       	std	Z+7, r23	; 0x07
    26ea:	8f e5       	ldi	r24, 0x5F	; 95
    26ec:	92 e0       	ldi	r25, 0x02	; 2
    26ee:	91 83       	std	Z+1, r25	; 0x01
    26f0:	80 83       	st	Z, r24
    26f2:	08 95       	ret

000026f4 <_ZN7TwoWire5beginEv>:
    26f4:	10 92 86 09 	sts	0x0986, r1
    26f8:	10 92 85 09 	sts	0x0985, r1
    26fc:	10 92 63 09 	sts	0x0963, r1
    2700:	10 92 62 09 	sts	0x0962, r1
    2704:	48 cd       	rjmp	.-1392   	; 0x2196 <twi_init>
    2706:	08 95       	ret

00002708 <_ZN7TwoWire11requestFromEhhh>:
    2708:	86 2f       	mov	r24, r22
    270a:	41 32       	cpi	r20, 0x21	; 33
    270c:	08 f0       	brcs	.+2      	; 0x2710 <_ZN7TwoWire11requestFromEhhh+0x8>
    270e:	40 e2       	ldi	r20, 0x20	; 32
    2710:	67 e8       	ldi	r22, 0x87	; 135
    2712:	79 e0       	ldi	r23, 0x09	; 9
    2714:	5e dd       	rcall	.-1348   	; 0x21d2 <twi_readFrom>
    2716:	10 92 86 09 	sts	0x0986, r1
    271a:	80 93 85 09 	sts	0x0985, r24
    271e:	08 95       	ret

00002720 <_ZN7TwoWire11requestFromEhh>:
    2720:	21 e0       	ldi	r18, 0x01	; 1
    2722:	f2 cf       	rjmp	.-28     	; 0x2708 <_ZN7TwoWire11requestFromEhhh>
    2724:	08 95       	ret

00002726 <_ZN7TwoWire17beginTransmissionEh>:
    2726:	81 e0       	ldi	r24, 0x01	; 1
    2728:	80 93 61 09 	sts	0x0961, r24
    272c:	60 93 84 09 	sts	0x0984, r22
    2730:	10 92 63 09 	sts	0x0963, r1
    2734:	10 92 62 09 	sts	0x0962, r1
    2738:	08 95       	ret

0000273a <_ZN7TwoWire15endTransmissionEh>:
    273a:	0f 93       	push	r16
    273c:	06 2f       	mov	r16, r22
    273e:	21 e0       	ldi	r18, 0x01	; 1
    2740:	40 91 62 09 	lds	r20, 0x0962
    2744:	64 e6       	ldi	r22, 0x64	; 100
    2746:	79 e0       	ldi	r23, 0x09	; 9
    2748:	80 91 84 09 	lds	r24, 0x0984
    274c:	90 dd       	rcall	.-1248   	; 0x226e <twi_writeTo>
    274e:	10 92 63 09 	sts	0x0963, r1
    2752:	10 92 62 09 	sts	0x0962, r1
    2756:	10 92 61 09 	sts	0x0961, r1
    275a:	0f 91       	pop	r16
    275c:	08 95       	ret

0000275e <_ZN7TwoWire15endTransmissionEv>:
    275e:	61 e0       	ldi	r22, 0x01	; 1
    2760:	ec cf       	rjmp	.-40     	; 0x273a <_ZN7TwoWire15endTransmissionEh>
    2762:	08 95       	ret

00002764 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2764:	85 e5       	ldi	r24, 0x55	; 85
    2766:	99 e0       	ldi	r25, 0x09	; 9
    2768:	b5 cf       	rjmp	.-150    	; 0x26d4 <_ZN7TwoWireC1Ev>
    276a:	08 95       	ret

0000276c <__subsf3>:
    276c:	50 58       	subi	r21, 0x80	; 128

0000276e <__addsf3>:
    276e:	bb 27       	eor	r27, r27
    2770:	aa 27       	eor	r26, r26
    2772:	0e d0       	rcall	.+28     	; 0x2790 <__addsf3x>
    2774:	fc c1       	rjmp	.+1016   	; 0x2b6e <__fp_round>
    2776:	ed d1       	rcall	.+986    	; 0x2b52 <__fp_pscA>
    2778:	30 f0       	brcs	.+12     	; 0x2786 <__addsf3+0x18>
    277a:	f2 d1       	rcall	.+996    	; 0x2b60 <__fp_pscB>
    277c:	20 f0       	brcs	.+8      	; 0x2786 <__addsf3+0x18>
    277e:	31 f4       	brne	.+12     	; 0x278c <__addsf3+0x1e>
    2780:	9f 3f       	cpi	r25, 0xFF	; 255
    2782:	11 f4       	brne	.+4      	; 0x2788 <__addsf3+0x1a>
    2784:	1e f4       	brtc	.+6      	; 0x278c <__addsf3+0x1e>
    2786:	bd c1       	rjmp	.+890    	; 0x2b02 <__fp_nan>
    2788:	0e f4       	brtc	.+2      	; 0x278c <__addsf3+0x1e>
    278a:	e0 95       	com	r30
    278c:	e7 fb       	bst	r30, 7
    278e:	b3 c1       	rjmp	.+870    	; 0x2af6 <__fp_inf>

00002790 <__addsf3x>:
    2790:	e9 2f       	mov	r30, r25
    2792:	fe d1       	rcall	.+1020   	; 0x2b90 <__fp_split3>
    2794:	80 f3       	brcs	.-32     	; 0x2776 <__addsf3+0x8>
    2796:	ba 17       	cp	r27, r26
    2798:	62 07       	cpc	r22, r18
    279a:	73 07       	cpc	r23, r19
    279c:	84 07       	cpc	r24, r20
    279e:	95 07       	cpc	r25, r21
    27a0:	18 f0       	brcs	.+6      	; 0x27a8 <__addsf3x+0x18>
    27a2:	71 f4       	brne	.+28     	; 0x27c0 <__addsf3x+0x30>
    27a4:	9e f5       	brtc	.+102    	; 0x280c <__addsf3x+0x7c>
    27a6:	16 c2       	rjmp	.+1068   	; 0x2bd4 <__fp_zero>
    27a8:	0e f4       	brtc	.+2      	; 0x27ac <__addsf3x+0x1c>
    27aa:	e0 95       	com	r30
    27ac:	0b 2e       	mov	r0, r27
    27ae:	ba 2f       	mov	r27, r26
    27b0:	a0 2d       	mov	r26, r0
    27b2:	0b 01       	movw	r0, r22
    27b4:	b9 01       	movw	r22, r18
    27b6:	90 01       	movw	r18, r0
    27b8:	0c 01       	movw	r0, r24
    27ba:	ca 01       	movw	r24, r20
    27bc:	a0 01       	movw	r20, r0
    27be:	11 24       	eor	r1, r1
    27c0:	ff 27       	eor	r31, r31
    27c2:	59 1b       	sub	r21, r25
    27c4:	99 f0       	breq	.+38     	; 0x27ec <__addsf3x+0x5c>
    27c6:	59 3f       	cpi	r21, 0xF9	; 249
    27c8:	50 f4       	brcc	.+20     	; 0x27de <__addsf3x+0x4e>
    27ca:	50 3e       	cpi	r21, 0xE0	; 224
    27cc:	68 f1       	brcs	.+90     	; 0x2828 <__addsf3x+0x98>
    27ce:	1a 16       	cp	r1, r26
    27d0:	f0 40       	sbci	r31, 0x00	; 0
    27d2:	a2 2f       	mov	r26, r18
    27d4:	23 2f       	mov	r18, r19
    27d6:	34 2f       	mov	r19, r20
    27d8:	44 27       	eor	r20, r20
    27da:	58 5f       	subi	r21, 0xF8	; 248
    27dc:	f3 cf       	rjmp	.-26     	; 0x27c4 <__addsf3x+0x34>
    27de:	46 95       	lsr	r20
    27e0:	37 95       	ror	r19
    27e2:	27 95       	ror	r18
    27e4:	a7 95       	ror	r26
    27e6:	f0 40       	sbci	r31, 0x00	; 0
    27e8:	53 95       	inc	r21
    27ea:	c9 f7       	brne	.-14     	; 0x27de <__addsf3x+0x4e>
    27ec:	7e f4       	brtc	.+30     	; 0x280c <__addsf3x+0x7c>
    27ee:	1f 16       	cp	r1, r31
    27f0:	ba 0b       	sbc	r27, r26
    27f2:	62 0b       	sbc	r22, r18
    27f4:	73 0b       	sbc	r23, r19
    27f6:	84 0b       	sbc	r24, r20
    27f8:	ba f0       	brmi	.+46     	; 0x2828 <__addsf3x+0x98>
    27fa:	91 50       	subi	r25, 0x01	; 1
    27fc:	a1 f0       	breq	.+40     	; 0x2826 <__addsf3x+0x96>
    27fe:	ff 0f       	add	r31, r31
    2800:	bb 1f       	adc	r27, r27
    2802:	66 1f       	adc	r22, r22
    2804:	77 1f       	adc	r23, r23
    2806:	88 1f       	adc	r24, r24
    2808:	c2 f7       	brpl	.-16     	; 0x27fa <__addsf3x+0x6a>
    280a:	0e c0       	rjmp	.+28     	; 0x2828 <__addsf3x+0x98>
    280c:	ba 0f       	add	r27, r26
    280e:	62 1f       	adc	r22, r18
    2810:	73 1f       	adc	r23, r19
    2812:	84 1f       	adc	r24, r20
    2814:	48 f4       	brcc	.+18     	; 0x2828 <__addsf3x+0x98>
    2816:	87 95       	ror	r24
    2818:	77 95       	ror	r23
    281a:	67 95       	ror	r22
    281c:	b7 95       	ror	r27
    281e:	f7 95       	ror	r31
    2820:	9e 3f       	cpi	r25, 0xFE	; 254
    2822:	08 f0       	brcs	.+2      	; 0x2826 <__addsf3x+0x96>
    2824:	b3 cf       	rjmp	.-154    	; 0x278c <__addsf3+0x1e>
    2826:	93 95       	inc	r25
    2828:	88 0f       	add	r24, r24
    282a:	08 f0       	brcs	.+2      	; 0x282e <__addsf3x+0x9e>
    282c:	99 27       	eor	r25, r25
    282e:	ee 0f       	add	r30, r30
    2830:	97 95       	ror	r25
    2832:	87 95       	ror	r24
    2834:	08 95       	ret
    2836:	8d d1       	rcall	.+794    	; 0x2b52 <__fp_pscA>
    2838:	58 f0       	brcs	.+22     	; 0x2850 <__addsf3x+0xc0>
    283a:	80 e8       	ldi	r24, 0x80	; 128
    283c:	91 e0       	ldi	r25, 0x01	; 1
    283e:	09 f4       	brne	.+2      	; 0x2842 <__addsf3x+0xb2>
    2840:	9e ef       	ldi	r25, 0xFE	; 254
    2842:	8e d1       	rcall	.+796    	; 0x2b60 <__fp_pscB>
    2844:	28 f0       	brcs	.+10     	; 0x2850 <__addsf3x+0xc0>
    2846:	40 e8       	ldi	r20, 0x80	; 128
    2848:	51 e0       	ldi	r21, 0x01	; 1
    284a:	59 f4       	brne	.+22     	; 0x2862 <atan2+0xe>
    284c:	5e ef       	ldi	r21, 0xFE	; 254
    284e:	09 c0       	rjmp	.+18     	; 0x2862 <atan2+0xe>
    2850:	58 c1       	rjmp	.+688    	; 0x2b02 <__fp_nan>
    2852:	c0 c1       	rjmp	.+896    	; 0x2bd4 <__fp_zero>

00002854 <atan2>:
    2854:	e9 2f       	mov	r30, r25
    2856:	e0 78       	andi	r30, 0x80	; 128
    2858:	9b d1       	rcall	.+822    	; 0x2b90 <__fp_split3>
    285a:	68 f3       	brcs	.-38     	; 0x2836 <__addsf3x+0xa6>
    285c:	09 2e       	mov	r0, r25
    285e:	05 2a       	or	r0, r21
    2860:	c1 f3       	breq	.-16     	; 0x2852 <__addsf3x+0xc2>
    2862:	26 17       	cp	r18, r22
    2864:	37 07       	cpc	r19, r23
    2866:	48 07       	cpc	r20, r24
    2868:	59 07       	cpc	r21, r25
    286a:	38 f0       	brcs	.+14     	; 0x287a <atan2+0x26>
    286c:	0e 2e       	mov	r0, r30
    286e:	07 f8       	bld	r0, 7
    2870:	e0 25       	eor	r30, r0
    2872:	69 f0       	breq	.+26     	; 0x288e <atan2+0x3a>
    2874:	e0 25       	eor	r30, r0
    2876:	e0 64       	ori	r30, 0x40	; 64
    2878:	0a c0       	rjmp	.+20     	; 0x288e <atan2+0x3a>
    287a:	ef 63       	ori	r30, 0x3F	; 63
    287c:	07 f8       	bld	r0, 7
    287e:	00 94       	com	r0
    2880:	07 fa       	bst	r0, 7
    2882:	db 01       	movw	r26, r22
    2884:	b9 01       	movw	r22, r18
    2886:	9d 01       	movw	r18, r26
    2888:	dc 01       	movw	r26, r24
    288a:	ca 01       	movw	r24, r20
    288c:	ad 01       	movw	r20, r26
    288e:	ef 93       	push	r30
    2890:	47 d0       	rcall	.+142    	; 0x2920 <__divsf3_pse>
    2892:	6d d1       	rcall	.+730    	; 0x2b6e <__fp_round>
    2894:	0a d0       	rcall	.+20     	; 0x28aa <atan>
    2896:	5f 91       	pop	r21
    2898:	55 23       	and	r21, r21
    289a:	31 f0       	breq	.+12     	; 0x28a8 <atan2+0x54>
    289c:	2b ed       	ldi	r18, 0xDB	; 219
    289e:	3f e0       	ldi	r19, 0x0F	; 15
    28a0:	49 e4       	ldi	r20, 0x49	; 73
    28a2:	50 fd       	sbrc	r21, 0
    28a4:	49 ec       	ldi	r20, 0xC9	; 201
    28a6:	63 cf       	rjmp	.-314    	; 0x276e <__addsf3>
    28a8:	08 95       	ret

000028aa <atan>:
    28aa:	df 93       	push	r29
    28ac:	dd 27       	eor	r29, r29
    28ae:	b9 2f       	mov	r27, r25
    28b0:	bf 77       	andi	r27, 0x7F	; 127
    28b2:	40 e8       	ldi	r20, 0x80	; 128
    28b4:	5f e3       	ldi	r21, 0x3F	; 63
    28b6:	16 16       	cp	r1, r22
    28b8:	17 06       	cpc	r1, r23
    28ba:	48 07       	cpc	r20, r24
    28bc:	5b 07       	cpc	r21, r27
    28be:	10 f4       	brcc	.+4      	; 0x28c4 <atan+0x1a>
    28c0:	d9 2f       	mov	r29, r25
    28c2:	8f d1       	rcall	.+798    	; 0x2be2 <inverse>
    28c4:	9f 93       	push	r25
    28c6:	8f 93       	push	r24
    28c8:	7f 93       	push	r23
    28ca:	6f 93       	push	r22
    28cc:	36 d2       	rcall	.+1132   	; 0x2d3a <square>
    28ce:	e6 e7       	ldi	r30, 0x76	; 118
    28d0:	f2 e0       	ldi	r31, 0x02	; 2
    28d2:	1a d1       	rcall	.+564    	; 0x2b08 <__fp_powser>
    28d4:	4c d1       	rcall	.+664    	; 0x2b6e <__fp_round>
    28d6:	2f 91       	pop	r18
    28d8:	3f 91       	pop	r19
    28da:	4f 91       	pop	r20
    28dc:	5f 91       	pop	r21
    28de:	94 d1       	rcall	.+808    	; 0x2c08 <__mulsf3x>
    28e0:	dd 23       	and	r29, r29
    28e2:	49 f0       	breq	.+18     	; 0x28f6 <atan+0x4c>
    28e4:	90 58       	subi	r25, 0x80	; 128
    28e6:	a2 ea       	ldi	r26, 0xA2	; 162
    28e8:	2a ed       	ldi	r18, 0xDA	; 218
    28ea:	3f e0       	ldi	r19, 0x0F	; 15
    28ec:	49 ec       	ldi	r20, 0xC9	; 201
    28ee:	5f e3       	ldi	r21, 0x3F	; 63
    28f0:	d0 78       	andi	r29, 0x80	; 128
    28f2:	5d 27       	eor	r21, r29
    28f4:	4d df       	rcall	.-358    	; 0x2790 <__addsf3x>
    28f6:	df 91       	pop	r29
    28f8:	3a c1       	rjmp	.+628    	; 0x2b6e <__fp_round>

000028fa <__cmpsf2>:
    28fa:	d9 d0       	rcall	.+434    	; 0x2aae <__fp_cmp>
    28fc:	08 f4       	brcc	.+2      	; 0x2900 <__cmpsf2+0x6>
    28fe:	81 e0       	ldi	r24, 0x01	; 1
    2900:	08 95       	ret

00002902 <__divsf3>:
    2902:	0c d0       	rcall	.+24     	; 0x291c <__divsf3x>
    2904:	34 c1       	rjmp	.+616    	; 0x2b6e <__fp_round>
    2906:	2c d1       	rcall	.+600    	; 0x2b60 <__fp_pscB>
    2908:	40 f0       	brcs	.+16     	; 0x291a <__divsf3+0x18>
    290a:	23 d1       	rcall	.+582    	; 0x2b52 <__fp_pscA>
    290c:	30 f0       	brcs	.+12     	; 0x291a <__divsf3+0x18>
    290e:	21 f4       	brne	.+8      	; 0x2918 <__divsf3+0x16>
    2910:	5f 3f       	cpi	r21, 0xFF	; 255
    2912:	19 f0       	breq	.+6      	; 0x291a <__divsf3+0x18>
    2914:	f0 c0       	rjmp	.+480    	; 0x2af6 <__fp_inf>
    2916:	51 11       	cpse	r21, r1
    2918:	5e c1       	rjmp	.+700    	; 0x2bd6 <__fp_szero>
    291a:	f3 c0       	rjmp	.+486    	; 0x2b02 <__fp_nan>

0000291c <__divsf3x>:
    291c:	39 d1       	rcall	.+626    	; 0x2b90 <__fp_split3>
    291e:	98 f3       	brcs	.-26     	; 0x2906 <__divsf3+0x4>

00002920 <__divsf3_pse>:
    2920:	99 23       	and	r25, r25
    2922:	c9 f3       	breq	.-14     	; 0x2916 <__divsf3+0x14>
    2924:	55 23       	and	r21, r21
    2926:	b1 f3       	breq	.-20     	; 0x2914 <__divsf3+0x12>
    2928:	95 1b       	sub	r25, r21
    292a:	55 0b       	sbc	r21, r21
    292c:	bb 27       	eor	r27, r27
    292e:	aa 27       	eor	r26, r26
    2930:	62 17       	cp	r22, r18
    2932:	73 07       	cpc	r23, r19
    2934:	84 07       	cpc	r24, r20
    2936:	38 f0       	brcs	.+14     	; 0x2946 <__divsf3_pse+0x26>
    2938:	9f 5f       	subi	r25, 0xFF	; 255
    293a:	5f 4f       	sbci	r21, 0xFF	; 255
    293c:	22 0f       	add	r18, r18
    293e:	33 1f       	adc	r19, r19
    2940:	44 1f       	adc	r20, r20
    2942:	aa 1f       	adc	r26, r26
    2944:	a9 f3       	breq	.-22     	; 0x2930 <__divsf3_pse+0x10>
    2946:	33 d0       	rcall	.+102    	; 0x29ae <__divsf3_pse+0x8e>
    2948:	0e 2e       	mov	r0, r30
    294a:	3a f0       	brmi	.+14     	; 0x295a <__divsf3_pse+0x3a>
    294c:	e0 e8       	ldi	r30, 0x80	; 128
    294e:	30 d0       	rcall	.+96     	; 0x29b0 <__divsf3_pse+0x90>
    2950:	91 50       	subi	r25, 0x01	; 1
    2952:	50 40       	sbci	r21, 0x00	; 0
    2954:	e6 95       	lsr	r30
    2956:	00 1c       	adc	r0, r0
    2958:	ca f7       	brpl	.-14     	; 0x294c <__divsf3_pse+0x2c>
    295a:	29 d0       	rcall	.+82     	; 0x29ae <__divsf3_pse+0x8e>
    295c:	fe 2f       	mov	r31, r30
    295e:	27 d0       	rcall	.+78     	; 0x29ae <__divsf3_pse+0x8e>
    2960:	66 0f       	add	r22, r22
    2962:	77 1f       	adc	r23, r23
    2964:	88 1f       	adc	r24, r24
    2966:	bb 1f       	adc	r27, r27
    2968:	26 17       	cp	r18, r22
    296a:	37 07       	cpc	r19, r23
    296c:	48 07       	cpc	r20, r24
    296e:	ab 07       	cpc	r26, r27
    2970:	b0 e8       	ldi	r27, 0x80	; 128
    2972:	09 f0       	breq	.+2      	; 0x2976 <__divsf3_pse+0x56>
    2974:	bb 0b       	sbc	r27, r27
    2976:	80 2d       	mov	r24, r0
    2978:	bf 01       	movw	r22, r30
    297a:	ff 27       	eor	r31, r31
    297c:	93 58       	subi	r25, 0x83	; 131
    297e:	5f 4f       	sbci	r21, 0xFF	; 255
    2980:	2a f0       	brmi	.+10     	; 0x298c <__divsf3_pse+0x6c>
    2982:	9e 3f       	cpi	r25, 0xFE	; 254
    2984:	51 05       	cpc	r21, r1
    2986:	68 f0       	brcs	.+26     	; 0x29a2 <__divsf3_pse+0x82>
    2988:	b6 c0       	rjmp	.+364    	; 0x2af6 <__fp_inf>
    298a:	25 c1       	rjmp	.+586    	; 0x2bd6 <__fp_szero>
    298c:	5f 3f       	cpi	r21, 0xFF	; 255
    298e:	ec f3       	brlt	.-6      	; 0x298a <__divsf3_pse+0x6a>
    2990:	98 3e       	cpi	r25, 0xE8	; 232
    2992:	dc f3       	brlt	.-10     	; 0x298a <__divsf3_pse+0x6a>
    2994:	86 95       	lsr	r24
    2996:	77 95       	ror	r23
    2998:	67 95       	ror	r22
    299a:	b7 95       	ror	r27
    299c:	f7 95       	ror	r31
    299e:	9f 5f       	subi	r25, 0xFF	; 255
    29a0:	c9 f7       	brne	.-14     	; 0x2994 <__divsf3_pse+0x74>
    29a2:	88 0f       	add	r24, r24
    29a4:	91 1d       	adc	r25, r1
    29a6:	96 95       	lsr	r25
    29a8:	87 95       	ror	r24
    29aa:	97 f9       	bld	r25, 7
    29ac:	08 95       	ret
    29ae:	e1 e0       	ldi	r30, 0x01	; 1
    29b0:	66 0f       	add	r22, r22
    29b2:	77 1f       	adc	r23, r23
    29b4:	88 1f       	adc	r24, r24
    29b6:	bb 1f       	adc	r27, r27
    29b8:	62 17       	cp	r22, r18
    29ba:	73 07       	cpc	r23, r19
    29bc:	84 07       	cpc	r24, r20
    29be:	ba 07       	cpc	r27, r26
    29c0:	20 f0       	brcs	.+8      	; 0x29ca <__divsf3_pse+0xaa>
    29c2:	62 1b       	sub	r22, r18
    29c4:	73 0b       	sbc	r23, r19
    29c6:	84 0b       	sbc	r24, r20
    29c8:	ba 0b       	sbc	r27, r26
    29ca:	ee 1f       	adc	r30, r30
    29cc:	88 f7       	brcc	.-30     	; 0x29b0 <__divsf3_pse+0x90>
    29ce:	e0 95       	com	r30
    29d0:	08 95       	ret

000029d2 <__fixsfsi>:
    29d2:	04 d0       	rcall	.+8      	; 0x29dc <__fixunssfsi>
    29d4:	68 94       	set
    29d6:	b1 11       	cpse	r27, r1
    29d8:	fe c0       	rjmp	.+508    	; 0x2bd6 <__fp_szero>
    29da:	08 95       	ret

000029dc <__fixunssfsi>:
    29dc:	e1 d0       	rcall	.+450    	; 0x2ba0 <__fp_splitA>
    29de:	88 f0       	brcs	.+34     	; 0x2a02 <__fixunssfsi+0x26>
    29e0:	9f 57       	subi	r25, 0x7F	; 127
    29e2:	90 f0       	brcs	.+36     	; 0x2a08 <__fixunssfsi+0x2c>
    29e4:	b9 2f       	mov	r27, r25
    29e6:	99 27       	eor	r25, r25
    29e8:	b7 51       	subi	r27, 0x17	; 23
    29ea:	a0 f0       	brcs	.+40     	; 0x2a14 <__fixunssfsi+0x38>
    29ec:	d1 f0       	breq	.+52     	; 0x2a22 <__fixunssfsi+0x46>
    29ee:	66 0f       	add	r22, r22
    29f0:	77 1f       	adc	r23, r23
    29f2:	88 1f       	adc	r24, r24
    29f4:	99 1f       	adc	r25, r25
    29f6:	1a f0       	brmi	.+6      	; 0x29fe <__fixunssfsi+0x22>
    29f8:	ba 95       	dec	r27
    29fa:	c9 f7       	brne	.-14     	; 0x29ee <__fixunssfsi+0x12>
    29fc:	12 c0       	rjmp	.+36     	; 0x2a22 <__fixunssfsi+0x46>
    29fe:	b1 30       	cpi	r27, 0x01	; 1
    2a00:	81 f0       	breq	.+32     	; 0x2a22 <__fixunssfsi+0x46>
    2a02:	e8 d0       	rcall	.+464    	; 0x2bd4 <__fp_zero>
    2a04:	b1 e0       	ldi	r27, 0x01	; 1
    2a06:	08 95       	ret
    2a08:	e5 c0       	rjmp	.+458    	; 0x2bd4 <__fp_zero>
    2a0a:	67 2f       	mov	r22, r23
    2a0c:	78 2f       	mov	r23, r24
    2a0e:	88 27       	eor	r24, r24
    2a10:	b8 5f       	subi	r27, 0xF8	; 248
    2a12:	39 f0       	breq	.+14     	; 0x2a22 <__fixunssfsi+0x46>
    2a14:	b9 3f       	cpi	r27, 0xF9	; 249
    2a16:	cc f3       	brlt	.-14     	; 0x2a0a <__fixunssfsi+0x2e>
    2a18:	86 95       	lsr	r24
    2a1a:	77 95       	ror	r23
    2a1c:	67 95       	ror	r22
    2a1e:	b3 95       	inc	r27
    2a20:	d9 f7       	brne	.-10     	; 0x2a18 <__fixunssfsi+0x3c>
    2a22:	3e f4       	brtc	.+14     	; 0x2a32 <__fixunssfsi+0x56>
    2a24:	90 95       	com	r25
    2a26:	80 95       	com	r24
    2a28:	70 95       	com	r23
    2a2a:	61 95       	neg	r22
    2a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a2e:	8f 4f       	sbci	r24, 0xFF	; 255
    2a30:	9f 4f       	sbci	r25, 0xFF	; 255
    2a32:	08 95       	ret

00002a34 <__floatunsisf>:
    2a34:	e8 94       	clt
    2a36:	09 c0       	rjmp	.+18     	; 0x2a4a <__floatsisf+0x12>

00002a38 <__floatsisf>:
    2a38:	97 fb       	bst	r25, 7
    2a3a:	3e f4       	brtc	.+14     	; 0x2a4a <__floatsisf+0x12>
    2a3c:	90 95       	com	r25
    2a3e:	80 95       	com	r24
    2a40:	70 95       	com	r23
    2a42:	61 95       	neg	r22
    2a44:	7f 4f       	sbci	r23, 0xFF	; 255
    2a46:	8f 4f       	sbci	r24, 0xFF	; 255
    2a48:	9f 4f       	sbci	r25, 0xFF	; 255
    2a4a:	99 23       	and	r25, r25
    2a4c:	a9 f0       	breq	.+42     	; 0x2a78 <__floatsisf+0x40>
    2a4e:	f9 2f       	mov	r31, r25
    2a50:	96 e9       	ldi	r25, 0x96	; 150
    2a52:	bb 27       	eor	r27, r27
    2a54:	93 95       	inc	r25
    2a56:	f6 95       	lsr	r31
    2a58:	87 95       	ror	r24
    2a5a:	77 95       	ror	r23
    2a5c:	67 95       	ror	r22
    2a5e:	b7 95       	ror	r27
    2a60:	f1 11       	cpse	r31, r1
    2a62:	f8 cf       	rjmp	.-16     	; 0x2a54 <__floatsisf+0x1c>
    2a64:	fa f4       	brpl	.+62     	; 0x2aa4 <__floatsisf+0x6c>
    2a66:	bb 0f       	add	r27, r27
    2a68:	11 f4       	brne	.+4      	; 0x2a6e <__floatsisf+0x36>
    2a6a:	60 ff       	sbrs	r22, 0
    2a6c:	1b c0       	rjmp	.+54     	; 0x2aa4 <__floatsisf+0x6c>
    2a6e:	6f 5f       	subi	r22, 0xFF	; 255
    2a70:	7f 4f       	sbci	r23, 0xFF	; 255
    2a72:	8f 4f       	sbci	r24, 0xFF	; 255
    2a74:	9f 4f       	sbci	r25, 0xFF	; 255
    2a76:	16 c0       	rjmp	.+44     	; 0x2aa4 <__floatsisf+0x6c>
    2a78:	88 23       	and	r24, r24
    2a7a:	11 f0       	breq	.+4      	; 0x2a80 <__floatsisf+0x48>
    2a7c:	96 e9       	ldi	r25, 0x96	; 150
    2a7e:	11 c0       	rjmp	.+34     	; 0x2aa2 <__floatsisf+0x6a>
    2a80:	77 23       	and	r23, r23
    2a82:	21 f0       	breq	.+8      	; 0x2a8c <__floatsisf+0x54>
    2a84:	9e e8       	ldi	r25, 0x8E	; 142
    2a86:	87 2f       	mov	r24, r23
    2a88:	76 2f       	mov	r23, r22
    2a8a:	05 c0       	rjmp	.+10     	; 0x2a96 <__floatsisf+0x5e>
    2a8c:	66 23       	and	r22, r22
    2a8e:	71 f0       	breq	.+28     	; 0x2aac <__floatsisf+0x74>
    2a90:	96 e8       	ldi	r25, 0x86	; 134
    2a92:	86 2f       	mov	r24, r22
    2a94:	70 e0       	ldi	r23, 0x00	; 0
    2a96:	60 e0       	ldi	r22, 0x00	; 0
    2a98:	2a f0       	brmi	.+10     	; 0x2aa4 <__floatsisf+0x6c>
    2a9a:	9a 95       	dec	r25
    2a9c:	66 0f       	add	r22, r22
    2a9e:	77 1f       	adc	r23, r23
    2aa0:	88 1f       	adc	r24, r24
    2aa2:	da f7       	brpl	.-10     	; 0x2a9a <__floatsisf+0x62>
    2aa4:	88 0f       	add	r24, r24
    2aa6:	96 95       	lsr	r25
    2aa8:	87 95       	ror	r24
    2aaa:	97 f9       	bld	r25, 7
    2aac:	08 95       	ret

00002aae <__fp_cmp>:
    2aae:	99 0f       	add	r25, r25
    2ab0:	00 08       	sbc	r0, r0
    2ab2:	55 0f       	add	r21, r21
    2ab4:	aa 0b       	sbc	r26, r26
    2ab6:	e0 e8       	ldi	r30, 0x80	; 128
    2ab8:	fe ef       	ldi	r31, 0xFE	; 254
    2aba:	16 16       	cp	r1, r22
    2abc:	17 06       	cpc	r1, r23
    2abe:	e8 07       	cpc	r30, r24
    2ac0:	f9 07       	cpc	r31, r25
    2ac2:	c0 f0       	brcs	.+48     	; 0x2af4 <__fp_cmp+0x46>
    2ac4:	12 16       	cp	r1, r18
    2ac6:	13 06       	cpc	r1, r19
    2ac8:	e4 07       	cpc	r30, r20
    2aca:	f5 07       	cpc	r31, r21
    2acc:	98 f0       	brcs	.+38     	; 0x2af4 <__fp_cmp+0x46>
    2ace:	62 1b       	sub	r22, r18
    2ad0:	73 0b       	sbc	r23, r19
    2ad2:	84 0b       	sbc	r24, r20
    2ad4:	95 0b       	sbc	r25, r21
    2ad6:	39 f4       	brne	.+14     	; 0x2ae6 <__fp_cmp+0x38>
    2ad8:	0a 26       	eor	r0, r26
    2ada:	61 f0       	breq	.+24     	; 0x2af4 <__fp_cmp+0x46>
    2adc:	23 2b       	or	r18, r19
    2ade:	24 2b       	or	r18, r20
    2ae0:	25 2b       	or	r18, r21
    2ae2:	21 f4       	brne	.+8      	; 0x2aec <__fp_cmp+0x3e>
    2ae4:	08 95       	ret
    2ae6:	0a 26       	eor	r0, r26
    2ae8:	09 f4       	brne	.+2      	; 0x2aec <__fp_cmp+0x3e>
    2aea:	a1 40       	sbci	r26, 0x01	; 1
    2aec:	a6 95       	lsr	r26
    2aee:	8f ef       	ldi	r24, 0xFF	; 255
    2af0:	81 1d       	adc	r24, r1
    2af2:	81 1d       	adc	r24, r1
    2af4:	08 95       	ret

00002af6 <__fp_inf>:
    2af6:	97 f9       	bld	r25, 7
    2af8:	9f 67       	ori	r25, 0x7F	; 127
    2afa:	80 e8       	ldi	r24, 0x80	; 128
    2afc:	70 e0       	ldi	r23, 0x00	; 0
    2afe:	60 e0       	ldi	r22, 0x00	; 0
    2b00:	08 95       	ret

00002b02 <__fp_nan>:
    2b02:	9f ef       	ldi	r25, 0xFF	; 255
    2b04:	80 ec       	ldi	r24, 0xC0	; 192
    2b06:	08 95       	ret

00002b08 <__fp_powser>:
    2b08:	df 93       	push	r29
    2b0a:	cf 93       	push	r28
    2b0c:	1f 93       	push	r17
    2b0e:	0f 93       	push	r16
    2b10:	ff 92       	push	r15
    2b12:	ef 92       	push	r14
    2b14:	df 92       	push	r13
    2b16:	7b 01       	movw	r14, r22
    2b18:	8c 01       	movw	r16, r24
    2b1a:	68 94       	set
    2b1c:	05 c0       	rjmp	.+10     	; 0x2b28 <__fp_powser+0x20>
    2b1e:	da 2e       	mov	r13, r26
    2b20:	ef 01       	movw	r28, r30
    2b22:	72 d0       	rcall	.+228    	; 0x2c08 <__mulsf3x>
    2b24:	fe 01       	movw	r30, r28
    2b26:	e8 94       	clt
    2b28:	a5 91       	lpm	r26, Z+
    2b2a:	25 91       	lpm	r18, Z+
    2b2c:	35 91       	lpm	r19, Z+
    2b2e:	45 91       	lpm	r20, Z+
    2b30:	55 91       	lpm	r21, Z+
    2b32:	ae f3       	brts	.-22     	; 0x2b1e <__fp_powser+0x16>
    2b34:	ef 01       	movw	r28, r30
    2b36:	2c de       	rcall	.-936    	; 0x2790 <__addsf3x>
    2b38:	fe 01       	movw	r30, r28
    2b3a:	97 01       	movw	r18, r14
    2b3c:	a8 01       	movw	r20, r16
    2b3e:	da 94       	dec	r13
    2b40:	79 f7       	brne	.-34     	; 0x2b20 <__fp_powser+0x18>
    2b42:	df 90       	pop	r13
    2b44:	ef 90       	pop	r14
    2b46:	ff 90       	pop	r15
    2b48:	0f 91       	pop	r16
    2b4a:	1f 91       	pop	r17
    2b4c:	cf 91       	pop	r28
    2b4e:	df 91       	pop	r29
    2b50:	08 95       	ret

00002b52 <__fp_pscA>:
    2b52:	00 24       	eor	r0, r0
    2b54:	0a 94       	dec	r0
    2b56:	16 16       	cp	r1, r22
    2b58:	17 06       	cpc	r1, r23
    2b5a:	18 06       	cpc	r1, r24
    2b5c:	09 06       	cpc	r0, r25
    2b5e:	08 95       	ret

00002b60 <__fp_pscB>:
    2b60:	00 24       	eor	r0, r0
    2b62:	0a 94       	dec	r0
    2b64:	12 16       	cp	r1, r18
    2b66:	13 06       	cpc	r1, r19
    2b68:	14 06       	cpc	r1, r20
    2b6a:	05 06       	cpc	r0, r21
    2b6c:	08 95       	ret

00002b6e <__fp_round>:
    2b6e:	09 2e       	mov	r0, r25
    2b70:	03 94       	inc	r0
    2b72:	00 0c       	add	r0, r0
    2b74:	11 f4       	brne	.+4      	; 0x2b7a <__fp_round+0xc>
    2b76:	88 23       	and	r24, r24
    2b78:	52 f0       	brmi	.+20     	; 0x2b8e <__fp_round+0x20>
    2b7a:	bb 0f       	add	r27, r27
    2b7c:	40 f4       	brcc	.+16     	; 0x2b8e <__fp_round+0x20>
    2b7e:	bf 2b       	or	r27, r31
    2b80:	11 f4       	brne	.+4      	; 0x2b86 <__fp_round+0x18>
    2b82:	60 ff       	sbrs	r22, 0
    2b84:	04 c0       	rjmp	.+8      	; 0x2b8e <__fp_round+0x20>
    2b86:	6f 5f       	subi	r22, 0xFF	; 255
    2b88:	7f 4f       	sbci	r23, 0xFF	; 255
    2b8a:	8f 4f       	sbci	r24, 0xFF	; 255
    2b8c:	9f 4f       	sbci	r25, 0xFF	; 255
    2b8e:	08 95       	ret

00002b90 <__fp_split3>:
    2b90:	57 fd       	sbrc	r21, 7
    2b92:	90 58       	subi	r25, 0x80	; 128
    2b94:	44 0f       	add	r20, r20
    2b96:	55 1f       	adc	r21, r21
    2b98:	59 f0       	breq	.+22     	; 0x2bb0 <__fp_splitA+0x10>
    2b9a:	5f 3f       	cpi	r21, 0xFF	; 255
    2b9c:	71 f0       	breq	.+28     	; 0x2bba <__fp_splitA+0x1a>
    2b9e:	47 95       	ror	r20

00002ba0 <__fp_splitA>:
    2ba0:	88 0f       	add	r24, r24
    2ba2:	97 fb       	bst	r25, 7
    2ba4:	99 1f       	adc	r25, r25
    2ba6:	61 f0       	breq	.+24     	; 0x2bc0 <__fp_splitA+0x20>
    2ba8:	9f 3f       	cpi	r25, 0xFF	; 255
    2baa:	79 f0       	breq	.+30     	; 0x2bca <__fp_splitA+0x2a>
    2bac:	87 95       	ror	r24
    2bae:	08 95       	ret
    2bb0:	12 16       	cp	r1, r18
    2bb2:	13 06       	cpc	r1, r19
    2bb4:	14 06       	cpc	r1, r20
    2bb6:	55 1f       	adc	r21, r21
    2bb8:	f2 cf       	rjmp	.-28     	; 0x2b9e <__fp_split3+0xe>
    2bba:	46 95       	lsr	r20
    2bbc:	f1 df       	rcall	.-30     	; 0x2ba0 <__fp_splitA>
    2bbe:	08 c0       	rjmp	.+16     	; 0x2bd0 <__fp_splitA+0x30>
    2bc0:	16 16       	cp	r1, r22
    2bc2:	17 06       	cpc	r1, r23
    2bc4:	18 06       	cpc	r1, r24
    2bc6:	99 1f       	adc	r25, r25
    2bc8:	f1 cf       	rjmp	.-30     	; 0x2bac <__fp_splitA+0xc>
    2bca:	86 95       	lsr	r24
    2bcc:	71 05       	cpc	r23, r1
    2bce:	61 05       	cpc	r22, r1
    2bd0:	08 94       	sec
    2bd2:	08 95       	ret

00002bd4 <__fp_zero>:
    2bd4:	e8 94       	clt

00002bd6 <__fp_szero>:
    2bd6:	bb 27       	eor	r27, r27
    2bd8:	66 27       	eor	r22, r22
    2bda:	77 27       	eor	r23, r23
    2bdc:	cb 01       	movw	r24, r22
    2bde:	97 f9       	bld	r25, 7
    2be0:	08 95       	ret

00002be2 <inverse>:
    2be2:	9b 01       	movw	r18, r22
    2be4:	ac 01       	movw	r20, r24
    2be6:	60 e0       	ldi	r22, 0x00	; 0
    2be8:	70 e0       	ldi	r23, 0x00	; 0
    2bea:	80 e8       	ldi	r24, 0x80	; 128
    2bec:	9f e3       	ldi	r25, 0x3F	; 63
    2bee:	89 ce       	rjmp	.-750    	; 0x2902 <__divsf3>

00002bf0 <__mulsf3>:
    2bf0:	0b d0       	rcall	.+22     	; 0x2c08 <__mulsf3x>
    2bf2:	bd cf       	rjmp	.-134    	; 0x2b6e <__fp_round>
    2bf4:	ae df       	rcall	.-164    	; 0x2b52 <__fp_pscA>
    2bf6:	28 f0       	brcs	.+10     	; 0x2c02 <__mulsf3+0x12>
    2bf8:	b3 df       	rcall	.-154    	; 0x2b60 <__fp_pscB>
    2bfa:	18 f0       	brcs	.+6      	; 0x2c02 <__mulsf3+0x12>
    2bfc:	95 23       	and	r25, r21
    2bfe:	09 f0       	breq	.+2      	; 0x2c02 <__mulsf3+0x12>
    2c00:	7a cf       	rjmp	.-268    	; 0x2af6 <__fp_inf>
    2c02:	7f cf       	rjmp	.-258    	; 0x2b02 <__fp_nan>
    2c04:	11 24       	eor	r1, r1
    2c06:	e7 cf       	rjmp	.-50     	; 0x2bd6 <__fp_szero>

00002c08 <__mulsf3x>:
    2c08:	c3 df       	rcall	.-122    	; 0x2b90 <__fp_split3>
    2c0a:	a0 f3       	brcs	.-24     	; 0x2bf4 <__mulsf3+0x4>

00002c0c <__mulsf3_pse>:
    2c0c:	95 9f       	mul	r25, r21
    2c0e:	d1 f3       	breq	.-12     	; 0x2c04 <__mulsf3+0x14>
    2c10:	95 0f       	add	r25, r21
    2c12:	50 e0       	ldi	r21, 0x00	; 0
    2c14:	55 1f       	adc	r21, r21
    2c16:	62 9f       	mul	r22, r18
    2c18:	f0 01       	movw	r30, r0
    2c1a:	72 9f       	mul	r23, r18
    2c1c:	bb 27       	eor	r27, r27
    2c1e:	f0 0d       	add	r31, r0
    2c20:	b1 1d       	adc	r27, r1
    2c22:	63 9f       	mul	r22, r19
    2c24:	aa 27       	eor	r26, r26
    2c26:	f0 0d       	add	r31, r0
    2c28:	b1 1d       	adc	r27, r1
    2c2a:	aa 1f       	adc	r26, r26
    2c2c:	64 9f       	mul	r22, r20
    2c2e:	66 27       	eor	r22, r22
    2c30:	b0 0d       	add	r27, r0
    2c32:	a1 1d       	adc	r26, r1
    2c34:	66 1f       	adc	r22, r22
    2c36:	82 9f       	mul	r24, r18
    2c38:	22 27       	eor	r18, r18
    2c3a:	b0 0d       	add	r27, r0
    2c3c:	a1 1d       	adc	r26, r1
    2c3e:	62 1f       	adc	r22, r18
    2c40:	73 9f       	mul	r23, r19
    2c42:	b0 0d       	add	r27, r0
    2c44:	a1 1d       	adc	r26, r1
    2c46:	62 1f       	adc	r22, r18
    2c48:	83 9f       	mul	r24, r19
    2c4a:	a0 0d       	add	r26, r0
    2c4c:	61 1d       	adc	r22, r1
    2c4e:	22 1f       	adc	r18, r18
    2c50:	74 9f       	mul	r23, r20
    2c52:	33 27       	eor	r19, r19
    2c54:	a0 0d       	add	r26, r0
    2c56:	61 1d       	adc	r22, r1
    2c58:	23 1f       	adc	r18, r19
    2c5a:	84 9f       	mul	r24, r20
    2c5c:	60 0d       	add	r22, r0
    2c5e:	21 1d       	adc	r18, r1
    2c60:	82 2f       	mov	r24, r18
    2c62:	76 2f       	mov	r23, r22
    2c64:	6a 2f       	mov	r22, r26
    2c66:	11 24       	eor	r1, r1
    2c68:	9f 57       	subi	r25, 0x7F	; 127
    2c6a:	50 40       	sbci	r21, 0x00	; 0
    2c6c:	8a f0       	brmi	.+34     	; 0x2c90 <__mulsf3_pse+0x84>
    2c6e:	e1 f0       	breq	.+56     	; 0x2ca8 <__mulsf3_pse+0x9c>
    2c70:	88 23       	and	r24, r24
    2c72:	4a f0       	brmi	.+18     	; 0x2c86 <__mulsf3_pse+0x7a>
    2c74:	ee 0f       	add	r30, r30
    2c76:	ff 1f       	adc	r31, r31
    2c78:	bb 1f       	adc	r27, r27
    2c7a:	66 1f       	adc	r22, r22
    2c7c:	77 1f       	adc	r23, r23
    2c7e:	88 1f       	adc	r24, r24
    2c80:	91 50       	subi	r25, 0x01	; 1
    2c82:	50 40       	sbci	r21, 0x00	; 0
    2c84:	a9 f7       	brne	.-22     	; 0x2c70 <__mulsf3_pse+0x64>
    2c86:	9e 3f       	cpi	r25, 0xFE	; 254
    2c88:	51 05       	cpc	r21, r1
    2c8a:	70 f0       	brcs	.+28     	; 0x2ca8 <__mulsf3_pse+0x9c>
    2c8c:	34 cf       	rjmp	.-408    	; 0x2af6 <__fp_inf>
    2c8e:	a3 cf       	rjmp	.-186    	; 0x2bd6 <__fp_szero>
    2c90:	5f 3f       	cpi	r21, 0xFF	; 255
    2c92:	ec f3       	brlt	.-6      	; 0x2c8e <__mulsf3_pse+0x82>
    2c94:	98 3e       	cpi	r25, 0xE8	; 232
    2c96:	dc f3       	brlt	.-10     	; 0x2c8e <__mulsf3_pse+0x82>
    2c98:	86 95       	lsr	r24
    2c9a:	77 95       	ror	r23
    2c9c:	67 95       	ror	r22
    2c9e:	b7 95       	ror	r27
    2ca0:	f7 95       	ror	r31
    2ca2:	e7 95       	ror	r30
    2ca4:	9f 5f       	subi	r25, 0xFF	; 255
    2ca6:	c1 f7       	brne	.-16     	; 0x2c98 <__mulsf3_pse+0x8c>
    2ca8:	fe 2b       	or	r31, r30
    2caa:	88 0f       	add	r24, r24
    2cac:	91 1d       	adc	r25, r1
    2cae:	96 95       	lsr	r25
    2cb0:	87 95       	ror	r24
    2cb2:	97 f9       	bld	r25, 7
    2cb4:	08 95       	ret
    2cb6:	11 f4       	brne	.+4      	; 0x2cbc <__mulsf3_pse+0xb0>
    2cb8:	0e f4       	brtc	.+2      	; 0x2cbc <__mulsf3_pse+0xb0>
    2cba:	23 cf       	rjmp	.-442    	; 0x2b02 <__fp_nan>
    2cbc:	41 c0       	rjmp	.+130    	; 0x2d40 <__fp_mpack>

00002cbe <sqrt>:
    2cbe:	70 df       	rcall	.-288    	; 0x2ba0 <__fp_splitA>
    2cc0:	d0 f3       	brcs	.-12     	; 0x2cb6 <__mulsf3_pse+0xaa>
    2cc2:	99 23       	and	r25, r25
    2cc4:	d9 f3       	breq	.-10     	; 0x2cbc <__mulsf3_pse+0xb0>
    2cc6:	ce f3       	brts	.-14     	; 0x2cba <__mulsf3_pse+0xae>
    2cc8:	9f 57       	subi	r25, 0x7F	; 127
    2cca:	55 0b       	sbc	r21, r21
    2ccc:	87 ff       	sbrs	r24, 7
    2cce:	46 d0       	rcall	.+140    	; 0x2d5c <__fp_norm2>
    2cd0:	00 24       	eor	r0, r0
    2cd2:	a0 e6       	ldi	r26, 0x60	; 96
    2cd4:	40 ea       	ldi	r20, 0xA0	; 160
    2cd6:	90 01       	movw	r18, r0
    2cd8:	80 58       	subi	r24, 0x80	; 128
    2cda:	56 95       	lsr	r21
    2cdc:	97 95       	ror	r25
    2cde:	28 f4       	brcc	.+10     	; 0x2cea <sqrt+0x2c>
    2ce0:	80 5c       	subi	r24, 0xC0	; 192
    2ce2:	66 0f       	add	r22, r22
    2ce4:	77 1f       	adc	r23, r23
    2ce6:	88 1f       	adc	r24, r24
    2ce8:	20 f0       	brcs	.+8      	; 0x2cf2 <sqrt+0x34>
    2cea:	26 17       	cp	r18, r22
    2cec:	37 07       	cpc	r19, r23
    2cee:	48 07       	cpc	r20, r24
    2cf0:	30 f4       	brcc	.+12     	; 0x2cfe <sqrt+0x40>
    2cf2:	62 1b       	sub	r22, r18
    2cf4:	73 0b       	sbc	r23, r19
    2cf6:	84 0b       	sbc	r24, r20
    2cf8:	20 29       	or	r18, r0
    2cfa:	31 29       	or	r19, r1
    2cfc:	4a 2b       	or	r20, r26
    2cfe:	a6 95       	lsr	r26
    2d00:	17 94       	ror	r1
    2d02:	07 94       	ror	r0
    2d04:	20 25       	eor	r18, r0
    2d06:	31 25       	eor	r19, r1
    2d08:	4a 27       	eor	r20, r26
    2d0a:	58 f7       	brcc	.-42     	; 0x2ce2 <sqrt+0x24>
    2d0c:	66 0f       	add	r22, r22
    2d0e:	77 1f       	adc	r23, r23
    2d10:	88 1f       	adc	r24, r24
    2d12:	20 f0       	brcs	.+8      	; 0x2d1c <sqrt+0x5e>
    2d14:	26 17       	cp	r18, r22
    2d16:	37 07       	cpc	r19, r23
    2d18:	48 07       	cpc	r20, r24
    2d1a:	30 f4       	brcc	.+12     	; 0x2d28 <sqrt+0x6a>
    2d1c:	62 0b       	sbc	r22, r18
    2d1e:	73 0b       	sbc	r23, r19
    2d20:	84 0b       	sbc	r24, r20
    2d22:	20 0d       	add	r18, r0
    2d24:	31 1d       	adc	r19, r1
    2d26:	41 1d       	adc	r20, r1
    2d28:	a0 95       	com	r26
    2d2a:	81 f7       	brne	.-32     	; 0x2d0c <sqrt+0x4e>
    2d2c:	b9 01       	movw	r22, r18
    2d2e:	84 2f       	mov	r24, r20
    2d30:	91 58       	subi	r25, 0x81	; 129
    2d32:	88 0f       	add	r24, r24
    2d34:	96 95       	lsr	r25
    2d36:	87 95       	ror	r24
    2d38:	08 95       	ret

00002d3a <square>:
    2d3a:	9b 01       	movw	r18, r22
    2d3c:	ac 01       	movw	r20, r24
    2d3e:	58 cf       	rjmp	.-336    	; 0x2bf0 <__mulsf3>

00002d40 <__fp_mpack>:
    2d40:	9f 3f       	cpi	r25, 0xFF	; 255
    2d42:	31 f0       	breq	.+12     	; 0x2d50 <__fp_mpack_finite+0xc>

00002d44 <__fp_mpack_finite>:
    2d44:	91 50       	subi	r25, 0x01	; 1
    2d46:	20 f4       	brcc	.+8      	; 0x2d50 <__fp_mpack_finite+0xc>
    2d48:	87 95       	ror	r24
    2d4a:	77 95       	ror	r23
    2d4c:	67 95       	ror	r22
    2d4e:	b7 95       	ror	r27
    2d50:	88 0f       	add	r24, r24
    2d52:	91 1d       	adc	r25, r1
    2d54:	96 95       	lsr	r25
    2d56:	87 95       	ror	r24
    2d58:	97 f9       	bld	r25, 7
    2d5a:	08 95       	ret

00002d5c <__fp_norm2>:
    2d5c:	91 50       	subi	r25, 0x01	; 1
    2d5e:	50 40       	sbci	r21, 0x00	; 0
    2d60:	66 0f       	add	r22, r22
    2d62:	77 1f       	adc	r23, r23
    2d64:	88 1f       	adc	r24, r24
    2d66:	d2 f7       	brpl	.-12     	; 0x2d5c <__fp_norm2>
    2d68:	08 95       	ret

00002d6a <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    2d6a:	fc 01       	movw	r30, r24
    2d6c:	81 8d       	ldd	r24, Z+25	; 0x19
    2d6e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2d70:	90 e0       	ldi	r25, 0x00	; 0
    2d72:	80 5c       	subi	r24, 0xC0	; 192
    2d74:	9f 4f       	sbci	r25, 0xFF	; 255
    2d76:	82 1b       	sub	r24, r18
    2d78:	91 09       	sbc	r25, r1
    2d7a:	8f 73       	andi	r24, 0x3F	; 63
    2d7c:	99 27       	eor	r25, r25
    2d7e:	08 95       	ret

00002d80 <_ZN14HardwareSerial4peekEv>:
    2d80:	fc 01       	movw	r30, r24
    2d82:	91 8d       	ldd	r25, Z+25	; 0x19
    2d84:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d86:	98 17       	cp	r25, r24
    2d88:	31 f0       	breq	.+12     	; 0x2d96 <_ZN14HardwareSerial4peekEv+0x16>
    2d8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d8c:	e8 0f       	add	r30, r24
    2d8e:	f1 1d       	adc	r31, r1
    2d90:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d92:	90 e0       	ldi	r25, 0x00	; 0
    2d94:	08 95       	ret
    2d96:	8f ef       	ldi	r24, 0xFF	; 255
    2d98:	9f ef       	ldi	r25, 0xFF	; 255
    2d9a:	08 95       	ret

00002d9c <_ZN14HardwareSerial4readEv>:
    2d9c:	fc 01       	movw	r30, r24
    2d9e:	91 8d       	ldd	r25, Z+25	; 0x19
    2da0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2da2:	98 17       	cp	r25, r24
    2da4:	61 f0       	breq	.+24     	; 0x2dbe <_ZN14HardwareSerial4readEv+0x22>
    2da6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2da8:	df 01       	movw	r26, r30
    2daa:	a8 0f       	add	r26, r24
    2dac:	b1 1d       	adc	r27, r1
    2dae:	5d 96       	adiw	r26, 0x1d	; 29
    2db0:	8c 91       	ld	r24, X
    2db2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2db4:	9f 5f       	subi	r25, 0xFF	; 255
    2db6:	9f 73       	andi	r25, 0x3F	; 63
    2db8:	92 8f       	std	Z+26, r25	; 0x1a
    2dba:	90 e0       	ldi	r25, 0x00	; 0
    2dbc:	08 95       	ret
    2dbe:	8f ef       	ldi	r24, 0xFF	; 255
    2dc0:	9f ef       	ldi	r25, 0xFF	; 255
    2dc2:	08 95       	ret

00002dc4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    2dc4:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    2dc6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dc8:	df 01       	movw	r26, r30
    2dca:	a8 0f       	add	r26, r24
    2dcc:	b1 1d       	adc	r27, r1
    2dce:	a3 5a       	subi	r26, 0xA3	; 163
    2dd0:	bf 4f       	sbci	r27, 0xFF	; 255
    2dd2:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    2dd4:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dd6:	90 e0       	ldi	r25, 0x00	; 0
    2dd8:	01 96       	adiw	r24, 0x01	; 1
    2dda:	8f 73       	andi	r24, 0x3F	; 63
    2ddc:	90 78       	andi	r25, 0x80	; 128
    2dde:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    2de0:	a6 89       	ldd	r26, Z+22	; 0x16
    2de2:	b7 89       	ldd	r27, Z+23	; 0x17
    2de4:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    2de6:	a0 89       	ldd	r26, Z+16	; 0x10
    2de8:	b1 89       	ldd	r27, Z+17	; 0x11
    2dea:	8c 91       	ld	r24, X
    2dec:	80 64       	ori	r24, 0x40	; 64
    2dee:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    2df0:	93 8d       	ldd	r25, Z+27	; 0x1b
    2df2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2df4:	98 13       	cpse	r25, r24
    2df6:	06 c0       	rjmp	.+12     	; 0x2e04 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    2df8:	02 88       	ldd	r0, Z+18	; 0x12
    2dfa:	f3 89       	ldd	r31, Z+19	; 0x13
    2dfc:	e0 2d       	mov	r30, r0
    2dfe:	80 81       	ld	r24, Z
    2e00:	8f 7d       	andi	r24, 0xDF	; 223
    2e02:	80 83       	st	Z, r24
    2e04:	08 95       	ret

00002e06 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    2e06:	cf 93       	push	r28
    2e08:	df 93       	push	r29
    2e0a:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    2e0c:	88 8d       	ldd	r24, Y+24	; 0x18
    2e0e:	81 11       	cpse	r24, r1
    2e10:	0a c0       	rjmp	.+20     	; 0x2e26 <_ZN14HardwareSerial5flushEv+0x20>
    2e12:	1a c0       	rjmp	.+52     	; 0x2e48 <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    2e14:	0f b6       	in	r0, 0x3f	; 63
    2e16:	07 fc       	sbrc	r0, 7
    2e18:	08 c0       	rjmp	.+16     	; 0x2e2a <_ZN14HardwareSerial5flushEv+0x24>
    2e1a:	80 81       	ld	r24, Z
    2e1c:	85 ff       	sbrs	r24, 5
    2e1e:	05 c0       	rjmp	.+10     	; 0x2e2a <_ZN14HardwareSerial5flushEv+0x24>
    2e20:	0d c0       	rjmp	.+26     	; 0x2e3c <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    2e22:	ce 01       	movw	r24, r28
    2e24:	cf df       	rcall	.-98     	; 0x2dc4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    2e26:	ea 89       	ldd	r30, Y+18	; 0x12
    2e28:	fb 89       	ldd	r31, Y+19	; 0x13
    2e2a:	80 81       	ld	r24, Z
    2e2c:	85 fd       	sbrc	r24, 5
    2e2e:	f2 cf       	rjmp	.-28     	; 0x2e14 <_ZN14HardwareSerial5flushEv+0xe>
    2e30:	a8 89       	ldd	r26, Y+16	; 0x10
    2e32:	b9 89       	ldd	r27, Y+17	; 0x11
    2e34:	8c 91       	ld	r24, X
    2e36:	86 ff       	sbrs	r24, 6
    2e38:	ed cf       	rjmp	.-38     	; 0x2e14 <_ZN14HardwareSerial5flushEv+0xe>
    2e3a:	06 c0       	rjmp	.+12     	; 0x2e48 <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    2e3c:	a8 89       	ldd	r26, Y+16	; 0x10
    2e3e:	b9 89       	ldd	r27, Y+17	; 0x11
    2e40:	8c 91       	ld	r24, X
    2e42:	85 ff       	sbrs	r24, 5
    2e44:	f2 cf       	rjmp	.-28     	; 0x2e2a <_ZN14HardwareSerial5flushEv+0x24>
    2e46:	ed cf       	rjmp	.-38     	; 0x2e22 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	08 95       	ret

00002e4e <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    2e4e:	0f 93       	push	r16
    2e50:	1f 93       	push	r17
    2e52:	cf 93       	push	r28
    2e54:	df 93       	push	r29
    2e56:	ec 01       	movw	r28, r24
    2e58:	16 2f       	mov	r17, r22
  _written = true;
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    2e5e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2e60:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2e62:	98 13       	cpse	r25, r24
    2e64:	21 c0       	rjmp	.+66     	; 0x2ea8 <_ZN14HardwareSerial5writeEh+0x5a>
    2e66:	e8 89       	ldd	r30, Y+16	; 0x10
    2e68:	f9 89       	ldd	r31, Y+17	; 0x11
    2e6a:	80 81       	ld	r24, Z
    2e6c:	85 fd       	sbrc	r24, 5
    2e6e:	23 c0       	rjmp	.+70     	; 0x2eb6 <_ZN14HardwareSerial5writeEh+0x68>
    2e70:	1b c0       	rjmp	.+54     	; 0x2ea8 <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    2e72:	0f b6       	in	r0, 0x3f	; 63
    2e74:	07 fc       	sbrc	r0, 7
    2e76:	07 c0       	rjmp	.+14     	; 0x2e86 <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    2e78:	e8 89       	ldd	r30, Y+16	; 0x10
    2e7a:	f9 89       	ldd	r31, Y+17	; 0x11
    2e7c:	80 81       	ld	r24, Z
    2e7e:	85 ff       	sbrs	r24, 5
    2e80:	02 c0       	rjmp	.+4      	; 0x2e86 <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    2e82:	ce 01       	movw	r24, r28
    2e84:	9f df       	rcall	.-194    	; 0x2dc4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2e86:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2e88:	09 17       	cp	r16, r25
    2e8a:	99 f3       	breq	.-26     	; 0x2e72 <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    2e8c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2e8e:	fe 01       	movw	r30, r28
    2e90:	e8 0f       	add	r30, r24
    2e92:	f1 1d       	adc	r31, r1
    2e94:	e3 5a       	subi	r30, 0xA3	; 163
    2e96:	ff 4f       	sbci	r31, 0xFF	; 255
    2e98:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    2e9a:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    2e9c:	ea 89       	ldd	r30, Y+18	; 0x12
    2e9e:	fb 89       	ldd	r31, Y+19	; 0x13
    2ea0:	80 81       	ld	r24, Z
    2ea2:	80 62       	ori	r24, 0x20	; 32
    2ea4:	80 83       	st	Z, r24
  
  return 1;
    2ea6:	0f c0       	rjmp	.+30     	; 0x2ec6 <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    2ea8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2eaa:	90 e0       	ldi	r25, 0x00	; 0
    2eac:	01 96       	adiw	r24, 0x01	; 1
    2eae:	8f 73       	andi	r24, 0x3F	; 63
    2eb0:	90 78       	andi	r25, 0x80	; 128
    2eb2:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2eb4:	e8 cf       	rjmp	.-48     	; 0x2e86 <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    2eb6:	ee 89       	ldd	r30, Y+22	; 0x16
    2eb8:	ff 89       	ldd	r31, Y+23	; 0x17
    2eba:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    2ebc:	e8 89       	ldd	r30, Y+16	; 0x10
    2ebe:	f9 89       	ldd	r31, Y+17	; 0x11
    2ec0:	80 81       	ld	r24, Z
    2ec2:	80 64       	ori	r24, 0x40	; 64
    2ec4:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    2ec6:	81 e0       	ldi	r24, 0x01	; 1
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	df 91       	pop	r29
    2ecc:	cf 91       	pop	r28
    2ece:	1f 91       	pop	r17
    2ed0:	0f 91       	pop	r16
    2ed2:	08 95       	ret

00002ed4 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    2ed4:	cf 92       	push	r12
    2ed6:	df 92       	push	r13
    2ed8:	ef 92       	push	r14
    2eda:	ff 92       	push	r15
    2edc:	1f 93       	push	r17
    2ede:	cf 93       	push	r28
    2ee0:	df 93       	push	r29
    2ee2:	ec 01       	movw	r28, r24
    2ee4:	6a 01       	movw	r12, r20
    2ee6:	7b 01       	movw	r14, r22
    2ee8:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    2eea:	e8 89       	ldd	r30, Y+16	; 0x10
    2eec:	f9 89       	ldd	r31, Y+17	; 0x11
    2eee:	82 e0       	ldi	r24, 0x02	; 2
    2ef0:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2ef2:	41 15       	cp	r20, r1
    2ef4:	81 ee       	ldi	r24, 0xE1	; 225
    2ef6:	58 07       	cpc	r21, r24
    2ef8:	61 05       	cpc	r22, r1
    2efa:	71 05       	cpc	r23, r1
    2efc:	a9 f0       	breq	.+42     	; 0x2f28 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    2efe:	60 e0       	ldi	r22, 0x00	; 0
    2f00:	79 e0       	ldi	r23, 0x09	; 9
    2f02:	8d e3       	ldi	r24, 0x3D	; 61
    2f04:	90 e0       	ldi	r25, 0x00	; 0
    2f06:	a7 01       	movw	r20, r14
    2f08:	96 01       	movw	r18, r12
    2f0a:	76 d4       	rcall	.+2284   	; 0x37f8 <__udivmodsi4>
    2f0c:	ba 01       	movw	r22, r20
    2f0e:	a9 01       	movw	r20, r18
    2f10:	41 50       	subi	r20, 0x01	; 1
    2f12:	51 09       	sbc	r21, r1
    2f14:	61 09       	sbc	r22, r1
    2f16:	71 09       	sbc	r23, r1
    2f18:	76 95       	lsr	r23
    2f1a:	67 95       	ror	r22
    2f1c:	57 95       	ror	r21
    2f1e:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2f20:	41 15       	cp	r20, r1
    2f22:	80 e1       	ldi	r24, 0x10	; 16
    2f24:	58 07       	cpc	r21, r24
    2f26:	a0 f0       	brcs	.+40     	; 0x2f50 <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    2f28:	e8 89       	ldd	r30, Y+16	; 0x10
    2f2a:	f9 89       	ldd	r31, Y+17	; 0x11
    2f2c:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    2f2e:	60 e8       	ldi	r22, 0x80	; 128
    2f30:	74 e8       	ldi	r23, 0x84	; 132
    2f32:	8e e1       	ldi	r24, 0x1E	; 30
    2f34:	90 e0       	ldi	r25, 0x00	; 0
    2f36:	a7 01       	movw	r20, r14
    2f38:	96 01       	movw	r18, r12
    2f3a:	5e d4       	rcall	.+2236   	; 0x37f8 <__udivmodsi4>
    2f3c:	ba 01       	movw	r22, r20
    2f3e:	a9 01       	movw	r20, r18
    2f40:	41 50       	subi	r20, 0x01	; 1
    2f42:	51 09       	sbc	r21, r1
    2f44:	61 09       	sbc	r22, r1
    2f46:	71 09       	sbc	r23, r1
    2f48:	76 95       	lsr	r23
    2f4a:	67 95       	ror	r22
    2f4c:	57 95       	ror	r21
    2f4e:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    2f50:	ec 85       	ldd	r30, Y+12	; 0x0c
    2f52:	fd 85       	ldd	r31, Y+13	; 0x0d
    2f54:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    2f56:	ee 85       	ldd	r30, Y+14	; 0x0e
    2f58:	ff 85       	ldd	r31, Y+15	; 0x0f
    2f5a:	40 83       	st	Z, r20

  _written = false;
    2f5c:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    2f5e:	ec 89       	ldd	r30, Y+20	; 0x14
    2f60:	fd 89       	ldd	r31, Y+21	; 0x15
    2f62:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    2f64:	ea 89       	ldd	r30, Y+18	; 0x12
    2f66:	fb 89       	ldd	r31, Y+19	; 0x13
    2f68:	80 81       	ld	r24, Z
    2f6a:	80 61       	ori	r24, 0x10	; 16
    2f6c:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    2f6e:	ea 89       	ldd	r30, Y+18	; 0x12
    2f70:	fb 89       	ldd	r31, Y+19	; 0x13
    2f72:	80 81       	ld	r24, Z
    2f74:	88 60       	ori	r24, 0x08	; 8
    2f76:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    2f78:	ea 89       	ldd	r30, Y+18	; 0x12
    2f7a:	fb 89       	ldd	r31, Y+19	; 0x13
    2f7c:	80 81       	ld	r24, Z
    2f7e:	80 68       	ori	r24, 0x80	; 128
    2f80:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    2f82:	ea 89       	ldd	r30, Y+18	; 0x12
    2f84:	fb 89       	ldd	r31, Y+19	; 0x13
    2f86:	80 81       	ld	r24, Z
    2f88:	8f 7d       	andi	r24, 0xDF	; 223
    2f8a:	80 83       	st	Z, r24
}
    2f8c:	df 91       	pop	r29
    2f8e:	cf 91       	pop	r28
    2f90:	1f 91       	pop	r17
    2f92:	ff 90       	pop	r15
    2f94:	ef 90       	pop	r14
    2f96:	df 90       	pop	r13
    2f98:	cf 90       	pop	r12
    2f9a:	08 95       	ret

00002f9c <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    2f9c:	1f 92       	push	r1
    2f9e:	0f 92       	push	r0
    2fa0:	0f b6       	in	r0, 0x3f	; 63
    2fa2:	0f 92       	push	r0
    2fa4:	11 24       	eor	r1, r1
    2fa6:	0b b6       	in	r0, 0x3b	; 59
    2fa8:	0f 92       	push	r0
    2faa:	2f 93       	push	r18
    2fac:	8f 93       	push	r24
    2fae:	9f 93       	push	r25
    2fb0:	af 93       	push	r26
    2fb2:	bf 93       	push	r27
    2fb4:	ef 93       	push	r30
    2fb6:	ff 93       	push	r31
    2fb8:	e0 91 b7 09 	lds	r30, 0x09B7
    2fbc:	f0 91 b8 09 	lds	r31, 0x09B8
    2fc0:	80 81       	ld	r24, Z
    2fc2:	82 fd       	sbrc	r24, 2
    2fc4:	17 c0       	rjmp	.+46     	; 0x2ff4 <__vector_25+0x58>
    2fc6:	e0 91 bd 09 	lds	r30, 0x09BD
    2fca:	f0 91 be 09 	lds	r31, 0x09BE
    2fce:	20 81       	ld	r18, Z
    2fd0:	80 91 c0 09 	lds	r24, 0x09C0
    2fd4:	8f 5f       	subi	r24, 0xFF	; 255
    2fd6:	8f 73       	andi	r24, 0x3F	; 63
    2fd8:	90 91 c1 09 	lds	r25, 0x09C1
    2fdc:	89 17       	cp	r24, r25
    2fde:	79 f0       	breq	.+30     	; 0x2ffe <__vector_25+0x62>
    2fe0:	e0 ec       	ldi	r30, 0xC0	; 192
    2fe2:	f9 e0       	ldi	r31, 0x09	; 9
    2fe4:	a0 81       	ld	r26, Z
    2fe6:	b0 e0       	ldi	r27, 0x00	; 0
    2fe8:	a9 55       	subi	r26, 0x59	; 89
    2fea:	b6 4f       	sbci	r27, 0xF6	; 246
    2fec:	5d 96       	adiw	r26, 0x1d	; 29
    2fee:	2c 93       	st	X, r18
    2ff0:	80 83       	st	Z, r24
    2ff2:	05 c0       	rjmp	.+10     	; 0x2ffe <__vector_25+0x62>
    2ff4:	e0 91 bd 09 	lds	r30, 0x09BD
    2ff8:	f0 91 be 09 	lds	r31, 0x09BE
    2ffc:	80 81       	ld	r24, Z
    2ffe:	ff 91       	pop	r31
    3000:	ef 91       	pop	r30
    3002:	bf 91       	pop	r27
    3004:	af 91       	pop	r26
    3006:	9f 91       	pop	r25
    3008:	8f 91       	pop	r24
    300a:	2f 91       	pop	r18
    300c:	0f 90       	pop	r0
    300e:	0b be       	out	0x3b, r0	; 59
    3010:	0f 90       	pop	r0
    3012:	0f be       	out	0x3f, r0	; 63
    3014:	0f 90       	pop	r0
    3016:	1f 90       	pop	r1
    3018:	18 95       	reti

0000301a <__vector_26>:
    301a:	1f 92       	push	r1
    301c:	0f 92       	push	r0
    301e:	0f b6       	in	r0, 0x3f	; 63
    3020:	0f 92       	push	r0
    3022:	11 24       	eor	r1, r1
    3024:	0b b6       	in	r0, 0x3b	; 59
    3026:	0f 92       	push	r0
    3028:	2f 93       	push	r18
    302a:	3f 93       	push	r19
    302c:	4f 93       	push	r20
    302e:	5f 93       	push	r21
    3030:	6f 93       	push	r22
    3032:	7f 93       	push	r23
    3034:	8f 93       	push	r24
    3036:	9f 93       	push	r25
    3038:	af 93       	push	r26
    303a:	bf 93       	push	r27
    303c:	ef 93       	push	r30
    303e:	ff 93       	push	r31
    3040:	87 ea       	ldi	r24, 0xA7	; 167
    3042:	99 e0       	ldi	r25, 0x09	; 9
    3044:	bf de       	rcall	.-642    	; 0x2dc4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3046:	ff 91       	pop	r31
    3048:	ef 91       	pop	r30
    304a:	bf 91       	pop	r27
    304c:	af 91       	pop	r26
    304e:	9f 91       	pop	r25
    3050:	8f 91       	pop	r24
    3052:	7f 91       	pop	r23
    3054:	6f 91       	pop	r22
    3056:	5f 91       	pop	r21
    3058:	4f 91       	pop	r20
    305a:	3f 91       	pop	r19
    305c:	2f 91       	pop	r18
    305e:	0f 90       	pop	r0
    3060:	0b be       	out	0x3b, r0	; 59
    3062:	0f 90       	pop	r0
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	0f 90       	pop	r0
    3068:	1f 90       	pop	r1
    306a:	18 95       	reti

0000306c <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    306c:	10 92 aa 09 	sts	0x09AA, r1
    3070:	10 92 a9 09 	sts	0x09A9, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    3074:	88 ee       	ldi	r24, 0xE8	; 232
    3076:	93 e0       	ldi	r25, 0x03	; 3
    3078:	a0 e0       	ldi	r26, 0x00	; 0
    307a:	b0 e0       	ldi	r27, 0x00	; 0
    307c:	80 93 ab 09 	sts	0x09AB, r24
    3080:	90 93 ac 09 	sts	0x09AC, r25
    3084:	a0 93 ad 09 	sts	0x09AD, r26
    3088:	b0 93 ae 09 	sts	0x09AE, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    308c:	8f e6       	ldi	r24, 0x6F	; 111
    308e:	92 e0       	ldi	r25, 0x02	; 2
    3090:	90 93 a8 09 	sts	0x09A8, r25
    3094:	80 93 a7 09 	sts	0x09A7, r24
    3098:	85 ec       	ldi	r24, 0xC5	; 197
    309a:	90 e0       	ldi	r25, 0x00	; 0
    309c:	90 93 b4 09 	sts	0x09B4, r25
    30a0:	80 93 b3 09 	sts	0x09B3, r24
    30a4:	84 ec       	ldi	r24, 0xC4	; 196
    30a6:	90 e0       	ldi	r25, 0x00	; 0
    30a8:	90 93 b6 09 	sts	0x09B6, r25
    30ac:	80 93 b5 09 	sts	0x09B5, r24
    30b0:	80 ec       	ldi	r24, 0xC0	; 192
    30b2:	90 e0       	ldi	r25, 0x00	; 0
    30b4:	90 93 b8 09 	sts	0x09B8, r25
    30b8:	80 93 b7 09 	sts	0x09B7, r24
    30bc:	81 ec       	ldi	r24, 0xC1	; 193
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	90 93 ba 09 	sts	0x09BA, r25
    30c4:	80 93 b9 09 	sts	0x09B9, r24
    30c8:	82 ec       	ldi	r24, 0xC2	; 194
    30ca:	90 e0       	ldi	r25, 0x00	; 0
    30cc:	90 93 bc 09 	sts	0x09BC, r25
    30d0:	80 93 bb 09 	sts	0x09BB, r24
    30d4:	86 ec       	ldi	r24, 0xC6	; 198
    30d6:	90 e0       	ldi	r25, 0x00	; 0
    30d8:	90 93 be 09 	sts	0x09BE, r25
    30dc:	80 93 bd 09 	sts	0x09BD, r24
    30e0:	10 92 c0 09 	sts	0x09C0, r1
    30e4:	10 92 c1 09 	sts	0x09C1, r1
    30e8:	10 92 c2 09 	sts	0x09C2, r1
    30ec:	10 92 c3 09 	sts	0x09C3, r1
    30f0:	08 95       	ret

000030f2 <__vector_36>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial1_available() {
  return Serial1.available();
}
    30f2:	1f 92       	push	r1
    30f4:	0f 92       	push	r0
    30f6:	0f b6       	in	r0, 0x3f	; 63
    30f8:	0f 92       	push	r0
    30fa:	11 24       	eor	r1, r1
    30fc:	0b b6       	in	r0, 0x3b	; 59
    30fe:	0f 92       	push	r0
    3100:	2f 93       	push	r18
    3102:	8f 93       	push	r24
    3104:	9f 93       	push	r25
    3106:	af 93       	push	r26
    3108:	bf 93       	push	r27
    310a:	ef 93       	push	r30
    310c:	ff 93       	push	r31
    310e:	e0 91 54 0a 	lds	r30, 0x0A54
    3112:	f0 91 55 0a 	lds	r31, 0x0A55
    3116:	80 81       	ld	r24, Z
    3118:	82 fd       	sbrc	r24, 2
    311a:	17 c0       	rjmp	.+46     	; 0x314a <__vector_36+0x58>
    311c:	e0 91 5a 0a 	lds	r30, 0x0A5A
    3120:	f0 91 5b 0a 	lds	r31, 0x0A5B
    3124:	20 81       	ld	r18, Z
    3126:	80 91 5d 0a 	lds	r24, 0x0A5D
    312a:	8f 5f       	subi	r24, 0xFF	; 255
    312c:	8f 73       	andi	r24, 0x3F	; 63
    312e:	90 91 5e 0a 	lds	r25, 0x0A5E
    3132:	89 17       	cp	r24, r25
    3134:	79 f0       	breq	.+30     	; 0x3154 <__vector_36+0x62>
    3136:	ed e5       	ldi	r30, 0x5D	; 93
    3138:	fa e0       	ldi	r31, 0x0A	; 10
    313a:	a0 81       	ld	r26, Z
    313c:	b0 e0       	ldi	r27, 0x00	; 0
    313e:	ac 5b       	subi	r26, 0xBC	; 188
    3140:	b5 4f       	sbci	r27, 0xF5	; 245
    3142:	5d 96       	adiw	r26, 0x1d	; 29
    3144:	2c 93       	st	X, r18
    3146:	80 83       	st	Z, r24
    3148:	05 c0       	rjmp	.+10     	; 0x3154 <__vector_36+0x62>
    314a:	e0 91 5a 0a 	lds	r30, 0x0A5A
    314e:	f0 91 5b 0a 	lds	r31, 0x0A5B
    3152:	80 81       	ld	r24, Z
    3154:	ff 91       	pop	r31
    3156:	ef 91       	pop	r30
    3158:	bf 91       	pop	r27
    315a:	af 91       	pop	r26
    315c:	9f 91       	pop	r25
    315e:	8f 91       	pop	r24
    3160:	2f 91       	pop	r18
    3162:	0f 90       	pop	r0
    3164:	0b be       	out	0x3b, r0	; 59
    3166:	0f 90       	pop	r0
    3168:	0f be       	out	0x3f, r0	; 63
    316a:	0f 90       	pop	r0
    316c:	1f 90       	pop	r1
    316e:	18 95       	reti

00003170 <__vector_37>:
    3170:	1f 92       	push	r1
    3172:	0f 92       	push	r0
    3174:	0f b6       	in	r0, 0x3f	; 63
    3176:	0f 92       	push	r0
    3178:	11 24       	eor	r1, r1
    317a:	0b b6       	in	r0, 0x3b	; 59
    317c:	0f 92       	push	r0
    317e:	2f 93       	push	r18
    3180:	3f 93       	push	r19
    3182:	4f 93       	push	r20
    3184:	5f 93       	push	r21
    3186:	6f 93       	push	r22
    3188:	7f 93       	push	r23
    318a:	8f 93       	push	r24
    318c:	9f 93       	push	r25
    318e:	af 93       	push	r26
    3190:	bf 93       	push	r27
    3192:	ef 93       	push	r30
    3194:	ff 93       	push	r31
    3196:	84 e4       	ldi	r24, 0x44	; 68
    3198:	9a e0       	ldi	r25, 0x0A	; 10
    319a:	14 de       	rcall	.-984    	; 0x2dc4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    319c:	ff 91       	pop	r31
    319e:	ef 91       	pop	r30
    31a0:	bf 91       	pop	r27
    31a2:	af 91       	pop	r26
    31a4:	9f 91       	pop	r25
    31a6:	8f 91       	pop	r24
    31a8:	7f 91       	pop	r23
    31aa:	6f 91       	pop	r22
    31ac:	5f 91       	pop	r21
    31ae:	4f 91       	pop	r20
    31b0:	3f 91       	pop	r19
    31b2:	2f 91       	pop	r18
    31b4:	0f 90       	pop	r0
    31b6:	0b be       	out	0x3b, r0	; 59
    31b8:	0f 90       	pop	r0
    31ba:	0f be       	out	0x3f, r0	; 63
    31bc:	0f 90       	pop	r0
    31be:	1f 90       	pop	r1
    31c0:	18 95       	reti

000031c2 <_GLOBAL__sub_I___vector_36>:
    31c2:	10 92 47 0a 	sts	0x0A47, r1
    31c6:	10 92 46 0a 	sts	0x0A46, r1
    31ca:	88 ee       	ldi	r24, 0xE8	; 232
    31cc:	93 e0       	ldi	r25, 0x03	; 3
    31ce:	a0 e0       	ldi	r26, 0x00	; 0
    31d0:	b0 e0       	ldi	r27, 0x00	; 0
    31d2:	80 93 48 0a 	sts	0x0A48, r24
    31d6:	90 93 49 0a 	sts	0x0A49, r25
    31da:	a0 93 4a 0a 	sts	0x0A4A, r26
    31de:	b0 93 4b 0a 	sts	0x0A4B, r27
    31e2:	8f e6       	ldi	r24, 0x6F	; 111
    31e4:	92 e0       	ldi	r25, 0x02	; 2
    31e6:	90 93 45 0a 	sts	0x0A45, r25
    31ea:	80 93 44 0a 	sts	0x0A44, r24
    31ee:	8d ec       	ldi	r24, 0xCD	; 205
    31f0:	90 e0       	ldi	r25, 0x00	; 0
    31f2:	90 93 51 0a 	sts	0x0A51, r25
    31f6:	80 93 50 0a 	sts	0x0A50, r24
    31fa:	8c ec       	ldi	r24, 0xCC	; 204
    31fc:	90 e0       	ldi	r25, 0x00	; 0
    31fe:	90 93 53 0a 	sts	0x0A53, r25
    3202:	80 93 52 0a 	sts	0x0A52, r24
    3206:	88 ec       	ldi	r24, 0xC8	; 200
    3208:	90 e0       	ldi	r25, 0x00	; 0
    320a:	90 93 55 0a 	sts	0x0A55, r25
    320e:	80 93 54 0a 	sts	0x0A54, r24
    3212:	89 ec       	ldi	r24, 0xC9	; 201
    3214:	90 e0       	ldi	r25, 0x00	; 0
    3216:	90 93 57 0a 	sts	0x0A57, r25
    321a:	80 93 56 0a 	sts	0x0A56, r24
    321e:	8a ec       	ldi	r24, 0xCA	; 202
    3220:	90 e0       	ldi	r25, 0x00	; 0
    3222:	90 93 59 0a 	sts	0x0A59, r25
    3226:	80 93 58 0a 	sts	0x0A58, r24
    322a:	8e ec       	ldi	r24, 0xCE	; 206
    322c:	90 e0       	ldi	r25, 0x00	; 0
    322e:	90 93 5b 0a 	sts	0x0A5B, r25
    3232:	80 93 5a 0a 	sts	0x0A5A, r24
    3236:	10 92 5d 0a 	sts	0x0A5D, r1
    323a:	10 92 5e 0a 	sts	0x0A5E, r1
    323e:	10 92 5f 0a 	sts	0x0A5F, r1
    3242:	10 92 60 0a 	sts	0x0A60, r1
    3246:	08 95       	ret

00003248 <_ZN5Print5writeEPKhj>:
size_t Print::println(const Printable& x)
{
  size_t n = print(x);
  n += println();
  return n;
}
    3248:	cf 92       	push	r12
    324a:	df 92       	push	r13
    324c:	ef 92       	push	r14
    324e:	ff 92       	push	r15
    3250:	0f 93       	push	r16
    3252:	1f 93       	push	r17
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
    3258:	6c 01       	movw	r12, r24
    325a:	41 15       	cp	r20, r1
    325c:	51 05       	cpc	r21, r1
    325e:	b1 f0       	breq	.+44     	; 0x328c <_ZN5Print5writeEPKhj+0x44>
    3260:	06 2f       	mov	r16, r22
    3262:	17 2f       	mov	r17, r23
    3264:	ea 01       	movw	r28, r20
    3266:	e1 2c       	mov	r14, r1
    3268:	f1 2c       	mov	r15, r1
    326a:	d8 01       	movw	r26, r16
    326c:	6d 91       	ld	r22, X+
    326e:	8d 01       	movw	r16, r26
    3270:	d6 01       	movw	r26, r12
    3272:	ed 91       	ld	r30, X+
    3274:	fc 91       	ld	r31, X
    3276:	01 90       	ld	r0, Z+
    3278:	f0 81       	ld	r31, Z
    327a:	e0 2d       	mov	r30, r0
    327c:	c6 01       	movw	r24, r12
    327e:	19 95       	eicall
    3280:	e8 0e       	add	r14, r24
    3282:	f9 1e       	adc	r15, r25
    3284:	21 97       	sbiw	r28, 0x01	; 1
    3286:	20 97       	sbiw	r28, 0x00	; 0
    3288:	81 f7       	brne	.-32     	; 0x326a <_ZN5Print5writeEPKhj+0x22>
    328a:	02 c0       	rjmp	.+4      	; 0x3290 <_ZN5Print5writeEPKhj+0x48>
    328c:	e1 2c       	mov	r14, r1
    328e:	f1 2c       	mov	r15, r1
    3290:	c7 01       	movw	r24, r14
    3292:	df 91       	pop	r29
    3294:	cf 91       	pop	r28
    3296:	1f 91       	pop	r17
    3298:	0f 91       	pop	r16
    329a:	ff 90       	pop	r15
    329c:	ef 90       	pop	r14
    329e:	df 90       	pop	r13
    32a0:	cf 90       	pop	r12
    32a2:	08 95       	ret

000032a4 <_ZN5Print5printEc>:
    32a4:	dc 01       	movw	r26, r24
    32a6:	ed 91       	ld	r30, X+
    32a8:	fc 91       	ld	r31, X
    32aa:	01 90       	ld	r0, Z+
    32ac:	f0 81       	ld	r31, Z
    32ae:	e0 2d       	mov	r30, r0
    32b0:	19 95       	eicall
    32b2:	08 95       	ret

000032b4 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
    32b4:	6f 92       	push	r6
    32b6:	7f 92       	push	r7
    32b8:	8f 92       	push	r8
    32ba:	9f 92       	push	r9
    32bc:	af 92       	push	r10
    32be:	bf 92       	push	r11
    32c0:	cf 92       	push	r12
    32c2:	df 92       	push	r13
    32c4:	ef 92       	push	r14
    32c6:	ff 92       	push	r15
    32c8:	0f 93       	push	r16
    32ca:	1f 93       	push	r17
    32cc:	cf 93       	push	r28
    32ce:	df 93       	push	r29
    32d0:	cd b7       	in	r28, 0x3d	; 61
    32d2:	de b7       	in	r29, 0x3e	; 62
    32d4:	a1 97       	sbiw	r28, 0x21	; 33
    32d6:	0f b6       	in	r0, 0x3f	; 63
    32d8:	f8 94       	cli
    32da:	de bf       	out	0x3e, r29	; 62
    32dc:	0f be       	out	0x3f, r0	; 63
    32de:	cd bf       	out	0x3d, r28	; 61
    32e0:	6c 01       	movw	r12, r24
    32e2:	74 2e       	mov	r7, r20
    32e4:	35 2f       	mov	r19, r21
    32e6:	86 2f       	mov	r24, r22
    32e8:	97 2f       	mov	r25, r23
    32ea:	62 2e       	mov	r6, r18
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    32ec:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    32ee:	21 e0       	ldi	r18, 0x01	; 1
    32f0:	26 15       	cp	r18, r6
    32f2:	20 f0       	brcs	.+8      	; 0x32fc <_ZN5Print11printNumberEmh+0x48>
    32f4:	0f 2e       	mov	r0, r31
    32f6:	fa e0       	ldi	r31, 0x0A	; 10
    32f8:	6f 2e       	mov	r6, r31
    32fa:	f0 2d       	mov	r31, r0
    32fc:	7e 01       	movw	r14, r28
    32fe:	a1 e2       	ldi	r26, 0x21	; 33
    3300:	ea 0e       	add	r14, r26
    3302:	f1 1c       	adc	r15, r1

  do {
    unsigned long m = n;
    n /= base;
    3304:	86 2c       	mov	r8, r6
    3306:	91 2c       	mov	r9, r1
    3308:	a1 2c       	mov	r10, r1
    330a:	b1 2c       	mov	r11, r1
    330c:	67 2d       	mov	r22, r7
    330e:	73 2f       	mov	r23, r19
    3310:	a5 01       	movw	r20, r10
    3312:	94 01       	movw	r18, r8
    3314:	71 d2       	rcall	.+1250   	; 0x37f8 <__udivmodsi4>
    3316:	e2 2f       	mov	r30, r18
    3318:	73 2f       	mov	r23, r19
    331a:	02 2f       	mov	r16, r18
    331c:	13 2f       	mov	r17, r19
    331e:	24 2f       	mov	r18, r20
    3320:	35 2f       	mov	r19, r21
    char c = m - base * n;
    3322:	f7 2d       	mov	r31, r7
    3324:	6e 9e       	mul	r6, r30
    3326:	f0 19       	sub	r31, r0
    3328:	11 24       	eor	r1, r1
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    332a:	b1 e0       	ldi	r27, 0x01	; 1
    332c:	eb 1a       	sub	r14, r27
    332e:	f1 08       	sbc	r15, r1
    3330:	fa 30       	cpi	r31, 0x0A	; 10
    3332:	10 f4       	brcc	.+4      	; 0x3338 <_ZN5Print11printNumberEmh+0x84>
    3334:	f0 5d       	subi	r31, 0xD0	; 208
    3336:	01 c0       	rjmp	.+2      	; 0x333a <_ZN5Print11printNumberEmh+0x86>
    3338:	f9 5c       	subi	r31, 0xC9	; 201
    333a:	d7 01       	movw	r26, r14
    333c:	fc 93       	st	X, r31
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    333e:	01 2b       	or	r16, r17
    3340:	02 2b       	or	r16, r18
    3342:	03 2b       	or	r16, r19
    3344:	29 f0       	breq	.+10     	; 0x3350 <_ZN5Print11printNumberEmh+0x9c>
    unsigned long m = n;
    n /= base;
    3346:	7e 2e       	mov	r7, r30
    3348:	37 2f       	mov	r19, r23
    334a:	84 2f       	mov	r24, r20
    334c:	95 2f       	mov	r25, r21
    334e:	de cf       	rjmp	.-68     	; 0x330c <_ZN5Print11printNumberEmh+0x58>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    3350:	e1 14       	cp	r14, r1
    3352:	f1 04       	cpc	r15, r1
    3354:	91 f0       	breq	.+36     	; 0x337a <_ZN5Print11printNumberEmh+0xc6>
      return write((const uint8_t *)str, strlen(str));
    3356:	f7 01       	movw	r30, r14
    3358:	01 90       	ld	r0, Z+
    335a:	00 20       	and	r0, r0
    335c:	e9 f7       	brne	.-6      	; 0x3358 <_ZN5Print11printNumberEmh+0xa4>
    335e:	31 97       	sbiw	r30, 0x01	; 1
    3360:	af 01       	movw	r20, r30
    3362:	4e 19       	sub	r20, r14
    3364:	5f 09       	sbc	r21, r15
    3366:	d6 01       	movw	r26, r12
    3368:	ed 91       	ld	r30, X+
    336a:	fc 91       	ld	r31, X
    336c:	02 80       	ldd	r0, Z+2	; 0x02
    336e:	f3 81       	ldd	r31, Z+3	; 0x03
    3370:	e0 2d       	mov	r30, r0
    3372:	b7 01       	movw	r22, r14
    3374:	c6 01       	movw	r24, r12
    3376:	19 95       	eicall
    3378:	02 c0       	rjmp	.+4      	; 0x337e <_ZN5Print11printNumberEmh+0xca>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    337a:	80 e0       	ldi	r24, 0x00	; 0
    337c:	90 e0       	ldi	r25, 0x00	; 0
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
}
    337e:	a1 96       	adiw	r28, 0x21	; 33
    3380:	0f b6       	in	r0, 0x3f	; 63
    3382:	f8 94       	cli
    3384:	de bf       	out	0x3e, r29	; 62
    3386:	0f be       	out	0x3f, r0	; 63
    3388:	cd bf       	out	0x3d, r28	; 61
    338a:	df 91       	pop	r29
    338c:	cf 91       	pop	r28
    338e:	1f 91       	pop	r17
    3390:	0f 91       	pop	r16
    3392:	ff 90       	pop	r15
    3394:	ef 90       	pop	r14
    3396:	df 90       	pop	r13
    3398:	cf 90       	pop	r12
    339a:	bf 90       	pop	r11
    339c:	af 90       	pop	r10
    339e:	9f 90       	pop	r9
    33a0:	8f 90       	pop	r8
    33a2:	7f 90       	pop	r7
    33a4:	6f 90       	pop	r6
    33a6:	08 95       	ret

000033a8 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    33a8:	cf 92       	push	r12
    33aa:	df 92       	push	r13
    33ac:	ef 92       	push	r14
    33ae:	ff 92       	push	r15
    33b0:	0f 93       	push	r16
    33b2:	1f 93       	push	r17
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	ec 01       	movw	r28, r24
    33ba:	6a 01       	movw	r12, r20
    33bc:	7b 01       	movw	r14, r22
  if (base == 0) {
    33be:	21 15       	cp	r18, r1
    33c0:	31 05       	cpc	r19, r1
    33c2:	41 f4       	brne	.+16     	; 0x33d4 <_ZN5Print5printEli+0x2c>
    return write(n);
    33c4:	e8 81       	ld	r30, Y
    33c6:	f9 81       	ldd	r31, Y+1	; 0x01
    33c8:	01 90       	ld	r0, Z+
    33ca:	f0 81       	ld	r31, Z
    33cc:	e0 2d       	mov	r30, r0
    33ce:	64 2f       	mov	r22, r20
    33d0:	19 95       	eicall
    33d2:	19 c0       	rjmp	.+50     	; 0x3406 <_ZN5Print5printEli+0x5e>
  } else if (base == 10) {
    33d4:	2a 30       	cpi	r18, 0x0A	; 10
    33d6:	31 05       	cpc	r19, r1
    33d8:	a9 f4       	brne	.+42     	; 0x3404 <_ZN5Print5printEli+0x5c>
    if (n < 0) {
    33da:	77 23       	and	r23, r23
    33dc:	84 f4       	brge	.+32     	; 0x33fe <_ZN5Print5printEli+0x56>
      int t = print('-');
    33de:	6d e2       	ldi	r22, 0x2D	; 45
    33e0:	61 df       	rcall	.-318    	; 0x32a4 <_ZN5Print5printEc>
    33e2:	8c 01       	movw	r16, r24
      n = -n;
    33e4:	44 27       	eor	r20, r20
    33e6:	55 27       	eor	r21, r21
    33e8:	ba 01       	movw	r22, r20
    33ea:	4c 19       	sub	r20, r12
    33ec:	5d 09       	sbc	r21, r13
    33ee:	6e 09       	sbc	r22, r14
    33f0:	7f 09       	sbc	r23, r15
      return printNumber(n, 10) + t;
    33f2:	2a e0       	ldi	r18, 0x0A	; 10
    33f4:	ce 01       	movw	r24, r28
    33f6:	5e df       	rcall	.-324    	; 0x32b4 <_ZN5Print11printNumberEmh>
    33f8:	80 0f       	add	r24, r16
    33fa:	91 1f       	adc	r25, r17
    33fc:	04 c0       	rjmp	.+8      	; 0x3406 <_ZN5Print5printEli+0x5e>
    }
    return printNumber(n, 10);
    33fe:	2a e0       	ldi	r18, 0x0A	; 10
    3400:	59 df       	rcall	.-334    	; 0x32b4 <_ZN5Print11printNumberEmh>
    3402:	01 c0       	rjmp	.+2      	; 0x3406 <_ZN5Print5printEli+0x5e>
  } else {
    return printNumber(n, base);
    3404:	57 df       	rcall	.-338    	; 0x32b4 <_ZN5Print11printNumberEmh>
  }
}
    3406:	df 91       	pop	r29
    3408:	cf 91       	pop	r28
    340a:	1f 91       	pop	r17
    340c:	0f 91       	pop	r16
    340e:	ff 90       	pop	r15
    3410:	ef 90       	pop	r14
    3412:	df 90       	pop	r13
    3414:	cf 90       	pop	r12
    3416:	08 95       	ret

00003418 <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    3418:	9a 01       	movw	r18, r20
  return print((long) n, base);
    341a:	ab 01       	movw	r20, r22
    341c:	66 27       	eor	r22, r22
    341e:	57 fd       	sbrc	r21, 7
    3420:	60 95       	com	r22
    3422:	76 2f       	mov	r23, r22
    3424:	c1 cf       	rjmp	.-126    	; 0x33a8 <_ZN5Print5printEli>
}
    3426:	08 95       	ret

00003428 <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    3428:	1f 92       	push	r1
    342a:	0f 92       	push	r0
    342c:	0f b6       	in	r0, 0x3f	; 63
    342e:	0f 92       	push	r0
    3430:	11 24       	eor	r1, r1
    3432:	2f 93       	push	r18
    3434:	3f 93       	push	r19
    3436:	8f 93       	push	r24
    3438:	9f 93       	push	r25
    343a:	af 93       	push	r26
    343c:	bf 93       	push	r27
    343e:	80 91 e2 0a 	lds	r24, 0x0AE2
    3442:	90 91 e3 0a 	lds	r25, 0x0AE3
    3446:	a0 91 e4 0a 	lds	r26, 0x0AE4
    344a:	b0 91 e5 0a 	lds	r27, 0x0AE5
    344e:	30 91 e1 0a 	lds	r19, 0x0AE1
    3452:	23 e0       	ldi	r18, 0x03	; 3
    3454:	23 0f       	add	r18, r19
    3456:	2d 37       	cpi	r18, 0x7D	; 125
    3458:	20 f4       	brcc	.+8      	; 0x3462 <__vector_23+0x3a>
    345a:	01 96       	adiw	r24, 0x01	; 1
    345c:	a1 1d       	adc	r26, r1
    345e:	b1 1d       	adc	r27, r1
    3460:	05 c0       	rjmp	.+10     	; 0x346c <__vector_23+0x44>
    3462:	26 e8       	ldi	r18, 0x86	; 134
    3464:	23 0f       	add	r18, r19
    3466:	02 96       	adiw	r24, 0x02	; 2
    3468:	a1 1d       	adc	r26, r1
    346a:	b1 1d       	adc	r27, r1
    346c:	20 93 e1 0a 	sts	0x0AE1, r18
    3470:	80 93 e2 0a 	sts	0x0AE2, r24
    3474:	90 93 e3 0a 	sts	0x0AE3, r25
    3478:	a0 93 e4 0a 	sts	0x0AE4, r26
    347c:	b0 93 e5 0a 	sts	0x0AE5, r27
    3480:	80 91 e6 0a 	lds	r24, 0x0AE6
    3484:	90 91 e7 0a 	lds	r25, 0x0AE7
    3488:	a0 91 e8 0a 	lds	r26, 0x0AE8
    348c:	b0 91 e9 0a 	lds	r27, 0x0AE9
    3490:	01 96       	adiw	r24, 0x01	; 1
    3492:	a1 1d       	adc	r26, r1
    3494:	b1 1d       	adc	r27, r1
    3496:	80 93 e6 0a 	sts	0x0AE6, r24
    349a:	90 93 e7 0a 	sts	0x0AE7, r25
    349e:	a0 93 e8 0a 	sts	0x0AE8, r26
    34a2:	b0 93 e9 0a 	sts	0x0AE9, r27
    34a6:	bf 91       	pop	r27
    34a8:	af 91       	pop	r26
    34aa:	9f 91       	pop	r25
    34ac:	8f 91       	pop	r24
    34ae:	3f 91       	pop	r19
    34b0:	2f 91       	pop	r18
    34b2:	0f 90       	pop	r0
    34b4:	0f be       	out	0x3f, r0	; 63
    34b6:	0f 90       	pop	r0
    34b8:	1f 90       	pop	r1
    34ba:	18 95       	reti

000034bc <millis>:
    34bc:	2f b7       	in	r18, 0x3f	; 63
    34be:	f8 94       	cli
    34c0:	60 91 e2 0a 	lds	r22, 0x0AE2
    34c4:	70 91 e3 0a 	lds	r23, 0x0AE3
    34c8:	80 91 e4 0a 	lds	r24, 0x0AE4
    34cc:	90 91 e5 0a 	lds	r25, 0x0AE5
    34d0:	2f bf       	out	0x3f, r18	; 63
    34d2:	08 95       	ret

000034d4 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    34d4:	82 30       	cpi	r24, 0x02	; 2
    34d6:	91 05       	cpc	r25, r1
    34d8:	38 f0       	brcs	.+14     	; 0x34e8 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    34da:	88 0f       	add	r24, r24
    34dc:	99 1f       	adc	r25, r25
    34de:	88 0f       	add	r24, r24
    34e0:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    34e2:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    34e4:	01 97       	sbiw	r24, 0x01	; 1
    34e6:	f1 f7       	brne	.-4      	; 0x34e4 <delayMicroseconds+0x10>
    34e8:	08 95       	ret

000034ea <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    34ea:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    34ec:	84 b5       	in	r24, 0x24	; 36
    34ee:	82 60       	ori	r24, 0x02	; 2
    34f0:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    34f2:	84 b5       	in	r24, 0x24	; 36
    34f4:	81 60       	ori	r24, 0x01	; 1
    34f6:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    34f8:	85 b5       	in	r24, 0x25	; 37
    34fa:	82 60       	ori	r24, 0x02	; 2
    34fc:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    34fe:	85 b5       	in	r24, 0x25	; 37
    3500:	81 60       	ori	r24, 0x01	; 1
    3502:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    3504:	ee e6       	ldi	r30, 0x6E	; 110
    3506:	f0 e0       	ldi	r31, 0x00	; 0
    3508:	80 81       	ld	r24, Z
    350a:	81 60       	ori	r24, 0x01	; 1
    350c:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    350e:	e1 e8       	ldi	r30, 0x81	; 129
    3510:	f0 e0       	ldi	r31, 0x00	; 0
    3512:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    3514:	80 81       	ld	r24, Z
    3516:	82 60       	ori	r24, 0x02	; 2
    3518:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    351a:	80 81       	ld	r24, Z
    351c:	81 60       	ori	r24, 0x01	; 1
    351e:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    3520:	e0 e8       	ldi	r30, 0x80	; 128
    3522:	f0 e0       	ldi	r31, 0x00	; 0
    3524:	80 81       	ld	r24, Z
    3526:	81 60       	ori	r24, 0x01	; 1
    3528:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    352a:	e1 eb       	ldi	r30, 0xB1	; 177
    352c:	f0 e0       	ldi	r31, 0x00	; 0
    352e:	80 81       	ld	r24, Z
    3530:	84 60       	ori	r24, 0x04	; 4
    3532:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    3534:	e0 eb       	ldi	r30, 0xB0	; 176
    3536:	f0 e0       	ldi	r31, 0x00	; 0
    3538:	80 81       	ld	r24, Z
    353a:	81 60       	ori	r24, 0x01	; 1
    353c:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    353e:	e1 e9       	ldi	r30, 0x91	; 145
    3540:	f0 e0       	ldi	r31, 0x00	; 0
    3542:	80 81       	ld	r24, Z
    3544:	82 60       	ori	r24, 0x02	; 2
    3546:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    3548:	80 81       	ld	r24, Z
    354a:	81 60       	ori	r24, 0x01	; 1
    354c:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    354e:	e0 e9       	ldi	r30, 0x90	; 144
    3550:	f0 e0       	ldi	r31, 0x00	; 0
    3552:	80 81       	ld	r24, Z
    3554:	81 60       	ori	r24, 0x01	; 1
    3556:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    3558:	e1 ea       	ldi	r30, 0xA1	; 161
    355a:	f0 e0       	ldi	r31, 0x00	; 0
    355c:	80 81       	ld	r24, Z
    355e:	82 60       	ori	r24, 0x02	; 2
    3560:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    3562:	80 81       	ld	r24, Z
    3564:	81 60       	ori	r24, 0x01	; 1
    3566:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    3568:	e0 ea       	ldi	r30, 0xA0	; 160
    356a:	f0 e0       	ldi	r31, 0x00	; 0
    356c:	80 81       	ld	r24, Z
    356e:	81 60       	ori	r24, 0x01	; 1
    3570:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    3572:	e1 e2       	ldi	r30, 0x21	; 33
    3574:	f1 e0       	ldi	r31, 0x01	; 1
    3576:	80 81       	ld	r24, Z
    3578:	82 60       	ori	r24, 0x02	; 2
    357a:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    357c:	80 81       	ld	r24, Z
    357e:	81 60       	ori	r24, 0x01	; 1
    3580:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    3582:	e0 e2       	ldi	r30, 0x20	; 32
    3584:	f1 e0       	ldi	r31, 0x01	; 1
    3586:	80 81       	ld	r24, Z
    3588:	81 60       	ori	r24, 0x01	; 1
    358a:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    358c:	ea e7       	ldi	r30, 0x7A	; 122
    358e:	f0 e0       	ldi	r31, 0x00	; 0
    3590:	80 81       	ld	r24, Z
    3592:	84 60       	ori	r24, 0x04	; 4
    3594:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    3596:	80 81       	ld	r24, Z
    3598:	82 60       	ori	r24, 0x02	; 2
    359a:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    359c:	80 81       	ld	r24, Z
    359e:	81 60       	ori	r24, 0x01	; 1
    35a0:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    35a2:	80 81       	ld	r24, Z
    35a4:	80 68       	ori	r24, 0x80	; 128
    35a6:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    35a8:	10 92 c1 00 	sts	0x00C1, r1
    35ac:	08 95       	ret

000035ae <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    35ae:	90 e0       	ldi	r25, 0x00	; 0
    35b0:	fc 01       	movw	r30, r24
    35b2:	31 97       	sbiw	r30, 0x01	; 1
    35b4:	e2 31       	cpi	r30, 0x12	; 18
    35b6:	f1 05       	cpc	r31, r1
    35b8:	08 f0       	brcs	.+2      	; 0x35bc <turnOffPWM+0xe>
    35ba:	5e c0       	rjmp	.+188    	; 0x3678 <turnOffPWM+0xca>
    35bc:	ee 5a       	subi	r30, 0xAE	; 174
    35be:	fe 4f       	sbci	r31, 0xFE	; 254
    35c0:	3d c1       	rjmp	.+634    	; 0x383c <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    35c2:	e0 e8       	ldi	r30, 0x80	; 128
    35c4:	f0 e0       	ldi	r31, 0x00	; 0
    35c6:	80 81       	ld	r24, Z
    35c8:	8f 77       	andi	r24, 0x7F	; 127
    35ca:	80 83       	st	Z, r24
    35cc:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    35ce:	e0 e8       	ldi	r30, 0x80	; 128
    35d0:	f0 e0       	ldi	r31, 0x00	; 0
    35d2:	80 81       	ld	r24, Z
    35d4:	8f 7d       	andi	r24, 0xDF	; 223
    35d6:	80 83       	st	Z, r24
    35d8:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    35da:	e0 e8       	ldi	r30, 0x80	; 128
    35dc:	f0 e0       	ldi	r31, 0x00	; 0
    35de:	80 81       	ld	r24, Z
    35e0:	87 7f       	andi	r24, 0xF7	; 247
    35e2:	80 83       	st	Z, r24
    35e4:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    35e6:	84 b5       	in	r24, 0x24	; 36
    35e8:	8f 77       	andi	r24, 0x7F	; 127
    35ea:	84 bd       	out	0x24, r24	; 36
    35ec:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    35ee:	84 b5       	in	r24, 0x24	; 36
    35f0:	8f 7d       	andi	r24, 0xDF	; 223
    35f2:	84 bd       	out	0x24, r24	; 36
    35f4:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    35f6:	e0 eb       	ldi	r30, 0xB0	; 176
    35f8:	f0 e0       	ldi	r31, 0x00	; 0
    35fa:	80 81       	ld	r24, Z
    35fc:	8f 77       	andi	r24, 0x7F	; 127
    35fe:	80 83       	st	Z, r24
    3600:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    3602:	e0 eb       	ldi	r30, 0xB0	; 176
    3604:	f0 e0       	ldi	r31, 0x00	; 0
    3606:	80 81       	ld	r24, Z
    3608:	8f 7d       	andi	r24, 0xDF	; 223
    360a:	80 83       	st	Z, r24
    360c:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    360e:	e0 e9       	ldi	r30, 0x90	; 144
    3610:	f0 e0       	ldi	r31, 0x00	; 0
    3612:	80 81       	ld	r24, Z
    3614:	8f 77       	andi	r24, 0x7F	; 127
    3616:	80 83       	st	Z, r24
    3618:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    361a:	e0 e9       	ldi	r30, 0x90	; 144
    361c:	f0 e0       	ldi	r31, 0x00	; 0
    361e:	80 81       	ld	r24, Z
    3620:	8f 7d       	andi	r24, 0xDF	; 223
    3622:	80 83       	st	Z, r24
    3624:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    3626:	e0 e9       	ldi	r30, 0x90	; 144
    3628:	f0 e0       	ldi	r31, 0x00	; 0
    362a:	80 81       	ld	r24, Z
    362c:	87 7f       	andi	r24, 0xF7	; 247
    362e:	80 83       	st	Z, r24
    3630:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    3632:	e0 ea       	ldi	r30, 0xA0	; 160
    3634:	f0 e0       	ldi	r31, 0x00	; 0
    3636:	80 81       	ld	r24, Z
    3638:	8f 77       	andi	r24, 0x7F	; 127
    363a:	80 83       	st	Z, r24
    363c:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    363e:	e0 ea       	ldi	r30, 0xA0	; 160
    3640:	f0 e0       	ldi	r31, 0x00	; 0
    3642:	80 81       	ld	r24, Z
    3644:	8f 7d       	andi	r24, 0xDF	; 223
    3646:	80 83       	st	Z, r24
    3648:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    364a:	e0 ea       	ldi	r30, 0xA0	; 160
    364c:	f0 e0       	ldi	r31, 0x00	; 0
    364e:	80 81       	ld	r24, Z
    3650:	87 7f       	andi	r24, 0xF7	; 247
    3652:	80 83       	st	Z, r24
    3654:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3656:	e0 e2       	ldi	r30, 0x20	; 32
    3658:	f1 e0       	ldi	r31, 0x01	; 1
    365a:	80 81       	ld	r24, Z
    365c:	8f 77       	andi	r24, 0x7F	; 127
    365e:	80 83       	st	Z, r24
    3660:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    3662:	e0 e2       	ldi	r30, 0x20	; 32
    3664:	f1 e0       	ldi	r31, 0x01	; 1
    3666:	80 81       	ld	r24, Z
    3668:	8f 7d       	andi	r24, 0xDF	; 223
    366a:	80 83       	st	Z, r24
    366c:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    366e:	e0 e2       	ldi	r30, 0x20	; 32
    3670:	f1 e0       	ldi	r31, 0x01	; 1
    3672:	80 81       	ld	r24, Z
    3674:	87 7f       	andi	r24, 0xF7	; 247
    3676:	80 83       	st	Z, r24
    3678:	08 95       	ret

0000367a <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    367a:	cf 93       	push	r28
    367c:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    367e:	90 e0       	ldi	r25, 0x00	; 0
    3680:	fc 01       	movw	r30, r24
    3682:	e2 5f       	subi	r30, 0xF2	; 242
    3684:	fc 4f       	sbci	r31, 0xFC	; 252
    3686:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    3688:	fc 01       	movw	r30, r24
    368a:	ec 5a       	subi	r30, 0xAC	; 172
    368c:	fc 4f       	sbci	r31, 0xFC	; 252
    368e:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    3690:	88 23       	and	r24, r24
    3692:	71 f1       	breq	.+92     	; 0x36f0 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3694:	90 e0       	ldi	r25, 0x00	; 0
    3696:	88 0f       	add	r24, r24
    3698:	99 1f       	adc	r25, r25
    369a:	fc 01       	movw	r30, r24
    369c:	e2 53       	subi	r30, 0x32	; 50
    369e:	fc 4f       	sbci	r31, 0xFC	; 252
    36a0:	a5 91       	lpm	r26, Z+
    36a2:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    36a4:	8c 54       	subi	r24, 0x4C	; 76
    36a6:	9c 4f       	sbci	r25, 0xFC	; 252
    36a8:	fc 01       	movw	r30, r24
    36aa:	c5 91       	lpm	r28, Z+
    36ac:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    36ae:	61 11       	cpse	r22, r1
    36b0:	0b c0       	rjmp	.+22     	; 0x36c8 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    36b2:	8f b7       	in	r24, 0x3f	; 63
                cli();
    36b4:	f8 94       	cli
		*reg &= ~bit;
    36b6:	9c 91       	ld	r25, X
    36b8:	20 95       	com	r18
    36ba:	92 23       	and	r25, r18
    36bc:	9c 93       	st	X, r25
		*out &= ~bit;
    36be:	e8 81       	ld	r30, Y
    36c0:	2e 23       	and	r18, r30
    36c2:	28 83       	st	Y, r18
		SREG = oldSREG;
    36c4:	8f bf       	out	0x3f, r24	; 63
    36c6:	14 c0       	rjmp	.+40     	; 0x36f0 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    36c8:	62 30       	cpi	r22, 0x02	; 2
    36ca:	61 f4       	brne	.+24     	; 0x36e4 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    36cc:	8f b7       	in	r24, 0x3f	; 63
                cli();
    36ce:	f8 94       	cli
		*reg &= ~bit;
    36d0:	3c 91       	ld	r19, X
    36d2:	92 2f       	mov	r25, r18
    36d4:	90 95       	com	r25
    36d6:	93 23       	and	r25, r19
    36d8:	9c 93       	st	X, r25
		*out |= bit;
    36da:	e8 81       	ld	r30, Y
    36dc:	2e 2b       	or	r18, r30
    36de:	28 83       	st	Y, r18
		SREG = oldSREG;
    36e0:	8f bf       	out	0x3f, r24	; 63
    36e2:	06 c0       	rjmp	.+12     	; 0x36f0 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    36e4:	8f b7       	in	r24, 0x3f	; 63
                cli();
    36e6:	f8 94       	cli
		*reg |= bit;
    36e8:	ec 91       	ld	r30, X
    36ea:	2e 2b       	or	r18, r30
    36ec:	2c 93       	st	X, r18
		SREG = oldSREG;
    36ee:	8f bf       	out	0x3f, r24	; 63
	}
}
    36f0:	df 91       	pop	r29
    36f2:	cf 91       	pop	r28
    36f4:	08 95       	ret

000036f6 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    36f6:	1f 93       	push	r17
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    36fe:	28 2f       	mov	r18, r24
    3700:	30 e0       	ldi	r19, 0x00	; 0
    3702:	f9 01       	movw	r30, r18
    3704:	e8 53       	subi	r30, 0x38	; 56
    3706:	fd 4f       	sbci	r31, 0xFD	; 253
    3708:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    370a:	f9 01       	movw	r30, r18
    370c:	e2 5f       	subi	r30, 0xF2	; 242
    370e:	fc 4f       	sbci	r31, 0xFC	; 252
    3710:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    3712:	f9 01       	movw	r30, r18
    3714:	ec 5a       	subi	r30, 0xAC	; 172
    3716:	fc 4f       	sbci	r31, 0xFC	; 252
    3718:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    371a:	dd 23       	and	r29, r29
    371c:	c1 f0       	breq	.+48     	; 0x374e <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    371e:	81 11       	cpse	r24, r1
    3720:	46 df       	rcall	.-372    	; 0x35ae <turnOffPWM>

	out = portOutputRegister(port);
    3722:	2d 2f       	mov	r18, r29
    3724:	30 e0       	ldi	r19, 0x00	; 0
    3726:	f9 01       	movw	r30, r18
    3728:	ee 0f       	add	r30, r30
    372a:	ff 1f       	adc	r31, r31
    372c:	ec 54       	subi	r30, 0x4C	; 76
    372e:	fc 4f       	sbci	r31, 0xFC	; 252
    3730:	a5 91       	lpm	r26, Z+
    3732:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    3734:	8f b7       	in	r24, 0x3f	; 63
	cli();
    3736:	f8 94       	cli

	if (val == LOW) {
    3738:	c1 11       	cpse	r28, r1
    373a:	05 c0       	rjmp	.+10     	; 0x3746 <digitalWrite+0x50>
		*out &= ~bit;
    373c:	ec 91       	ld	r30, X
    373e:	10 95       	com	r17
    3740:	1e 23       	and	r17, r30
    3742:	1c 93       	st	X, r17
    3744:	03 c0       	rjmp	.+6      	; 0x374c <digitalWrite+0x56>
	} else {
		*out |= bit;
    3746:	ec 91       	ld	r30, X
    3748:	1e 2b       	or	r17, r30
    374a:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    374c:	8f bf       	out	0x3f, r24	; 63
}
    374e:	df 91       	pop	r29
    3750:	cf 91       	pop	r28
    3752:	1f 91       	pop	r17
    3754:	08 95       	ret

00003756 <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3756:	0f 93       	push	r16
    3758:	1f 93       	push	r17
    375a:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    375c:	90 e0       	ldi	r25, 0x00	; 0
    375e:	fc 01       	movw	r30, r24
    3760:	e2 5f       	subi	r30, 0xF2	; 242
    3762:	fc 4f       	sbci	r31, 0xFC	; 252
    3764:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    3766:	fc 01       	movw	r30, r24
    3768:	ec 5a       	subi	r30, 0xAC	; 172
    376a:	fc 4f       	sbci	r31, 0xFC	; 252
    376c:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    376e:	71 11       	cpse	r23, r1
    3770:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3772:	f0 e0       	ldi	r31, 0x00	; 0
    3774:	ee 0f       	add	r30, r30
    3776:	ff 1f       	adc	r31, r31
    3778:	e6 56       	subi	r30, 0x66	; 102
    377a:	fc 4f       	sbci	r31, 0xFC	; 252
    377c:	85 91       	lpm	r24, Z+
    377e:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    3780:	89 01       	movw	r16, r18
    3782:	9a 01       	movw	r18, r20
    3784:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3786:	47 2f       	mov	r20, r23
    3788:	0e 94 2a 02 	call	0x454	; 0x454 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    378c:	61 15       	cp	r22, r1
    378e:	71 05       	cpc	r23, r1
    3790:	81 05       	cpc	r24, r1
    3792:	91 05       	cpc	r25, r1
    3794:	49 f0       	breq	.+18     	; 0x37a8 <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    3796:	dc 01       	movw	r26, r24
    3798:	cb 01       	movw	r24, r22
    379a:	01 96       	adiw	r24, 0x01	; 1
    379c:	a1 1d       	adc	r26, r1
    379e:	b1 1d       	adc	r27, r1
    37a0:	bc 01       	movw	r22, r24
    37a2:	cd 01       	movw	r24, r26
    37a4:	9f 70       	andi	r25, 0x0F	; 15
    37a6:	03 c0       	rjmp	.+6      	; 0x37ae <pulseIn+0x58>
	else
		return 0;
    37a8:	60 e0       	ldi	r22, 0x00	; 0
    37aa:	70 e0       	ldi	r23, 0x00	; 0
    37ac:	cb 01       	movw	r24, r22
}
    37ae:	1f 91       	pop	r17
    37b0:	0f 91       	pop	r16
    37b2:	08 95       	ret

000037b4 <__mulsi3>:
    37b4:	db 01       	movw	r26, r22
    37b6:	8f 93       	push	r24
    37b8:	9f 93       	push	r25
    37ba:	46 d0       	rcall	.+140    	; 0x3848 <__muluhisi3>
    37bc:	bf 91       	pop	r27
    37be:	af 91       	pop	r26
    37c0:	a2 9f       	mul	r26, r18
    37c2:	80 0d       	add	r24, r0
    37c4:	91 1d       	adc	r25, r1
    37c6:	a3 9f       	mul	r26, r19
    37c8:	90 0d       	add	r25, r0
    37ca:	b2 9f       	mul	r27, r18
    37cc:	90 0d       	add	r25, r0
    37ce:	11 24       	eor	r1, r1
    37d0:	08 95       	ret

000037d2 <__divmodhi4>:
    37d2:	97 fb       	bst	r25, 7
    37d4:	07 2e       	mov	r0, r23
    37d6:	16 f4       	brtc	.+4      	; 0x37dc <__divmodhi4+0xa>
    37d8:	00 94       	com	r0
    37da:	06 d0       	rcall	.+12     	; 0x37e8 <__divmodhi4_neg1>
    37dc:	77 fd       	sbrc	r23, 7
    37de:	08 d0       	rcall	.+16     	; 0x37f0 <__divmodhi4_neg2>
    37e0:	41 d0       	rcall	.+130    	; 0x3864 <__udivmodhi4>
    37e2:	07 fc       	sbrc	r0, 7
    37e4:	05 d0       	rcall	.+10     	; 0x37f0 <__divmodhi4_neg2>
    37e6:	3e f4       	brtc	.+14     	; 0x37f6 <__divmodhi4_exit>

000037e8 <__divmodhi4_neg1>:
    37e8:	90 95       	com	r25
    37ea:	81 95       	neg	r24
    37ec:	9f 4f       	sbci	r25, 0xFF	; 255
    37ee:	08 95       	ret

000037f0 <__divmodhi4_neg2>:
    37f0:	70 95       	com	r23
    37f2:	61 95       	neg	r22
    37f4:	7f 4f       	sbci	r23, 0xFF	; 255

000037f6 <__divmodhi4_exit>:
    37f6:	08 95       	ret

000037f8 <__udivmodsi4>:
    37f8:	a1 e2       	ldi	r26, 0x21	; 33
    37fa:	1a 2e       	mov	r1, r26
    37fc:	aa 1b       	sub	r26, r26
    37fe:	bb 1b       	sub	r27, r27
    3800:	fd 01       	movw	r30, r26
    3802:	0d c0       	rjmp	.+26     	; 0x381e <__udivmodsi4_ep>

00003804 <__udivmodsi4_loop>:
    3804:	aa 1f       	adc	r26, r26
    3806:	bb 1f       	adc	r27, r27
    3808:	ee 1f       	adc	r30, r30
    380a:	ff 1f       	adc	r31, r31
    380c:	a2 17       	cp	r26, r18
    380e:	b3 07       	cpc	r27, r19
    3810:	e4 07       	cpc	r30, r20
    3812:	f5 07       	cpc	r31, r21
    3814:	20 f0       	brcs	.+8      	; 0x381e <__udivmodsi4_ep>
    3816:	a2 1b       	sub	r26, r18
    3818:	b3 0b       	sbc	r27, r19
    381a:	e4 0b       	sbc	r30, r20
    381c:	f5 0b       	sbc	r31, r21

0000381e <__udivmodsi4_ep>:
    381e:	66 1f       	adc	r22, r22
    3820:	77 1f       	adc	r23, r23
    3822:	88 1f       	adc	r24, r24
    3824:	99 1f       	adc	r25, r25
    3826:	1a 94       	dec	r1
    3828:	69 f7       	brne	.-38     	; 0x3804 <__udivmodsi4_loop>
    382a:	60 95       	com	r22
    382c:	70 95       	com	r23
    382e:	80 95       	com	r24
    3830:	90 95       	com	r25
    3832:	9b 01       	movw	r18, r22
    3834:	ac 01       	movw	r20, r24
    3836:	bd 01       	movw	r22, r26
    3838:	cf 01       	movw	r24, r30
    383a:	08 95       	ret

0000383c <__tablejump2__>:
    383c:	ee 0f       	add	r30, r30
    383e:	ff 1f       	adc	r31, r31

00003840 <__tablejump__>:
    3840:	05 90       	lpm	r0, Z+
    3842:	f4 91       	lpm	r31, Z
    3844:	e0 2d       	mov	r30, r0
    3846:	19 94       	eijmp

00003848 <__muluhisi3>:
    3848:	21 d0       	rcall	.+66     	; 0x388c <__umulhisi3>
    384a:	a5 9f       	mul	r26, r21
    384c:	90 0d       	add	r25, r0
    384e:	b4 9f       	mul	r27, r20
    3850:	90 0d       	add	r25, r0
    3852:	a4 9f       	mul	r26, r20
    3854:	80 0d       	add	r24, r0
    3856:	91 1d       	adc	r25, r1
    3858:	11 24       	eor	r1, r1
    385a:	08 95       	ret

0000385c <__tablejump_elpm__>:
    385c:	07 90       	elpm	r0, Z+
    385e:	f6 91       	elpm	r31, Z
    3860:	e0 2d       	mov	r30, r0
    3862:	19 94       	eijmp

00003864 <__udivmodhi4>:
    3864:	aa 1b       	sub	r26, r26
    3866:	bb 1b       	sub	r27, r27
    3868:	51 e1       	ldi	r21, 0x11	; 17
    386a:	07 c0       	rjmp	.+14     	; 0x387a <__udivmodhi4_ep>

0000386c <__udivmodhi4_loop>:
    386c:	aa 1f       	adc	r26, r26
    386e:	bb 1f       	adc	r27, r27
    3870:	a6 17       	cp	r26, r22
    3872:	b7 07       	cpc	r27, r23
    3874:	10 f0       	brcs	.+4      	; 0x387a <__udivmodhi4_ep>
    3876:	a6 1b       	sub	r26, r22
    3878:	b7 0b       	sbc	r27, r23

0000387a <__udivmodhi4_ep>:
    387a:	88 1f       	adc	r24, r24
    387c:	99 1f       	adc	r25, r25
    387e:	5a 95       	dec	r21
    3880:	a9 f7       	brne	.-22     	; 0x386c <__udivmodhi4_loop>
    3882:	80 95       	com	r24
    3884:	90 95       	com	r25
    3886:	bc 01       	movw	r22, r24
    3888:	cd 01       	movw	r24, r26
    388a:	08 95       	ret

0000388c <__umulhisi3>:
    388c:	a2 9f       	mul	r26, r18
    388e:	b0 01       	movw	r22, r0
    3890:	b3 9f       	mul	r27, r19
    3892:	c0 01       	movw	r24, r0
    3894:	a3 9f       	mul	r26, r19
    3896:	70 0d       	add	r23, r0
    3898:	81 1d       	adc	r24, r1
    389a:	11 24       	eor	r1, r1
    389c:	91 1d       	adc	r25, r1
    389e:	b2 9f       	mul	r27, r18
    38a0:	70 0d       	add	r23, r0
    38a2:	81 1d       	adc	r24, r1
    38a4:	11 24       	eor	r1, r1
    38a6:	91 1d       	adc	r25, r1
    38a8:	08 95       	ret

000038aa <_exit>:
    38aa:	f8 94       	cli

000038ac <__stop_program>:
    38ac:	ff cf       	rjmp	.-2      	; 0x38ac <__stop_program>
