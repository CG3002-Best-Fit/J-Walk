
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a6  00800200  00004328  000043bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004328  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000089f  008002a6  008002a6  00004462  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004462  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000007f0  00000000  00000000  00004498  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00012173  00000000  00000000  00004c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000032ee  00000000  00000000  00016dfb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005a72  00000000  00000000  0001a0e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001750  00000000  00000000  0001fb5c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003b5e  00000000  00000000  000212ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00007f1c  00000000  00000000  00024e0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000007a0  00000000  00000000  0002cd26  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	38 c2       	rjmp	.+1136   	; 0x472 <__ctors_end>
       2:	00 00       	nop
       4:	67 c2       	rjmp	.+1230   	; 0x4d4 <__bad_interrupt>
       6:	00 00       	nop
       8:	65 c2       	rjmp	.+1226   	; 0x4d4 <__bad_interrupt>
       a:	00 00       	nop
       c:	63 c2       	rjmp	.+1222   	; 0x4d4 <__bad_interrupt>
       e:	00 00       	nop
      10:	61 c2       	rjmp	.+1218   	; 0x4d4 <__bad_interrupt>
      12:	00 00       	nop
      14:	5f c2       	rjmp	.+1214   	; 0x4d4 <__bad_interrupt>
      16:	00 00       	nop
      18:	5d c2       	rjmp	.+1210   	; 0x4d4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5b c2       	rjmp	.+1206   	; 0x4d4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	59 c2       	rjmp	.+1202   	; 0x4d4 <__bad_interrupt>
      22:	00 00       	nop
      24:	57 c2       	rjmp	.+1198   	; 0x4d4 <__bad_interrupt>
      26:	00 00       	nop
      28:	55 c2       	rjmp	.+1194   	; 0x4d4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	53 c2       	rjmp	.+1190   	; 0x4d4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	51 c2       	rjmp	.+1186   	; 0x4d4 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 be 0d 	jmp	0x1b7c	; 0x1b7c <__vector_13>
      38:	4d c2       	rjmp	.+1178   	; 0x4d4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4b c2       	rjmp	.+1174   	; 0x4d4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	49 c2       	rjmp	.+1170   	; 0x4d4 <__bad_interrupt>
      42:	00 00       	nop
      44:	47 c2       	rjmp	.+1166   	; 0x4d4 <__bad_interrupt>
      46:	00 00       	nop
      48:	45 c2       	rjmp	.+1162   	; 0x4d4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	43 c2       	rjmp	.+1158   	; 0x4d4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	41 c2       	rjmp	.+1154   	; 0x4d4 <__bad_interrupt>
      52:	00 00       	nop
      54:	3f c2       	rjmp	.+1150   	; 0x4d4 <__bad_interrupt>
      56:	00 00       	nop
      58:	3d c2       	rjmp	.+1146   	; 0x4d4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 4e 1f 	jmp	0x3e9c	; 0x3e9c <__vector_23>
      60:	39 c2       	rjmp	.+1138   	; 0x4d4 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 08 1d 	jmp	0x3a10	; 0x3a10 <__vector_25>
      68:	0c 94 47 1d 	jmp	0x3a8e	; 0x3a8e <__vector_26>
      6c:	33 c2       	rjmp	.+1126   	; 0x4d4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	31 c2       	rjmp	.+1122   	; 0x4d4 <__bad_interrupt>
      72:	00 00       	nop
      74:	2f c2       	rjmp	.+1118   	; 0x4d4 <__bad_interrupt>
      76:	00 00       	nop
      78:	2d c2       	rjmp	.+1114   	; 0x4d4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2b c2       	rjmp	.+1110   	; 0x4d4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	29 c2       	rjmp	.+1106   	; 0x4d4 <__bad_interrupt>
      82:	00 00       	nop
      84:	27 c2       	rjmp	.+1102   	; 0x4d4 <__bad_interrupt>
      86:	00 00       	nop
      88:	25 c2       	rjmp	.+1098   	; 0x4d4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	23 c2       	rjmp	.+1094   	; 0x4d4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 b3 1d 	jmp	0x3b66	; 0x3b66 <__vector_36>
      94:	0c 94 f2 1d 	jmp	0x3be4	; 0x3be4 <__vector_37>
      98:	1d c2       	rjmp	.+1082   	; 0x4d4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 d3 15 	jmp	0x2ba6	; 0x2ba6 <__vector_39>
      a0:	19 c2       	rjmp	.+1074   	; 0x4d4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	17 c2       	rjmp	.+1070   	; 0x4d4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	15 c2       	rjmp	.+1066   	; 0x4d4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	13 c2       	rjmp	.+1062   	; 0x4d4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	11 c2       	rjmp	.+1058   	; 0x4d4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0f c2       	rjmp	.+1054   	; 0x4d4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0d c2       	rjmp	.+1050   	; 0x4d4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0b c2       	rjmp	.+1046   	; 0x4d4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	09 c2       	rjmp	.+1042   	; 0x4d4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	07 c2       	rjmp	.+1038   	; 0x4d4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	05 c2       	rjmp	.+1034   	; 0x4d4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	03 c2       	rjmp	.+1030   	; 0x4d4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	01 c2       	rjmp	.+1026   	; 0x4d4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	ff c1       	rjmp	.+1022   	; 0x4d4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fd c1       	rjmp	.+1018   	; 0x4d4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	fb c1       	rjmp	.+1014   	; 0x4d4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f9 c1       	rjmp	.+1010   	; 0x4d4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	d9 16       	cp	r13, r25
      e6:	dc 16       	cp	r13, r28
      e8:	dc 16       	cp	r13, r28
      ea:	dc 16       	cp	r13, r28
      ec:	dc 16       	cp	r13, r28
      ee:	dc 16       	cp	r13, r28
      f0:	dc 16       	cp	r13, r28
      f2:	dc 16       	cp	r13, r28
      f4:	f3 15       	cp	r31, r3
      f6:	dc 16       	cp	r13, r28
      f8:	dc 16       	cp	r13, r28
      fa:	dc 16       	cp	r13, r28
      fc:	dc 16       	cp	r13, r28
      fe:	dc 16       	cp	r13, r28
     100:	dc 16       	cp	r13, r28
     102:	dc 16       	cp	r13, r28
     104:	f3 15       	cp	r31, r3
     106:	dc 16       	cp	r13, r28
     108:	dc 16       	cp	r13, r28
     10a:	dc 16       	cp	r13, r28
     10c:	dc 16       	cp	r13, r28
     10e:	dc 16       	cp	r13, r28
     110:	dc 16       	cp	r13, r28
     112:	dc 16       	cp	r13, r28
     114:	fb 15       	cp	r31, r11
     116:	dc 16       	cp	r13, r28
     118:	dc 16       	cp	r13, r28
     11a:	dc 16       	cp	r13, r28
     11c:	dc 16       	cp	r13, r28
     11e:	dc 16       	cp	r13, r28
     120:	dc 16       	cp	r13, r28
     122:	dc 16       	cp	r13, r28
     124:	20 16       	cp	r2, r16
     126:	dc 16       	cp	r13, r28
     128:	dc 16       	cp	r13, r28
     12a:	dc 16       	cp	r13, r28
     12c:	dc 16       	cp	r13, r28
     12e:	dc 16       	cp	r13, r28
     130:	dc 16       	cp	r13, r28
     132:	dc 16       	cp	r13, r28
     134:	fb 15       	cp	r31, r11
     136:	dc 16       	cp	r13, r28
     138:	dc 16       	cp	r13, r28
     13a:	dc 16       	cp	r13, r28
     13c:	dc 16       	cp	r13, r28
     13e:	dc 16       	cp	r13, r28
     140:	dc 16       	cp	r13, r28
     142:	dc 16       	cp	r13, r28
     144:	25 16       	cp	r2, r21
     146:	dc 16       	cp	r13, r28
     148:	dc 16       	cp	r13, r28
     14a:	dc 16       	cp	r13, r28
     14c:	dc 16       	cp	r13, r28
     14e:	dc 16       	cp	r13, r28
     150:	dc 16       	cp	r13, r28
     152:	dc 16       	cp	r13, r28
     154:	2a 16       	cp	r2, r26
     156:	dc 16       	cp	r13, r28
     158:	dc 16       	cp	r13, r28
     15a:	dc 16       	cp	r13, r28
     15c:	dc 16       	cp	r13, r28
     15e:	dc 16       	cp	r13, r28
     160:	dc 16       	cp	r13, r28
     162:	dc 16       	cp	r13, r28
     164:	3b 16       	cp	r3, r27
     166:	dc 16       	cp	r13, r28
     168:	dc 16       	cp	r13, r28
     16a:	dc 16       	cp	r13, r28
     16c:	dc 16       	cp	r13, r28
     16e:	dc 16       	cp	r13, r28
     170:	dc 16       	cp	r13, r28
     172:	dc 16       	cp	r13, r28
     174:	64 16       	cp	r6, r20
     176:	dc 16       	cp	r13, r28
     178:	dc 16       	cp	r13, r28
     17a:	dc 16       	cp	r13, r28
     17c:	dc 16       	cp	r13, r28
     17e:	dc 16       	cp	r13, r28
     180:	dc 16       	cp	r13, r28
     182:	dc 16       	cp	r13, r28
     184:	2f 16       	cp	r2, r31
     186:	dc 16       	cp	r13, r28
     188:	dc 16       	cp	r13, r28
     18a:	dc 16       	cp	r13, r28
     18c:	dc 16       	cp	r13, r28
     18e:	dc 16       	cp	r13, r28
     190:	dc 16       	cp	r13, r28
     192:	dc 16       	cp	r13, r28
     194:	49 16       	cp	r4, r25
     196:	dc 16       	cp	r13, r28
     198:	dc 16       	cp	r13, r28
     19a:	dc 16       	cp	r13, r28
     19c:	dc 16       	cp	r13, r28
     19e:	dc 16       	cp	r13, r28
     1a0:	dc 16       	cp	r13, r28
     1a2:	dc 16       	cp	r13, r28
     1a4:	66 16       	cp	r6, r22
     1a6:	dc 16       	cp	r13, r28
     1a8:	dc 16       	cp	r13, r28
     1aa:	dc 16       	cp	r13, r28
     1ac:	dc 16       	cp	r13, r28
     1ae:	dc 16       	cp	r13, r28
     1b0:	dc 16       	cp	r13, r28
     1b2:	dc 16       	cp	r13, r28
     1b4:	66 16       	cp	r6, r22
     1b6:	dc 16       	cp	r13, r28
     1b8:	dc 16       	cp	r13, r28
     1ba:	dc 16       	cp	r13, r28
     1bc:	dc 16       	cp	r13, r28
     1be:	dc 16       	cp	r13, r28
     1c0:	dc 16       	cp	r13, r28
     1c2:	dc 16       	cp	r13, r28
     1c4:	66 16       	cp	r6, r22
     1c6:	dc 16       	cp	r13, r28
     1c8:	dc 16       	cp	r13, r28
     1ca:	dc 16       	cp	r13, r28
     1cc:	dc 16       	cp	r13, r28
     1ce:	dc 16       	cp	r13, r28
     1d0:	dc 16       	cp	r13, r28
     1d2:	dc 16       	cp	r13, r28
     1d4:	66 16       	cp	r6, r22
     1d6:	dc 16       	cp	r13, r28
     1d8:	dc 16       	cp	r13, r28
     1da:	dc 16       	cp	r13, r28
     1dc:	dc 16       	cp	r13, r28
     1de:	dc 16       	cp	r13, r28
     1e0:	dc 16       	cp	r13, r28
     1e2:	dc 16       	cp	r13, r28
     1e4:	6f 16       	cp	r6, r31
     1e6:	dc 16       	cp	r13, r28
     1e8:	dc 16       	cp	r13, r28
     1ea:	dc 16       	cp	r13, r28
     1ec:	dc 16       	cp	r13, r28
     1ee:	dc 16       	cp	r13, r28
     1f0:	dc 16       	cp	r13, r28
     1f2:	dc 16       	cp	r13, r28
     1f4:	a0 16       	cp	r10, r16
     1f6:	dc 16       	cp	r13, r28
     1f8:	dc 16       	cp	r13, r28
     1fa:	dc 16       	cp	r13, r28
     1fc:	dc 16       	cp	r13, r28
     1fe:	dc 16       	cp	r13, r28
     200:	dc 16       	cp	r13, r28
     202:	dc 16       	cp	r13, r28
     204:	6f 16       	cp	r6, r31
     206:	dc 16       	cp	r13, r28
     208:	dc 16       	cp	r13, r28
     20a:	dc 16       	cp	r13, r28
     20c:	dc 16       	cp	r13, r28
     20e:	dc 16       	cp	r13, r28
     210:	dc 16       	cp	r13, r28
     212:	dc 16       	cp	r13, r28
     214:	a0 16       	cp	r10, r16
     216:	dc 16       	cp	r13, r28
     218:	dc 16       	cp	r13, r28
     21a:	dc 16       	cp	r13, r28
     21c:	dc 16       	cp	r13, r28
     21e:	dc 16       	cp	r13, r28
     220:	dc 16       	cp	r13, r28
     222:	dc 16       	cp	r13, r28
     224:	87 16       	cp	r8, r23
     226:	dc 16       	cp	r13, r28
     228:	dc 16       	cp	r13, r28
     22a:	dc 16       	cp	r13, r28
     22c:	dc 16       	cp	r13, r28
     22e:	dc 16       	cp	r13, r28
     230:	dc 16       	cp	r13, r28
     232:	dc 16       	cp	r13, r28
     234:	a4 16       	cp	r10, r20
     236:	dc 16       	cp	r13, r28
     238:	dc 16       	cp	r13, r28
     23a:	dc 16       	cp	r13, r28
     23c:	dc 16       	cp	r13, r28
     23e:	dc 16       	cp	r13, r28
     240:	dc 16       	cp	r13, r28
     242:	dc 16       	cp	r13, r28
     244:	a4 16       	cp	r10, r20
     246:	dc 16       	cp	r13, r28
     248:	dc 16       	cp	r13, r28
     24a:	dc 16       	cp	r13, r28
     24c:	dc 16       	cp	r13, r28
     24e:	dc 16       	cp	r13, r28
     250:	dc 16       	cp	r13, r28
     252:	dc 16       	cp	r13, r28
     254:	b9 16       	cp	r11, r25
     256:	dc 16       	cp	r13, r28
     258:	dc 16       	cp	r13, r28
     25a:	dc 16       	cp	r13, r28
     25c:	dc 16       	cp	r13, r28
     25e:	dc 16       	cp	r13, r28
     260:	dc 16       	cp	r13, r28
     262:	dc 16       	cp	r13, r28
     264:	d3 16       	cp	r13, r19
     266:	dc 16       	cp	r13, r28
     268:	dc 16       	cp	r13, r28
     26a:	dc 16       	cp	r13, r28
     26c:	dc 16       	cp	r13, r28
     26e:	dc 16       	cp	r13, r28
     270:	dc 16       	cp	r13, r28
     272:	dc 16       	cp	r13, r28
     274:	d3 16       	cp	r13, r19
     276:	08 4a       	sbci	r16, 0xA8	; 168
     278:	d7 3b       	cpi	r29, 0xB7	; 183
     27a:	3b ce       	rjmp	.-906    	; 0xfffffef2 <__eeprom_end+0xff7efef2>
     27c:	01 6e       	ori	r16, 0xE1	; 225
     27e:	84 bc       	out	0x24, r8	; 36
     280:	bf fd       	.word	0xfdbf	; ????
     282:	c1 2f       	mov	r28, r17
     284:	3d 6c       	ori	r19, 0xCD	; 205
     286:	74 31       	cpi	r23, 0x14	; 20
     288:	9a bd       	out	0x2a, r25	; 42
     28a:	56 83       	std	Z+6, r21	; 0x06
     28c:	3d da       	rcall	.-2950   	; 0xfffff708 <__eeprom_end+0xff7ef708>
     28e:	3d 00       	.word	0x003d	; ????
     290:	c7 7f       	andi	r28, 0xF7	; 247
     292:	11 be       	out	0x31, r1	; 49
     294:	d9 e4       	ldi	r29, 0x49	; 73
     296:	bb 4c       	sbci	r27, 0xCB	; 203
     298:	3e 91       	ld	r19, -X
     29a:	6b aa       	std	Y+51, r6	; 0x33
     29c:	aa be       	out	0x3a, r10	; 58
     29e:	00 00       	nop
     2a0:	00 80       	ld	r0, Z
     2a2:	3f 07       	cpc	r19, r31
     2a4:	63 42       	sbci	r22, 0x23	; 35
     2a6:	36 b7       	in	r19, 0x36	; 54
     2a8:	9b d8       	rcall	.-3786   	; 0xfffff3e0 <__eeprom_end+0xff7ef3e0>
     2aa:	a7 1a       	sub	r10, r23
     2ac:	39 68       	ori	r19, 0x89	; 137
     2ae:	56 18       	sub	r5, r6
     2b0:	ae ba       	out	0x1e, r10	; 30
     2b2:	ab 55       	subi	r26, 0x5B	; 91
     2b4:	8c 1d       	adc	r24, r12
     2b6:	3c b7       	in	r19, 0x3c	; 60
     2b8:	cc 57       	subi	r28, 0x7C	; 124
     2ba:	63 bd       	out	0x23, r22	; 35
     2bc:	6d ed       	ldi	r22, 0xDD	; 221
     2be:	fd 75       	andi	r31, 0x5D	; 93
     2c0:	3e f6       	brtc	.-114    	; 0x250 <__SREG__+0x211>
     2c2:	17 72       	andi	r17, 0x27	; 39
     2c4:	31 bf       	out	0x31, r19	; 49
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 08       	sbc	r3, r15
     2cc:	00 00       	nop
     2ce:	00 be       	out	0x30, r0	; 48
     2d0:	92 24       	eor	r9, r2
     2d2:	49 12       	cpse	r4, r25
     2d4:	3e ab       	std	Y+54, r19	; 0x36
     2d6:	aa aa       	std	Y+50, r10	; 0x32
     2d8:	2a be       	out	0x3a, r2	; 58
     2da:	cd cc       	rjmp	.-1638   	; 0xfffffc76 <__eeprom_end+0xff7efc76>
     2dc:	cc 4c       	sbci	r28, 0xCC	; 204
     2de:	3e 00       	.word	0x003e	; ????
     2e0:	00 00       	nop
     2e2:	80 be       	out	0x30, r8	; 48
     2e4:	ab aa       	std	Y+51, r10	; 0x33
     2e6:	aa aa       	std	Y+50, r10	; 0x32
     2e8:	3e 00       	.word	0x003e	; ????
     2ea:	00 00       	nop
     2ec:	00 bf       	out	0x30, r16	; 48
     2ee:	00 00       	nop
     2f0:	00 80       	ld	r0, Z
     2f2:	3f 00       	.word	0x003f	; ????
     2f4:	00 00       	nop
     2f6:	00 00       	nop
     2f8:	08 41       	sbci	r16, 0x18	; 24
     2fa:	78 d3       	rcall	.+1776   	; 0x9ec <_ZN3LPS24pressureToAltitudeMetersEff+0x10>
     2fc:	bb 43       	sbci	r27, 0x3B	; 59
     2fe:	87 d1       	rcall	.+782    	; 0x60e <_ZN3L3G8writeRegEhh+0x34>
     300:	13 3d       	cpi	r17, 0xD3	; 211
     302:	19 0e       	add	r1, r25
     304:	3c c3       	rjmp	.+1656   	; 0x97e <vListInsert+0x5c>
     306:	bd 42       	sbci	r27, 0x2D	; 45
     308:	82 ad       	ldd	r24, Z+58	; 0x3a
     30a:	2b 3e       	cpi	r18, 0xEB	; 235
     30c:	68 ec       	ldi	r22, 0xC8	; 200
     30e:	82 76       	andi	r24, 0x62	; 98
     310:	be d9       	rcall	.-3204   	; 0xfffff68e <__eeprom_end+0xff7ef68e>
     312:	8f e1       	ldi	r24, 0x1F	; 31
     314:	a9 3e       	cpi	r26, 0xE9	; 233
     316:	4c 80       	ldd	r4, Y+4	; 0x04
     318:	ef ff       	.word	0xffef	; ????
     31a:	be 01       	movw	r22, r28
     31c:	c4 ff       	sbrs	r28, 4
     31e:	7f 3f       	cpi	r23, 0xFF	; 255
     320:	00 00       	nop
     322:	00 00       	nop
     324:	00 00       	nop
     326:	30 20       	and	r3, r0
     328:	34 20       	and	r3, r4
     32a:	1e 20       	and	r1, r14
     32c:	24 20       	and	r2, r4
     32e:	2a 20       	and	r2, r10
     330:	79 20       	and	r7, r9
     332:	38 20       	and	r3, r8
     334:	3e 20       	and	r3, r14
     336:	44 20       	and	r4, r4
     338:	4a 20       	and	r4, r10
     33a:	50 20       	and	r5, r0
     33c:	56 20       	and	r5, r6
     33e:	5c 20       	and	r5, r12
     340:	62 20       	and	r6, r2
     342:	79 20       	and	r7, r9
     344:	68 20       	and	r6, r8
     346:	6e 20       	and	r6, r14
     348:	74 20       	and	r7, r4

0000034a <__trampolines_end>:
     34a:	00 00       	nop
     34c:	0a 0b       	sbc	r16, r26
     34e:	02 09       	sbc	r16, r2
     350:	0c 0d       	add	r16, r12
     352:	0e 08       	sbc	r0, r14
     354:	07 03       	mulsu	r16, r23
     356:	04 01       	movw	r0, r8
	...
     374:	00 00       	nop
     376:	12 11       	cpse	r17, r2
     378:	10 00       	.word	0x0010	; ????
	...

00000390 <digital_pin_to_bit_mask_PGM>:
     390:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     3a0:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     3b0:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     3c0:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     3d0:	04 08 10 20 40 80                                   ... @.

000003d6 <digital_pin_to_port_PGM>:
     3d6:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     3e6:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     3f6:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     406:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     416:	0b 0b 0b 0b 0b 0b                                   ......

0000041c <port_to_input_PGM>:
     41c:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     42c:	00 01 00 00 03 01 06 01 09 01                       ..........

00000436 <port_to_output_PGM>:
     436:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     446:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000450 <port_to_mode_PGM>:
     450:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     460:	01 01 00 00 04 01 07 01 0a 01                       ..........

0000046a <__ctors_start>:
     46a:	b5 10       	cpse	r11, r5
     46c:	c1 17       	cp	r28, r17
     46e:	70 1d       	adc	r23, r0
     470:	1b 1e       	adc	r1, r27

00000472 <__ctors_end>:
     472:	11 24       	eor	r1, r1
     474:	1f be       	out	0x3f, r1	; 63
     476:	cf ef       	ldi	r28, 0xFF	; 255
     478:	d1 e2       	ldi	r29, 0x21	; 33
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	cd bf       	out	0x3d, r28	; 61
     47e:	00 e0       	ldi	r16, 0x00	; 0
     480:	0c bf       	out	0x3c, r16	; 60

00000482 <__do_copy_data>:
     482:	12 e0       	ldi	r17, 0x02	; 2
     484:	a0 e0       	ldi	r26, 0x00	; 0
     486:	b2 e0       	ldi	r27, 0x02	; 2
     488:	e8 e2       	ldi	r30, 0x28	; 40
     48a:	f3 e4       	ldi	r31, 0x43	; 67
     48c:	00 e0       	ldi	r16, 0x00	; 0
     48e:	0b bf       	out	0x3b, r16	; 59
     490:	02 c0       	rjmp	.+4      	; 0x496 <__do_copy_data+0x14>
     492:	07 90       	elpm	r0, Z+
     494:	0d 92       	st	X+, r0
     496:	a6 3a       	cpi	r26, 0xA6	; 166
     498:	b1 07       	cpc	r27, r17
     49a:	d9 f7       	brne	.-10     	; 0x492 <__do_copy_data+0x10>

0000049c <__do_clear_bss>:
     49c:	2b e0       	ldi	r18, 0x0B	; 11
     49e:	a6 ea       	ldi	r26, 0xA6	; 166
     4a0:	b2 e0       	ldi	r27, 0x02	; 2
     4a2:	01 c0       	rjmp	.+2      	; 0x4a6 <.do_clear_bss_start>

000004a4 <.do_clear_bss_loop>:
     4a4:	1d 92       	st	X+, r1

000004a6 <.do_clear_bss_start>:
     4a6:	a5 34       	cpi	r26, 0x45	; 69
     4a8:	b2 07       	cpc	r27, r18
     4aa:	e1 f7       	brne	.-8      	; 0x4a4 <.do_clear_bss_loop>

000004ac <__do_global_ctors>:
     4ac:	14 e0       	ldi	r17, 0x04	; 4
     4ae:	c2 e7       	ldi	r28, 0x72	; 114
     4b0:	d4 e0       	ldi	r29, 0x04	; 4
     4b2:	00 e0       	ldi	r16, 0x00	; 0
     4b4:	06 c0       	rjmp	.+12     	; 0x4c2 <__do_global_ctors+0x16>
     4b6:	22 97       	sbiw	r28, 0x02	; 2
     4b8:	01 09       	sbc	r16, r1
     4ba:	fe 01       	movw	r30, r28
     4bc:	0b bf       	out	0x3b, r16	; 59
     4be:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <__tablejump_elpm__>
     4c2:	ca 36       	cpi	r28, 0x6A	; 106
     4c4:	d1 07       	cpc	r29, r17
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	08 07       	cpc	r16, r24
     4ca:	a9 f7       	brne	.-22     	; 0x4b6 <__do_global_ctors+0xa>
     4cc:	0e 94 3c 10 	call	0x2078	; 0x2078 <main>
     4d0:	0c 94 92 21 	jmp	0x4324	; 0x4324 <_exit>

000004d4 <__bad_interrupt>:
     4d4:	95 cd       	rjmp	.-1238   	; 0x0 <__vectors>

000004d6 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     4d6:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     4d8:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     4da:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     4dc:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     4de:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     4e0:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     4e2:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     4e4:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     4e6:	05 c0       	rjmp	.+10     	; 0x4f2 <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     4e8:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4ea:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4ec:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     4ee:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     4f0:	61 f1       	breq	.+88     	; 0x54a <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     4f2:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     4f4:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     4f6:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     4f8:	b9 f3       	breq	.-18     	; 0x4e8 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     4fa:	05 c0       	rjmp	.+10     	; 0x506 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     4fc:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4fe:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     500:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     502:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     504:	11 f1       	breq	.+68     	; 0x54a <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     506:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     508:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     50a:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     50c:	f7 cf       	rjmp	.-18     	; 0x4fc <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     50e:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     510:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     512:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     514:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     516:	0a c0       	rjmp	.+20     	; 0x52c <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     518:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     51a:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     51c:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     51e:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     520:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     522:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     524:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     526:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     528:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     52a:	79 f0       	breq	.+30     	; 0x54a <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     52c:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     52e:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     530:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     532:	91 f3       	breq	.-28     	; 0x518 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     534:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     536:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     538:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     53a:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     53c:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     53e:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     540:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     542:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     544:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     546:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     548:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     54a:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     54c:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     54e:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     550:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     552:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     554:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     556:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     558:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     55a:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     55c:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     55e:	08 95       	ret

00000560 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     560:	cf 93       	push	r28
     562:	df 93       	push	r29
     564:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     566:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     56a:	80 91 a6 02 	lds	r24, 0x02A6
     56e:	90 91 a7 02 	lds	r25, 0x02A7
     572:	89 2b       	or	r24, r25
     574:	31 f4       	brne	.+12     	; 0x582 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     576:	8b ea       	ldi	r24, 0xAB	; 171
     578:	92 e0       	ldi	r25, 0x02	; 2
     57a:	90 93 a7 02 	sts	0x02A7, r25
     57e:	80 93 a6 02 	sts	0x02A6, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     582:	40 91 a8 02 	lds	r20, 0x02A8
     586:	50 91 a9 02 	lds	r21, 0x02A9
     58a:	9e 01       	movw	r18, r28
     58c:	24 0f       	add	r18, r20
     58e:	35 1f       	adc	r19, r21
     590:	2b 3d       	cpi	r18, 0xDB	; 219
     592:	85 e0       	ldi	r24, 0x05	; 5
     594:	38 07       	cpc	r19, r24
     596:	70 f4       	brcc	.+28     	; 0x5b4 <pvPortMalloc+0x54>
     598:	42 17       	cp	r20, r18
     59a:	53 07       	cpc	r21, r19
     59c:	70 f4       	brcc	.+28     	; 0x5ba <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     59e:	c0 91 a6 02 	lds	r28, 0x02A6
     5a2:	d0 91 a7 02 	lds	r29, 0x02A7
     5a6:	c4 0f       	add	r28, r20
     5a8:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     5aa:	30 93 a9 02 	sts	0x02A9, r19
     5ae:	20 93 a8 02 	sts	0x02A8, r18
     5b2:	05 c0       	rjmp	.+10     	; 0x5be <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5b4:	c0 e0       	ldi	r28, 0x00	; 0
     5b6:	d0 e0       	ldi	r29, 0x00	; 0
     5b8:	02 c0       	rjmp	.+4      	; 0x5be <pvPortMalloc+0x5e>
     5ba:	c0 e0       	ldi	r28, 0x00	; 0
     5bc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5be:	0e 94 a6 13 	call	0x274c	; 0x274c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5c2:	ce 01       	movw	r24, r28
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	08 95       	ret

000005ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5ca:	08 95       	ret

000005cc <_ZN3L3GC1Ev>:
  Wire.requestFrom(address, (byte)1);
  value = Wire.read();
  Wire.endTransmission();

  return value;
}
     5cc:	fc 01       	movw	r30, r24
     5ce:	83 e0       	ldi	r24, 0x03	; 3
     5d0:	87 83       	std	Z+7, r24	; 0x07
     5d2:	12 86       	std	Z+10, r1	; 0x0a
     5d4:	11 86       	std	Z+9, r1	; 0x09
     5d6:	13 86       	std	Z+11, r1	; 0x0b
     5d8:	08 95       	ret

000005da <_ZN3L3G8writeRegEhh>:
     5da:	0f 93       	push	r16
     5dc:	1f 93       	push	r17
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	ec 01       	movw	r28, r24
     5e4:	06 2f       	mov	r16, r22
     5e6:	14 2f       	mov	r17, r20
     5e8:	68 85       	ldd	r22, Y+8	; 0x08
     5ea:	80 eb       	ldi	r24, 0xB0	; 176
     5ec:	99 e0       	ldi	r25, 0x09	; 9
     5ee:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
     5f2:	60 2f       	mov	r22, r16
     5f4:	80 eb       	ldi	r24, 0xB0	; 176
     5f6:	99 e0       	ldi	r25, 0x09	; 9
     5f8:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
     5fc:	61 2f       	mov	r22, r17
     5fe:	80 eb       	ldi	r24, 0xB0	; 176
     600:	99 e0       	ldi	r25, 0x09	; 9
     602:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
     606:	80 eb       	ldi	r24, 0xB0	; 176
     608:	99 e0       	ldi	r25, 0x09	; 9
     60a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
     60e:	8e 83       	std	Y+6, r24	; 0x06
     610:	df 91       	pop	r29
     612:	cf 91       	pop	r28
     614:	1f 91       	pop	r17
     616:	0f 91       	pop	r16
     618:	08 95       	ret

0000061a <_ZN3L3G13enableDefaultEv>:
     61a:	cf 93       	push	r28
     61c:	df 93       	push	r29
     61e:	ec 01       	movw	r28, r24
     620:	8f 81       	ldd	r24, Y+7	; 0x07
     622:	82 30       	cpi	r24, 0x02	; 2
     624:	21 f4       	brne	.+8      	; 0x62e <_ZN3L3G13enableDefaultEv+0x14>
     626:	40 e0       	ldi	r20, 0x00	; 0
     628:	69 e3       	ldi	r22, 0x39	; 57
     62a:	ce 01       	movw	r24, r28
     62c:	d6 df       	rcall	.-84     	; 0x5da <_ZN3L3G8writeRegEhh>
     62e:	40 e0       	ldi	r20, 0x00	; 0
     630:	63 e2       	ldi	r22, 0x23	; 35
     632:	ce 01       	movw	r24, r28
     634:	d2 df       	rcall	.-92     	; 0x5da <_ZN3L3G8writeRegEhh>
     636:	4f e6       	ldi	r20, 0x6F	; 111
     638:	60 e2       	ldi	r22, 0x20	; 32
     63a:	ce 01       	movw	r24, r28
     63c:	ce df       	rcall	.-100    	; 0x5da <_ZN3L3G8writeRegEhh>
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	08 95       	ret

00000644 <_ZN3L3G4readEv>:

// Reads the 3 gyro channels and stores them in vector g
void L3G::read()
{
     644:	9f 92       	push	r9
     646:	af 92       	push	r10
     648:	bf 92       	push	r11
     64a:	cf 92       	push	r12
     64c:	df 92       	push	r13
     64e:	ef 92       	push	r14
     650:	ff 92       	push	r15
     652:	0f 93       	push	r16
     654:	1f 93       	push	r17
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
     65a:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     65c:	68 85       	ldd	r22, Y+8	; 0x08
     65e:	80 eb       	ldi	r24, 0xB0	; 176
     660:	99 e0       	ldi	r25, 0x09	; 9
     662:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     666:	e0 91 b0 09 	lds	r30, 0x09B0
     66a:	f0 91 b1 09 	lds	r31, 0x09B1
     66e:	01 90       	ld	r0, Z+
     670:	f0 81       	ld	r31, Z
     672:	e0 2d       	mov	r30, r0
     674:	68 ea       	ldi	r22, 0xA8	; 168
     676:	80 eb       	ldi	r24, 0xB0	; 176
     678:	99 e0       	ldi	r25, 0x09	; 9
     67a:	19 95       	eicall
  // assert the MSB of the address to get the gyro
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
     67c:	80 eb       	ldi	r24, 0xB0	; 176
     67e:	99 e0       	ldi	r25, 0x09	; 9
     680:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)6);
     684:	46 e0       	ldi	r20, 0x06	; 6
     686:	68 85       	ldd	r22, Y+8	; 0x08
     688:	80 eb       	ldi	r24, 0xB0	; 176
     68a:	99 e0       	ldi	r25, 0x09	; 9
     68c:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>
  
  unsigned int millis_start = millis();
     690:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <millis>
     694:	8b 01       	movw	r16, r22
  while (Wire.available() < 6)
     696:	10 c0       	rjmp	.+32     	; 0x6b8 <_ZN3L3G4readEv+0x74>
  {
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     698:	89 85       	ldd	r24, Y+9	; 0x09
     69a:	9a 85       	ldd	r25, Y+10	; 0x0a
     69c:	89 2b       	or	r24, r25
     69e:	61 f0       	breq	.+24     	; 0x6b8 <_ZN3L3G4readEv+0x74>
     6a0:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <millis>
     6a4:	60 1b       	sub	r22, r16
     6a6:	71 0b       	sbc	r23, r17
     6a8:	89 85       	ldd	r24, Y+9	; 0x09
     6aa:	9a 85       	ldd	r25, Y+10	; 0x0a
     6ac:	86 17       	cp	r24, r22
     6ae:	97 07       	cpc	r25, r23
     6b0:	18 f4       	brcc	.+6      	; 0x6b8 <_ZN3L3G4readEv+0x74>
    {
      did_timeout = true;
     6b2:	81 e0       	ldi	r24, 0x01	; 1
     6b4:	8b 87       	std	Y+11, r24	; 0x0b
      return;
     6b6:	32 c0       	rjmp	.+100    	; 0x71c <_ZN3L3G4readEv+0xd8>
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
  Wire.requestFrom(address, (byte)6);
  
  unsigned int millis_start = millis();
  while (Wire.available() < 6)
     6b8:	80 eb       	ldi	r24, 0xB0	; 176
     6ba:	99 e0       	ldi	r25, 0x09	; 9
     6bc:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
     6c0:	06 97       	sbiw	r24, 0x06	; 6
     6c2:	54 f3       	brlt	.-44     	; 0x698 <_ZN3L3G4readEv+0x54>
      did_timeout = true;
      return;
    }
  }

  uint8_t xlg = Wire.read();
     6c4:	80 eb       	ldi	r24, 0xB0	; 176
     6c6:	99 e0       	ldi	r25, 0x09	; 9
     6c8:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     6cc:	a8 2e       	mov	r10, r24
  uint8_t xhg = Wire.read();
     6ce:	80 eb       	ldi	r24, 0xB0	; 176
     6d0:	99 e0       	ldi	r25, 0x09	; 9
     6d2:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     6d6:	98 2e       	mov	r9, r24
  uint8_t ylg = Wire.read();
     6d8:	80 eb       	ldi	r24, 0xB0	; 176
     6da:	99 e0       	ldi	r25, 0x09	; 9
     6dc:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     6e0:	08 2f       	mov	r16, r24
  uint8_t yhg = Wire.read();
     6e2:	80 eb       	ldi	r24, 0xB0	; 176
     6e4:	99 e0       	ldi	r25, 0x09	; 9
     6e6:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     6ea:	b8 2e       	mov	r11, r24
  uint8_t zlg = Wire.read();
     6ec:	80 eb       	ldi	r24, 0xB0	; 176
     6ee:	99 e0       	ldi	r25, 0x09	; 9
     6f0:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     6f4:	18 2f       	mov	r17, r24
  uint8_t zhg = Wire.read();
     6f6:	80 eb       	ldi	r24, 0xB0	; 176
     6f8:	99 e0       	ldi	r25, 0x09	; 9
     6fa:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
     6fe:	d9 2c       	mov	r13, r9
     700:	c1 2c       	mov	r12, r1
     702:	ca 28       	or	r12, r10
     704:	d9 82       	std	Y+1, r13	; 0x01
     706:	c8 82       	st	Y, r12
  g.y = (int16_t)(yhg << 8 | ylg);
     708:	fb 2c       	mov	r15, r11
     70a:	e1 2c       	mov	r14, r1
     70c:	e0 2a       	or	r14, r16
     70e:	fb 82       	std	Y+3, r15	; 0x03
     710:	ea 82       	std	Y+2, r14	; 0x02
  g.z = (int16_t)(zhg << 8 | zlg);
     712:	98 2f       	mov	r25, r24
     714:	88 27       	eor	r24, r24
     716:	81 2b       	or	r24, r17
     718:	9d 83       	std	Y+5, r25	; 0x05
     71a:	8c 83       	std	Y+4, r24	; 0x04
}
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	1f 91       	pop	r17
     722:	0f 91       	pop	r16
     724:	ff 90       	pop	r15
     726:	ef 90       	pop	r14
     728:	df 90       	pop	r13
     72a:	cf 90       	pop	r12
     72c:	bf 90       	pop	r11
     72e:	af 90       	pop	r10
     730:	9f 90       	pop	r9
     732:	08 95       	ret

00000734 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	c6 2f       	mov	r28, r22
     73a:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     73c:	80 eb       	ldi	r24, 0xB0	; 176
     73e:	99 e0       	ldi	r25, 0x09	; 9
     740:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     744:	6d 2f       	mov	r22, r29
     746:	80 eb       	ldi	r24, 0xB0	; 176
     748:	99 e0       	ldi	r25, 0x09	; 9
     74a:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     74e:	80 eb       	ldi	r24, 0xB0	; 176
     750:	99 e0       	ldi	r25, 0x09	; 9
     752:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
     756:	81 11       	cpse	r24, r1
     758:	11 c0       	rjmp	.+34     	; 0x77c <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     75a:	41 e0       	ldi	r20, 0x01	; 1
     75c:	6c 2f       	mov	r22, r28
     75e:	80 eb       	ldi	r24, 0xB0	; 176
     760:	99 e0       	ldi	r25, 0x09	; 9
     762:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     766:	80 eb       	ldi	r24, 0xB0	; 176
     768:	99 e0       	ldi	r25, 0x09	; 9
     76a:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
     76e:	89 2b       	or	r24, r25
     770:	41 f0       	breq	.+16     	; 0x782 <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     772:	80 eb       	ldi	r24, 0xB0	; 176
     774:	99 e0       	ldi	r25, 0x09	; 9
     776:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     77a:	05 c0       	rjmp	.+10     	; 0x786 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     77c:	8f ef       	ldi	r24, 0xFF	; 255
     77e:	9f ef       	ldi	r25, 0xFF	; 255
     780:	02 c0       	rjmp	.+4      	; 0x786 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     782:	8f ef       	ldi	r24, 0xFF	; 255
     784:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     786:	df 91       	pop	r29
     788:	cf 91       	pop	r28
     78a:	08 95       	ret

0000078c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     78c:	0f 93       	push	r16
     78e:	1f 93       	push	r17
     790:	cf 93       	push	r28
     792:	df 93       	push	r29
     794:	ec 01       	movw	r28, r24
     796:	16 2f       	mov	r17, r22
     798:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     79a:	63 30       	cpi	r22, 0x03	; 3
     79c:	09 f4       	brne	.+2      	; 0x7a0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     79e:	56 c0       	rjmp	.+172    	; 0x84c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     7a0:	42 30       	cpi	r20, 0x02	; 2
     7a2:	c9 f5       	brne	.+114    	; 0x816 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     7a4:	56 c0       	rjmp	.+172    	; 0x852 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     7a6:	13 30       	cpi	r17, 0x03	; 3
     7a8:	09 f0       	breq	.+2      	; 0x7ac <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     7aa:	58 c0       	rjmp	.+176    	; 0x85c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7ac:	87 3d       	cpi	r24, 0xD7	; 215
     7ae:	91 05       	cpc	r25, r1
     7b0:	09 f4       	brne	.+2      	; 0x7b4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     7b2:	58 c0       	rjmp	.+176    	; 0x864 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7b4:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7b6:	11 e0       	ldi	r17, 0x01	; 1
     7b8:	2c c0       	rjmp	.+88     	; 0x812 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7ba:	01 30       	cpi	r16, 0x01	; 1
     7bc:	91 f0       	breq	.+36     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     7be:	4f e0       	ldi	r20, 0x0F	; 15
     7c0:	6a e6       	ldi	r22, 0x6A	; 106
     7c2:	ce 01       	movw	r24, r28
     7c4:	b7 df       	rcall	.-146    	; 0x734 <_ZN3L3G7testRegEhNS_7regAddrE>
     7c6:	8f 3f       	cpi	r24, 0xFF	; 255
     7c8:	2f ef       	ldi	r18, 0xFF	; 255
     7ca:	92 07       	cpc	r25, r18
     7cc:	51 f0       	breq	.+20     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     7ce:	13 30       	cpi	r17, 0x03	; 3
     7d0:	09 f0       	breq	.+2      	; 0x7d4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     7d2:	46 c0       	rjmp	.+140    	; 0x860 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7d4:	87 3d       	cpi	r24, 0xD7	; 215
     7d6:	91 05       	cpc	r25, r1
     7d8:	09 f0       	breq	.+2      	; 0x7dc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     7da:	47 c0       	rjmp	.+142    	; 0x86a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7dc:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7de:	12 e0       	ldi	r17, 0x02	; 2
     7e0:	18 c0       	rjmp	.+48     	; 0x812 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     7e2:	13 30       	cpi	r17, 0x03	; 3
     7e4:	11 f0       	breq	.+4      	; 0x7ea <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     7e6:	11 11       	cpse	r17, r1
     7e8:	14 c0       	rjmp	.+40     	; 0x812 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7ea:	00 23       	and	r16, r16
     7ec:	49 f0       	breq	.+18     	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     7ee:	4f e0       	ldi	r20, 0x0F	; 15
     7f0:	69 e6       	ldi	r22, 0x69	; 105
     7f2:	ce 01       	movw	r24, r28
     7f4:	9f df       	rcall	.-194    	; 0x734 <_ZN3L3G7testRegEhNS_7regAddrE>
     7f6:	83 3d       	cpi	r24, 0xD3	; 211
     7f8:	91 05       	cpc	r25, r1
     7fa:	d1 f1       	breq	.+116    	; 0x870 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7fc:	01 30       	cpi	r16, 0x01	; 1
     7fe:	39 f0       	breq	.+14     	; 0x80e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     800:	4f e0       	ldi	r20, 0x0F	; 15
     802:	68 e6       	ldi	r22, 0x68	; 104
     804:	ce 01       	movw	r24, r28
     806:	96 df       	rcall	.-212    	; 0x734 <_ZN3L3G7testRegEhNS_7regAddrE>
     808:	83 3d       	cpi	r24, 0xD3	; 211
     80a:	91 05       	cpc	r25, r1
     80c:	99 f1       	breq	.+102    	; 0x874 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     80e:	13 30       	cpi	r17, 0x03	; 3
     810:	b9 f0       	breq	.+46     	; 0x840 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     812:	02 30       	cpi	r16, 0x02	; 2
     814:	b9 f0       	breq	.+46     	; 0x844 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     816:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     818:	11 23       	and	r17, r17
     81a:	51 f0       	breq	.+20     	; 0x830 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     81c:	13 30       	cpi	r17, 0x03	; 3
     81e:	a0 f4       	brcc	.+40     	; 0x848 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     820:	01 30       	cpi	r16, 0x01	; 1
     822:	11 f4       	brne	.+4      	; 0x828 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     824:	8b e6       	ldi	r24, 0x6B	; 107
     826:	01 c0       	rjmp	.+2      	; 0x82a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     828:	8a e6       	ldi	r24, 0x6A	; 106
     82a:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     82c:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     82e:	41 c0       	rjmp	.+130    	; 0x8b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     830:	01 30       	cpi	r16, 0x01	; 1
     832:	11 f4       	brne	.+4      	; 0x838 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     834:	89 e6       	ldi	r24, 0x69	; 105
     836:	01 c0       	rjmp	.+2      	; 0x83a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     838:	88 e6       	ldi	r24, 0x68	; 104
     83a:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     83c:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     83e:	39 c0       	rjmp	.+114    	; 0x8b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     840:	80 e0       	ldi	r24, 0x00	; 0
     842:	37 c0       	rjmp	.+110    	; 0x8b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	35 c0       	rjmp	.+106    	; 0x8b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	33 c0       	rjmp	.+102    	; 0x8b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     84c:	44 23       	and	r20, r20
     84e:	41 f1       	breq	.+80     	; 0x8a0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     850:	1e c0       	rjmp	.+60     	; 0x88e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     852:	8f ef       	ldi	r24, 0xFF	; 255
     854:	86 0f       	add	r24, r22
     856:	83 30       	cpi	r24, 0x03	; 3
     858:	30 f6       	brcc	.-116    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     85a:	0f c0       	rjmp	.+30     	; 0x87a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     85c:	01 e0       	ldi	r16, 0x01	; 1
     85e:	c3 cf       	rjmp	.-122    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     860:	00 e0       	ldi	r16, 0x00	; 0
     862:	c1 cf       	rjmp	.-126    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     864:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     866:	12 e0       	ldi	r17, 0x02	; 2
     868:	d4 cf       	rjmp	.-88     	; 0x812 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     86a:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     86c:	11 e0       	ldi	r17, 0x01	; 1
     86e:	d1 cf       	rjmp	.-94     	; 0x812 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     870:	01 e0       	ldi	r16, 0x01	; 1
     872:	01 c0       	rjmp	.+2      	; 0x876 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     874:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     876:	1f 82       	std	Y+7, r1	; 0x07
     878:	db cf       	rjmp	.-74     	; 0x830 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     87a:	4f e0       	ldi	r20, 0x0F	; 15
     87c:	6b e6       	ldi	r22, 0x6B	; 107
     87e:	ce 01       	movw	r24, r28
     880:	59 df       	rcall	.-334    	; 0x734 <_ZN3L3G7testRegEhNS_7regAddrE>
     882:	8f 3f       	cpi	r24, 0xFF	; 255
     884:	2f ef       	ldi	r18, 0xFF	; 255
     886:	92 07       	cpc	r25, r18
     888:	09 f0       	breq	.+2      	; 0x88c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     88a:	8d cf       	rjmp	.-230    	; 0x7a6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     88c:	98 cf       	rjmp	.-208    	; 0x7be <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     88e:	4f e0       	ldi	r20, 0x0F	; 15
     890:	6b e6       	ldi	r22, 0x6B	; 107
     892:	50 df       	rcall	.-352    	; 0x734 <_ZN3L3G7testRegEhNS_7regAddrE>
     894:	8f 3f       	cpi	r24, 0xFF	; 255
     896:	2f ef       	ldi	r18, 0xFF	; 255
     898:	92 07       	cpc	r25, r18
     89a:	09 f0       	breq	.+2      	; 0x89e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     89c:	87 cf       	rjmp	.-242    	; 0x7ac <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     89e:	8d cf       	rjmp	.-230    	; 0x7ba <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     8a0:	4f e0       	ldi	r20, 0x0F	; 15
     8a2:	6a e6       	ldi	r22, 0x6A	; 106
     8a4:	47 df       	rcall	.-370    	; 0x734 <_ZN3L3G7testRegEhNS_7regAddrE>
     8a6:	8f 3f       	cpi	r24, 0xFF	; 255
     8a8:	2f ef       	ldi	r18, 0xFF	; 255
     8aa:	92 07       	cpc	r25, r18
     8ac:	09 f0       	breq	.+2      	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     8ae:	92 cf       	rjmp	.-220    	; 0x7d4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     8b0:	98 cf       	rjmp	.-208    	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	1f 91       	pop	r17
     8b8:	0f 91       	pop	r16
     8ba:	08 95       	ret

000008bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8bc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8be:	03 96       	adiw	r24, 0x03	; 3
     8c0:	92 83       	std	Z+2, r25	; 0x02
     8c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8c4:	2f ef       	ldi	r18, 0xFF	; 255
     8c6:	3f ef       	ldi	r19, 0xFF	; 255
     8c8:	34 83       	std	Z+4, r19	; 0x04
     8ca:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8cc:	96 83       	std	Z+6, r25	; 0x06
     8ce:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8d0:	90 87       	std	Z+8, r25	; 0x08
     8d2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8d4:	10 82       	st	Z, r1
     8d6:	08 95       	ret

000008d8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8d8:	fc 01       	movw	r30, r24
     8da:	11 86       	std	Z+9, r1	; 0x09
     8dc:	10 86       	std	Z+8, r1	; 0x08
     8de:	08 95       	ret

000008e0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8e0:	cf 93       	push	r28
     8e2:	df 93       	push	r29
     8e4:	9c 01       	movw	r18, r24
     8e6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8e8:	dc 01       	movw	r26, r24
     8ea:	11 96       	adiw	r26, 0x01	; 1
     8ec:	cd 91       	ld	r28, X+
     8ee:	dc 91       	ld	r29, X
     8f0:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8f2:	d3 83       	std	Z+3, r29	; 0x03
     8f4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8f6:	8c 81       	ldd	r24, Y+4	; 0x04
     8f8:	9d 81       	ldd	r25, Y+5	; 0x05
     8fa:	95 83       	std	Z+5, r25	; 0x05
     8fc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8fe:	8c 81       	ldd	r24, Y+4	; 0x04
     900:	9d 81       	ldd	r25, Y+5	; 0x05
     902:	dc 01       	movw	r26, r24
     904:	13 96       	adiw	r26, 0x03	; 3
     906:	7c 93       	st	X, r23
     908:	6e 93       	st	-X, r22
     90a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     90c:	7d 83       	std	Y+5, r23	; 0x05
     90e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     910:	31 87       	std	Z+9, r19	; 0x09
     912:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     914:	f9 01       	movw	r30, r18
     916:	80 81       	ld	r24, Z
     918:	8f 5f       	subi	r24, 0xFF	; 255
     91a:	80 83       	st	Z, r24
}
     91c:	df 91       	pop	r29
     91e:	cf 91       	pop	r28
     920:	08 95       	ret

00000922 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     922:	cf 93       	push	r28
     924:	df 93       	push	r29
     926:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     928:	48 81       	ld	r20, Y
     92a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     92c:	4f 3f       	cpi	r20, 0xFF	; 255
     92e:	2f ef       	ldi	r18, 0xFF	; 255
     930:	52 07       	cpc	r21, r18
     932:	21 f4       	brne	.+8      	; 0x93c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     934:	fc 01       	movw	r30, r24
     936:	a7 81       	ldd	r26, Z+7	; 0x07
     938:	b0 85       	ldd	r27, Z+8	; 0x08
     93a:	0d c0       	rjmp	.+26     	; 0x956 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     93c:	dc 01       	movw	r26, r24
     93e:	13 96       	adiw	r26, 0x03	; 3
     940:	12 96       	adiw	r26, 0x02	; 2
     942:	ed 91       	ld	r30, X+
     944:	fc 91       	ld	r31, X
     946:	13 97       	sbiw	r26, 0x03	; 3
     948:	20 81       	ld	r18, Z
     94a:	31 81       	ldd	r19, Z+1	; 0x01
     94c:	42 17       	cp	r20, r18
     94e:	53 07       	cpc	r21, r19
     950:	10 f0       	brcs	.+4      	; 0x956 <vListInsert+0x34>
     952:	df 01       	movw	r26, r30
     954:	f5 cf       	rjmp	.-22     	; 0x940 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     956:	12 96       	adiw	r26, 0x02	; 2
     958:	ed 91       	ld	r30, X+
     95a:	fc 91       	ld	r31, X
     95c:	13 97       	sbiw	r26, 0x03	; 3
     95e:	fb 83       	std	Y+3, r31	; 0x03
     960:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     962:	d5 83       	std	Z+5, r29	; 0x05
     964:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     966:	bd 83       	std	Y+5, r27	; 0x05
     968:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     96a:	13 96       	adiw	r26, 0x03	; 3
     96c:	dc 93       	st	X, r29
     96e:	ce 93       	st	-X, r28
     970:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     972:	99 87       	std	Y+9, r25	; 0x09
     974:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     976:	fc 01       	movw	r30, r24
     978:	20 81       	ld	r18, Z
     97a:	2f 5f       	subi	r18, 0xFF	; 255
     97c:	20 83       	st	Z, r18
}
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	08 95       	ret

00000984 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     984:	cf 93       	push	r28
     986:	df 93       	push	r29
     988:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     98a:	a0 85       	ldd	r26, Z+8	; 0x08
     98c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     98e:	c2 81       	ldd	r28, Z+2	; 0x02
     990:	d3 81       	ldd	r29, Z+3	; 0x03
     992:	84 81       	ldd	r24, Z+4	; 0x04
     994:	95 81       	ldd	r25, Z+5	; 0x05
     996:	9d 83       	std	Y+5, r25	; 0x05
     998:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     99a:	c4 81       	ldd	r28, Z+4	; 0x04
     99c:	d5 81       	ldd	r29, Z+5	; 0x05
     99e:	82 81       	ldd	r24, Z+2	; 0x02
     9a0:	93 81       	ldd	r25, Z+3	; 0x03
     9a2:	9b 83       	std	Y+3, r25	; 0x03
     9a4:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9a6:	11 96       	adiw	r26, 0x01	; 1
     9a8:	cd 91       	ld	r28, X+
     9aa:	dc 91       	ld	r29, X
     9ac:	12 97       	sbiw	r26, 0x02	; 2
     9ae:	ce 17       	cp	r28, r30
     9b0:	df 07       	cpc	r29, r31
     9b2:	31 f4       	brne	.+12     	; 0x9c0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9b4:	8c 81       	ldd	r24, Y+4	; 0x04
     9b6:	9d 81       	ldd	r25, Y+5	; 0x05
     9b8:	12 96       	adiw	r26, 0x02	; 2
     9ba:	9c 93       	st	X, r25
     9bc:	8e 93       	st	-X, r24
     9be:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9c0:	11 86       	std	Z+9, r1	; 0x09
     9c2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9c4:	8c 91       	ld	r24, X
     9c6:	81 50       	subi	r24, 0x01	; 1
     9c8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     9ca:	df 91       	pop	r29
     9cc:	cf 91       	pop	r28
     9ce:	08 95       	ret

000009d0 <_ZN3LPSC1Ev>:

// reads temperature in degrees F
float LPS::readTemperatureF(void)
{
  return 108.5 + (float)readTemperatureRaw() / 480 * 1.8;
}
     9d0:	22 e0       	ldi	r18, 0x02	; 2
     9d2:	fc 01       	movw	r30, r24
     9d4:	20 83       	st	Z, r18
     9d6:	2d e5       	ldi	r18, 0x5D	; 93
     9d8:	21 83       	std	Z+1, r18	; 0x01
     9da:	08 95       	ret

000009dc <_ZN3LPS24pressureToAltitudeMetersEff>:
     9dc:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
     9e0:	2e e4       	ldi	r18, 0x4E	; 78
     9e2:	34 ed       	ldi	r19, 0xD4	; 212
     9e4:	42 e4       	ldi	r20, 0x42	; 66
     9e6:	5e e3       	ldi	r21, 0x3E	; 62
     9e8:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <pow>
     9ec:	9b 01       	movw	r18, r22
     9ee:	ac 01       	movw	r20, r24
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	70 e0       	ldi	r23, 0x00	; 0
     9f4:	80 e8       	ldi	r24, 0x80	; 128
     9f6:	9f e3       	ldi	r25, 0x3F	; 63
     9f8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__subsf3>
     9fc:	2d ec       	ldi	r18, 0xCD	; 205
     9fe:	3a e2       	ldi	r19, 0x2A	; 42
     a00:	4d e2       	ldi	r20, 0x2D	; 45
     a02:	57 e4       	ldi	r21, 0x47	; 71
     a04:	0c 94 07 1a 	jmp	0x340e	; 0x340e <__mulsf3>
     a08:	08 95       	ret

00000a0a <_ZN3LPS8writeRegEih>:
     a0a:	1f 93       	push	r17
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	eb 01       	movw	r28, r22
     a12:	14 2f       	mov	r17, r20
     a14:	dd 23       	and	r29, r29
     a16:	3c f4       	brge	.+14     	; 0xa26 <_ZN3LPS8writeRegEih+0x1c>
     a18:	fc 01       	movw	r30, r24
     a1a:	e6 1b       	sub	r30, r22
     a1c:	f7 0b       	sbc	r31, r23
     a1e:	c2 81       	ldd	r28, Z+2	; 0x02
     a20:	dd 27       	eor	r29, r29
     a22:	c7 fd       	sbrc	r28, 7
     a24:	d0 95       	com	r29
     a26:	fc 01       	movw	r30, r24
     a28:	61 81       	ldd	r22, Z+1	; 0x01
     a2a:	80 eb       	ldi	r24, 0xB0	; 176
     a2c:	99 e0       	ldi	r25, 0x09	; 9
     a2e:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
     a32:	e0 91 b0 09 	lds	r30, 0x09B0
     a36:	f0 91 b1 09 	lds	r31, 0x09B1
     a3a:	01 90       	ld	r0, Z+
     a3c:	f0 81       	ld	r31, Z
     a3e:	e0 2d       	mov	r30, r0
     a40:	6c 2f       	mov	r22, r28
     a42:	80 eb       	ldi	r24, 0xB0	; 176
     a44:	99 e0       	ldi	r25, 0x09	; 9
     a46:	19 95       	eicall
     a48:	61 2f       	mov	r22, r17
     a4a:	80 eb       	ldi	r24, 0xB0	; 176
     a4c:	99 e0       	ldi	r25, 0x09	; 9
     a4e:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
     a52:	80 eb       	ldi	r24, 0xB0	; 176
     a54:	99 e0       	ldi	r25, 0x09	; 9
     a56:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	1f 91       	pop	r17
     a60:	08 95       	ret

00000a62 <_ZN3LPS13enableDefaultEv>:
     a62:	fc 01       	movw	r30, r24
     a64:	20 81       	ld	r18, Z
     a66:	21 30       	cpi	r18, 0x01	; 1
     a68:	29 f4       	brne	.+10     	; 0xa74 <_ZN3LPS13enableDefaultEv+0x12>
     a6a:	40 eb       	ldi	r20, 0xB0	; 176
     a6c:	60 e2       	ldi	r22, 0x20	; 32
     a6e:	70 e0       	ldi	r23, 0x00	; 0
     a70:	cc cf       	rjmp	.-104    	; 0xa0a <_ZN3LPS8writeRegEih>
     a72:	08 95       	ret
     a74:	21 11       	cpse	r18, r1
     a76:	04 c0       	rjmp	.+8      	; 0xa80 <_ZN3LPS13enableDefaultEv+0x1e>
     a78:	40 ee       	ldi	r20, 0xE0	; 224
     a7a:	60 e2       	ldi	r22, 0x20	; 32
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	c5 cf       	rjmp	.-118    	; 0xa0a <_ZN3LPS8writeRegEih>
     a80:	08 95       	ret

00000a82 <_ZN3LPS15readPressureRawEv>:
     a82:	0f 93       	push	r16
     a84:	1f 93       	push	r17
     a86:	cf 93       	push	r28
     a88:	df 93       	push	r29
     a8a:	8c 01       	movw	r16, r24
     a8c:	fc 01       	movw	r30, r24
     a8e:	61 81       	ldd	r22, Z+1	; 0x01
     a90:	80 eb       	ldi	r24, 0xB0	; 176
     a92:	99 e0       	ldi	r25, 0x09	; 9
     a94:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
     a98:	e0 91 b0 09 	lds	r30, 0x09B0
     a9c:	f0 91 b1 09 	lds	r31, 0x09B1
     aa0:	01 90       	ld	r0, Z+
     aa2:	f0 81       	ld	r31, Z
     aa4:	e0 2d       	mov	r30, r0
     aa6:	68 ea       	ldi	r22, 0xA8	; 168
     aa8:	80 eb       	ldi	r24, 0xB0	; 176
     aaa:	99 e0       	ldi	r25, 0x09	; 9
     aac:	19 95       	eicall
     aae:	80 eb       	ldi	r24, 0xB0	; 176
     ab0:	99 e0       	ldi	r25, 0x09	; 9
     ab2:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
     ab6:	43 e0       	ldi	r20, 0x03	; 3
     ab8:	f8 01       	movw	r30, r16
     aba:	61 81       	ldd	r22, Z+1	; 0x01
     abc:	80 eb       	ldi	r24, 0xB0	; 176
     abe:	99 e0       	ldi	r25, 0x09	; 9
     ac0:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>
     ac4:	80 eb       	ldi	r24, 0xB0	; 176
     ac6:	99 e0       	ldi	r25, 0x09	; 9
     ac8:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
     acc:	03 97       	sbiw	r24, 0x03	; 3
     ace:	d4 f3       	brlt	.-12     	; 0xac4 <_ZN3LPS15readPressureRawEv+0x42>
     ad0:	80 eb       	ldi	r24, 0xB0	; 176
     ad2:	99 e0       	ldi	r25, 0x09	; 9
     ad4:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     ad8:	08 2f       	mov	r16, r24
     ada:	80 eb       	ldi	r24, 0xB0	; 176
     adc:	99 e0       	ldi	r25, 0x09	; 9
     ade:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     ae2:	18 2f       	mov	r17, r24
     ae4:	80 eb       	ldi	r24, 0xB0	; 176
     ae6:	99 e0       	ldi	r25, 0x09	; 9
     ae8:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     aec:	48 2f       	mov	r20, r24
     aee:	55 27       	eor	r21, r21
     af0:	47 fd       	sbrc	r20, 7
     af2:	50 95       	com	r21
     af4:	65 2f       	mov	r22, r21
     af6:	75 2f       	mov	r23, r21
     af8:	ba 01       	movw	r22, r20
     afa:	55 27       	eor	r21, r21
     afc:	44 27       	eor	r20, r20
     afe:	40 2b       	or	r20, r16
     b00:	d1 2f       	mov	r29, r17
     b02:	f0 e0       	ldi	r31, 0x00	; 0
     b04:	cf 2f       	mov	r28, r31
     b06:	ce 01       	movw	r24, r28
     b08:	a0 e0       	ldi	r26, 0x00	; 0
     b0a:	b0 e0       	ldi	r27, 0x00	; 0
     b0c:	8a 01       	movw	r16, r20
     b0e:	9b 01       	movw	r18, r22
     b10:	08 2b       	or	r16, r24
     b12:	19 2b       	or	r17, r25
     b14:	2a 2b       	or	r18, r26
     b16:	3b 2b       	or	r19, r27
     b18:	c9 01       	movw	r24, r18
     b1a:	b8 01       	movw	r22, r16
     b1c:	df 91       	pop	r29
     b1e:	cf 91       	pop	r28
     b20:	1f 91       	pop	r17
     b22:	0f 91       	pop	r16
     b24:	08 95       	ret

00000b26 <_ZN3LPS21readPressureMillibarsEv>:
     b26:	ad df       	rcall	.-166    	; 0xa82 <_ZN3LPS15readPressureRawEv>
     b28:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
     b2c:	20 e0       	ldi	r18, 0x00	; 0
     b2e:	30 e0       	ldi	r19, 0x00	; 0
     b30:	40 e8       	ldi	r20, 0x80	; 128
     b32:	59 e3       	ldi	r21, 0x39	; 57
     b34:	0c 94 07 1a 	jmp	0x340e	; 0x340e <__mulsf3>
     b38:	08 95       	ret

00000b3a <_ZN3LPS10testWhoAmIEh>:

  return false;
}

int LPS::testWhoAmI(byte address)
{
     b3a:	cf 93       	push	r28
     b3c:	c6 2f       	mov	r28, r22
  Wire.beginTransmission(address);
     b3e:	80 eb       	ldi	r24, 0xB0	; 176
     b40:	99 e0       	ldi	r25, 0x09	; 9
     b42:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
     b46:	e0 91 b0 09 	lds	r30, 0x09B0
     b4a:	f0 91 b1 09 	lds	r31, 0x09B1
     b4e:	01 90       	ld	r0, Z+
     b50:	f0 81       	ld	r31, Z
     b52:	e0 2d       	mov	r30, r0
     b54:	6f e0       	ldi	r22, 0x0F	; 15
     b56:	80 eb       	ldi	r24, 0xB0	; 176
     b58:	99 e0       	ldi	r25, 0x09	; 9
     b5a:	19 95       	eicall
  Wire.write(WHO_AM_I);
  Wire.endTransmission();
     b5c:	80 eb       	ldi	r24, 0xB0	; 176
     b5e:	99 e0       	ldi	r25, 0x09	; 9
     b60:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>

  Wire.requestFrom(address, (byte)1);
     b64:	41 e0       	ldi	r20, 0x01	; 1
     b66:	6c 2f       	mov	r22, r28
     b68:	80 eb       	ldi	r24, 0xB0	; 176
     b6a:	99 e0       	ldi	r25, 0x09	; 9
     b6c:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     b70:	80 eb       	ldi	r24, 0xB0	; 176
     b72:	99 e0       	ldi	r25, 0x09	; 9
     b74:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
     b78:	89 2b       	or	r24, r25
     b7a:	29 f0       	breq	.+10     	; 0xb86 <_ZN3LPS10testWhoAmIEh+0x4c>
    return Wire.read();
     b7c:	80 eb       	ldi	r24, 0xB0	; 176
     b7e:	99 e0       	ldi	r25, 0x09	; 9
     b80:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
     b84:	02 c0       	rjmp	.+4      	; 0xb8a <_ZN3LPS10testWhoAmIEh+0x50>
  else
    return TEST_REG_NACK;
     b86:	8f ef       	ldi	r24, 0xFF	; 255
     b88:	9f ef       	ldi	r25, 0xFF	; 255
     b8a:	cf 91       	pop	r28
     b8c:	08 95       	ret

00000b8e <_ZN3LPS12detectDeviceENS_10deviceTypeE>:

  return false;
}

bool LPS::detectDevice(deviceType device)
{
     b8e:	1f 93       	push	r17
     b90:	cf 93       	push	r28
     b92:	df 93       	push	r29
     b94:	ec 01       	movw	r28, r24
     b96:	16 2f       	mov	r17, r22
  int id = testWhoAmI(address);
     b98:	69 81       	ldd	r22, Y+1	; 0x01
     b9a:	cf df       	rcall	.-98     	; 0xb3a <_ZN3LPS10testWhoAmIEh>
  
  if ((device == device_auto || device == device_25H) && id == LPS25H_WHO_ID)
     b9c:	2f ef       	ldi	r18, 0xFF	; 255
     b9e:	21 0f       	add	r18, r17
     ba0:	22 30       	cpi	r18, 0x02	; 2
     ba2:	30 f4       	brcc	.+12     	; 0xbb0 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x22>
     ba4:	8d 3b       	cpi	r24, 0xBD	; 189
     ba6:	91 05       	cpc	r25, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x22>
  {
    _device = device_25H;
     baa:	81 e0       	ldi	r24, 0x01	; 1
     bac:	88 83       	st	Y, r24
    return true;
     bae:	0b c0       	rjmp	.+22     	; 0xbc6 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x38>
  }
  if ((device == device_auto || device == device_331AP) && id == LPS331AP_WHO_ID)
     bb0:	1d 7f       	andi	r17, 0xFD	; 253
     bb2:	31 f4       	brne	.+12     	; 0xbc0 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x32>
     bb4:	8b 3b       	cpi	r24, 0xBB	; 187
     bb6:	91 05       	cpc	r25, r1
     bb8:	29 f4       	brne	.+10     	; 0xbc4 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x36>
  {
    _device = device_331AP;
     bba:	18 82       	st	Y, r1
    return true;
     bbc:	81 e0       	ldi	r24, 0x01	; 1
     bbe:	03 c0       	rjmp	.+6      	; 0xbc6 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x38>
  }

  return false;
     bc0:	80 e0       	ldi	r24, 0x00	; 0
     bc2:	01 c0       	rjmp	.+2      	; 0xbc6 <_ZN3LPS12detectDeviceENS_10deviceTypeE+0x38>
     bc4:	80 e0       	ldi	r24, 0x00	; 0
}
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	1f 91       	pop	r17
     bcc:	08 95       	ret

00000bce <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE>:
}

// Private Methods ///////////////////////////////////////////////////

bool LPS::detectDeviceAndAddress(deviceType device, sa0State sa0)
{
     bce:	0f 93       	push	r16
     bd0:	1f 93       	push	r17
     bd2:	cf 93       	push	r28
     bd4:	df 93       	push	r29
     bd6:	ec 01       	movw	r28, r24
     bd8:	06 2f       	mov	r16, r22
     bda:	14 2f       	mov	r17, r20
  if (sa0 == sa0_auto || sa0 == sa0_high)
     bdc:	8f ef       	ldi	r24, 0xFF	; 255
     bde:	84 0f       	add	r24, r20
     be0:	82 30       	cpi	r24, 0x02	; 2
     be2:	30 f4       	brcc	.+12     	; 0xbf0 <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE+0x22>
  {
    address = SA0_HIGH_ADDRESS;
     be4:	8d e5       	ldi	r24, 0x5D	; 93
     be6:	89 83       	std	Y+1, r24	; 0x01
    if (detectDevice(device)) return true;
     be8:	ce 01       	movw	r24, r28
     bea:	d1 df       	rcall	.-94     	; 0xb8e <_ZN3LPS12detectDeviceENS_10deviceTypeE>
     bec:	81 11       	cpse	r24, r1
     bee:	08 c0       	rjmp	.+16     	; 0xc00 <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE+0x32>
  }
  if (sa0 == sa0_auto || sa0 == sa0_low)
     bf0:	1d 7f       	andi	r17, 0xFD	; 253
     bf2:	41 f4       	brne	.+16     	; 0xc04 <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE+0x36>
  {
    address = SA0_LOW_ADDRESS;
     bf4:	8c e5       	ldi	r24, 0x5C	; 92
     bf6:	89 83       	std	Y+1, r24	; 0x01
    if (detectDevice(device)) return true;
     bf8:	60 2f       	mov	r22, r16
     bfa:	ce 01       	movw	r24, r28
     bfc:	c8 df       	rcall	.-112    	; 0xb8e <_ZN3LPS12detectDeviceENS_10deviceTypeE>
     bfe:	03 c0       	rjmp	.+6      	; 0xc06 <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE+0x38>
bool LPS::detectDeviceAndAddress(deviceType device, sa0State sa0)
{
  if (sa0 == sa0_auto || sa0 == sa0_high)
  {
    address = SA0_HIGH_ADDRESS;
    if (detectDevice(device)) return true;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	01 c0       	rjmp	.+2      	; 0xc06 <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE+0x38>
  {
    address = SA0_LOW_ADDRESS;
    if (detectDevice(device)) return true;
  }

  return false;
     c04:	80 e0       	ldi	r24, 0x00	; 0
}
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	08 95       	ret

00000c10 <_ZN3LPS4initENS_10deviceTypeEh>:

// Public Methods ////////////////////////////////////////////////////

// sets or detects device type and slave address; returns bool indicating success
bool LPS::init(deviceType device, byte sa0)
{
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	ec 01       	movw	r28, r24
  if (!detectDeviceAndAddress(device, (sa0State)sa0))
     c16:	db df       	rcall	.-74     	; 0xbce <_ZN3LPS22detectDeviceAndAddressENS_10deviceTypeENS_8sa0StateE>
     c18:	88 23       	and	r24, r24
     c1a:	b9 f0       	breq	.+46     	; 0xc4a <_ZN3LPS4initENS_10deviceTypeEh+0x3a>
    return false;
    
  switch (_device)
     c1c:	98 81       	ld	r25, Y
     c1e:	99 23       	and	r25, r25
     c20:	59 f0       	breq	.+22     	; 0xc38 <_ZN3LPS4initENS_10deviceTypeEh+0x28>
     c22:	91 30       	cpi	r25, 0x01	; 1
     c24:	91 f4       	brne	.+36     	; 0xc4a <_ZN3LPS4initENS_10deviceTypeEh+0x3a>
  {
    case device_25H:
      translated_regs[-INTERRUPT_CFG] = LPS25H_INTERRUPT_CFG;
     c26:	94 e2       	ldi	r25, 0x24	; 36
     c28:	9b 83       	std	Y+3, r25	; 0x03
      translated_regs[-INT_SOURCE]    = LPS25H_INT_SOURCE;
     c2a:	95 e2       	ldi	r25, 0x25	; 37
     c2c:	9c 83       	std	Y+4, r25	; 0x04
      translated_regs[-THS_P_L]       = LPS25H_THS_P_L;
     c2e:	90 e3       	ldi	r25, 0x30	; 48
     c30:	9d 83       	std	Y+5, r25	; 0x05
      translated_regs[-THS_P_H]       = LPS25H_THS_P_H;
     c32:	91 e3       	ldi	r25, 0x31	; 49
     c34:	9e 83       	std	Y+6, r25	; 0x06
      return true;
     c36:	09 c0       	rjmp	.+18     	; 0xc4a <_ZN3LPS4initENS_10deviceTypeEh+0x3a>
      break;
      
    case device_331AP:
      translated_regs[-INTERRUPT_CFG] = LPS331AP_INTERRUPT_CFG;
     c38:	93 e2       	ldi	r25, 0x23	; 35
     c3a:	9b 83       	std	Y+3, r25	; 0x03
      translated_regs[-INT_SOURCE]    = LPS331AP_INT_SOURCE;
     c3c:	94 e2       	ldi	r25, 0x24	; 36
     c3e:	9c 83       	std	Y+4, r25	; 0x04
      translated_regs[-THS_P_L]       = LPS331AP_THS_P_L;
     c40:	95 e2       	ldi	r25, 0x25	; 37
     c42:	9d 83       	std	Y+5, r25	; 0x05
      translated_regs[-THS_P_H]       = LPS331AP_THS_P_H;
     c44:	96 e2       	ldi	r25, 0x26	; 38
     c46:	9e 83       	std	Y+6, r25	; 0x06
      return true;
     c48:	00 c0       	rjmp	.+0      	; 0xc4a <_ZN3LPS4initENS_10deviceTypeEh+0x3a>
      break;
  }
}
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	ec 01       	movw	r28, r24
     c56:	86 e0       	ldi	r24, 0x06	; 6
     c58:	e3 e1       	ldi	r30, 0x13	; 19
     c5a:	f2 e0       	ldi	r31, 0x02	; 2
     c5c:	de 01       	movw	r26, r28
     c5e:	52 96       	adiw	r26, 0x12	; 18
     c60:	01 90       	ld	r0, Z+
     c62:	0d 92       	st	X+, r0
     c64:	8a 95       	dec	r24
     c66:	e1 f7       	brne	.-8      	; 0xc60 <_ZN6LSM303C1Ev+0x10>
     c68:	86 e0       	ldi	r24, 0x06	; 6
     c6a:	e9 e1       	ldi	r30, 0x19	; 25
     c6c:	f2 e0       	ldi	r31, 0x02	; 2
     c6e:	de 01       	movw	r26, r28
     c70:	1c 96       	adiw	r26, 0x0c	; 12
     c72:	01 90       	ld	r0, Z+
     c74:	0d 92       	st	X+, r0
     c76:	8a 95       	dec	r24
     c78:	e1 f7       	brne	.-8      	; 0xc72 <_ZN6LSM303C1Ev+0x22>
     c7a:	84 e0       	ldi	r24, 0x04	; 4
     c7c:	89 8f       	std	Y+25, r24	; 0x19
     c7e:	1c a2       	std	Y+36, r1	; 0x24
     c80:	1b a2       	std	Y+35, r1	; 0x23
     c82:	1d a2       	std	Y+37, r1	; 0x25
     c84:	df 91       	pop	r29
     c86:	cf 91       	pop	r28
     c88:	08 95       	ret

00000c8a <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>:
     c8a:	4f 92       	push	r4
     c8c:	5f 92       	push	r5
     c8e:	6f 92       	push	r6
     c90:	7f 92       	push	r7
     c92:	8f 92       	push	r8
     c94:	9f 92       	push	r9
     c96:	af 92       	push	r10
     c98:	bf 92       	push	r11
     c9a:	cf 92       	push	r12
     c9c:	df 92       	push	r13
     c9e:	ef 92       	push	r14
     ca0:	ff 92       	push	r15
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	cf 93       	push	r28
     ca8:	df 93       	push	r29
     caa:	00 d0       	rcall	.+0      	; 0xcac <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE+0x22>
     cac:	1f 92       	push	r1
     cae:	cd b7       	in	r28, 0x3d	; 61
     cb0:	de b7       	in	r29, 0x3e	; 62
     cb2:	8c 01       	movw	r16, r24
     cb4:	dc 01       	movw	r26, r24
     cb6:	4d 90       	ld	r4, X+
     cb8:	5d 90       	ld	r5, X+
     cba:	6d 90       	ld	r6, X+
     cbc:	7c 90       	ld	r7, X
     cbe:	13 97       	sbiw	r26, 0x03	; 3
     cc0:	14 96       	adiw	r26, 0x04	; 4
     cc2:	8d 90       	ld	r8, X+
     cc4:	9d 90       	ld	r9, X+
     cc6:	ad 90       	ld	r10, X+
     cc8:	bc 90       	ld	r11, X
     cca:	17 97       	sbiw	r26, 0x07	; 7
     ccc:	18 96       	adiw	r26, 0x08	; 8
     cce:	8d 91       	ld	r24, X+
     cd0:	9d 91       	ld	r25, X+
     cd2:	0d 90       	ld	r0, X+
     cd4:	bc 91       	ld	r27, X
     cd6:	a0 2d       	mov	r26, r0
     cd8:	89 83       	std	Y+1, r24	; 0x01
     cda:	9a 83       	std	Y+2, r25	; 0x02
     cdc:	ab 83       	std	Y+3, r26	; 0x03
     cde:	bc 83       	std	Y+4, r27	; 0x04
     ce0:	a3 01       	movw	r20, r6
     ce2:	92 01       	movw	r18, r4
     ce4:	c3 01       	movw	r24, r6
     ce6:	b2 01       	movw	r22, r4
     ce8:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
     cec:	6b 01       	movw	r12, r22
     cee:	7c 01       	movw	r14, r24
     cf0:	a5 01       	movw	r20, r10
     cf2:	94 01       	movw	r18, r8
     cf4:	c5 01       	movw	r24, r10
     cf6:	b4 01       	movw	r22, r8
     cf8:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
     cfc:	9b 01       	movw	r18, r22
     cfe:	ac 01       	movw	r20, r24
     d00:	c7 01       	movw	r24, r14
     d02:	b6 01       	movw	r22, r12
     d04:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
     d08:	6b 01       	movw	r12, r22
     d0a:	7c 01       	movw	r14, r24
     d0c:	29 81       	ldd	r18, Y+1	; 0x01
     d0e:	3a 81       	ldd	r19, Y+2	; 0x02
     d10:	4b 81       	ldd	r20, Y+3	; 0x03
     d12:	5c 81       	ldd	r21, Y+4	; 0x04
     d14:	ca 01       	movw	r24, r20
     d16:	b9 01       	movw	r22, r18
     d18:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
     d1c:	9b 01       	movw	r18, r22
     d1e:	ac 01       	movw	r20, r24
     d20:	c7 01       	movw	r24, r14
     d22:	b6 01       	movw	r22, r12
     d24:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
     d28:	0e 94 ba 1a 	call	0x3574	; 0x3574 <sqrt>
     d2c:	6b 01       	movw	r12, r22
     d2e:	7c 01       	movw	r14, r24
     d30:	9b 01       	movw	r18, r22
     d32:	ac 01       	movw	r20, r24
     d34:	c3 01       	movw	r24, r6
     d36:	b2 01       	movw	r22, r4
     d38:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
     d3c:	f8 01       	movw	r30, r16
     d3e:	60 83       	st	Z, r22
     d40:	71 83       	std	Z+1, r23	; 0x01
     d42:	82 83       	std	Z+2, r24	; 0x02
     d44:	93 83       	std	Z+3, r25	; 0x03
     d46:	a7 01       	movw	r20, r14
     d48:	96 01       	movw	r18, r12
     d4a:	c5 01       	movw	r24, r10
     d4c:	b4 01       	movw	r22, r8
     d4e:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
     d52:	d8 01       	movw	r26, r16
     d54:	14 96       	adiw	r26, 0x04	; 4
     d56:	6d 93       	st	X+, r22
     d58:	7d 93       	st	X+, r23
     d5a:	8d 93       	st	X+, r24
     d5c:	9c 93       	st	X, r25
     d5e:	17 97       	sbiw	r26, 0x07	; 7
     d60:	a7 01       	movw	r20, r14
     d62:	96 01       	movw	r18, r12
     d64:	69 81       	ldd	r22, Y+1	; 0x01
     d66:	7a 81       	ldd	r23, Y+2	; 0x02
     d68:	8b 81       	ldd	r24, Y+3	; 0x03
     d6a:	9c 81       	ldd	r25, Y+4	; 0x04
     d6c:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
     d70:	f8 01       	movw	r30, r16
     d72:	60 87       	std	Z+8, r22	; 0x08
     d74:	71 87       	std	Z+9, r23	; 0x09
     d76:	82 87       	std	Z+10, r24	; 0x0a
     d78:	93 87       	std	Z+11, r25	; 0x0b
     d7a:	0f 90       	pop	r0
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	1f 91       	pop	r17
     d88:	0f 91       	pop	r16
     d8a:	ff 90       	pop	r15
     d8c:	ef 90       	pop	r14
     d8e:	df 90       	pop	r13
     d90:	cf 90       	pop	r12
     d92:	bf 90       	pop	r11
     d94:	af 90       	pop	r10
     d96:	9f 90       	pop	r9
     d98:	8f 90       	pop	r8
     d9a:	7f 90       	pop	r7
     d9c:	6f 90       	pop	r6
     d9e:	5f 90       	pop	r5
     da0:	4f 90       	pop	r4
     da2:	08 95       	ret

00000da4 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>:
     da4:	4f 92       	push	r4
     da6:	5f 92       	push	r5
     da8:	6f 92       	push	r6
     daa:	7f 92       	push	r7
     dac:	8f 92       	push	r8
     dae:	9f 92       	push	r9
     db0:	af 92       	push	r10
     db2:	bf 92       	push	r11
     db4:	cf 92       	push	r12
     db6:	df 92       	push	r13
     db8:	ef 92       	push	r14
     dba:	ff 92       	push	r15
     dbc:	0f 93       	push	r16
     dbe:	1f 93       	push	r17
     dc0:	cf 93       	push	r28
     dc2:	df 93       	push	r29
     dc4:	cd b7       	in	r28, 0x3d	; 61
     dc6:	de b7       	in	r29, 0x3e	; 62
     dc8:	aa 97       	sbiw	r28, 0x2a	; 42
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	de bf       	out	0x3e, r29	; 62
     dd0:	0f be       	out	0x3f, r0	; 63
     dd2:	cd bf       	out	0x3d, r28	; 61
     dd4:	8c 01       	movw	r16, r24
     dd6:	29 8f       	std	Y+25, r18	; 0x19
     dd8:	3a 8f       	std	Y+26, r19	; 0x1a
     dda:	4b 8f       	std	Y+27, r20	; 0x1b
     ddc:	5c 8f       	std	Y+28, r21	; 0x1c
     dde:	6d 8f       	std	Y+29, r22	; 0x1d
     de0:	7e 8f       	std	Y+30, r23	; 0x1e
     de2:	dc 01       	movw	r26, r24
     de4:	16 96       	adiw	r26, 0x06	; 6
     de6:	cd 90       	ld	r12, X+
     de8:	dc 90       	ld	r13, X
     dea:	17 97       	sbiw	r26, 0x07	; 7
     dec:	ee 24       	eor	r14, r14
     dee:	d7 fc       	sbrc	r13, 7
     df0:	e0 94       	com	r14
     df2:	fe 2c       	mov	r15, r14
     df4:	52 96       	adiw	r26, 0x12	; 18
     df6:	4d 91       	ld	r20, X+
     df8:	5c 91       	ld	r21, X
     dfa:	53 97       	sbiw	r26, 0x13	; 19
     dfc:	66 27       	eor	r22, r22
     dfe:	57 fd       	sbrc	r21, 7
     e00:	60 95       	com	r22
     e02:	76 2f       	mov	r23, r22
     e04:	1c 96       	adiw	r26, 0x0c	; 12
     e06:	8d 91       	ld	r24, X+
     e08:	9c 91       	ld	r25, X
     e0a:	1d 97       	sbiw	r26, 0x0d	; 13
     e0c:	aa 27       	eor	r26, r26
     e0e:	97 fd       	sbrc	r25, 7
     e10:	a0 95       	com	r26
     e12:	ba 2f       	mov	r27, r26
     e14:	48 0f       	add	r20, r24
     e16:	59 1f       	adc	r21, r25
     e18:	6a 1f       	adc	r22, r26
     e1a:	7b 1f       	adc	r23, r27
     e1c:	db 01       	movw	r26, r22
     e1e:	ca 01       	movw	r24, r20
     e20:	77 23       	and	r23, r23
     e22:	1c f4       	brge	.+6      	; 0xe2a <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x86>
     e24:	01 96       	adiw	r24, 0x01	; 1
     e26:	a1 1d       	adc	r26, r1
     e28:	b1 1d       	adc	r27, r1
     e2a:	b5 95       	asr	r27
     e2c:	a7 95       	ror	r26
     e2e:	97 95       	ror	r25
     e30:	87 95       	ror	r24
     e32:	a7 01       	movw	r20, r14
     e34:	96 01       	movw	r18, r12
     e36:	28 1b       	sub	r18, r24
     e38:	39 0b       	sbc	r19, r25
     e3a:	4a 0b       	sbc	r20, r26
     e3c:	5b 0b       	sbc	r21, r27
     e3e:	2f 8f       	std	Y+31, r18	; 0x1f
     e40:	38 a3       	std	Y+32, r19	; 0x20
     e42:	49 a3       	std	Y+33, r20	; 0x21
     e44:	5a a3       	std	Y+34, r21	; 0x22
     e46:	d8 01       	movw	r26, r16
     e48:	18 96       	adiw	r26, 0x08	; 8
     e4a:	cd 90       	ld	r12, X+
     e4c:	dc 90       	ld	r13, X
     e4e:	19 97       	sbiw	r26, 0x09	; 9
     e50:	ee 24       	eor	r14, r14
     e52:	d7 fc       	sbrc	r13, 7
     e54:	e0 94       	com	r14
     e56:	fe 2c       	mov	r15, r14
     e58:	54 96       	adiw	r26, 0x14	; 20
     e5a:	4d 91       	ld	r20, X+
     e5c:	5c 91       	ld	r21, X
     e5e:	55 97       	sbiw	r26, 0x15	; 21
     e60:	66 27       	eor	r22, r22
     e62:	57 fd       	sbrc	r21, 7
     e64:	60 95       	com	r22
     e66:	76 2f       	mov	r23, r22
     e68:	1e 96       	adiw	r26, 0x0e	; 14
     e6a:	8d 91       	ld	r24, X+
     e6c:	9c 91       	ld	r25, X
     e6e:	1f 97       	sbiw	r26, 0x0f	; 15
     e70:	aa 27       	eor	r26, r26
     e72:	97 fd       	sbrc	r25, 7
     e74:	a0 95       	com	r26
     e76:	ba 2f       	mov	r27, r26
     e78:	48 0f       	add	r20, r24
     e7a:	59 1f       	adc	r21, r25
     e7c:	6a 1f       	adc	r22, r26
     e7e:	7b 1f       	adc	r23, r27
     e80:	db 01       	movw	r26, r22
     e82:	ca 01       	movw	r24, r20
     e84:	77 23       	and	r23, r23
     e86:	1c f4       	brge	.+6      	; 0xe8e <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0xea>
     e88:	01 96       	adiw	r24, 0x01	; 1
     e8a:	a1 1d       	adc	r26, r1
     e8c:	b1 1d       	adc	r27, r1
     e8e:	b5 95       	asr	r27
     e90:	a7 95       	ror	r26
     e92:	97 95       	ror	r25
     e94:	87 95       	ror	r24
     e96:	a7 01       	movw	r20, r14
     e98:	96 01       	movw	r18, r12
     e9a:	28 1b       	sub	r18, r24
     e9c:	39 0b       	sbc	r19, r25
     e9e:	4a 0b       	sbc	r20, r26
     ea0:	5b 0b       	sbc	r21, r27
     ea2:	2b a3       	std	Y+35, r18	; 0x23
     ea4:	3c a3       	std	Y+36, r19	; 0x24
     ea6:	4d a3       	std	Y+37, r20	; 0x25
     ea8:	5e a3       	std	Y+38, r21	; 0x26
     eaa:	d8 01       	movw	r26, r16
     eac:	1a 96       	adiw	r26, 0x0a	; 10
     eae:	4d 90       	ld	r4, X+
     eb0:	5c 90       	ld	r5, X
     eb2:	1b 97       	sbiw	r26, 0x0b	; 11
     eb4:	66 24       	eor	r6, r6
     eb6:	57 fc       	sbrc	r5, 7
     eb8:	60 94       	com	r6
     eba:	76 2c       	mov	r7, r6
     ebc:	56 96       	adiw	r26, 0x16	; 22
     ebe:	4d 91       	ld	r20, X+
     ec0:	5c 91       	ld	r21, X
     ec2:	57 97       	sbiw	r26, 0x17	; 23
     ec4:	66 27       	eor	r22, r22
     ec6:	57 fd       	sbrc	r21, 7
     ec8:	60 95       	com	r22
     eca:	76 2f       	mov	r23, r22
     ecc:	50 96       	adiw	r26, 0x10	; 16
     ece:	8d 91       	ld	r24, X+
     ed0:	9c 91       	ld	r25, X
     ed2:	51 97       	sbiw	r26, 0x11	; 17
     ed4:	aa 27       	eor	r26, r26
     ed6:	97 fd       	sbrc	r25, 7
     ed8:	a0 95       	com	r26
     eda:	ba 2f       	mov	r27, r26
     edc:	48 0f       	add	r20, r24
     ede:	59 1f       	adc	r21, r25
     ee0:	6a 1f       	adc	r22, r26
     ee2:	7b 1f       	adc	r23, r27
     ee4:	db 01       	movw	r26, r22
     ee6:	ca 01       	movw	r24, r20
     ee8:	77 23       	and	r23, r23
     eea:	1c f4       	brge	.+6      	; 0xef2 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x14e>
     eec:	01 96       	adiw	r24, 0x01	; 1
     eee:	a1 1d       	adc	r26, r1
     ef0:	b1 1d       	adc	r27, r1
     ef2:	b5 95       	asr	r27
     ef4:	a7 95       	ror	r26
     ef6:	97 95       	ror	r25
     ef8:	87 95       	ror	r24
     efa:	48 1a       	sub	r4, r24
     efc:	59 0a       	sbc	r5, r25
     efe:	6a 0a       	sbc	r6, r26
     f00:	7b 0a       	sbc	r7, r27
     f02:	f8 01       	movw	r30, r16
     f04:	84 80       	ldd	r8, Z+4	; 0x04
     f06:	95 80       	ldd	r9, Z+5	; 0x05
     f08:	aa 24       	eor	r10, r10
     f0a:	97 fc       	sbrc	r9, 7
     f0c:	a0 94       	com	r10
     f0e:	ba 2c       	mov	r11, r10
     f10:	82 81       	ldd	r24, Z+2	; 0x02
     f12:	93 81       	ldd	r25, Z+3	; 0x03
     f14:	9c 01       	movw	r18, r24
     f16:	44 27       	eor	r20, r20
     f18:	37 fd       	sbrc	r19, 7
     f1a:	40 95       	com	r20
     f1c:	54 2f       	mov	r21, r20
     f1e:	2f a3       	std	Y+39, r18	; 0x27
     f20:	38 a7       	std	Y+40, r19	; 0x28
     f22:	49 a7       	std	Y+41, r20	; 0x29
     f24:	5a a7       	std	Y+42, r21	; 0x2a
     f26:	2b a1       	ldd	r18, Y+35	; 0x23
     f28:	3c a1       	ldd	r19, Y+36	; 0x24
     f2a:	4d a1       	ldd	r20, Y+37	; 0x25
     f2c:	5e a1       	ldd	r21, Y+38	; 0x26
     f2e:	c5 01       	movw	r24, r10
     f30:	b4 01       	movw	r22, r8
     f32:	0e 94 17 21 	call	0x422e	; 0x422e <__mulsi3>
     f36:	6b 01       	movw	r12, r22
     f38:	7c 01       	movw	r14, r24
     f3a:	a3 01       	movw	r20, r6
     f3c:	92 01       	movw	r18, r4
     f3e:	6f a1       	ldd	r22, Y+39	; 0x27
     f40:	78 a5       	ldd	r23, Y+40	; 0x28
     f42:	89 a5       	ldd	r24, Y+41	; 0x29
     f44:	9a a5       	ldd	r25, Y+42	; 0x2a
     f46:	0e 94 17 21 	call	0x422e	; 0x422e <__mulsi3>
     f4a:	a7 01       	movw	r20, r14
     f4c:	96 01       	movw	r18, r12
     f4e:	26 1b       	sub	r18, r22
     f50:	37 0b       	sbc	r19, r23
     f52:	48 0b       	sbc	r20, r24
     f54:	59 0b       	sbc	r21, r25
     f56:	ca 01       	movw	r24, r20
     f58:	b9 01       	movw	r22, r18
     f5a:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
     f5e:	6d 87       	std	Y+13, r22	; 0x0d
     f60:	7e 87       	std	Y+14, r23	; 0x0e
     f62:	8f 87       	std	Y+15, r24	; 0x0f
     f64:	98 8b       	std	Y+16, r25	; 0x10
     f66:	d8 01       	movw	r26, r16
     f68:	cd 90       	ld	r12, X+
     f6a:	dc 90       	ld	r13, X
     f6c:	ee 24       	eor	r14, r14
     f6e:	d7 fc       	sbrc	r13, 7
     f70:	e0 94       	com	r14
     f72:	fe 2c       	mov	r15, r14
     f74:	a3 01       	movw	r20, r6
     f76:	92 01       	movw	r18, r4
     f78:	c7 01       	movw	r24, r14
     f7a:	b6 01       	movw	r22, r12
     f7c:	0e 94 17 21 	call	0x422e	; 0x422e <__mulsi3>
     f80:	2b 01       	movw	r4, r22
     f82:	3c 01       	movw	r6, r24
     f84:	2f 8d       	ldd	r18, Y+31	; 0x1f
     f86:	38 a1       	ldd	r19, Y+32	; 0x20
     f88:	49 a1       	ldd	r20, Y+33	; 0x21
     f8a:	5a a1       	ldd	r21, Y+34	; 0x22
     f8c:	c5 01       	movw	r24, r10
     f8e:	b4 01       	movw	r22, r8
     f90:	0e 94 17 21 	call	0x422e	; 0x422e <__mulsi3>
     f94:	a3 01       	movw	r20, r6
     f96:	92 01       	movw	r18, r4
     f98:	26 1b       	sub	r18, r22
     f9a:	37 0b       	sbc	r19, r23
     f9c:	48 0b       	sbc	r20, r24
     f9e:	59 0b       	sbc	r21, r25
     fa0:	ca 01       	movw	r24, r20
     fa2:	b9 01       	movw	r22, r18
     fa4:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
     fa8:	69 8b       	std	Y+17, r22	; 0x11
     faa:	7a 8b       	std	Y+18, r23	; 0x12
     fac:	8b 8b       	std	Y+19, r24	; 0x13
     fae:	9c 8b       	std	Y+20, r25	; 0x14
     fb0:	2f 8d       	ldd	r18, Y+31	; 0x1f
     fb2:	38 a1       	ldd	r19, Y+32	; 0x20
     fb4:	49 a1       	ldd	r20, Y+33	; 0x21
     fb6:	5a a1       	ldd	r21, Y+34	; 0x22
     fb8:	6f a1       	ldd	r22, Y+39	; 0x27
     fba:	78 a5       	ldd	r23, Y+40	; 0x28
     fbc:	89 a5       	ldd	r24, Y+41	; 0x29
     fbe:	9a a5       	ldd	r25, Y+42	; 0x2a
     fc0:	0e 94 17 21 	call	0x422e	; 0x422e <__mulsi3>
     fc4:	4b 01       	movw	r8, r22
     fc6:	5c 01       	movw	r10, r24
     fc8:	2b a1       	ldd	r18, Y+35	; 0x23
     fca:	3c a1       	ldd	r19, Y+36	; 0x24
     fcc:	4d a1       	ldd	r20, Y+37	; 0x25
     fce:	5e a1       	ldd	r21, Y+38	; 0x26
     fd0:	c7 01       	movw	r24, r14
     fd2:	b6 01       	movw	r22, r12
     fd4:	0e 94 17 21 	call	0x422e	; 0x422e <__mulsi3>
     fd8:	a5 01       	movw	r20, r10
     fda:	94 01       	movw	r18, r8
     fdc:	26 1b       	sub	r18, r22
     fde:	37 0b       	sbc	r19, r23
     fe0:	48 0b       	sbc	r20, r24
     fe2:	59 0b       	sbc	r21, r25
     fe4:	ca 01       	movw	r24, r20
     fe6:	b9 01       	movw	r22, r18
     fe8:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
     fec:	6d 8b       	std	Y+21, r22	; 0x15
     fee:	7e 8b       	std	Y+22, r23	; 0x16
     ff0:	8f 8b       	std	Y+23, r24	; 0x17
     ff2:	98 8f       	std	Y+24, r25	; 0x18
     ff4:	ce 01       	movw	r24, r28
     ff6:	0d 96       	adiw	r24, 0x0d	; 13
     ff8:	48 de       	rcall	.-880    	; 0xc8a <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     ffa:	d8 01       	movw	r26, r16
     ffc:	12 96       	adiw	r26, 0x02	; 2
     ffe:	6d 91       	ld	r22, X+
    1000:	7c 91       	ld	r23, X
    1002:	13 97       	sbiw	r26, 0x03	; 3
    1004:	88 27       	eor	r24, r24
    1006:	77 fd       	sbrc	r23, 7
    1008:	80 95       	com	r24
    100a:	98 2f       	mov	r25, r24
    100c:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1010:	6b 01       	movw	r12, r22
    1012:	7c 01       	movw	r14, r24
    1014:	2d 89       	ldd	r18, Y+21	; 0x15
    1016:	3e 89       	ldd	r19, Y+22	; 0x16
    1018:	4f 89       	ldd	r20, Y+23	; 0x17
    101a:	58 8d       	ldd	r21, Y+24	; 0x18
    101c:	2f 8f       	std	Y+31, r18	; 0x1f
    101e:	38 a3       	std	Y+32, r19	; 0x20
    1020:	49 a3       	std	Y+33, r20	; 0x21
    1022:	5a a3       	std	Y+34, r21	; 0x22
    1024:	d8 01       	movw	r26, r16
    1026:	14 96       	adiw	r26, 0x04	; 4
    1028:	6d 91       	ld	r22, X+
    102a:	7c 91       	ld	r23, X
    102c:	15 97       	sbiw	r26, 0x05	; 5
    102e:	88 27       	eor	r24, r24
    1030:	77 fd       	sbrc	r23, 7
    1032:	80 95       	com	r24
    1034:	98 2f       	mov	r25, r24
    1036:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    103a:	2b 01       	movw	r4, r22
    103c:	3c 01       	movw	r6, r24
    103e:	29 89       	ldd	r18, Y+17	; 0x11
    1040:	3a 89       	ldd	r19, Y+18	; 0x12
    1042:	4b 89       	ldd	r20, Y+19	; 0x13
    1044:	5c 89       	ldd	r21, Y+20	; 0x14
    1046:	2b a3       	std	Y+35, r18	; 0x23
    1048:	3c a3       	std	Y+36, r19	; 0x24
    104a:	4d a3       	std	Y+37, r20	; 0x25
    104c:	5e a3       	std	Y+38, r21	; 0x26
    104e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1050:	38 a1       	ldd	r19, Y+32	; 0x20
    1052:	49 a1       	ldd	r20, Y+33	; 0x21
    1054:	5a a1       	ldd	r21, Y+34	; 0x22
    1056:	c7 01       	movw	r24, r14
    1058:	b6 01       	movw	r22, r12
    105a:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    105e:	4b 01       	movw	r8, r22
    1060:	5c 01       	movw	r10, r24
    1062:	2b a1       	ldd	r18, Y+35	; 0x23
    1064:	3c a1       	ldd	r19, Y+36	; 0x24
    1066:	4d a1       	ldd	r20, Y+37	; 0x25
    1068:	5e a1       	ldd	r21, Y+38	; 0x26
    106a:	c3 01       	movw	r24, r6
    106c:	b2 01       	movw	r22, r4
    106e:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1072:	9b 01       	movw	r18, r22
    1074:	ac 01       	movw	r20, r24
    1076:	c5 01       	movw	r24, r10
    1078:	b4 01       	movw	r22, r8
    107a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__subsf3>
    107e:	69 83       	std	Y+1, r22	; 0x01
    1080:	7a 83       	std	Y+2, r23	; 0x02
    1082:	8b 83       	std	Y+3, r24	; 0x03
    1084:	9c 83       	std	Y+4, r25	; 0x04
    1086:	8d 85       	ldd	r24, Y+13	; 0x0d
    1088:	9e 85       	ldd	r25, Y+14	; 0x0e
    108a:	af 85       	ldd	r26, Y+15	; 0x0f
    108c:	b8 89       	ldd	r27, Y+16	; 0x10
    108e:	8f a3       	std	Y+39, r24	; 0x27
    1090:	98 a7       	std	Y+40, r25	; 0x28
    1092:	a9 a7       	std	Y+41, r26	; 0x29
    1094:	ba a7       	std	Y+42, r27	; 0x2a
    1096:	d8 01       	movw	r26, r16
    1098:	6d 91       	ld	r22, X+
    109a:	7c 91       	ld	r23, X
    109c:	88 27       	eor	r24, r24
    109e:	77 fd       	sbrc	r23, 7
    10a0:	80 95       	com	r24
    10a2:	98 2f       	mov	r25, r24
    10a4:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    10a8:	4b 01       	movw	r8, r22
    10aa:	5c 01       	movw	r10, r24
    10ac:	2f a1       	ldd	r18, Y+39	; 0x27
    10ae:	38 a5       	ldd	r19, Y+40	; 0x28
    10b0:	49 a5       	ldd	r20, Y+41	; 0x29
    10b2:	5a a5       	ldd	r21, Y+42	; 0x2a
    10b4:	c3 01       	movw	r24, r6
    10b6:	b2 01       	movw	r22, r4
    10b8:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    10bc:	2b 01       	movw	r4, r22
    10be:	3c 01       	movw	r6, r24
    10c0:	a5 01       	movw	r20, r10
    10c2:	94 01       	movw	r18, r8
    10c4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    10c6:	78 a1       	ldd	r23, Y+32	; 0x20
    10c8:	89 a1       	ldd	r24, Y+33	; 0x21
    10ca:	9a a1       	ldd	r25, Y+34	; 0x22
    10cc:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    10d0:	9b 01       	movw	r18, r22
    10d2:	ac 01       	movw	r20, r24
    10d4:	c3 01       	movw	r24, r6
    10d6:	b2 01       	movw	r22, r4
    10d8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__subsf3>
    10dc:	6d 83       	std	Y+5, r22	; 0x05
    10de:	7e 83       	std	Y+6, r23	; 0x06
    10e0:	8f 83       	std	Y+7, r24	; 0x07
    10e2:	98 87       	std	Y+8, r25	; 0x08
    10e4:	a5 01       	movw	r20, r10
    10e6:	94 01       	movw	r18, r8
    10e8:	6b a1       	ldd	r22, Y+35	; 0x23
    10ea:	7c a1       	ldd	r23, Y+36	; 0x24
    10ec:	8d a1       	ldd	r24, Y+37	; 0x25
    10ee:	9e a1       	ldd	r25, Y+38	; 0x26
    10f0:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    10f4:	4b 01       	movw	r8, r22
    10f6:	5c 01       	movw	r10, r24
    10f8:	2f a1       	ldd	r18, Y+39	; 0x27
    10fa:	38 a5       	ldd	r19, Y+40	; 0x28
    10fc:	49 a5       	ldd	r20, Y+41	; 0x29
    10fe:	5a a5       	ldd	r21, Y+42	; 0x2a
    1100:	c7 01       	movw	r24, r14
    1102:	b6 01       	movw	r22, r12
    1104:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1108:	9b 01       	movw	r18, r22
    110a:	ac 01       	movw	r20, r24
    110c:	c5 01       	movw	r24, r10
    110e:	b4 01       	movw	r22, r8
    1110:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__subsf3>
    1114:	69 87       	std	Y+9, r22	; 0x09
    1116:	7a 87       	std	Y+10, r23	; 0x0a
    1118:	8b 87       	std	Y+11, r24	; 0x0b
    111a:	9c 87       	std	Y+12, r25	; 0x0c
    111c:	ce 01       	movw	r24, r28
    111e:	01 96       	adiw	r24, 0x01	; 1
    1120:	b4 dd       	rcall	.-1176   	; 0xc8a <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
    1122:	69 8d       	ldd	r22, Y+25	; 0x19
    1124:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1126:	88 27       	eor	r24, r24
    1128:	77 fd       	sbrc	r23, 7
    112a:	80 95       	com	r24
    112c:	98 2f       	mov	r25, r24
    112e:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1132:	2b 01       	movw	r4, r22
    1134:	3c 01       	movw	r6, r24
    1136:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1138:	7c 8d       	ldd	r23, Y+28	; 0x1c
    113a:	88 27       	eor	r24, r24
    113c:	77 fd       	sbrc	r23, 7
    113e:	80 95       	com	r24
    1140:	98 2f       	mov	r25, r24
    1142:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1146:	4b 01       	movw	r8, r22
    1148:	5c 01       	movw	r10, r24
    114a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    114c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    114e:	88 27       	eor	r24, r24
    1150:	77 fd       	sbrc	r23, 7
    1152:	80 95       	com	r24
    1154:	98 2f       	mov	r25, r24
    1156:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    115a:	6b 01       	movw	r12, r22
    115c:	7c 01       	movw	r14, r24
    115e:	29 81       	ldd	r18, Y+1	; 0x01
    1160:	3a 81       	ldd	r19, Y+2	; 0x02
    1162:	4b 81       	ldd	r20, Y+3	; 0x03
    1164:	5c 81       	ldd	r21, Y+4	; 0x04
    1166:	c3 01       	movw	r24, r6
    1168:	b2 01       	movw	r22, r4
    116a:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    116e:	6f 8f       	std	Y+31, r22	; 0x1f
    1170:	78 a3       	std	Y+32, r23	; 0x20
    1172:	89 a3       	std	Y+33, r24	; 0x21
    1174:	9a a3       	std	Y+34, r25	; 0x22
    1176:	2d 81       	ldd	r18, Y+5	; 0x05
    1178:	3e 81       	ldd	r19, Y+6	; 0x06
    117a:	4f 81       	ldd	r20, Y+7	; 0x07
    117c:	58 85       	ldd	r21, Y+8	; 0x08
    117e:	c5 01       	movw	r24, r10
    1180:	b4 01       	movw	r22, r8
    1182:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1186:	9b 01       	movw	r18, r22
    1188:	ac 01       	movw	r20, r24
    118a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    118c:	78 a1       	ldd	r23, Y+32	; 0x20
    118e:	89 a1       	ldd	r24, Y+33	; 0x21
    1190:	9a a1       	ldd	r25, Y+34	; 0x22
    1192:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
    1196:	6f 8f       	std	Y+31, r22	; 0x1f
    1198:	78 a3       	std	Y+32, r23	; 0x20
    119a:	89 a3       	std	Y+33, r24	; 0x21
    119c:	9a a3       	std	Y+34, r25	; 0x22
    119e:	29 85       	ldd	r18, Y+9	; 0x09
    11a0:	3a 85       	ldd	r19, Y+10	; 0x0a
    11a2:	4b 85       	ldd	r20, Y+11	; 0x0b
    11a4:	5c 85       	ldd	r21, Y+12	; 0x0c
    11a6:	c7 01       	movw	r24, r14
    11a8:	b6 01       	movw	r22, r12
    11aa:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    11ae:	9b 01       	movw	r18, r22
    11b0:	ac 01       	movw	r20, r24
    11b2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    11b4:	78 a1       	ldd	r23, Y+32	; 0x20
    11b6:	89 a1       	ldd	r24, Y+33	; 0x21
    11b8:	9a a1       	ldd	r25, Y+34	; 0x22
    11ba:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
    11be:	6f 8f       	std	Y+31, r22	; 0x1f
    11c0:	78 a3       	std	Y+32, r23	; 0x20
    11c2:	89 a3       	std	Y+33, r24	; 0x21
    11c4:	9a a3       	std	Y+34, r25	; 0x22
    11c6:	2d 85       	ldd	r18, Y+13	; 0x0d
    11c8:	3e 85       	ldd	r19, Y+14	; 0x0e
    11ca:	4f 85       	ldd	r20, Y+15	; 0x0f
    11cc:	58 89       	ldd	r21, Y+16	; 0x10
    11ce:	c3 01       	movw	r24, r6
    11d0:	b2 01       	movw	r22, r4
    11d2:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    11d6:	2b 01       	movw	r4, r22
    11d8:	3c 01       	movw	r6, r24
    11da:	29 89       	ldd	r18, Y+17	; 0x11
    11dc:	3a 89       	ldd	r19, Y+18	; 0x12
    11de:	4b 89       	ldd	r20, Y+19	; 0x13
    11e0:	5c 89       	ldd	r21, Y+20	; 0x14
    11e2:	c5 01       	movw	r24, r10
    11e4:	b4 01       	movw	r22, r8
    11e6:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    11ea:	9b 01       	movw	r18, r22
    11ec:	ac 01       	movw	r20, r24
    11ee:	c3 01       	movw	r24, r6
    11f0:	b2 01       	movw	r22, r4
    11f2:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
    11f6:	4b 01       	movw	r8, r22
    11f8:	5c 01       	movw	r10, r24
    11fa:	2d 89       	ldd	r18, Y+21	; 0x15
    11fc:	3e 89       	ldd	r19, Y+22	; 0x16
    11fe:	4f 89       	ldd	r20, Y+23	; 0x17
    1200:	58 8d       	ldd	r21, Y+24	; 0x18
    1202:	c7 01       	movw	r24, r14
    1204:	b6 01       	movw	r22, r12
    1206:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    120a:	9b 01       	movw	r18, r22
    120c:	ac 01       	movw	r20, r24
    120e:	c5 01       	movw	r24, r10
    1210:	b4 01       	movw	r22, r8
    1212:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
    1216:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1218:	38 a1       	ldd	r19, Y+32	; 0x20
    121a:	49 a1       	ldd	r20, Y+33	; 0x21
    121c:	5a a1       	ldd	r21, Y+34	; 0x22
    121e:	0e 94 39 18 	call	0x3072	; 0x3072 <atan2>
    1222:	20 e0       	ldi	r18, 0x00	; 0
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	44 e3       	ldi	r20, 0x34	; 52
    1228:	53 e4       	ldi	r21, 0x43	; 67
    122a:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    122e:	2b ed       	ldi	r18, 0xDB	; 219
    1230:	3f e0       	ldi	r19, 0x0F	; 15
    1232:	49 e4       	ldi	r20, 0x49	; 73
    1234:	50 e4       	ldi	r21, 0x40	; 64
    1236:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    123a:	6b 01       	movw	r12, r22
    123c:	7c 01       	movw	r14, r24
    123e:	20 e0       	ldi	r18, 0x00	; 0
    1240:	30 e0       	ldi	r19, 0x00	; 0
    1242:	a9 01       	movw	r20, r18
    1244:	0e 94 8c 18 	call	0x3118	; 0x3118 <__cmpsf2>
    1248:	88 23       	and	r24, r24
    124a:	54 f4       	brge	.+20     	; 0x1260 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x4bc>
    124c:	20 e0       	ldi	r18, 0x00	; 0
    124e:	30 e0       	ldi	r19, 0x00	; 0
    1250:	44 eb       	ldi	r20, 0xB4	; 180
    1252:	53 e4       	ldi	r21, 0x43	; 67
    1254:	c7 01       	movw	r24, r14
    1256:	b6 01       	movw	r22, r12
    1258:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <__addsf3>
    125c:	6b 01       	movw	r12, r22
    125e:	7c 01       	movw	r14, r24
    1260:	c7 01       	movw	r24, r14
    1262:	b6 01       	movw	r22, r12
    1264:	aa 96       	adiw	r28, 0x2a	; 42
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	cd bf       	out	0x3d, r28	; 61
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	1f 91       	pop	r17
    1276:	0f 91       	pop	r16
    1278:	ff 90       	pop	r15
    127a:	ef 90       	pop	r14
    127c:	df 90       	pop	r13
    127e:	cf 90       	pop	r12
    1280:	bf 90       	pop	r11
    1282:	af 90       	pop	r10
    1284:	9f 90       	pop	r9
    1286:	8f 90       	pop	r8
    1288:	7f 90       	pop	r7
    128a:	6f 90       	pop	r6
    128c:	5f 90       	pop	r5
    128e:	4f 90       	pop	r4
    1290:	08 95       	ret

00001292 <_ZN6LSM3037headingEv>:
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	cd b7       	in	r28, 0x3d	; 61
    1298:	de b7       	in	r29, 0x3e	; 62
    129a:	2c 97       	sbiw	r28, 0x0c	; 12
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	f8 94       	cli
    12a0:	de bf       	out	0x3e, r29	; 62
    12a2:	0f be       	out	0x3f, r0	; 63
    12a4:	cd bf       	out	0x3d, r28	; 61
    12a6:	fc 01       	movw	r30, r24
    12a8:	21 8d       	ldd	r18, Z+25	; 0x19
    12aa:	23 30       	cpi	r18, 0x03	; 3
    12ac:	79 f4       	brne	.+30     	; 0x12cc <_ZN6LSM3037headingEv+0x3a>
    12ae:	31 e0       	ldi	r19, 0x01	; 1
    12b0:	23 2f       	mov	r18, r19
    12b2:	3f 83       	std	Y+7, r19	; 0x07
    12b4:	18 86       	std	Y+8, r1	; 0x08
    12b6:	1a 86       	std	Y+10, r1	; 0x0a
    12b8:	19 86       	std	Y+9, r1	; 0x09
    12ba:	1c 86       	std	Y+12, r1	; 0x0c
    12bc:	1b 86       	std	Y+11, r1	; 0x0b
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	40 e0       	ldi	r20, 0x00	; 0
    12c2:	5a 85       	ldd	r21, Y+10	; 0x0a
    12c4:	60 e0       	ldi	r22, 0x00	; 0
    12c6:	7c 85       	ldd	r23, Y+12	; 0x0c
    12c8:	6d dd       	rcall	.-1318   	; 0xda4 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
    12ca:	0e c0       	rjmp	.+28     	; 0x12e8 <_ZN6LSM3037headingEv+0x56>
    12cc:	1a 82       	std	Y+2, r1	; 0x02
    12ce:	19 82       	std	Y+1, r1	; 0x01
    12d0:	2f ef       	ldi	r18, 0xFF	; 255
    12d2:	42 2f       	mov	r20, r18
    12d4:	2b 83       	std	Y+3, r18	; 0x03
    12d6:	2c 83       	std	Y+4, r18	; 0x04
    12d8:	1e 82       	std	Y+6, r1	; 0x06
    12da:	1d 82       	std	Y+5, r1	; 0x05
    12dc:	20 e0       	ldi	r18, 0x00	; 0
    12de:	3a 81       	ldd	r19, Y+2	; 0x02
    12e0:	5f ef       	ldi	r21, 0xFF	; 255
    12e2:	60 e0       	ldi	r22, 0x00	; 0
    12e4:	7e 81       	ldd	r23, Y+6	; 0x06
    12e6:	5e dd       	rcall	.-1348   	; 0xda4 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
    12e8:	2c 96       	adiw	r28, 0x0c	; 12
    12ea:	0f b6       	in	r0, 0x3f	; 63
    12ec:	f8 94       	cli
    12ee:	de bf       	out	0x3e, r29	; 62
    12f0:	0f be       	out	0x3f, r0	; 63
    12f2:	cd bf       	out	0x3d, r28	; 61
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	08 95       	ret

000012fa <_ZN6LSM30311writeAccRegEhh>:
    12fa:	0f 93       	push	r16
    12fc:	1f 93       	push	r17
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	ec 01       	movw	r28, r24
    1304:	06 2f       	mov	r16, r22
    1306:	14 2f       	mov	r17, r20
    1308:	6a 8d       	ldd	r22, Y+26	; 0x1a
    130a:	80 eb       	ldi	r24, 0xB0	; 176
    130c:	99 e0       	ldi	r25, 0x09	; 9
    130e:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
    1312:	60 2f       	mov	r22, r16
    1314:	80 eb       	ldi	r24, 0xB0	; 176
    1316:	99 e0       	ldi	r25, 0x09	; 9
    1318:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
    131c:	61 2f       	mov	r22, r17
    131e:	80 eb       	ldi	r24, 0xB0	; 176
    1320:	99 e0       	ldi	r25, 0x09	; 9
    1322:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
    1326:	80 eb       	ldi	r24, 0xB0	; 176
    1328:	99 e0       	ldi	r25, 0x09	; 9
    132a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
    132e:	88 8f       	std	Y+24, r24	; 0x18
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	08 95       	ret

0000133a <_ZN6LSM30311writeMagRegEhh>:
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	ec 01       	movw	r28, r24
    1344:	06 2f       	mov	r16, r22
    1346:	14 2f       	mov	r17, r20
    1348:	6b 8d       	ldd	r22, Y+27	; 0x1b
    134a:	80 eb       	ldi	r24, 0xB0	; 176
    134c:	99 e0       	ldi	r25, 0x09	; 9
    134e:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
    1352:	60 2f       	mov	r22, r16
    1354:	80 eb       	ldi	r24, 0xB0	; 176
    1356:	99 e0       	ldi	r25, 0x09	; 9
    1358:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
    135c:	61 2f       	mov	r22, r17
    135e:	80 eb       	ldi	r24, 0xB0	; 176
    1360:	99 e0       	ldi	r25, 0x09	; 9
    1362:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
    1366:	80 eb       	ldi	r24, 0xB0	; 176
    1368:	99 e0       	ldi	r25, 0x09	; 9
    136a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
    136e:	88 8f       	std	Y+24, r24	; 0x18
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	1f 91       	pop	r17
    1376:	0f 91       	pop	r16
    1378:	08 95       	ret

0000137a <_ZN6LSM3038writeRegEhh>:
    137a:	fc 01       	movw	r30, r24
    137c:	21 8d       	ldd	r18, Z+25	; 0x19
    137e:	23 30       	cpi	r18, 0x03	; 3
    1380:	11 f0       	breq	.+4      	; 0x1386 <_ZN6LSM3038writeRegEhh+0xc>
    1382:	60 32       	cpi	r22, 0x20	; 32
    1384:	10 f4       	brcc	.+4      	; 0x138a <_ZN6LSM3038writeRegEhh+0x10>
    1386:	d9 cf       	rjmp	.-78     	; 0x133a <_ZN6LSM30311writeMagRegEhh>
    1388:	08 95       	ret
    138a:	b7 cf       	rjmp	.-146    	; 0x12fa <_ZN6LSM30311writeAccRegEhh>
    138c:	08 95       	ret

0000138e <_ZN6LSM30313enableDefaultEv>:
    138e:	cf 93       	push	r28
    1390:	df 93       	push	r29
    1392:	ec 01       	movw	r28, r24
    1394:	89 8d       	ldd	r24, Y+25	; 0x19
    1396:	83 30       	cpi	r24, 0x03	; 3
    1398:	a9 f4       	brne	.+42     	; 0x13c4 <_ZN6LSM30313enableDefaultEv+0x36>
    139a:	40 e0       	ldi	r20, 0x00	; 0
    139c:	61 e2       	ldi	r22, 0x21	; 33
    139e:	ce 01       	movw	r24, r28
    13a0:	ec df       	rcall	.-40     	; 0x137a <_ZN6LSM3038writeRegEhh>
    13a2:	47 e5       	ldi	r20, 0x57	; 87
    13a4:	60 e2       	ldi	r22, 0x20	; 32
    13a6:	ce 01       	movw	r24, r28
    13a8:	e8 df       	rcall	.-48     	; 0x137a <_ZN6LSM3038writeRegEhh>
    13aa:	44 e6       	ldi	r20, 0x64	; 100
    13ac:	64 e2       	ldi	r22, 0x24	; 36
    13ae:	ce 01       	movw	r24, r28
    13b0:	e4 df       	rcall	.-56     	; 0x137a <_ZN6LSM3038writeRegEhh>
    13b2:	40 e2       	ldi	r20, 0x20	; 32
    13b4:	65 e2       	ldi	r22, 0x25	; 37
    13b6:	ce 01       	movw	r24, r28
    13b8:	e0 df       	rcall	.-64     	; 0x137a <_ZN6LSM3038writeRegEhh>
    13ba:	40 e0       	ldi	r20, 0x00	; 0
    13bc:	66 e2       	ldi	r22, 0x26	; 38
    13be:	ce 01       	movw	r24, r28
    13c0:	dc df       	rcall	.-72     	; 0x137a <_ZN6LSM3038writeRegEhh>
    13c2:	1f c0       	rjmp	.+62     	; 0x1402 <_ZN6LSM30313enableDefaultEv+0x74>
    13c4:	82 30       	cpi	r24, 0x02	; 2
    13c6:	49 f4       	brne	.+18     	; 0x13da <_ZN6LSM30313enableDefaultEv+0x4c>
    13c8:	48 e0       	ldi	r20, 0x08	; 8
    13ca:	63 e2       	ldi	r22, 0x23	; 35
    13cc:	ce 01       	movw	r24, r28
    13ce:	95 df       	rcall	.-214    	; 0x12fa <_ZN6LSM30311writeAccRegEhh>
    13d0:	47 e4       	ldi	r20, 0x47	; 71
    13d2:	60 e2       	ldi	r22, 0x20	; 32
    13d4:	ce 01       	movw	r24, r28
    13d6:	91 df       	rcall	.-222    	; 0x12fa <_ZN6LSM30311writeAccRegEhh>
    13d8:	08 c0       	rjmp	.+16     	; 0x13ea <_ZN6LSM30313enableDefaultEv+0x5c>
    13da:	40 e0       	ldi	r20, 0x00	; 0
    13dc:	63 e2       	ldi	r22, 0x23	; 35
    13de:	ce 01       	movw	r24, r28
    13e0:	8c df       	rcall	.-232    	; 0x12fa <_ZN6LSM30311writeAccRegEhh>
    13e2:	47 e2       	ldi	r20, 0x27	; 39
    13e4:	60 e2       	ldi	r22, 0x20	; 32
    13e6:	ce 01       	movw	r24, r28
    13e8:	88 df       	rcall	.-240    	; 0x12fa <_ZN6LSM30311writeAccRegEhh>
    13ea:	4c e0       	ldi	r20, 0x0C	; 12
    13ec:	60 e0       	ldi	r22, 0x00	; 0
    13ee:	ce 01       	movw	r24, r28
    13f0:	a4 df       	rcall	.-184    	; 0x133a <_ZN6LSM30311writeMagRegEhh>
    13f2:	40 e2       	ldi	r20, 0x20	; 32
    13f4:	61 e0       	ldi	r22, 0x01	; 1
    13f6:	ce 01       	movw	r24, r28
    13f8:	a0 df       	rcall	.-192    	; 0x133a <_ZN6LSM30311writeMagRegEhh>
    13fa:	40 e0       	ldi	r20, 0x00	; 0
    13fc:	62 e0       	ldi	r22, 0x02	; 2
    13fe:	ce 01       	movw	r24, r28
    1400:	9c df       	rcall	.-200    	; 0x133a <_ZN6LSM30311writeMagRegEhh>
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	08 95       	ret

00001408 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
    1408:	9f 92       	push	r9
    140a:	af 92       	push	r10
    140c:	bf 92       	push	r11
    140e:	cf 92       	push	r12
    1410:	df 92       	push	r13
    1412:	ef 92       	push	r14
    1414:	ff 92       	push	r15
    1416:	0f 93       	push	r16
    1418:	1f 93       	push	r17
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
    1420:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1422:	80 eb       	ldi	r24, 0xB0	; 176
    1424:	99 e0       	ldi	r25, 0x09	; 9
    1426:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
    142a:	e0 91 b0 09 	lds	r30, 0x09B0
    142e:	f0 91 b1 09 	lds	r31, 0x09B1
    1432:	01 90       	ld	r0, Z+
    1434:	f0 81       	ld	r31, Z
    1436:	e0 2d       	mov	r30, r0
    1438:	68 ea       	ldi	r22, 0xA8	; 168
    143a:	80 eb       	ldi	r24, 0xB0	; 176
    143c:	99 e0       	ldi	r25, 0x09	; 9
    143e:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
    1440:	80 eb       	ldi	r24, 0xB0	; 176
    1442:	99 e0       	ldi	r25, 0x09	; 9
    1444:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
    1448:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
    144a:	46 e0       	ldi	r20, 0x06	; 6
    144c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    144e:	80 eb       	ldi	r24, 0xB0	; 176
    1450:	99 e0       	ldi	r25, 0x09	; 9
    1452:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    1456:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <millis>
    145a:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    145c:	10 c0       	rjmp	.+32     	; 0x147e <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    145e:	8b a1       	ldd	r24, Y+35	; 0x23
    1460:	9c a1       	ldd	r25, Y+36	; 0x24
    1462:	89 2b       	or	r24, r25
    1464:	61 f0       	breq	.+24     	; 0x147e <_ZN6LSM3037readAccEv+0x76>
    1466:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <millis>
    146a:	60 1b       	sub	r22, r16
    146c:	71 0b       	sbc	r23, r17
    146e:	8b a1       	ldd	r24, Y+35	; 0x23
    1470:	9c a1       	ldd	r25, Y+36	; 0x24
    1472:	86 17       	cp	r24, r22
    1474:	97 07       	cpc	r25, r23
    1476:	18 f4       	brcc	.+6      	; 0x147e <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
    1478:	81 e0       	ldi	r24, 0x01	; 1
    147a:	8d a3       	std	Y+37, r24	; 0x25
      return;
    147c:	32 c0       	rjmp	.+100    	; 0x14e2 <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    147e:	80 eb       	ldi	r24, 0xB0	; 176
    1480:	99 e0       	ldi	r25, 0x09	; 9
    1482:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
    1486:	06 97       	sbiw	r24, 0x06	; 6
    1488:	54 f3       	brlt	.-44     	; 0x145e <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
    148a:	80 eb       	ldi	r24, 0xB0	; 176
    148c:	99 e0       	ldi	r25, 0x09	; 9
    148e:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    1492:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
    1494:	80 eb       	ldi	r24, 0xB0	; 176
    1496:	99 e0       	ldi	r25, 0x09	; 9
    1498:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    149c:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
    149e:	80 eb       	ldi	r24, 0xB0	; 176
    14a0:	99 e0       	ldi	r25, 0x09	; 9
    14a2:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    14a6:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
    14a8:	80 eb       	ldi	r24, 0xB0	; 176
    14aa:	99 e0       	ldi	r25, 0x09	; 9
    14ac:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    14b0:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
    14b2:	80 eb       	ldi	r24, 0xB0	; 176
    14b4:	99 e0       	ldi	r25, 0x09	; 9
    14b6:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    14ba:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
    14bc:	80 eb       	ldi	r24, 0xB0	; 176
    14be:	99 e0       	ldi	r25, 0x09	; 9
    14c0:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
    14c4:	d9 2c       	mov	r13, r9
    14c6:	c1 2c       	mov	r12, r1
    14c8:	ca 28       	or	r12, r10
    14ca:	d9 82       	std	Y+1, r13	; 0x01
    14cc:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
    14ce:	fb 2c       	mov	r15, r11
    14d0:	e1 2c       	mov	r14, r1
    14d2:	e0 2a       	or	r14, r16
    14d4:	fb 82       	std	Y+3, r15	; 0x03
    14d6:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
    14d8:	98 2f       	mov	r25, r24
    14da:	88 27       	eor	r24, r24
    14dc:	81 2b       	or	r24, r17
    14de:	9d 83       	std	Y+5, r25	; 0x05
    14e0:	8c 83       	std	Y+4, r24	; 0x04
}
    14e2:	df 91       	pop	r29
    14e4:	cf 91       	pop	r28
    14e6:	1f 91       	pop	r17
    14e8:	0f 91       	pop	r16
    14ea:	ff 90       	pop	r15
    14ec:	ef 90       	pop	r14
    14ee:	df 90       	pop	r13
    14f0:	cf 90       	pop	r12
    14f2:	bf 90       	pop	r11
    14f4:	af 90       	pop	r10
    14f6:	9f 90       	pop	r9
    14f8:	08 95       	ret

000014fa <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
    14fa:	cf 92       	push	r12
    14fc:	df 92       	push	r13
    14fe:	ef 92       	push	r14
    1500:	ff 92       	push	r15
    1502:	0f 93       	push	r16
    1504:	1f 93       	push	r17
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
    150c:	6b 8d       	ldd	r22, Y+27	; 0x1b
    150e:	80 eb       	ldi	r24, 0xB0	; 176
    1510:	99 e0       	ldi	r25, 0x09	; 9
    1512:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
    1516:	89 8d       	ldd	r24, Y+25	; 0x19
    1518:	83 30       	cpi	r24, 0x03	; 3
    151a:	31 f4       	brne	.+12     	; 0x1528 <_ZN6LSM3037readMagEv+0x2e>
    151c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    151e:	77 27       	eor	r23, r23
    1520:	67 fd       	sbrc	r22, 7
    1522:	70 95       	com	r23
    1524:	60 68       	ori	r22, 0x80	; 128
    1526:	04 c0       	rjmp	.+8      	; 0x1530 <_ZN6LSM3037readMagEv+0x36>
    1528:	6d 8d       	ldd	r22, Y+29	; 0x1d
    152a:	77 27       	eor	r23, r23
    152c:	67 fd       	sbrc	r22, 7
    152e:	70 95       	com	r23
    1530:	e0 91 b0 09 	lds	r30, 0x09B0
    1534:	f0 91 b1 09 	lds	r31, 0x09B1
    1538:	01 90       	ld	r0, Z+
    153a:	f0 81       	ld	r31, Z
    153c:	e0 2d       	mov	r30, r0
    153e:	80 eb       	ldi	r24, 0xB0	; 176
    1540:	99 e0       	ldi	r25, 0x09	; 9
    1542:	19 95       	eicall
  last_status = Wire.endTransmission();
    1544:	80 eb       	ldi	r24, 0xB0	; 176
    1546:	99 e0       	ldi	r25, 0x09	; 9
    1548:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
    154c:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
    154e:	46 e0       	ldi	r20, 0x06	; 6
    1550:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1552:	80 eb       	ldi	r24, 0xB0	; 176
    1554:	99 e0       	ldi	r25, 0x09	; 9
    1556:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    155a:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <millis>
    155e:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    1560:	10 c0       	rjmp	.+32     	; 0x1582 <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    1562:	8b a1       	ldd	r24, Y+35	; 0x23
    1564:	9c a1       	ldd	r25, Y+36	; 0x24
    1566:	89 2b       	or	r24, r25
    1568:	61 f0       	breq	.+24     	; 0x1582 <_ZN6LSM3037readMagEv+0x88>
    156a:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <millis>
    156e:	60 1b       	sub	r22, r16
    1570:	71 0b       	sbc	r23, r17
    1572:	8b a1       	ldd	r24, Y+35	; 0x23
    1574:	9c a1       	ldd	r25, Y+36	; 0x24
    1576:	86 17       	cp	r24, r22
    1578:	97 07       	cpc	r25, r23
    157a:	18 f4       	brcc	.+6      	; 0x1582 <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	8d a3       	std	Y+37, r24	; 0x25
      return;
    1580:	6e c0       	rjmp	.+220    	; 0x165e <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    1582:	80 eb       	ldi	r24, 0xB0	; 176
    1584:	99 e0       	ldi	r25, 0x09	; 9
    1586:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
    158a:	06 97       	sbiw	r24, 0x06	; 6
    158c:	54 f3       	brlt	.-44     	; 0x1562 <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
    158e:	89 8d       	ldd	r24, Y+25	; 0x19
    1590:	83 30       	cpi	r24, 0x03	; 3
    1592:	f9 f4       	brne	.+62     	; 0x15d2 <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
    1594:	80 eb       	ldi	r24, 0xB0	; 176
    1596:	99 e0       	ldi	r25, 0x09	; 9
    1598:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    159c:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
    159e:	80 eb       	ldi	r24, 0xB0	; 176
    15a0:	99 e0       	ldi	r25, 0x09	; 9
    15a2:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15a6:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
    15a8:	80 eb       	ldi	r24, 0xB0	; 176
    15aa:	99 e0       	ldi	r25, 0x09	; 9
    15ac:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15b0:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
    15b2:	80 eb       	ldi	r24, 0xB0	; 176
    15b4:	99 e0       	ldi	r25, 0x09	; 9
    15b6:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15ba:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
    15bc:	80 eb       	ldi	r24, 0xB0	; 176
    15be:	99 e0       	ldi	r25, 0x09	; 9
    15c0:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15c4:	08 2f       	mov	r16, r24
    zhm = Wire.read();
    15c6:	80 eb       	ldi	r24, 0xB0	; 176
    15c8:	99 e0       	ldi	r25, 0x09	; 9
    15ca:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15ce:	18 2f       	mov	r17, r24
    15d0:	36 c0       	rjmp	.+108    	; 0x163e <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
    15d2:	80 eb       	ldi	r24, 0xB0	; 176
    15d4:	99 e0       	ldi	r25, 0x09	; 9
    15d6:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15da:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
    15dc:	80 eb       	ldi	r24, 0xB0	; 176
    15de:	99 e0       	ldi	r25, 0x09	; 9
    15e0:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15e4:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
    15e6:	89 8d       	ldd	r24, Y+25	; 0x19
    15e8:	81 11       	cpse	r24, r1
    15ea:	15 c0       	rjmp	.+42     	; 0x1616 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
    15ec:	80 eb       	ldi	r24, 0xB0	; 176
    15ee:	99 e0       	ldi	r25, 0x09	; 9
    15f0:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15f4:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    15f6:	80 eb       	ldi	r24, 0xB0	; 176
    15f8:	99 e0       	ldi	r25, 0x09	; 9
    15fa:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    15fe:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
    1600:	80 eb       	ldi	r24, 0xB0	; 176
    1602:	99 e0       	ldi	r25, 0x09	; 9
    1604:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    1608:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    160a:	80 eb       	ldi	r24, 0xB0	; 176
    160c:	99 e0       	ldi	r25, 0x09	; 9
    160e:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    1612:	08 2f       	mov	r16, r24
    1614:	14 c0       	rjmp	.+40     	; 0x163e <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
    1616:	80 eb       	ldi	r24, 0xB0	; 176
    1618:	99 e0       	ldi	r25, 0x09	; 9
    161a:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    161e:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    1620:	80 eb       	ldi	r24, 0xB0	; 176
    1622:	99 e0       	ldi	r25, 0x09	; 9
    1624:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    1628:	08 2f       	mov	r16, r24
      yhm = Wire.read();
    162a:	80 eb       	ldi	r24, 0xB0	; 176
    162c:	99 e0       	ldi	r25, 0x09	; 9
    162e:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    1632:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    1634:	80 eb       	ldi	r24, 0xB0	; 176
    1636:	99 e0       	ldi	r25, 0x09	; 9
    1638:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    163c:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
    163e:	6c 2d       	mov	r22, r12
    1640:	70 e0       	ldi	r23, 0x00	; 0
    1642:	7d 29       	or	r23, r13
    1644:	7f 83       	std	Y+7, r23	; 0x07
    1646:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
    1648:	4e 2d       	mov	r20, r14
    164a:	50 e0       	ldi	r21, 0x00	; 0
    164c:	5f 29       	or	r21, r15
    164e:	59 87       	std	Y+9, r21	; 0x09
    1650:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
    1652:	20 2f       	mov	r18, r16
    1654:	30 e0       	ldi	r19, 0x00	; 0
    1656:	c9 01       	movw	r24, r18
    1658:	91 2b       	or	r25, r17
    165a:	9b 87       	std	Y+11, r25	; 0x0b
    165c:	8a 87       	std	Y+10, r24	; 0x0a
}
    165e:	df 91       	pop	r29
    1660:	cf 91       	pop	r28
    1662:	1f 91       	pop	r17
    1664:	0f 91       	pop	r16
    1666:	ff 90       	pop	r15
    1668:	ef 90       	pop	r14
    166a:	df 90       	pop	r13
    166c:	cf 90       	pop	r12
    166e:	08 95       	ret

00001670 <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
    1670:	cf 93       	push	r28
    1672:	df 93       	push	r29
    1674:	ec 01       	movw	r28, r24
  readAcc();
    1676:	c8 de       	rcall	.-624    	; 0x1408 <_ZN6LSM3037readAccEv>
  readMag();
    1678:	ce 01       	movw	r24, r28
    167a:	3f df       	rcall	.-386    	; 0x14fa <_ZN6LSM3037readMagEv>
}
    167c:	df 91       	pop	r29
    167e:	cf 91       	pop	r28
    1680:	08 95       	ret

00001682 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
    1682:	cf 93       	push	r28
    1684:	df 93       	push	r29
    1686:	c6 2f       	mov	r28, r22
    1688:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
    168a:	80 eb       	ldi	r24, 0xB0	; 176
    168c:	99 e0       	ldi	r25, 0x09	; 9
    168e:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
    1692:	6d 2f       	mov	r22, r29
    1694:	80 eb       	ldi	r24, 0xB0	; 176
    1696:	99 e0       	ldi	r25, 0x09	; 9
    1698:	0e 94 49 17 	call	0x2e92	; 0x2e92 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
    169c:	80 eb       	ldi	r24, 0xB0	; 176
    169e:	99 e0       	ldi	r25, 0x09	; 9
    16a0:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7TwoWire15endTransmissionEv>
    16a4:	81 11       	cpse	r24, r1
    16a6:	11 c0       	rjmp	.+34     	; 0x16ca <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
    16a8:	41 e0       	ldi	r20, 0x01	; 1
    16aa:	6c 2f       	mov	r22, r28
    16ac:	80 eb       	ldi	r24, 0xB0	; 176
    16ae:	99 e0       	ldi	r25, 0x09	; 9
    16b0:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
    16b4:	80 eb       	ldi	r24, 0xB0	; 176
    16b6:	99 e0       	ldi	r25, 0x09	; 9
    16b8:	0e 94 ef 16 	call	0x2dde	; 0x2dde <_ZN7TwoWire9availableEv>
    16bc:	89 2b       	or	r24, r25
    16be:	41 f0       	breq	.+16     	; 0x16d0 <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
    16c0:	80 eb       	ldi	r24, 0xB0	; 176
    16c2:	99 e0       	ldi	r25, 0x09	; 9
    16c4:	0e 94 f7 16 	call	0x2dee	; 0x2dee <_ZN7TwoWire4readEv>
    16c8:	05 c0       	rjmp	.+10     	; 0x16d4 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
    16ca:	8f ef       	ldi	r24, 0xFF	; 255
    16cc:	9f ef       	ldi	r25, 0xFF	; 255
    16ce:	02 c0       	rjmp	.+4      	; 0x16d4 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
    16d0:	8f ef       	ldi	r24, 0xFF	; 255
    16d2:	9f ef       	ldi	r25, 0xFF	; 255
  }
    16d4:	df 91       	pop	r29
    16d6:	cf 91       	pop	r28
    16d8:	08 95       	ret

000016da <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
    16da:	0f 93       	push	r16
    16dc:	1f 93       	push	r17
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	ec 01       	movw	r28, r24
    16e4:	16 2f       	mov	r17, r22
    16e6:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
    16e8:	64 30       	cpi	r22, 0x04	; 4
    16ea:	09 f4       	brne	.+2      	; 0x16ee <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
    16ec:	ad c0       	rjmp	.+346    	; 0x1848 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
    16ee:	42 30       	cpi	r20, 0x02	; 2
    16f0:	09 f0       	breq	.+2      	; 0x16f4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
    16f2:	47 c0       	rjmp	.+142    	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    16f4:	ad c0       	rjmp	.+346    	; 0x1850 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    16f6:	4f e0       	ldi	r20, 0x0F	; 15
    16f8:	6d e1       	ldi	r22, 0x1D	; 29
    16fa:	ce 01       	movw	r24, r28
    16fc:	c2 df       	rcall	.-124    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    16fe:	89 34       	cpi	r24, 0x49	; 73
    1700:	91 05       	cpc	r25, r1
    1702:	09 f4       	brne	.+2      	; 0x1706 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
    1704:	ab c0       	rjmp	.+342    	; 0x185c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1706:	01 30       	cpi	r16, 0x01	; 1
    1708:	41 f0       	breq	.+16     	; 0x171a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    170a:	4f e0       	ldi	r20, 0x0F	; 15
    170c:	6e e1       	ldi	r22, 0x1E	; 30
    170e:	ce 01       	movw	r24, r28
    1710:	b8 df       	rcall	.-144    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1712:	89 34       	cpi	r24, 0x49	; 73
    1714:	91 05       	cpc	r25, r1
    1716:	09 f4       	brne	.+2      	; 0x171a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1718:	a3 c0       	rjmp	.+326    	; 0x1860 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
    171a:	14 30       	cpi	r17, 0x04	; 4
    171c:	11 f0       	breq	.+4      	; 0x1722 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
    171e:	13 30       	cpi	r17, 0x03	; 3
    1720:	68 f5       	brcc	.+90     	; 0x177c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    1722:	00 23       	and	r16, r16
    1724:	a9 f0       	breq	.+42     	; 0x1750 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
    1726:	40 e2       	ldi	r20, 0x20	; 32
    1728:	69 e1       	ldi	r22, 0x19	; 25
    172a:	ce 01       	movw	r24, r28
    172c:	aa df       	rcall	.-172    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    172e:	01 96       	adiw	r24, 0x01	; 1
    1730:	69 f0       	breq	.+26     	; 0x174c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
    1732:	14 30       	cpi	r17, 0x04	; 4
    1734:	09 f0       	breq	.+2      	; 0x1738 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
    1736:	99 c0       	rjmp	.+306    	; 0x186a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1738:	4f e0       	ldi	r20, 0x0F	; 15
    173a:	6e e1       	ldi	r22, 0x1E	; 30
    173c:	ce 01       	movw	r24, r28
    173e:	a1 df       	rcall	.-190    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1740:	cc 97       	sbiw	r24, 0x3c	; 60
    1742:	09 f0       	breq	.+2      	; 0x1746 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
    1744:	94 c0       	rjmp	.+296    	; 0x186e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    1746:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1748:	12 e0       	ldi	r17, 0x02	; 2
    174a:	1b c0       	rjmp	.+54     	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    174c:	01 30       	cpi	r16, 0x01	; 1
    174e:	99 f0       	breq	.+38     	; 0x1776 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
    1750:	40 e2       	ldi	r20, 0x20	; 32
    1752:	68 e1       	ldi	r22, 0x18	; 24
    1754:	ce 01       	movw	r24, r28
    1756:	95 df       	rcall	.-214    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1758:	01 96       	adiw	r24, 0x01	; 1
    175a:	69 f0       	breq	.+26     	; 0x1776 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
    175c:	14 30       	cpi	r17, 0x04	; 4
    175e:	09 f0       	breq	.+2      	; 0x1762 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
    1760:	89 c0       	rjmp	.+274    	; 0x1874 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
    1762:	4f e0       	ldi	r20, 0x0F	; 15
    1764:	6e e1       	ldi	r22, 0x1E	; 30
    1766:	ce 01       	movw	r24, r28
    1768:	8c df       	rcall	.-232    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    176a:	11 e0       	ldi	r17, 0x01	; 1
    176c:	cc 97       	sbiw	r24, 0x3c	; 60
    176e:	09 f0       	breq	.+2      	; 0x1772 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
    1770:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    1772:	00 e0       	ldi	r16, 0x00	; 0
    1774:	06 c0       	rjmp	.+12     	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    1776:	14 30       	cpi	r17, 0x04	; 4
    1778:	09 f4       	brne	.+2      	; 0x177c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    177a:	60 c0       	rjmp	.+192    	; 0x183c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
    177c:	02 30       	cpi	r16, 0x02	; 2
    177e:	09 f4       	brne	.+2      	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    1780:	5f c0       	rjmp	.+190    	; 0x1840 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
    1782:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
    1784:	11 30       	cpi	r17, 0x01	; 1
    1786:	71 f1       	breq	.+92     	; 0x17e4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
    1788:	08 f4       	brcc	.+2      	; 0x178c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
    178a:	42 c0       	rjmp	.+132    	; 0x1810 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
    178c:	12 30       	cpi	r17, 0x02	; 2
    178e:	c1 f0       	breq	.+48     	; 0x17c0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
    1790:	13 30       	cpi	r17, 0x03	; 3
    1792:	09 f0       	breq	.+2      	; 0x1796 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
    1794:	57 c0       	rjmp	.+174    	; 0x1844 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
    1796:	01 30       	cpi	r16, 0x01	; 1
    1798:	11 f4       	brne	.+4      	; 0x179e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
    179a:	8d e1       	ldi	r24, 0x1D	; 29
    179c:	01 c0       	rjmp	.+2      	; 0x17a0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
    179e:	8e e1       	ldi	r24, 0x1E	; 30
    17a0:	8b 8f       	std	Y+27, r24	; 0x1b
    17a2:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
    17a4:	88 e0       	ldi	r24, 0x08	; 8
    17a6:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
    17a8:	89 e0       	ldi	r24, 0x09	; 9
    17aa:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
    17ac:	8a e0       	ldi	r24, 0x0A	; 10
    17ae:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
    17b0:	8b e0       	ldi	r24, 0x0B	; 11
    17b2:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
    17b4:	8c e0       	ldi	r24, 0x0C	; 12
    17b6:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
    17b8:	8d e0       	ldi	r24, 0x0D	; 13
    17ba:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    17bc:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
    17be:	64 c0       	rjmp	.+200    	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
    17c0:	89 e1       	ldi	r24, 0x19	; 25
    17c2:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    17c4:	8e e1       	ldi	r24, 0x1E	; 30
    17c6:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
    17c8:	83 e0       	ldi	r24, 0x03	; 3
    17ca:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
    17cc:	84 e0       	ldi	r24, 0x04	; 4
    17ce:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
    17d0:	87 e0       	ldi	r24, 0x07	; 7
    17d2:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
    17d4:	88 e0       	ldi	r24, 0x08	; 8
    17d6:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
    17d8:	85 e0       	ldi	r24, 0x05	; 5
    17da:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
    17dc:	86 e0       	ldi	r24, 0x06	; 6
    17de:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    17e0:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
    17e2:	52 c0       	rjmp	.+164    	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    17e4:	01 30       	cpi	r16, 0x01	; 1
    17e6:	11 f4       	brne	.+4      	; 0x17ec <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
    17e8:	89 e1       	ldi	r24, 0x19	; 25
    17ea:	01 c0       	rjmp	.+2      	; 0x17ee <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
    17ec:	88 e1       	ldi	r24, 0x18	; 24
    17ee:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    17f0:	8e e1       	ldi	r24, 0x1E	; 30
    17f2:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
    17f4:	83 e0       	ldi	r24, 0x03	; 3
    17f6:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
    17f8:	84 e0       	ldi	r24, 0x04	; 4
    17fa:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
    17fc:	87 e0       	ldi	r24, 0x07	; 7
    17fe:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
    1800:	88 e0       	ldi	r24, 0x08	; 8
    1802:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
    1804:	85 e0       	ldi	r24, 0x05	; 5
    1806:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
    1808:	86 e0       	ldi	r24, 0x06	; 6
    180a:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    180c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
    180e:	3c c0       	rjmp	.+120    	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    1810:	01 30       	cpi	r16, 0x01	; 1
    1812:	11 f4       	brne	.+4      	; 0x1818 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
    1814:	89 e1       	ldi	r24, 0x19	; 25
    1816:	01 c0       	rjmp	.+2      	; 0x181a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
    1818:	88 e1       	ldi	r24, 0x18	; 24
    181a:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    181c:	8e e1       	ldi	r24, 0x1E	; 30
    181e:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
    1820:	83 e0       	ldi	r24, 0x03	; 3
    1822:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
    1824:	84 e0       	ldi	r24, 0x04	; 4
    1826:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
    1828:	85 e0       	ldi	r24, 0x05	; 5
    182a:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
    182c:	86 e0       	ldi	r24, 0x06	; 6
    182e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
    1830:	87 e0       	ldi	r24, 0x07	; 7
    1832:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
    1834:	88 e0       	ldi	r24, 0x08	; 8
    1836:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
    1838:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
    183a:	26 c0       	rjmp	.+76     	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
    183c:	80 e0       	ldi	r24, 0x00	; 0
    183e:	24 c0       	rjmp	.+72     	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    1840:	80 e0       	ldi	r24, 0x00	; 0
    1842:	22 c0       	rjmp	.+68     	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    1844:	81 e0       	ldi	r24, 0x01	; 1
    1846:	20 c0       	rjmp	.+64     	; 0x1888 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1848:	44 23       	and	r20, r20
    184a:	09 f4       	brne	.+2      	; 0x184e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
    184c:	5e cf       	rjmp	.-324    	; 0x170a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
    184e:	53 cf       	rjmp	.-346    	; 0x16f6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    1850:	8d ef       	ldi	r24, 0xFD	; 253
    1852:	86 0f       	add	r24, r22
    1854:	82 30       	cpi	r24, 0x02	; 2
    1856:	08 f0       	brcs	.+2      	; 0x185a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
    1858:	62 cf       	rjmp	.-316    	; 0x171e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
    185a:	0e c0       	rjmp	.+28     	; 0x1878 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    185c:	01 e0       	ldi	r16, 0x01	; 1
    185e:	03 c0       	rjmp	.+6      	; 0x1866 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
    1860:	00 e0       	ldi	r16, 0x00	; 0
    1862:	01 c0       	rjmp	.+2      	; 0x1866 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    1864:	01 e0       	ldi	r16, 0x01	; 1
    1866:	13 e0       	ldi	r17, 0x03	; 3
    1868:	89 cf       	rjmp	.-238    	; 0x177c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    186a:	01 e0       	ldi	r16, 0x01	; 1
    186c:	8a cf       	rjmp	.-236    	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    186e:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    1870:	10 e0       	ldi	r17, 0x00	; 0
    1872:	87 cf       	rjmp	.-242    	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    1874:	00 e0       	ldi	r16, 0x00	; 0
    1876:	85 cf       	rjmp	.-246    	; 0x1782 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1878:	4f e0       	ldi	r20, 0x0F	; 15
    187a:	6d e1       	ldi	r22, 0x1D	; 29
    187c:	ce 01       	movw	r24, r28
    187e:	01 df       	rcall	.-510    	; 0x1682 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1880:	89 34       	cpi	r24, 0x49	; 73
    1882:	91 05       	cpc	r25, r1
    1884:	79 f3       	breq	.-34     	; 0x1864 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
    1886:	41 cf       	rjmp	.-382    	; 0x170a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
    1888:	df 91       	pop	r29
    188a:	cf 91       	pop	r28
    188c:	1f 91       	pop	r17
    188e:	0f 91       	pop	r16
    1890:	08 95       	ret

00001892 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1892:	31 e1       	ldi	r19, 0x11	; 17
    1894:	fc 01       	movw	r30, r24
    1896:	30 83       	st	Z, r19
    1898:	31 97       	sbiw	r30, 0x01	; 1
    189a:	22 e2       	ldi	r18, 0x22	; 34
    189c:	20 83       	st	Z, r18
    189e:	31 97       	sbiw	r30, 0x01	; 1
    18a0:	a3 e3       	ldi	r26, 0x33	; 51
    18a2:	a0 83       	st	Z, r26
    18a4:	31 97       	sbiw	r30, 0x01	; 1
    18a6:	60 83       	st	Z, r22
    18a8:	31 97       	sbiw	r30, 0x01	; 1
    18aa:	70 83       	st	Z, r23
    18ac:	31 97       	sbiw	r30, 0x01	; 1
    18ae:	10 82       	st	Z, r1
    18b0:	31 97       	sbiw	r30, 0x01	; 1
    18b2:	10 82       	st	Z, r1
    18b4:	31 97       	sbiw	r30, 0x01	; 1
    18b6:	60 e8       	ldi	r22, 0x80	; 128
    18b8:	60 83       	st	Z, r22
    18ba:	31 97       	sbiw	r30, 0x01	; 1
    18bc:	10 82       	st	Z, r1
    18be:	31 97       	sbiw	r30, 0x01	; 1
    18c0:	10 82       	st	Z, r1
    18c2:	31 97       	sbiw	r30, 0x01	; 1
    18c4:	10 82       	st	Z, r1
    18c6:	31 97       	sbiw	r30, 0x01	; 1
    18c8:	62 e0       	ldi	r22, 0x02	; 2
    18ca:	60 83       	st	Z, r22
    18cc:	31 97       	sbiw	r30, 0x01	; 1
    18ce:	63 e0       	ldi	r22, 0x03	; 3
    18d0:	60 83       	st	Z, r22
    18d2:	31 97       	sbiw	r30, 0x01	; 1
    18d4:	64 e0       	ldi	r22, 0x04	; 4
    18d6:	60 83       	st	Z, r22
    18d8:	31 97       	sbiw	r30, 0x01	; 1
    18da:	65 e0       	ldi	r22, 0x05	; 5
    18dc:	60 83       	st	Z, r22
    18de:	31 97       	sbiw	r30, 0x01	; 1
    18e0:	66 e0       	ldi	r22, 0x06	; 6
    18e2:	60 83       	st	Z, r22
    18e4:	31 97       	sbiw	r30, 0x01	; 1
    18e6:	67 e0       	ldi	r22, 0x07	; 7
    18e8:	60 83       	st	Z, r22
    18ea:	31 97       	sbiw	r30, 0x01	; 1
    18ec:	68 e0       	ldi	r22, 0x08	; 8
    18ee:	60 83       	st	Z, r22
    18f0:	31 97       	sbiw	r30, 0x01	; 1
    18f2:	69 e0       	ldi	r22, 0x09	; 9
    18f4:	60 83       	st	Z, r22
    18f6:	31 97       	sbiw	r30, 0x01	; 1
    18f8:	60 e1       	ldi	r22, 0x10	; 16
    18fa:	60 83       	st	Z, r22
    18fc:	31 97       	sbiw	r30, 0x01	; 1
    18fe:	30 83       	st	Z, r19
    1900:	31 97       	sbiw	r30, 0x01	; 1
    1902:	32 e1       	ldi	r19, 0x12	; 18
    1904:	30 83       	st	Z, r19
    1906:	31 97       	sbiw	r30, 0x01	; 1
    1908:	33 e1       	ldi	r19, 0x13	; 19
    190a:	30 83       	st	Z, r19
    190c:	31 97       	sbiw	r30, 0x01	; 1
    190e:	34 e1       	ldi	r19, 0x14	; 20
    1910:	30 83       	st	Z, r19
    1912:	31 97       	sbiw	r30, 0x01	; 1
    1914:	35 e1       	ldi	r19, 0x15	; 21
    1916:	30 83       	st	Z, r19
    1918:	31 97       	sbiw	r30, 0x01	; 1
    191a:	36 e1       	ldi	r19, 0x16	; 22
    191c:	30 83       	st	Z, r19
    191e:	31 97       	sbiw	r30, 0x01	; 1
    1920:	37 e1       	ldi	r19, 0x17	; 23
    1922:	30 83       	st	Z, r19
    1924:	31 97       	sbiw	r30, 0x01	; 1
    1926:	38 e1       	ldi	r19, 0x18	; 24
    1928:	30 83       	st	Z, r19
    192a:	31 97       	sbiw	r30, 0x01	; 1
    192c:	39 e1       	ldi	r19, 0x19	; 25
    192e:	30 83       	st	Z, r19
    1930:	31 97       	sbiw	r30, 0x01	; 1
    1932:	30 e2       	ldi	r19, 0x20	; 32
    1934:	30 83       	st	Z, r19
    1936:	31 97       	sbiw	r30, 0x01	; 1
    1938:	31 e2       	ldi	r19, 0x21	; 33
    193a:	30 83       	st	Z, r19
    193c:	31 97       	sbiw	r30, 0x01	; 1
    193e:	20 83       	st	Z, r18
    1940:	31 97       	sbiw	r30, 0x01	; 1
    1942:	23 e2       	ldi	r18, 0x23	; 35
    1944:	20 83       	st	Z, r18
    1946:	31 97       	sbiw	r30, 0x01	; 1
    1948:	40 83       	st	Z, r20
    194a:	31 97       	sbiw	r30, 0x01	; 1
    194c:	50 83       	st	Z, r21
    194e:	31 97       	sbiw	r30, 0x01	; 1
    1950:	26 e2       	ldi	r18, 0x26	; 38
    1952:	20 83       	st	Z, r18
    1954:	31 97       	sbiw	r30, 0x01	; 1
    1956:	27 e2       	ldi	r18, 0x27	; 39
    1958:	20 83       	st	Z, r18
    195a:	31 97       	sbiw	r30, 0x01	; 1
    195c:	28 e2       	ldi	r18, 0x28	; 40
    195e:	20 83       	st	Z, r18
    1960:	31 97       	sbiw	r30, 0x01	; 1
    1962:	29 e2       	ldi	r18, 0x29	; 41
    1964:	20 83       	st	Z, r18
    1966:	31 97       	sbiw	r30, 0x01	; 1
    1968:	20 e3       	ldi	r18, 0x30	; 48
    196a:	20 83       	st	Z, r18
    196c:	31 97       	sbiw	r30, 0x01	; 1
    196e:	21 e3       	ldi	r18, 0x31	; 49
    1970:	20 83       	st	Z, r18
    1972:	89 97       	sbiw	r24, 0x29	; 41
    1974:	08 95       	ret

00001976 <xPortStartScheduler>:
    1976:	82 e0       	ldi	r24, 0x02	; 2
    1978:	80 93 b0 00 	sts	0x00B0, r24
    197c:	10 92 b2 00 	sts	0x00B2, r1
    1980:	8a ef       	ldi	r24, 0xFA	; 250
    1982:	80 93 b3 00 	sts	0x00B3, r24
    1986:	e0 e7       	ldi	r30, 0x70	; 112
    1988:	f0 e0       	ldi	r31, 0x00	; 0
    198a:	80 81       	ld	r24, Z
    198c:	82 60       	ori	r24, 0x02	; 2
    198e:	80 83       	st	Z, r24
    1990:	84 e0       	ldi	r24, 0x04	; 4
    1992:	80 93 b1 00 	sts	0x00B1, r24
    1996:	a0 91 40 09 	lds	r26, 0x0940
    199a:	b0 91 41 09 	lds	r27, 0x0941
    199e:	cd 91       	ld	r28, X+
    19a0:	cd bf       	out	0x3d, r28	; 61
    19a2:	dd 91       	ld	r29, X+
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	ff 91       	pop	r31
    19a8:	ef 91       	pop	r30
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	bf 91       	pop	r27
    19b0:	af 91       	pop	r26
    19b2:	9f 91       	pop	r25
    19b4:	8f 91       	pop	r24
    19b6:	7f 91       	pop	r23
    19b8:	6f 91       	pop	r22
    19ba:	5f 91       	pop	r21
    19bc:	4f 91       	pop	r20
    19be:	3f 91       	pop	r19
    19c0:	2f 91       	pop	r18
    19c2:	1f 91       	pop	r17
    19c4:	0f 91       	pop	r16
    19c6:	ff 90       	pop	r15
    19c8:	ef 90       	pop	r14
    19ca:	df 90       	pop	r13
    19cc:	cf 90       	pop	r12
    19ce:	bf 90       	pop	r11
    19d0:	af 90       	pop	r10
    19d2:	9f 90       	pop	r9
    19d4:	8f 90       	pop	r8
    19d6:	7f 90       	pop	r7
    19d8:	6f 90       	pop	r6
    19da:	5f 90       	pop	r5
    19dc:	4f 90       	pop	r4
    19de:	3f 90       	pop	r3
    19e0:	2f 90       	pop	r2
    19e2:	1f 90       	pop	r1
    19e4:	0f 90       	pop	r0
    19e6:	0c be       	out	0x3c, r0	; 60
    19e8:	0f 90       	pop	r0
    19ea:	0b be       	out	0x3b, r0	; 59
    19ec:	0f 90       	pop	r0
    19ee:	0f be       	out	0x3f, r0	; 63
    19f0:	0f 90       	pop	r0
    19f2:	08 95       	ret
    19f4:	81 e0       	ldi	r24, 0x01	; 1
    19f6:	08 95       	ret

000019f8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    19f8:	0f 92       	push	r0
    19fa:	0f b6       	in	r0, 0x3f	; 63
    19fc:	f8 94       	cli
    19fe:	0f 92       	push	r0
    1a00:	0c b6       	in	r0, 0x3c	; 60
    1a02:	0f 92       	push	r0
    1a04:	0b b6       	in	r0, 0x3b	; 59
    1a06:	0f 92       	push	r0
    1a08:	1f 92       	push	r1
    1a0a:	11 24       	eor	r1, r1
    1a0c:	2f 92       	push	r2
    1a0e:	3f 92       	push	r3
    1a10:	4f 92       	push	r4
    1a12:	5f 92       	push	r5
    1a14:	6f 92       	push	r6
    1a16:	7f 92       	push	r7
    1a18:	8f 92       	push	r8
    1a1a:	9f 92       	push	r9
    1a1c:	af 92       	push	r10
    1a1e:	bf 92       	push	r11
    1a20:	cf 92       	push	r12
    1a22:	df 92       	push	r13
    1a24:	ef 92       	push	r14
    1a26:	ff 92       	push	r15
    1a28:	0f 93       	push	r16
    1a2a:	1f 93       	push	r17
    1a2c:	2f 93       	push	r18
    1a2e:	3f 93       	push	r19
    1a30:	4f 93       	push	r20
    1a32:	5f 93       	push	r21
    1a34:	6f 93       	push	r22
    1a36:	7f 93       	push	r23
    1a38:	8f 93       	push	r24
    1a3a:	9f 93       	push	r25
    1a3c:	af 93       	push	r26
    1a3e:	bf 93       	push	r27
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
    1a44:	ef 93       	push	r30
    1a46:	ff 93       	push	r31
    1a48:	a0 91 40 09 	lds	r26, 0x0940
    1a4c:	b0 91 41 09 	lds	r27, 0x0941
    1a50:	0d b6       	in	r0, 0x3d	; 61
    1a52:	0d 92       	st	X+, r0
    1a54:	0e b6       	in	r0, 0x3e	; 62
    1a56:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1a58:	4f d7       	rcall	.+3742   	; 0x28f8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a5a:	a0 91 40 09 	lds	r26, 0x0940
    1a5e:	b0 91 41 09 	lds	r27, 0x0941
    1a62:	cd 91       	ld	r28, X+
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	dd 91       	ld	r29, X+
    1a68:	de bf       	out	0x3e, r29	; 62
    1a6a:	ff 91       	pop	r31
    1a6c:	ef 91       	pop	r30
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	bf 91       	pop	r27
    1a74:	af 91       	pop	r26
    1a76:	9f 91       	pop	r25
    1a78:	8f 91       	pop	r24
    1a7a:	7f 91       	pop	r23
    1a7c:	6f 91       	pop	r22
    1a7e:	5f 91       	pop	r21
    1a80:	4f 91       	pop	r20
    1a82:	3f 91       	pop	r19
    1a84:	2f 91       	pop	r18
    1a86:	1f 91       	pop	r17
    1a88:	0f 91       	pop	r16
    1a8a:	ff 90       	pop	r15
    1a8c:	ef 90       	pop	r14
    1a8e:	df 90       	pop	r13
    1a90:	cf 90       	pop	r12
    1a92:	bf 90       	pop	r11
    1a94:	af 90       	pop	r10
    1a96:	9f 90       	pop	r9
    1a98:	8f 90       	pop	r8
    1a9a:	7f 90       	pop	r7
    1a9c:	6f 90       	pop	r6
    1a9e:	5f 90       	pop	r5
    1aa0:	4f 90       	pop	r4
    1aa2:	3f 90       	pop	r3
    1aa4:	2f 90       	pop	r2
    1aa6:	1f 90       	pop	r1
    1aa8:	0f 90       	pop	r0
    1aaa:	0c be       	out	0x3c, r0	; 60
    1aac:	0f 90       	pop	r0
    1aae:	0b be       	out	0x3b, r0	; 59
    1ab0:	0f 90       	pop	r0
    1ab2:	0f be       	out	0x3f, r0	; 63
    1ab4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ab6:	08 95       	ret

00001ab8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ab8:	0f 92       	push	r0
    1aba:	0f b6       	in	r0, 0x3f	; 63
    1abc:	f8 94       	cli
    1abe:	0f 92       	push	r0
    1ac0:	0c b6       	in	r0, 0x3c	; 60
    1ac2:	0f 92       	push	r0
    1ac4:	0b b6       	in	r0, 0x3b	; 59
    1ac6:	0f 92       	push	r0
    1ac8:	1f 92       	push	r1
    1aca:	11 24       	eor	r1, r1
    1acc:	2f 92       	push	r2
    1ace:	3f 92       	push	r3
    1ad0:	4f 92       	push	r4
    1ad2:	5f 92       	push	r5
    1ad4:	6f 92       	push	r6
    1ad6:	7f 92       	push	r7
    1ad8:	8f 92       	push	r8
    1ada:	9f 92       	push	r9
    1adc:	af 92       	push	r10
    1ade:	bf 92       	push	r11
    1ae0:	cf 92       	push	r12
    1ae2:	df 92       	push	r13
    1ae4:	ef 92       	push	r14
    1ae6:	ff 92       	push	r15
    1ae8:	0f 93       	push	r16
    1aea:	1f 93       	push	r17
    1aec:	2f 93       	push	r18
    1aee:	3f 93       	push	r19
    1af0:	4f 93       	push	r20
    1af2:	5f 93       	push	r21
    1af4:	6f 93       	push	r22
    1af6:	7f 93       	push	r23
    1af8:	8f 93       	push	r24
    1afa:	9f 93       	push	r25
    1afc:	af 93       	push	r26
    1afe:	bf 93       	push	r27
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
    1b04:	ef 93       	push	r30
    1b06:	ff 93       	push	r31
    1b08:	a0 91 40 09 	lds	r26, 0x0940
    1b0c:	b0 91 41 09 	lds	r27, 0x0941
    1b10:	0d b6       	in	r0, 0x3d	; 61
    1b12:	0d 92       	st	X+, r0
    1b14:	0e b6       	in	r0, 0x3e	; 62
    1b16:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1b18:	5b d5       	rcall	.+2742   	; 0x25d0 <xTaskIncrementTick>
    1b1a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1b1c:	ed d6       	rcall	.+3546   	; 0x28f8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1b1e:	a0 91 40 09 	lds	r26, 0x0940
    1b22:	b0 91 41 09 	lds	r27, 0x0941
    1b26:	cd 91       	ld	r28, X+
    1b28:	cd bf       	out	0x3d, r28	; 61
    1b2a:	dd 91       	ld	r29, X+
    1b2c:	de bf       	out	0x3e, r29	; 62
    1b2e:	ff 91       	pop	r31
    1b30:	ef 91       	pop	r30
    1b32:	df 91       	pop	r29
    1b34:	cf 91       	pop	r28
    1b36:	bf 91       	pop	r27
    1b38:	af 91       	pop	r26
    1b3a:	9f 91       	pop	r25
    1b3c:	8f 91       	pop	r24
    1b3e:	7f 91       	pop	r23
    1b40:	6f 91       	pop	r22
    1b42:	5f 91       	pop	r21
    1b44:	4f 91       	pop	r20
    1b46:	3f 91       	pop	r19
    1b48:	2f 91       	pop	r18
    1b4a:	1f 91       	pop	r17
    1b4c:	0f 91       	pop	r16
    1b4e:	ff 90       	pop	r15
    1b50:	ef 90       	pop	r14
    1b52:	df 90       	pop	r13
    1b54:	cf 90       	pop	r12
    1b56:	bf 90       	pop	r11
    1b58:	af 90       	pop	r10
    1b5a:	9f 90       	pop	r9
    1b5c:	8f 90       	pop	r8
    1b5e:	7f 90       	pop	r7
    1b60:	6f 90       	pop	r6
    1b62:	5f 90       	pop	r5
    1b64:	4f 90       	pop	r4
    1b66:	3f 90       	pop	r3
    1b68:	2f 90       	pop	r2
    1b6a:	1f 90       	pop	r1
    1b6c:	0f 90       	pop	r0
    1b6e:	0c be       	out	0x3c, r0	; 60
    1b70:	0f 90       	pop	r0
    1b72:	0b be       	out	0x3b, r0	; 59
    1b74:	0f 90       	pop	r0
    1b76:	0f be       	out	0x3f, r0	; 63
    1b78:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b7a:	08 95       	ret

00001b7c <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    1b7c:	9d df       	rcall	.-198    	; 0x1ab8 <vPortYieldFromTick>
	asm volatile ( "reti" );
    1b7e:	18 95       	reti

00001b80 <_Z13taskReadSonarPv>:
	int distance;
	while(1) {
		distance = sharp.distance();
		data[10] = distance;
		
		vTaskDelay(500);
    1b80:	0f 2e       	mov	r0, r31
    1b82:	fc e0       	ldi	r31, 0x0C	; 12
    1b84:	ef 2e       	mov	r14, r31
    1b86:	f2 e0       	ldi	r31, 0x02	; 2
    1b88:	ff 2e       	mov	r15, r31
    1b8a:	f0 2d       	mov	r31, r0
    1b8c:	0f 2e       	mov	r0, r31
    1b8e:	fe e0       	ldi	r31, 0x0E	; 14
    1b90:	cf 2e       	mov	r12, r31
    1b92:	f2 e0       	ldi	r31, 0x02	; 2
    1b94:	df 2e       	mov	r13, r31
    1b96:	f0 2d       	mov	r31, r0
    1b98:	0f 2e       	mov	r0, r31
    1b9a:	f8 e8       	ldi	r31, 0x88	; 136
    1b9c:	8f 2e       	mov	r8, r31
    1b9e:	f8 e0       	ldi	r31, 0x08	; 8
    1ba0:	9f 2e       	mov	r9, r31
    1ba2:	f0 2d       	mov	r31, r0
    1ba4:	08 e0       	ldi	r16, 0x08	; 8
    1ba6:	12 e0       	ldi	r17, 0x02	; 2
    1ba8:	0f 2e       	mov	r0, r31
    1baa:	fa e0       	ldi	r31, 0x0A	; 10
    1bac:	af 2e       	mov	r10, r31
    1bae:	f2 e0       	ldi	r31, 0x02	; 2
    1bb0:	bf 2e       	mov	r11, r31
    1bb2:	f0 2d       	mov	r31, r0
    1bb4:	0f 2e       	mov	r0, r31
    1bb6:	fa e8       	ldi	r31, 0x8A	; 138
    1bb8:	6f 2e       	mov	r6, r31
    1bba:	f8 e0       	ldi	r31, 0x08	; 8
    1bbc:	7f 2e       	mov	r7, r31
    1bbe:	f0 2d       	mov	r31, r0
    1bc0:	c4 e0       	ldi	r28, 0x04	; 4
    1bc2:	d2 e0       	ldi	r29, 0x02	; 2
    1bc4:	0f 2e       	mov	r0, r31
    1bc6:	f6 e0       	ldi	r31, 0x06	; 6
    1bc8:	4f 2e       	mov	r4, r31
    1bca:	f2 e0       	ldi	r31, 0x02	; 2
    1bcc:	5f 2e       	mov	r5, r31
    1bce:	f0 2d       	mov	r31, r0
    1bd0:	0f 2e       	mov	r0, r31
    1bd2:	fc e8       	ldi	r31, 0x8C	; 140
    1bd4:	2f 2e       	mov	r2, r31
    1bd6:	f8 e0       	ldi	r31, 0x08	; 8
    1bd8:	3f 2e       	mov	r3, r31
    1bda:	f0 2d       	mov	r31, r0
    1bdc:	f3 d4       	rcall	.+2534   	; 0x25c4 <vTaskSuspendAll>
    1bde:	60 e0       	ldi	r22, 0x00	; 0
    1be0:	f7 01       	movw	r30, r14
    1be2:	80 81       	ld	r24, Z
    1be4:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1be8:	85 e0       	ldi	r24, 0x05	; 5
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <delayMicroseconds>
    1bf0:	61 e0       	ldi	r22, 0x01	; 1
    1bf2:	f7 01       	movw	r30, r14
    1bf4:	80 81       	ld	r24, Z
    1bf6:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1bfa:	8a e0       	ldi	r24, 0x0A	; 10
    1bfc:	90 e0       	ldi	r25, 0x00	; 0
    1bfe:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <delayMicroseconds>
    1c02:	60 e0       	ldi	r22, 0x00	; 0
    1c04:	f7 01       	movw	r30, r14
    1c06:	80 81       	ld	r24, Z
    1c08:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1c0c:	60 e0       	ldi	r22, 0x00	; 0
    1c0e:	f6 01       	movw	r30, r12
    1c10:	80 81       	ld	r24, Z
    1c12:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
    1c16:	20 e4       	ldi	r18, 0x40	; 64
    1c18:	32 e4       	ldi	r19, 0x42	; 66
    1c1a:	4f e0       	ldi	r20, 0x0F	; 15
    1c1c:	50 e0       	ldi	r21, 0x00	; 0
    1c1e:	61 e0       	ldi	r22, 0x01	; 1
    1c20:	f6 01       	movw	r30, r12
    1c22:	80 81       	ld	r24, Z
    1c24:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <pulseIn>
    1c28:	9b 01       	movw	r18, r22
    1c2a:	77 23       	and	r23, r23
    1c2c:	14 f4       	brge	.+4      	; 0x1c32 <_Z13taskReadSonarPv+0xb2>
    1c2e:	2f 5f       	subi	r18, 0xFF	; 255
    1c30:	3f 4f       	sbci	r19, 0xFF	; 255
    1c32:	b9 01       	movw	r22, r18
    1c34:	75 95       	asr	r23
    1c36:	67 95       	ror	r22
    1c38:	88 27       	eor	r24, r24
    1c3a:	77 fd       	sbrc	r23, 7
    1c3c:	80 95       	com	r24
    1c3e:	98 2f       	mov	r25, r24
    1c40:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1c44:	2d ec       	ldi	r18, 0xCD	; 205
    1c46:	3c ec       	ldi	r19, 0xCC	; 204
    1c48:	48 ee       	ldi	r20, 0xE8	; 232
    1c4a:	51 e4       	ldi	r21, 0x41	; 65
    1c4c:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1c50:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1c54:	f4 01       	movw	r30, r8
    1c56:	71 83       	std	Z+1, r23	; 0x01
    1c58:	60 83       	st	Z, r22
    1c5a:	60 e0       	ldi	r22, 0x00	; 0
    1c5c:	f8 01       	movw	r30, r16
    1c5e:	80 81       	ld	r24, Z
    1c60:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1c64:	85 e0       	ldi	r24, 0x05	; 5
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <delayMicroseconds>
    1c6c:	61 e0       	ldi	r22, 0x01	; 1
    1c6e:	f8 01       	movw	r30, r16
    1c70:	80 81       	ld	r24, Z
    1c72:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1c76:	8a e0       	ldi	r24, 0x0A	; 10
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <delayMicroseconds>
    1c7e:	60 e0       	ldi	r22, 0x00	; 0
    1c80:	f8 01       	movw	r30, r16
    1c82:	80 81       	ld	r24, Z
    1c84:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1c88:	20 e4       	ldi	r18, 0x40	; 64
    1c8a:	32 e4       	ldi	r19, 0x42	; 66
    1c8c:	4f e0       	ldi	r20, 0x0F	; 15
    1c8e:	50 e0       	ldi	r21, 0x00	; 0
    1c90:	61 e0       	ldi	r22, 0x01	; 1
    1c92:	f5 01       	movw	r30, r10
    1c94:	80 81       	ld	r24, Z
    1c96:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <pulseIn>
    1c9a:	9b 01       	movw	r18, r22
    1c9c:	77 23       	and	r23, r23
    1c9e:	14 f4       	brge	.+4      	; 0x1ca4 <_Z13taskReadSonarPv+0x124>
    1ca0:	2f 5f       	subi	r18, 0xFF	; 255
    1ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca4:	b9 01       	movw	r22, r18
    1ca6:	75 95       	asr	r23
    1ca8:	67 95       	ror	r22
    1caa:	88 27       	eor	r24, r24
    1cac:	77 fd       	sbrc	r23, 7
    1cae:	80 95       	com	r24
    1cb0:	98 2f       	mov	r25, r24
    1cb2:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1cb6:	2d ec       	ldi	r18, 0xCD	; 205
    1cb8:	3c ec       	ldi	r19, 0xCC	; 204
    1cba:	48 ee       	ldi	r20, 0xE8	; 232
    1cbc:	51 e4       	ldi	r21, 0x41	; 65
    1cbe:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1cc2:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1cc6:	f3 01       	movw	r30, r6
    1cc8:	71 83       	std	Z+1, r23	; 0x01
    1cca:	60 83       	st	Z, r22
    1ccc:	60 e0       	ldi	r22, 0x00	; 0
    1cce:	88 81       	ld	r24, Y
    1cd0:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1cd4:	85 e0       	ldi	r24, 0x05	; 5
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <delayMicroseconds>
    1cdc:	61 e0       	ldi	r22, 0x01	; 1
    1cde:	88 81       	ld	r24, Y
    1ce0:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1ce4:	8a e0       	ldi	r24, 0x0A	; 10
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <delayMicroseconds>
    1cec:	60 e0       	ldi	r22, 0x00	; 0
    1cee:	88 81       	ld	r24, Y
    1cf0:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    1cf4:	20 e4       	ldi	r18, 0x40	; 64
    1cf6:	32 e4       	ldi	r19, 0x42	; 66
    1cf8:	4f e0       	ldi	r20, 0x0F	; 15
    1cfa:	50 e0       	ldi	r21, 0x00	; 0
    1cfc:	61 e0       	ldi	r22, 0x01	; 1
    1cfe:	f2 01       	movw	r30, r4
    1d00:	80 81       	ld	r24, Z
    1d02:	0e 94 e8 20 	call	0x41d0	; 0x41d0 <pulseIn>
    1d06:	9b 01       	movw	r18, r22
    1d08:	77 23       	and	r23, r23
    1d0a:	14 f4       	brge	.+4      	; 0x1d10 <_Z13taskReadSonarPv+0x190>
    1d0c:	2f 5f       	subi	r18, 0xFF	; 255
    1d0e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d10:	b9 01       	movw	r22, r18
    1d12:	75 95       	asr	r23
    1d14:	67 95       	ror	r22
    1d16:	88 27       	eor	r24, r24
    1d18:	77 fd       	sbrc	r23, 7
    1d1a:	80 95       	com	r24
    1d1c:	98 2f       	mov	r25, r24
    1d1e:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1d22:	2d ec       	ldi	r18, 0xCD	; 205
    1d24:	3c ec       	ldi	r19, 0xCC	; 204
    1d26:	48 ee       	ldi	r20, 0xE8	; 232
    1d28:	51 e4       	ldi	r21, 0x41	; 65
    1d2a:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1d2e:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1d32:	f1 01       	movw	r30, r2
    1d34:	71 83       	std	Z+1, r23	; 0x01
    1d36:	60 83       	st	Z, r22
    1d38:	09 d5       	rcall	.+2578   	; 0x274c <xTaskResumeAll>
    1d3a:	84 ef       	ldi	r24, 0xF4	; 244
    1d3c:	91 e0       	ldi	r25, 0x01	; 1
    1d3e:	87 d5       	rcall	.+2830   	; 0x284e <vTaskDelay>
    1d40:	4d cf       	rjmp	.-358    	; 0x1bdc <_Z13taskReadSonarPv+0x5c>

00001d42 <_Z11taskReadAccPv>:
    1d42:	0f 2e       	mov	r0, r31
    1d44:	f3 ec       	ldi	r31, 0xC3	; 195
    1d46:	af 2e       	mov	r10, r31
    1d48:	f8 e0       	ldi	r31, 0x08	; 8
    1d4a:	bf 2e       	mov	r11, r31
    1d4c:	f0 2d       	mov	r31, r0
    1d4e:	05 ec       	ldi	r16, 0xC5	; 197
    1d50:	18 e0       	ldi	r17, 0x08	; 8
    1d52:	ce e8       	ldi	r28, 0x8E	; 142
    1d54:	d8 e0       	ldi	r29, 0x08	; 8
    1d56:	0f 2e       	mov	r0, r31
    1d58:	f0 e9       	ldi	r31, 0x90	; 144
    1d5a:	8f 2e       	mov	r8, r31
    1d5c:	f8 e0       	ldi	r31, 0x08	; 8
    1d5e:	9f 2e       	mov	r9, r31
    1d60:	f0 2d       	mov	r31, r0
    1d62:	0f 2e       	mov	r0, r31
    1d64:	f2 e9       	ldi	r31, 0x92	; 146
    1d66:	2f 2e       	mov	r2, r31
    1d68:	f8 e0       	ldi	r31, 0x08	; 8
    1d6a:	3f 2e       	mov	r3, r31
    1d6c:	f0 2d       	mov	r31, r0
    1d6e:	2a d4       	rcall	.+2132   	; 0x25c4 <vTaskSuspendAll>
    1d70:	81 ec       	ldi	r24, 0xC1	; 193
    1d72:	98 e0       	ldi	r25, 0x08	; 8
    1d74:	7d dc       	rcall	.-1798   	; 0x1670 <_ZN6LSM3034readEv>
    1d76:	ea d4       	rcall	.+2516   	; 0x274c <xTaskResumeAll>
    1d78:	f5 01       	movw	r30, r10
    1d7a:	60 81       	ld	r22, Z
    1d7c:	71 81       	ldd	r23, Z+1	; 0x01
    1d7e:	88 27       	eor	r24, r24
    1d80:	77 fd       	sbrc	r23, 7
    1d82:	80 95       	com	r24
    1d84:	98 2f       	mov	r25, r24
    1d86:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1d8a:	20 e0       	ldi	r18, 0x00	; 0
    1d8c:	30 e0       	ldi	r19, 0x00	; 0
    1d8e:	4a e7       	ldi	r20, 0x7A	; 122
    1d90:	54 e4       	ldi	r21, 0x44	; 68
    1d92:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1d96:	20 e0       	ldi	r18, 0x00	; 0
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	44 e7       	ldi	r20, 0x74	; 116
    1d9c:	52 e4       	ldi	r21, 0x42	; 66
    1d9e:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1da2:	2d ec       	ldi	r18, 0xCD	; 205
    1da4:	3c ec       	ldi	r19, 0xCC	; 204
    1da6:	4c e1       	ldi	r20, 0x1C	; 28
    1da8:	51 e4       	ldi	r21, 0x41	; 65
    1daa:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1dae:	20 e0       	ldi	r18, 0x00	; 0
    1db0:	30 e0       	ldi	r19, 0x00	; 0
    1db2:	40 e2       	ldi	r20, 0x20	; 32
    1db4:	51 e4       	ldi	r21, 0x41	; 65
    1db6:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1dba:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1dbe:	2b 01       	movw	r4, r22
    1dc0:	3c 01       	movw	r6, r24
    1dc2:	f8 01       	movw	r30, r16
    1dc4:	60 81       	ld	r22, Z
    1dc6:	71 81       	ldd	r23, Z+1	; 0x01
    1dc8:	88 27       	eor	r24, r24
    1dca:	77 fd       	sbrc	r23, 7
    1dcc:	80 95       	com	r24
    1dce:	98 2f       	mov	r25, r24
    1dd0:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1dd4:	20 e0       	ldi	r18, 0x00	; 0
    1dd6:	30 e0       	ldi	r19, 0x00	; 0
    1dd8:	4a e7       	ldi	r20, 0x7A	; 122
    1dda:	54 e4       	ldi	r21, 0x44	; 68
    1ddc:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1de0:	20 e0       	ldi	r18, 0x00	; 0
    1de2:	30 e0       	ldi	r19, 0x00	; 0
    1de4:	44 e7       	ldi	r20, 0x74	; 116
    1de6:	52 e4       	ldi	r21, 0x42	; 66
    1de8:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1dec:	2d ec       	ldi	r18, 0xCD	; 205
    1dee:	3c ec       	ldi	r19, 0xCC	; 204
    1df0:	4c e1       	ldi	r20, 0x1C	; 28
    1df2:	51 e4       	ldi	r21, 0x41	; 65
    1df4:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1df8:	20 e0       	ldi	r18, 0x00	; 0
    1dfa:	30 e0       	ldi	r19, 0x00	; 0
    1dfc:	40 e2       	ldi	r20, 0x20	; 32
    1dfe:	51 e4       	ldi	r21, 0x41	; 65
    1e00:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1e04:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1e08:	6b 01       	movw	r12, r22
    1e0a:	7c 01       	movw	r14, r24
    1e0c:	80 91 c1 08 	lds	r24, 0x08C1
    1e10:	90 91 c2 08 	lds	r25, 0x08C2
    1e14:	bc 01       	movw	r22, r24
    1e16:	88 27       	eor	r24, r24
    1e18:	77 fd       	sbrc	r23, 7
    1e1a:	80 95       	com	r24
    1e1c:	98 2f       	mov	r25, r24
    1e1e:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1e22:	20 e0       	ldi	r18, 0x00	; 0
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	4a e7       	ldi	r20, 0x7A	; 122
    1e28:	54 e4       	ldi	r21, 0x44	; 68
    1e2a:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1e2e:	20 e0       	ldi	r18, 0x00	; 0
    1e30:	30 e0       	ldi	r19, 0x00	; 0
    1e32:	44 e7       	ldi	r20, 0x74	; 116
    1e34:	52 e4       	ldi	r21, 0x42	; 66
    1e36:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1e3a:	2d ec       	ldi	r18, 0xCD	; 205
    1e3c:	3c ec       	ldi	r19, 0xCC	; 204
    1e3e:	4c e1       	ldi	r20, 0x1C	; 28
    1e40:	51 e4       	ldi	r21, 0x41	; 65
    1e42:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1e46:	20 e0       	ldi	r18, 0x00	; 0
    1e48:	30 e0       	ldi	r19, 0x00	; 0
    1e4a:	40 e2       	ldi	r20, 0x20	; 32
    1e4c:	51 e4       	ldi	r21, 0x41	; 65
    1e4e:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1e52:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1e56:	79 83       	std	Y+1, r23	; 0x01
    1e58:	68 83       	st	Y, r22
    1e5a:	f4 01       	movw	r30, r8
    1e5c:	51 82       	std	Z+1, r5	; 0x01
    1e5e:	40 82       	st	Z, r4
    1e60:	f1 01       	movw	r30, r2
    1e62:	d1 82       	std	Z+1, r13	; 0x01
    1e64:	c0 82       	st	Z, r12
    1e66:	84 ef       	ldi	r24, 0xF4	; 244
    1e68:	91 e0       	ldi	r25, 0x01	; 1
    1e6a:	f1 d4       	rcall	.+2530   	; 0x284e <vTaskDelay>
    1e6c:	80 cf       	rjmp	.-256    	; 0x1d6e <_Z11taskReadAccPv+0x2c>

00001e6e <_Z12taskReadGyroPv>:
    1e6e:	0f 2e       	mov	r0, r31
    1e70:	f7 eb       	ldi	r31, 0xB7	; 183
    1e72:	af 2e       	mov	r10, r31
    1e74:	f8 e0       	ldi	r31, 0x08	; 8
    1e76:	bf 2e       	mov	r11, r31
    1e78:	f0 2d       	mov	r31, r0
    1e7a:	09 eb       	ldi	r16, 0xB9	; 185
    1e7c:	18 e0       	ldi	r17, 0x08	; 8
    1e7e:	c4 e9       	ldi	r28, 0x94	; 148
    1e80:	d8 e0       	ldi	r29, 0x08	; 8
    1e82:	0f 2e       	mov	r0, r31
    1e84:	f6 e9       	ldi	r31, 0x96	; 150
    1e86:	8f 2e       	mov	r8, r31
    1e88:	f8 e0       	ldi	r31, 0x08	; 8
    1e8a:	9f 2e       	mov	r9, r31
    1e8c:	f0 2d       	mov	r31, r0
    1e8e:	0f 2e       	mov	r0, r31
    1e90:	f8 e9       	ldi	r31, 0x98	; 152
    1e92:	2f 2e       	mov	r2, r31
    1e94:	f8 e0       	ldi	r31, 0x08	; 8
    1e96:	3f 2e       	mov	r3, r31
    1e98:	f0 2d       	mov	r31, r0
    1e9a:	94 d3       	rcall	.+1832   	; 0x25c4 <vTaskSuspendAll>
    1e9c:	85 eb       	ldi	r24, 0xB5	; 181
    1e9e:	98 e0       	ldi	r25, 0x08	; 8
    1ea0:	0e 94 22 03 	call	0x644	; 0x644 <_ZN3L3G4readEv>
    1ea4:	53 d4       	rcall	.+2214   	; 0x274c <xTaskResumeAll>
    1ea6:	f5 01       	movw	r30, r10
    1ea8:	60 81       	ld	r22, Z
    1eaa:	71 81       	ldd	r23, Z+1	; 0x01
    1eac:	88 27       	eor	r24, r24
    1eae:	77 fd       	sbrc	r23, 7
    1eb0:	80 95       	com	r24
    1eb2:	98 2f       	mov	r25, r24
    1eb4:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1eb8:	20 e0       	ldi	r18, 0x00	; 0
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	4c e0       	ldi	r20, 0x0C	; 12
    1ebe:	51 e4       	ldi	r21, 0x41	; 65
    1ec0:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1ec4:	20 e0       	ldi	r18, 0x00	; 0
    1ec6:	30 e0       	ldi	r19, 0x00	; 0
    1ec8:	4a e7       	ldi	r20, 0x7A	; 122
    1eca:	54 e4       	ldi	r21, 0x44	; 68
    1ecc:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1ed0:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1ed4:	2b 01       	movw	r4, r22
    1ed6:	3c 01       	movw	r6, r24
    1ed8:	f8 01       	movw	r30, r16
    1eda:	60 81       	ld	r22, Z
    1edc:	71 81       	ldd	r23, Z+1	; 0x01
    1ede:	88 27       	eor	r24, r24
    1ee0:	77 fd       	sbrc	r23, 7
    1ee2:	80 95       	com	r24
    1ee4:	98 2f       	mov	r25, r24
    1ee6:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1eea:	20 e0       	ldi	r18, 0x00	; 0
    1eec:	30 e0       	ldi	r19, 0x00	; 0
    1eee:	4c e0       	ldi	r20, 0x0C	; 12
    1ef0:	51 e4       	ldi	r21, 0x41	; 65
    1ef2:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1ef6:	20 e0       	ldi	r18, 0x00	; 0
    1ef8:	30 e0       	ldi	r19, 0x00	; 0
    1efa:	4a e7       	ldi	r20, 0x7A	; 122
    1efc:	54 e4       	ldi	r21, 0x44	; 68
    1efe:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1f02:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1f06:	6b 01       	movw	r12, r22
    1f08:	7c 01       	movw	r14, r24
    1f0a:	80 91 b5 08 	lds	r24, 0x08B5
    1f0e:	90 91 b6 08 	lds	r25, 0x08B6
    1f12:	bc 01       	movw	r22, r24
    1f14:	88 27       	eor	r24, r24
    1f16:	77 fd       	sbrc	r23, 7
    1f18:	80 95       	com	r24
    1f1a:	98 2f       	mov	r25, r24
    1f1c:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1f20:	20 e0       	ldi	r18, 0x00	; 0
    1f22:	30 e0       	ldi	r19, 0x00	; 0
    1f24:	4c e0       	ldi	r20, 0x0C	; 12
    1f26:	51 e4       	ldi	r21, 0x41	; 65
    1f28:	0e 94 07 1a 	call	0x340e	; 0x340e <__mulsf3>
    1f2c:	20 e0       	ldi	r18, 0x00	; 0
    1f2e:	30 e0       	ldi	r19, 0x00	; 0
    1f30:	4a e7       	ldi	r20, 0x7A	; 122
    1f32:	54 e4       	ldi	r21, 0x44	; 68
    1f34:	0e 94 90 18 	call	0x3120	; 0x3120 <__divsf3>
    1f38:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1f3c:	79 83       	std	Y+1, r23	; 0x01
    1f3e:	68 83       	st	Y, r22
    1f40:	f4 01       	movw	r30, r8
    1f42:	51 82       	std	Z+1, r5	; 0x01
    1f44:	40 82       	st	Z, r4
    1f46:	f1 01       	movw	r30, r2
    1f48:	d1 82       	std	Z+1, r13	; 0x01
    1f4a:	c0 82       	st	Z, r12
    1f4c:	84 ef       	ldi	r24, 0xF4	; 244
    1f4e:	91 e0       	ldi	r25, 0x01	; 1
    1f50:	7e d4       	rcall	.+2300   	; 0x284e <vTaskDelay>
    1f52:	a3 cf       	rjmp	.-186    	; 0x1e9a <_Z12taskReadGyroPv+0x2c>

00001f54 <_Z15taskReadMagnetoPv>:
    1f54:	cc e9       	ldi	r28, 0x9C	; 156
    1f56:	d8 e0       	ldi	r29, 0x08	; 8
    1f58:	35 d3       	rcall	.+1642   	; 0x25c4 <vTaskSuspendAll>
    1f5a:	81 ec       	ldi	r24, 0xC1	; 193
    1f5c:	98 e0       	ldi	r25, 0x08	; 8
    1f5e:	88 db       	rcall	.-2288   	; 0x1670 <_ZN6LSM3034readEv>
    1f60:	f5 d3       	rcall	.+2026   	; 0x274c <xTaskResumeAll>
    1f62:	81 ec       	ldi	r24, 0xC1	; 193
    1f64:	98 e0       	ldi	r25, 0x08	; 8
    1f66:	95 d9       	rcall	.-3286   	; 0x1292 <_ZN6LSM3037headingEv>
    1f68:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1f6c:	79 83       	std	Y+1, r23	; 0x01
    1f6e:	68 83       	st	Y, r22
    1f70:	84 ef       	ldi	r24, 0xF4	; 244
    1f72:	91 e0       	ldi	r25, 0x01	; 1
    1f74:	6c d4       	rcall	.+2264   	; 0x284e <vTaskDelay>
    1f76:	f0 cf       	rjmp	.-32     	; 0x1f58 <_Z15taskReadMagnetoPv+0x4>

00001f78 <_Z17taskReadAltimeterPv>:
    1f78:	ce e9       	ldi	r28, 0x9E	; 158
    1f7a:	d8 e0       	ldi	r29, 0x08	; 8
    1f7c:	23 d3       	rcall	.+1606   	; 0x25c4 <vTaskSuspendAll>
    1f7e:	8e ea       	ldi	r24, 0xAE	; 174
    1f80:	98 e0       	ldi	r25, 0x08	; 8
    1f82:	0e 94 93 05 	call	0xb26	; 0xb26 <_ZN3LPS21readPressureMillibarsEv>
    1f86:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1f8a:	88 27       	eor	r24, r24
    1f8c:	77 fd       	sbrc	r23, 7
    1f8e:	80 95       	com	r24
    1f90:	98 2f       	mov	r25, r24
    1f92:	0e 94 2b 19 	call	0x3256	; 0x3256 <__floatsisf>
    1f96:	20 e0       	ldi	r18, 0x00	; 0
    1f98:	30 e5       	ldi	r19, 0x50	; 80
    1f9a:	4d e7       	ldi	r20, 0x7D	; 125
    1f9c:	54 e4       	ldi	r21, 0x44	; 68
    1f9e:	0e 94 ee 04 	call	0x9dc	; 0x9dc <_ZN3LPS24pressureToAltitudeMetersEff>
    1fa2:	6b 01       	movw	r12, r22
    1fa4:	7c 01       	movw	r14, r24
    1fa6:	d2 d3       	rcall	.+1956   	; 0x274c <xTaskResumeAll>
    1fa8:	c7 01       	movw	r24, r14
    1faa:	b6 01       	movw	r22, r12
    1fac:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <__fixsfsi>
    1fb0:	79 83       	std	Y+1, r23	; 0x01
    1fb2:	68 83       	st	Y, r22
    1fb4:	84 ef       	ldi	r24, 0xF4	; 244
    1fb6:	91 e0       	ldi	r25, 0x01	; 1
    1fb8:	4a d4       	rcall	.+2196   	; 0x284e <vTaskDelay>
    1fba:	e0 cf       	rjmp	.-64     	; 0x1f7c <_Z17taskReadAltimeterPv+0x4>

00001fbc <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1fbc:	26 e0       	ldi	r18, 0x06	; 6
    1fbe:	40 e8       	ldi	r20, 0x80	; 128
    1fc0:	55 e2       	ldi	r21, 0x25	; 37
    1fc2:	60 e0       	ldi	r22, 0x00	; 0
    1fc4:	70 e0       	ldi	r23, 0x00	; 0
    1fc6:	8f e9       	ldi	r24, 0x9F	; 159
    1fc8:	9a e0       	ldi	r25, 0x0A	; 10
    1fca:	0e 94 a4 1c 	call	0x3948	; 0x3948 <_ZN14HardwareSerial5beginEmh>
{
	// Starting up serial monitor
	Serial1.begin(9600);
	//Serial.begin(9600);
	// Setting up compass
	Wire.begin();
    1fce:	80 eb       	ldi	r24, 0xB0	; 176
    1fd0:	99 e0       	ldi	r25, 0x09	; 9
    1fd2:	9f d7       	rcall	.+3902   	; 0x2f12 <_ZN7TwoWire5beginEv>
	compass.init();
    1fd4:	42 e0       	ldi	r20, 0x02	; 2
    1fd6:	64 e0       	ldi	r22, 0x04	; 4
    1fd8:	81 ec       	ldi	r24, 0xC1	; 193
    1fda:	98 e0       	ldi	r25, 0x08	; 8
    1fdc:	7e db       	rcall	.-2308   	; 0x16da <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    1fde:	81 ec       	ldi	r24, 0xC1	; 193
    1fe0:	98 e0       	ldi	r25, 0x08	; 8
    1fe2:	d5 d9       	rcall	.-3158   	; 0x138e <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    1fe4:	86 e0       	ldi	r24, 0x06	; 6
    1fe6:	ef e1       	ldi	r30, 0x1F	; 31
    1fe8:	f2 e0       	ldi	r31, 0x02	; 2
    1fea:	a3 ed       	ldi	r26, 0xD3	; 211
    1fec:	b8 e0       	ldi	r27, 0x08	; 8
    1fee:	01 90       	ld	r0, Z+
    1ff0:	0d 92       	st	X+, r0
    1ff2:	8a 95       	dec	r24
    1ff4:	e1 f7       	brne	.-8      	; 0x1fee <setup+0x32>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    1ff6:	86 e0       	ldi	r24, 0x06	; 6
    1ff8:	e5 e2       	ldi	r30, 0x25	; 37
    1ffa:	f2 e0       	ldi	r31, 0x02	; 2
    1ffc:	ad ec       	ldi	r26, 0xCD	; 205
    1ffe:	b8 e0       	ldi	r27, 0x08	; 8
    2000:	01 90       	ld	r0, Z+
    2002:	0d 92       	st	X+, r0
    2004:	8a 95       	dec	r24
    2006:	e1 f7       	brne	.-8      	; 0x2000 <setup+0x44>
	gyro.init();
    2008:	42 e0       	ldi	r20, 0x02	; 2
    200a:	63 e0       	ldi	r22, 0x03	; 3
    200c:	85 eb       	ldi	r24, 0xB5	; 181
    200e:	98 e0       	ldi	r25, 0x08	; 8
    2010:	0e 94 c6 03 	call	0x78c	; 0x78c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
	gyro.enableDefault();
    2014:	85 eb       	ldi	r24, 0xB5	; 181
    2016:	98 e0       	ldi	r25, 0x08	; 8
    2018:	0e 94 0d 03 	call	0x61a	; 0x61a <_ZN3L3G13enableDefaultEv>
	ps.init();
    201c:	42 e0       	ldi	r20, 0x02	; 2
    201e:	62 e0       	ldi	r22, 0x02	; 2
    2020:	8e ea       	ldi	r24, 0xAE	; 174
    2022:	98 e0       	ldi	r25, 0x08	; 8
    2024:	0e 94 08 06 	call	0xc10	; 0xc10 <_ZN3LPS4initENS_10deviceTypeEh>
	ps.enableDefault();
    2028:	8e ea       	ldi	r24, 0xAE	; 174
    202a:	98 e0       	ldi	r25, 0x08	; 8
    202c:	0e 94 31 05 	call	0xa62	; 0xa62 <_ZN3LPS13enableDefaultEv>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    2030:	61 e0       	ldi	r22, 0x01	; 1
    2032:	80 91 0c 02 	lds	r24, 0x020C
    2036:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
	pinMode(echo_1, INPUT);
    203a:	60 e0       	ldi	r22, 0x00	; 0
    203c:	80 91 0e 02 	lds	r24, 0x020E
    2040:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
	pinMode(echo_2, INPUT);
    2044:	60 e0       	ldi	r22, 0x00	; 0
    2046:	80 91 0a 02 	lds	r24, 0x020A
    204a:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
	pinMode(trigger_2, OUTPUT);
    204e:	61 e0       	ldi	r22, 0x01	; 1
    2050:	80 91 08 02 	lds	r24, 0x0208
    2054:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
	pinMode(echo_3, INPUT);
    2058:	60 e0       	ldi	r22, 0x00	; 0
    205a:	80 91 06 02 	lds	r24, 0x0206
    205e:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
	pinMode(trigger_3, OUTPUT);
    2062:	61 e0       	ldi	r22, 0x01	; 1
    2064:	80 91 04 02 	lds	r24, 0x0204
    2068:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <pinMode>
	
	pinMode(analog_1, INPUT);
    206c:	60 e0       	ldi	r22, 0x00	; 0
    206e:	80 91 02 02 	lds	r24, 0x0202
    2072:	0c 94 7a 20 	jmp	0x40f4	; 0x40f4 <pinMode>
    2076:	08 95       	ret

00002078 <main>:
}

int main(void)
{
    2078:	af 92       	push	r10
    207a:	bf 92       	push	r11
    207c:	cf 92       	push	r12
    207e:	df 92       	push	r13
    2080:	ef 92       	push	r14
    2082:	ff 92       	push	r15
    2084:	0f 93       	push	r16
    2086:	cf 93       	push	r28
    2088:	df 93       	push	r29
    208a:	cd b7       	in	r28, 0x3d	; 61
    208c:	de b7       	in	r29, 0x3e	; 62
    208e:	2c 97       	sbiw	r28, 0x0c	; 12
    2090:	0f b6       	in	r0, 0x3f	; 63
    2092:	f8 94       	cli
    2094:	de bf       	out	0x3e, r29	; 62
    2096:	0f be       	out	0x3f, r0	; 63
    2098:	cd bf       	out	0x3d, r28	; 61
	init();
    209a:	0e 94 af 1f 	call	0x3f5e	; 0x3f5e <init>
	setup();
    209e:	8e df       	rcall	.-228    	; 0x1fbc <setup>
	TaskHandle_t t1, t2, t3, t4, t5, t6, t7;
	// Create tasks
	xTaskCreate(handShake, "printA", STACK_DEPTH, NULL, 10, &t1);
    20a0:	a1 2c       	mov	r10, r1
    20a2:	b1 2c       	mov	r11, r1
    20a4:	c1 2c       	mov	r12, r1
    20a6:	d1 2c       	mov	r13, r1
    20a8:	ce 01       	movw	r24, r28
    20aa:	0b 96       	adiw	r24, 0x0b	; 11
    20ac:	7c 01       	movw	r14, r24
    20ae:	0a e0       	ldi	r16, 0x0A	; 10
    20b0:	20 e0       	ldi	r18, 0x00	; 0
    20b2:	30 e0       	ldi	r19, 0x00	; 0
    20b4:	40 ea       	ldi	r20, 0xA0	; 160
    20b6:	50 e0       	ldi	r21, 0x00	; 0
    20b8:	6b e2       	ldi	r22, 0x2B	; 43
    20ba:	72 e0       	ldi	r23, 0x02	; 2
    20bc:	81 ed       	ldi	r24, 0xD1	; 209
    20be:	90 e1       	ldi	r25, 0x10	; 16
    20c0:	50 d1       	rcall	.+672    	; 0x2362 <xTaskGenericCreate>
	//xTaskCreate(printArray, "print", STACK_DEPTH, NULL, 10, &t1);
	xTaskCreate(taskReadGyro, "Read Gyrometer", STACK_DEPTH, NULL, 9, &t2);
    20c2:	ce 01       	movw	r24, r28
    20c4:	09 96       	adiw	r24, 0x09	; 9
    20c6:	7c 01       	movw	r14, r24
    20c8:	09 e0       	ldi	r16, 0x09	; 9
    20ca:	20 e0       	ldi	r18, 0x00	; 0
    20cc:	30 e0       	ldi	r19, 0x00	; 0
    20ce:	40 ea       	ldi	r20, 0xA0	; 160
    20d0:	50 e0       	ldi	r21, 0x00	; 0
    20d2:	62 e3       	ldi	r22, 0x32	; 50
    20d4:	72 e0       	ldi	r23, 0x02	; 2
    20d6:	87 e3       	ldi	r24, 0x37	; 55
    20d8:	9f e0       	ldi	r25, 0x0F	; 15
    20da:	43 d1       	rcall	.+646    	; 0x2362 <xTaskGenericCreate>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
    20dc:	ce 01       	movw	r24, r28
    20de:	07 96       	adiw	r24, 0x07	; 7
    20e0:	7c 01       	movw	r14, r24
    20e2:	08 e0       	ldi	r16, 0x08	; 8
    20e4:	20 e0       	ldi	r18, 0x00	; 0
    20e6:	30 e0       	ldi	r19, 0x00	; 0
    20e8:	40 ea       	ldi	r20, 0xA0	; 160
    20ea:	50 e0       	ldi	r21, 0x00	; 0
    20ec:	61 e4       	ldi	r22, 0x41	; 65
    20ee:	72 e0       	ldi	r23, 0x02	; 2
    20f0:	81 ea       	ldi	r24, 0xA1	; 161
    20f2:	9e e0       	ldi	r25, 0x0E	; 14
    20f4:	36 d1       	rcall	.+620    	; 0x2362 <xTaskGenericCreate>
	//xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
    20f6:	ce 01       	movw	r24, r28
    20f8:	05 96       	adiw	r24, 0x05	; 5
    20fa:	7c 01       	movw	r14, r24
    20fc:	06 e0       	ldi	r16, 0x06	; 6
    20fe:	20 e0       	ldi	r18, 0x00	; 0
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	40 ea       	ldi	r20, 0xA0	; 160
    2104:	50 e0       	ldi	r21, 0x00	; 0
    2106:	64 e5       	ldi	r22, 0x54	; 84
    2108:	72 e0       	ldi	r23, 0x02	; 2
    210a:	8a ea       	ldi	r24, 0xAA	; 170
    210c:	9f e0       	ldi	r25, 0x0F	; 15
    210e:	29 d1       	rcall	.+594    	; 0x2362 <xTaskGenericCreate>
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
    2110:	ce 01       	movw	r24, r28
    2112:	03 96       	adiw	r24, 0x03	; 3
    2114:	7c 01       	movw	r14, r24
    2116:	05 e0       	ldi	r16, 0x05	; 5
    2118:	20 e0       	ldi	r18, 0x00	; 0
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	40 ea       	ldi	r20, 0xA0	; 160
    211e:	50 e0       	ldi	r21, 0x00	; 0
    2120:	61 e6       	ldi	r22, 0x61	; 97
    2122:	72 e0       	ldi	r23, 0x02	; 2
    2124:	80 ec       	ldi	r24, 0xC0	; 192
    2126:	9d e0       	ldi	r25, 0x0D	; 13
    2128:	1c d1       	rcall	.+568    	; 0x2362 <xTaskGenericCreate>
	xTaskCreate(taskReadAltimeter, "Read Altimeter", STACK_DEPTH, NULL, 4, &t7);
    212a:	ce 01       	movw	r24, r28
    212c:	01 96       	adiw	r24, 0x01	; 1
    212e:	7c 01       	movw	r14, r24
    2130:	04 e0       	ldi	r16, 0x04	; 4
    2132:	20 e0       	ldi	r18, 0x00	; 0
    2134:	30 e0       	ldi	r19, 0x00	; 0
    2136:	40 ea       	ldi	r20, 0xA0	; 160
    2138:	50 e0       	ldi	r21, 0x00	; 0
    213a:	61 e7       	ldi	r22, 0x71	; 113
    213c:	72 e0       	ldi	r23, 0x02	; 2
    213e:	8c eb       	ldi	r24, 0xBC	; 188
    2140:	9f e0       	ldi	r25, 0x0F	; 15
    2142:	0f d1       	rcall	.+542    	; 0x2362 <xTaskGenericCreate>
	vTaskStartScheduler();
    2144:	16 d2       	rcall	.+1068   	; 0x2572 <vTaskStartScheduler>
    2146:	80 e0       	ldi	r24, 0x00	; 0
    2148:	90 e0       	ldi	r25, 0x00	; 0
    214a:	2c 96       	adiw	r28, 0x0c	; 12
    214c:	0f b6       	in	r0, 0x3f	; 63
    214e:	f8 94       	cli
    2150:	de bf       	out	0x3e, r29	; 62
    2152:	0f be       	out	0x3f, r0	; 63
    2154:	cd bf       	out	0x3d, r28	; 61
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	0f 91       	pop	r16
    215c:	ff 90       	pop	r15
    215e:	ef 90       	pop	r14
    2160:	df 90       	pop	r13
    2162:	cf 90       	pop	r12
    2164:	bf 90       	pop	r11
    2166:	af 90       	pop	r10
    2168:	08 95       	ret

0000216a <_GLOBAL__sub_I_echo_1>:
    216a:	0f 93       	push	r16
    216c:	1f 93       	push	r17
int trigger_3 = 8;

int checkSum = 0;
int analog_1 = A0; 
int numOfData = 12;
LSM303 compass;
    216e:	81 ec       	ldi	r24, 0xC1	; 193
    2170:	98 e0       	ldi	r25, 0x08	; 8
    2172:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6LSM303C1Ev>
L3G gyro;
    2176:	85 eb       	ldi	r24, 0xB5	; 181
    2178:	98 e0       	ldi	r25, 0x08	; 8
    217a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <_ZN3L3GC1Ev>
LPS ps;
    217e:	8e ea       	ldi	r24, 0xAE	; 174
    2180:	98 e0       	ldi	r25, 0x08	; 8
    2182:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <_ZN3LPSC1Ev>
SharpIR sharp(A0, 25, 93, 20150);
    2186:	06 eb       	ldi	r16, 0xB6	; 182
    2188:	1e e4       	ldi	r17, 0x4E	; 78
    218a:	2d e5       	ldi	r18, 0x5D	; 93
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	49 e1       	ldi	r20, 0x19	; 25
    2190:	50 e0       	ldi	r21, 0x00	; 0
    2192:	66 e3       	ldi	r22, 0x36	; 54
    2194:	70 e0       	ldi	r23, 0x00	; 0
    2196:	80 ea       	ldi	r24, 0xA0	; 160
    2198:	98 e0       	ldi	r25, 0x08	; 8
    219a:	77 d0       	rcall	.+238    	; 0x228a <_ZN7SharpIRC1Eiiii>
	//xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
	xTaskCreate(taskReadAltimeter, "Read Altimeter", STACK_DEPTH, NULL, 4, &t7);
	vTaskStartScheduler();
    219c:	1f 91       	pop	r17
    219e:	0f 91       	pop	r16
    21a0:	08 95       	ret

000021a2 <_Z9handShakePv>:
index 10 for analog distance sensor
index 11 for compass heading
index 12 for altimeter
*/

void handShake(void *p) {
    21a2:	0f 2e       	mov	r0, r31
    21a4:	f8 e8       	ldi	r31, 0x88	; 136
    21a6:	ef 2e       	mov	r14, r31
    21a8:	f8 e0       	ldi	r31, 0x08	; 8
    21aa:	ff 2e       	mov	r15, r31
    21ac:	f0 2d       	mov	r31, r0
    21ae:	00 ea       	ldi	r16, 0xA0	; 160
    21b0:	18 e0       	ldi	r17, 0x08	; 8
	int i;
	char canRead = '0';
	while(1) {
		//vTaskSuspendAll();
		if(Serial1.available()) {
    21b2:	8f e9       	ldi	r24, 0x9F	; 159
    21b4:	9a e0       	ldi	r25, 0x0A	; 10
    21b6:	0e 94 ef 1b 	call	0x37de	; 0x37de <_ZN14HardwareSerial9availableEv>
    21ba:	89 2b       	or	r24, r25
    21bc:	09 f4       	brne	.+2      	; 0x21c0 <_Z9handShakePv+0x1e>
    21be:	61 c0       	rjmp	.+194    	; 0x2282 <__stack+0x83>
			canRead = Serial1.read();
    21c0:	8f e9       	ldi	r24, 0x9F	; 159
    21c2:	9a e0       	ldi	r25, 0x0A	; 10
    21c4:	0e 94 08 1c 	call	0x3810	; 0x3810 <_ZN14HardwareSerial4readEv>
			if(canRead == 'H') {
    21c8:	88 34       	cpi	r24, 0x48	; 72
    21ca:	59 f4       	brne	.+22     	; 0x21e2 <_Z9handShakePv+0x40>
				Serial1.print('A');
    21cc:	61 e4       	ldi	r22, 0x41	; 65
    21ce:	8f e9       	ldi	r24, 0x9F	; 159
    21d0:	9a e0       	ldi	r25, 0x0A	; 10
    21d2:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
				Serial1.print('\r');
    21d6:	6d e0       	ldi	r22, 0x0D	; 13
    21d8:	8f e9       	ldi	r24, 0x9F	; 159
    21da:	9a e0       	ldi	r25, 0x0A	; 10
    21dc:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
    21e0:	50 c0       	rjmp	.+160    	; 0x2282 <__stack+0x83>
			}
			else if(canRead == 'P') {
    21e2:	80 35       	cpi	r24, 0x50	; 80
    21e4:	09 f0       	breq	.+2      	; 0x21e8 <_Z9handShakePv+0x46>
    21e6:	43 c0       	rjmp	.+134    	; 0x226e <__stack+0x6f>
				checkSum = numOfData;
    21e8:	60 91 00 02 	lds	r22, 0x0200
    21ec:	70 91 01 02 	lds	r23, 0x0201
    21f0:	70 93 e8 08 	sts	0x08E8, r23
    21f4:	60 93 e7 08 	sts	0x08E7, r22
				Serial1.print(numOfData);
    21f8:	4a e0       	ldi	r20, 0x0A	; 10
    21fa:	50 e0       	ldi	r21, 0x00	; 0
    21fc:	8f e9       	ldi	r24, 0x9F	; 159
    21fe:	9a e0       	ldi	r25, 0x0A	; 10
    2200:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <_ZN5Print5printEii>
				Serial1.print('\n');
    2204:	6a e0       	ldi	r22, 0x0A	; 10
    2206:	8f e9       	ldi	r24, 0x9F	; 159
    2208:	9a e0       	ldi	r25, 0x0A	; 10
    220a:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
    220e:	e7 01       	movw	r28, r14
				for(i = 1; i < 13; i++) {
					checkSum += data[i];
    2210:	69 91       	ld	r22, Y+
    2212:	79 91       	ld	r23, Y+
    2214:	80 91 e7 08 	lds	r24, 0x08E7
    2218:	90 91 e8 08 	lds	r25, 0x08E8
    221c:	86 0f       	add	r24, r22
    221e:	97 1f       	adc	r25, r23
    2220:	90 93 e8 08 	sts	0x08E8, r25
    2224:	80 93 e7 08 	sts	0x08E7, r24
					Serial1.print(data[i]);
    2228:	4a e0       	ldi	r20, 0x0A	; 10
    222a:	50 e0       	ldi	r21, 0x00	; 0
    222c:	8f e9       	ldi	r24, 0x9F	; 159
    222e:	9a e0       	ldi	r25, 0x0A	; 10
    2230:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <_ZN5Print5printEii>
					Serial1.print('\n');
    2234:	6a e0       	ldi	r22, 0x0A	; 10
    2236:	8f e9       	ldi	r24, 0x9F	; 159
    2238:	9a e0       	ldi	r25, 0x0A	; 10
    223a:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
			}
			else if(canRead == 'P') {
				checkSum = numOfData;
				Serial1.print(numOfData);
				Serial1.print('\n');
				for(i = 1; i < 13; i++) {
    223e:	c0 17       	cp	r28, r16
    2240:	d1 07       	cpc	r29, r17
    2242:	31 f7       	brne	.-52     	; 0x2210 <__stack+0x11>
					checkSum += data[i];
					Serial1.print(data[i]);
					Serial1.print('\n');
				}
				Serial1.print(checkSum);
    2244:	60 91 e7 08 	lds	r22, 0x08E7
    2248:	70 91 e8 08 	lds	r23, 0x08E8
    224c:	4a e0       	ldi	r20, 0x0A	; 10
    224e:	50 e0       	ldi	r21, 0x00	; 0
    2250:	8f e9       	ldi	r24, 0x9F	; 159
    2252:	9a e0       	ldi	r25, 0x0A	; 10
    2254:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <_ZN5Print5printEii>
				Serial1.print('\n');
    2258:	6a e0       	ldi	r22, 0x0A	; 10
    225a:	8f e9       	ldi	r24, 0x9F	; 159
    225c:	9a e0       	ldi	r25, 0x0A	; 10
    225e:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
				Serial1.print('\r');
    2262:	6d e0       	ldi	r22, 0x0D	; 13
    2264:	8f e9       	ldi	r24, 0x9F	; 159
    2266:	9a e0       	ldi	r25, 0x0A	; 10
    2268:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
    226c:	0a c0       	rjmp	.+20     	; 0x2282 <__stack+0x83>
			}
			else {
				Serial1.print('N');
    226e:	6e e4       	ldi	r22, 0x4E	; 78
    2270:	8f e9       	ldi	r24, 0x9F	; 159
    2272:	9a e0       	ldi	r25, 0x0A	; 10
    2274:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
				Serial1.print('\r');
    2278:	6d e0       	ldi	r22, 0x0D	; 13
    227a:	8f e9       	ldi	r24, 0x9F	; 159
    227c:	9a e0       	ldi	r25, 0x0A	; 10
    227e:	0e 94 8c 1e 	call	0x3d18	; 0x3d18 <_ZN5Print5printEc>
			}
			canRead = '0';
		}
		//xTaskResumeAll();
		vTaskDelay(100);
    2282:	84 e6       	ldi	r24, 0x64	; 100
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	e3 d2       	rcall	.+1478   	; 0x284e <vTaskDelay>
	}
    2288:	94 cf       	rjmp	.-216    	; 0x21b2 <_Z9handShakePv+0x10>

0000228a <_ZN7SharpIRC1Eiiii>:
#include "Arduino.h"
#include "SharpIR.h"



SharpIR::SharpIR(int irPin, int avg, int tolerance, int sensorModel) {
    228a:	0f 93       	push	r16
    228c:	1f 93       	push	r17
    228e:	fc 01       	movw	r30, r24
    2290:	c9 01       	movw	r24, r18
  
    _irPin=irPin;
    2292:	71 83       	std	Z+1, r23	; 0x01
    2294:	60 83       	st	Z, r22
    _avg=avg;
    2296:	55 83       	std	Z+5, r21	; 0x05
    2298:	44 83       	std	Z+4, r20	; 0x04
    _tol=tolerance/100;
    229a:	64 e6       	ldi	r22, 0x64	; 100
    229c:	70 e0       	ldi	r23, 0x00	; 0
    229e:	0e 94 26 21 	call	0x424c	; 0x424c <__divmodhi4>
    22a2:	75 87       	std	Z+13, r23	; 0x0d
    22a4:	64 87       	std	Z+12, r22	; 0x0c
    _model=sensorModel;
    22a6:	13 83       	std	Z+3, r17	; 0x03
    22a8:	02 83       	std	Z+2, r16	; 0x02
    
    analogReference(DEFAULT);
    22aa:	81 e0       	ldi	r24, 0x01	; 1
    22ac:	0e 94 11 20 	call	0x4022	; 0x4022 <analogReference>
 
}
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	08 95       	ret

000022b6 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    22b6:	e0 91 08 09 	lds	r30, 0x0908
    22ba:	f0 91 09 09 	lds	r31, 0x0909
    22be:	80 81       	ld	r24, Z
    22c0:	81 11       	cpse	r24, r1
    22c2:	07 c0       	rjmp	.+14     	; 0x22d2 <prvResetNextTaskUnblockTime+0x1c>
    22c4:	8f ef       	ldi	r24, 0xFF	; 255
    22c6:	9f ef       	ldi	r25, 0xFF	; 255
    22c8:	90 93 11 02 	sts	0x0211, r25
    22cc:	80 93 10 02 	sts	0x0210, r24
    22d0:	08 95       	ret
    22d2:	e0 91 08 09 	lds	r30, 0x0908
    22d6:	f0 91 09 09 	lds	r31, 0x0909
    22da:	05 80       	ldd	r0, Z+5	; 0x05
    22dc:	f6 81       	ldd	r31, Z+6	; 0x06
    22de:	e0 2d       	mov	r30, r0
    22e0:	06 80       	ldd	r0, Z+6	; 0x06
    22e2:	f7 81       	ldd	r31, Z+7	; 0x07
    22e4:	e0 2d       	mov	r30, r0
    22e6:	82 81       	ldd	r24, Z+2	; 0x02
    22e8:	93 81       	ldd	r25, Z+3	; 0x03
    22ea:	90 93 11 02 	sts	0x0211, r25
    22ee:	80 93 10 02 	sts	0x0210, r24
    22f2:	08 95       	ret

000022f4 <prvAddCurrentTaskToDelayedList>:
    22f4:	cf 93       	push	r28
    22f6:	df 93       	push	r29
    22f8:	ec 01       	movw	r28, r24
    22fa:	e0 91 40 09 	lds	r30, 0x0940
    22fe:	f0 91 41 09 	lds	r31, 0x0941
    2302:	93 83       	std	Z+3, r25	; 0x03
    2304:	82 83       	std	Z+2, r24	; 0x02
    2306:	80 91 f0 08 	lds	r24, 0x08F0
    230a:	90 91 f1 08 	lds	r25, 0x08F1
    230e:	c8 17       	cp	r28, r24
    2310:	d9 07       	cpc	r29, r25
    2312:	68 f4       	brcc	.+26     	; 0x232e <prvAddCurrentTaskToDelayedList+0x3a>
    2314:	60 91 40 09 	lds	r22, 0x0940
    2318:	70 91 41 09 	lds	r23, 0x0941
    231c:	80 91 06 09 	lds	r24, 0x0906
    2320:	90 91 07 09 	lds	r25, 0x0907
    2324:	6e 5f       	subi	r22, 0xFE	; 254
    2326:	7f 4f       	sbci	r23, 0xFF	; 255
    2328:	0e 94 91 04 	call	0x922	; 0x922 <vListInsert>
    232c:	17 c0       	rjmp	.+46     	; 0x235c <prvAddCurrentTaskToDelayedList+0x68>
    232e:	60 91 40 09 	lds	r22, 0x0940
    2332:	70 91 41 09 	lds	r23, 0x0941
    2336:	80 91 08 09 	lds	r24, 0x0908
    233a:	90 91 09 09 	lds	r25, 0x0909
    233e:	6e 5f       	subi	r22, 0xFE	; 254
    2340:	7f 4f       	sbci	r23, 0xFF	; 255
    2342:	0e 94 91 04 	call	0x922	; 0x922 <vListInsert>
    2346:	80 91 10 02 	lds	r24, 0x0210
    234a:	90 91 11 02 	lds	r25, 0x0211
    234e:	c8 17       	cp	r28, r24
    2350:	d9 07       	cpc	r29, r25
    2352:	20 f4       	brcc	.+8      	; 0x235c <prvAddCurrentTaskToDelayedList+0x68>
    2354:	d0 93 11 02 	sts	0x0211, r29
    2358:	c0 93 10 02 	sts	0x0210, r28
    235c:	df 91       	pop	r29
    235e:	cf 91       	pop	r28
    2360:	08 95       	ret

00002362 <xTaskGenericCreate>:
    2362:	4f 92       	push	r4
    2364:	5f 92       	push	r5
    2366:	6f 92       	push	r6
    2368:	7f 92       	push	r7
    236a:	8f 92       	push	r8
    236c:	9f 92       	push	r9
    236e:	af 92       	push	r10
    2370:	bf 92       	push	r11
    2372:	cf 92       	push	r12
    2374:	df 92       	push	r13
    2376:	ef 92       	push	r14
    2378:	ff 92       	push	r15
    237a:	0f 93       	push	r16
    237c:	1f 93       	push	r17
    237e:	cf 93       	push	r28
    2380:	df 93       	push	r29
    2382:	4c 01       	movw	r8, r24
    2384:	5b 01       	movw	r10, r22
    2386:	2a 01       	movw	r4, r20
    2388:	39 01       	movw	r6, r18
    238a:	81 e2       	ldi	r24, 0x21	; 33
    238c:	90 e0       	ldi	r25, 0x00	; 0
    238e:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    2392:	ec 01       	movw	r28, r24
    2394:	00 97       	sbiw	r24, 0x00	; 0
    2396:	09 f4       	brne	.+2      	; 0x239a <xTaskGenericCreate+0x38>
    2398:	da c0       	rjmp	.+436    	; 0x254e <xTaskGenericCreate+0x1ec>
    239a:	c1 14       	cp	r12, r1
    239c:	d1 04       	cpc	r13, r1
    239e:	09 f0       	breq	.+2      	; 0x23a2 <xTaskGenericCreate+0x40>
    23a0:	bf c0       	rjmp	.+382    	; 0x2520 <xTaskGenericCreate+0x1be>
    23a2:	c2 01       	movw	r24, r4
    23a4:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    23a8:	98 8f       	std	Y+24, r25	; 0x18
    23aa:	8f 8b       	std	Y+23, r24	; 0x17
    23ac:	89 2b       	or	r24, r25
    23ae:	09 f0       	breq	.+2      	; 0x23b2 <xTaskGenericCreate+0x50>
    23b0:	b9 c0       	rjmp	.+370    	; 0x2524 <xTaskGenericCreate+0x1c2>
    23b2:	ce 01       	movw	r24, r28
    23b4:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>
    23b8:	ca c0       	rjmp	.+404    	; 0x254e <xTaskGenericCreate+0x1ec>
    23ba:	cf 01       	movw	r24, r30
    23bc:	31 91       	ld	r19, Z+
    23be:	da 01       	movw	r26, r20
    23c0:	3d 93       	st	X+, r19
    23c2:	ad 01       	movw	r20, r26
    23c4:	dc 01       	movw	r26, r24
    23c6:	8c 91       	ld	r24, X
    23c8:	88 23       	and	r24, r24
    23ca:	11 f0       	breq	.+4      	; 0x23d0 <xTaskGenericCreate+0x6e>
    23cc:	21 50       	subi	r18, 0x01	; 1
    23ce:	a9 f7       	brne	.-22     	; 0x23ba <xTaskGenericCreate+0x58>
    23d0:	18 a2       	std	Y+32, r1	; 0x20
    23d2:	10 2f       	mov	r17, r16
    23d4:	04 30       	cpi	r16, 0x04	; 4
    23d6:	08 f0       	brcs	.+2      	; 0x23da <xTaskGenericCreate+0x78>
    23d8:	13 e0       	ldi	r17, 0x03	; 3
    23da:	1e 8b       	std	Y+22, r17	; 0x16
    23dc:	5e 01       	movw	r10, r28
    23de:	b2 e0       	ldi	r27, 0x02	; 2
    23e0:	ab 0e       	add	r10, r27
    23e2:	b1 1c       	adc	r11, r1
    23e4:	c5 01       	movw	r24, r10
    23e6:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialiseItem>
    23ea:	ce 01       	movw	r24, r28
    23ec:	0c 96       	adiw	r24, 0x0c	; 12
    23ee:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialiseItem>
    23f2:	d9 87       	std	Y+9, r29	; 0x09
    23f4:	c8 87       	std	Y+8, r28	; 0x08
    23f6:	84 e0       	ldi	r24, 0x04	; 4
    23f8:	90 e0       	ldi	r25, 0x00	; 0
    23fa:	81 1b       	sub	r24, r17
    23fc:	91 09       	sbc	r25, r1
    23fe:	9d 87       	std	Y+13, r25	; 0x0d
    2400:	8c 87       	std	Y+12, r24	; 0x0c
    2402:	db 8b       	std	Y+19, r29	; 0x13
    2404:	ca 8b       	std	Y+18, r28	; 0x12
    2406:	a3 01       	movw	r20, r6
    2408:	b4 01       	movw	r22, r8
    240a:	c6 01       	movw	r24, r12
    240c:	42 da       	rcall	.-2940   	; 0x1892 <pxPortInitialiseStack>
    240e:	99 83       	std	Y+1, r25	; 0x01
    2410:	88 83       	st	Y, r24
    2412:	e1 14       	cp	r14, r1
    2414:	f1 04       	cpc	r15, r1
    2416:	19 f0       	breq	.+6      	; 0x241e <xTaskGenericCreate+0xbc>
    2418:	f7 01       	movw	r30, r14
    241a:	d1 83       	std	Z+1, r29	; 0x01
    241c:	c0 83       	st	Z, r28
    241e:	0f b6       	in	r0, 0x3f	; 63
    2420:	f8 94       	cli
    2422:	0f 92       	push	r0
    2424:	80 91 f2 08 	lds	r24, 0x08F2
    2428:	8f 5f       	subi	r24, 0xFF	; 255
    242a:	80 93 f2 08 	sts	0x08F2, r24
    242e:	80 91 40 09 	lds	r24, 0x0940
    2432:	90 91 41 09 	lds	r25, 0x0941
    2436:	89 2b       	or	r24, r25
    2438:	a9 f5       	brne	.+106    	; 0x24a4 <xTaskGenericCreate+0x142>
    243a:	d0 93 41 09 	sts	0x0941, r29
    243e:	c0 93 40 09 	sts	0x0940, r28
    2442:	80 91 f2 08 	lds	r24, 0x08F2
    2446:	81 30       	cpi	r24, 0x01	; 1
    2448:	e1 f5       	brne	.+120    	; 0x24c2 <xTaskGenericCreate+0x160>
    244a:	8c e1       	ldi	r24, 0x1C	; 28
    244c:	99 e0       	ldi	r25, 0x09	; 9
    244e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    2452:	85 e2       	ldi	r24, 0x25	; 37
    2454:	99 e0       	ldi	r25, 0x09	; 9
    2456:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    245a:	8e e2       	ldi	r24, 0x2E	; 46
    245c:	99 e0       	ldi	r25, 0x09	; 9
    245e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    2462:	87 e3       	ldi	r24, 0x37	; 55
    2464:	99 e0       	ldi	r25, 0x09	; 9
    2466:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    246a:	83 e1       	ldi	r24, 0x13	; 19
    246c:	99 e0       	ldi	r25, 0x09	; 9
    246e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    2472:	8a e0       	ldi	r24, 0x0A	; 10
    2474:	99 e0       	ldi	r25, 0x09	; 9
    2476:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    247a:	8d ef       	ldi	r24, 0xFD	; 253
    247c:	98 e0       	ldi	r25, 0x08	; 8
    247e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    2482:	84 ef       	ldi	r24, 0xF4	; 244
    2484:	98 e0       	ldi	r25, 0x08	; 8
    2486:	0e 94 5e 04 	call	0x8bc	; 0x8bc <vListInitialise>
    248a:	83 e1       	ldi	r24, 0x13	; 19
    248c:	99 e0       	ldi	r25, 0x09	; 9
    248e:	90 93 09 09 	sts	0x0909, r25
    2492:	80 93 08 09 	sts	0x0908, r24
    2496:	8a e0       	ldi	r24, 0x0A	; 10
    2498:	99 e0       	ldi	r25, 0x09	; 9
    249a:	90 93 07 09 	sts	0x0907, r25
    249e:	80 93 06 09 	sts	0x0906, r24
    24a2:	0f c0       	rjmp	.+30     	; 0x24c2 <xTaskGenericCreate+0x160>
    24a4:	80 91 ee 08 	lds	r24, 0x08EE
    24a8:	81 11       	cpse	r24, r1
    24aa:	0b c0       	rjmp	.+22     	; 0x24c2 <xTaskGenericCreate+0x160>
    24ac:	e0 91 40 09 	lds	r30, 0x0940
    24b0:	f0 91 41 09 	lds	r31, 0x0941
    24b4:	86 89       	ldd	r24, Z+22	; 0x16
    24b6:	08 17       	cp	r16, r24
    24b8:	20 f0       	brcs	.+8      	; 0x24c2 <xTaskGenericCreate+0x160>
    24ba:	d0 93 41 09 	sts	0x0941, r29
    24be:	c0 93 40 09 	sts	0x0940, r28
    24c2:	80 91 ea 08 	lds	r24, 0x08EA
    24c6:	8f 5f       	subi	r24, 0xFF	; 255
    24c8:	80 93 ea 08 	sts	0x08EA, r24
    24cc:	8e 89       	ldd	r24, Y+22	; 0x16
    24ce:	90 91 ef 08 	lds	r25, 0x08EF
    24d2:	98 17       	cp	r25, r24
    24d4:	10 f4       	brcc	.+4      	; 0x24da <xTaskGenericCreate+0x178>
    24d6:	80 93 ef 08 	sts	0x08EF, r24
    24da:	90 e0       	ldi	r25, 0x00	; 0
    24dc:	9c 01       	movw	r18, r24
    24de:	22 0f       	add	r18, r18
    24e0:	33 1f       	adc	r19, r19
    24e2:	22 0f       	add	r18, r18
    24e4:	33 1f       	adc	r19, r19
    24e6:	22 0f       	add	r18, r18
    24e8:	33 1f       	adc	r19, r19
    24ea:	82 0f       	add	r24, r18
    24ec:	93 1f       	adc	r25, r19
    24ee:	b5 01       	movw	r22, r10
    24f0:	84 5e       	subi	r24, 0xE4	; 228
    24f2:	96 4f       	sbci	r25, 0xF6	; 246
    24f4:	0e 94 70 04 	call	0x8e0	; 0x8e0 <vListInsertEnd>
    24f8:	0f 90       	pop	r0
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	80 91 ee 08 	lds	r24, 0x08EE
    2500:	88 23       	and	r24, r24
    2502:	51 f0       	breq	.+20     	; 0x2518 <xTaskGenericCreate+0x1b6>
    2504:	e0 91 40 09 	lds	r30, 0x0940
    2508:	f0 91 41 09 	lds	r31, 0x0941
    250c:	86 89       	ldd	r24, Z+22	; 0x16
    250e:	80 17       	cp	r24, r16
    2510:	28 f4       	brcc	.+10     	; 0x251c <xTaskGenericCreate+0x1ba>
    2512:	72 da       	rcall	.-2844   	; 0x19f8 <vPortYield>
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	1c c0       	rjmp	.+56     	; 0x2550 <xTaskGenericCreate+0x1ee>
    2518:	81 e0       	ldi	r24, 0x01	; 1
    251a:	1a c0       	rjmp	.+52     	; 0x2550 <xTaskGenericCreate+0x1ee>
    251c:	81 e0       	ldi	r24, 0x01	; 1
    251e:	18 c0       	rjmp	.+48     	; 0x2550 <xTaskGenericCreate+0x1ee>
    2520:	d8 8e       	std	Y+24, r13	; 0x18
    2522:	cf 8a       	std	Y+23, r12	; 0x17
    2524:	f1 e0       	ldi	r31, 0x01	; 1
    2526:	4f 1a       	sub	r4, r31
    2528:	51 08       	sbc	r5, r1
    252a:	cf 88       	ldd	r12, Y+23	; 0x17
    252c:	d8 8c       	ldd	r13, Y+24	; 0x18
    252e:	c4 0c       	add	r12, r4
    2530:	d5 1c       	adc	r13, r5
    2532:	d5 01       	movw	r26, r10
    2534:	8c 91       	ld	r24, X
    2536:	89 8f       	std	Y+25, r24	; 0x19
    2538:	8c 91       	ld	r24, X
    253a:	88 23       	and	r24, r24
    253c:	09 f4       	brne	.+2      	; 0x2540 <xTaskGenericCreate+0x1de>
    253e:	48 cf       	rjmp	.-368    	; 0x23d0 <xTaskGenericCreate+0x6e>
    2540:	ae 01       	movw	r20, r28
    2542:	46 5e       	subi	r20, 0xE6	; 230
    2544:	5f 4f       	sbci	r21, 0xFF	; 255
    2546:	f5 01       	movw	r30, r10
    2548:	31 96       	adiw	r30, 0x01	; 1
    254a:	27 e0       	ldi	r18, 0x07	; 7
    254c:	36 cf       	rjmp	.-404    	; 0x23ba <xTaskGenericCreate+0x58>
    254e:	8f ef       	ldi	r24, 0xFF	; 255
    2550:	df 91       	pop	r29
    2552:	cf 91       	pop	r28
    2554:	1f 91       	pop	r17
    2556:	0f 91       	pop	r16
    2558:	ff 90       	pop	r15
    255a:	ef 90       	pop	r14
    255c:	df 90       	pop	r13
    255e:	cf 90       	pop	r12
    2560:	bf 90       	pop	r11
    2562:	af 90       	pop	r10
    2564:	9f 90       	pop	r9
    2566:	8f 90       	pop	r8
    2568:	7f 90       	pop	r7
    256a:	6f 90       	pop	r6
    256c:	5f 90       	pop	r5
    256e:	4f 90       	pop	r4
    2570:	08 95       	ret

00002572 <vTaskStartScheduler>:
    2572:	af 92       	push	r10
    2574:	bf 92       	push	r11
    2576:	cf 92       	push	r12
    2578:	df 92       	push	r13
    257a:	ef 92       	push	r14
    257c:	ff 92       	push	r15
    257e:	0f 93       	push	r16
    2580:	a1 2c       	mov	r10, r1
    2582:	b1 2c       	mov	r11, r1
    2584:	c1 2c       	mov	r12, r1
    2586:	d1 2c       	mov	r13, r1
    2588:	e1 2c       	mov	r14, r1
    258a:	f1 2c       	mov	r15, r1
    258c:	00 e0       	ldi	r16, 0x00	; 0
    258e:	20 e0       	ldi	r18, 0x00	; 0
    2590:	30 e0       	ldi	r19, 0x00	; 0
    2592:	45 e5       	ldi	r20, 0x55	; 85
    2594:	50 e0       	ldi	r21, 0x00	; 0
    2596:	60 e8       	ldi	r22, 0x80	; 128
    2598:	72 e0       	ldi	r23, 0x02	; 2
    259a:	83 e4       	ldi	r24, 0x43	; 67
    259c:	94 e1       	ldi	r25, 0x14	; 20
    259e:	e1 de       	rcall	.-574    	; 0x2362 <xTaskGenericCreate>
    25a0:	81 30       	cpi	r24, 0x01	; 1
    25a2:	41 f4       	brne	.+16     	; 0x25b4 <vTaskStartScheduler+0x42>
    25a4:	f8 94       	cli
    25a6:	80 93 ee 08 	sts	0x08EE, r24
    25aa:	10 92 f1 08 	sts	0x08F1, r1
    25ae:	10 92 f0 08 	sts	0x08F0, r1
    25b2:	e1 d9       	rcall	.-3134   	; 0x1976 <xPortStartScheduler>
    25b4:	0f 91       	pop	r16
    25b6:	ff 90       	pop	r15
    25b8:	ef 90       	pop	r14
    25ba:	df 90       	pop	r13
    25bc:	cf 90       	pop	r12
    25be:	bf 90       	pop	r11
    25c0:	af 90       	pop	r10
    25c2:	08 95       	ret

000025c4 <vTaskSuspendAll>:
    25c4:	80 91 e9 08 	lds	r24, 0x08E9
    25c8:	8f 5f       	subi	r24, 0xFF	; 255
    25ca:	80 93 e9 08 	sts	0x08E9, r24
    25ce:	08 95       	ret

000025d0 <xTaskIncrementTick>:
    25d0:	cf 92       	push	r12
    25d2:	df 92       	push	r13
    25d4:	ef 92       	push	r14
    25d6:	ff 92       	push	r15
    25d8:	0f 93       	push	r16
    25da:	1f 93       	push	r17
    25dc:	cf 93       	push	r28
    25de:	df 93       	push	r29
    25e0:	80 91 e9 08 	lds	r24, 0x08E9
    25e4:	81 11       	cpse	r24, r1
    25e6:	99 c0       	rjmp	.+306    	; 0x271a <xTaskIncrementTick+0x14a>
    25e8:	80 91 f0 08 	lds	r24, 0x08F0
    25ec:	90 91 f1 08 	lds	r25, 0x08F1
    25f0:	01 96       	adiw	r24, 0x01	; 1
    25f2:	90 93 f1 08 	sts	0x08F1, r25
    25f6:	80 93 f0 08 	sts	0x08F0, r24
    25fa:	e0 90 f0 08 	lds	r14, 0x08F0
    25fe:	f0 90 f1 08 	lds	r15, 0x08F1
    2602:	e1 14       	cp	r14, r1
    2604:	f1 04       	cpc	r15, r1
    2606:	b1 f4       	brne	.+44     	; 0x2634 <xTaskIncrementTick+0x64>
    2608:	80 91 08 09 	lds	r24, 0x0908
    260c:	90 91 09 09 	lds	r25, 0x0909
    2610:	20 91 06 09 	lds	r18, 0x0906
    2614:	30 91 07 09 	lds	r19, 0x0907
    2618:	30 93 09 09 	sts	0x0909, r19
    261c:	20 93 08 09 	sts	0x0908, r18
    2620:	90 93 07 09 	sts	0x0907, r25
    2624:	80 93 06 09 	sts	0x0906, r24
    2628:	80 91 eb 08 	lds	r24, 0x08EB
    262c:	8f 5f       	subi	r24, 0xFF	; 255
    262e:	80 93 eb 08 	sts	0x08EB, r24
    2632:	41 de       	rcall	.-894    	; 0x22b6 <prvResetNextTaskUnblockTime>
    2634:	80 91 10 02 	lds	r24, 0x0210
    2638:	90 91 11 02 	lds	r25, 0x0211
    263c:	e8 16       	cp	r14, r24
    263e:	f9 06       	cpc	r15, r25
    2640:	08 f4       	brcc	.+2      	; 0x2644 <xTaskIncrementTick+0x74>
    2642:	54 c0       	rjmp	.+168    	; 0x26ec <xTaskIncrementTick+0x11c>
    2644:	d1 2c       	mov	r13, r1
    2646:	cc 24       	eor	r12, r12
    2648:	c3 94       	inc	r12
    264a:	01 c0       	rjmp	.+2      	; 0x264e <xTaskIncrementTick+0x7e>
    264c:	dc 2c       	mov	r13, r12
    264e:	e0 91 08 09 	lds	r30, 0x0908
    2652:	f0 91 09 09 	lds	r31, 0x0909
    2656:	80 81       	ld	r24, Z
    2658:	81 11       	cpse	r24, r1
    265a:	07 c0       	rjmp	.+14     	; 0x266a <xTaskIncrementTick+0x9a>
    265c:	8f ef       	ldi	r24, 0xFF	; 255
    265e:	9f ef       	ldi	r25, 0xFF	; 255
    2660:	90 93 11 02 	sts	0x0211, r25
    2664:	80 93 10 02 	sts	0x0210, r24
    2668:	42 c0       	rjmp	.+132    	; 0x26ee <xTaskIncrementTick+0x11e>
    266a:	e0 91 08 09 	lds	r30, 0x0908
    266e:	f0 91 09 09 	lds	r31, 0x0909
    2672:	05 80       	ldd	r0, Z+5	; 0x05
    2674:	f6 81       	ldd	r31, Z+6	; 0x06
    2676:	e0 2d       	mov	r30, r0
    2678:	c6 81       	ldd	r28, Z+6	; 0x06
    267a:	d7 81       	ldd	r29, Z+7	; 0x07
    267c:	2a 81       	ldd	r18, Y+2	; 0x02
    267e:	3b 81       	ldd	r19, Y+3	; 0x03
    2680:	e2 16       	cp	r14, r18
    2682:	f3 06       	cpc	r15, r19
    2684:	28 f4       	brcc	.+10     	; 0x2690 <xTaskIncrementTick+0xc0>
    2686:	30 93 11 02 	sts	0x0211, r19
    268a:	20 93 10 02 	sts	0x0210, r18
    268e:	2f c0       	rjmp	.+94     	; 0x26ee <xTaskIncrementTick+0x11e>
    2690:	8e 01       	movw	r16, r28
    2692:	0e 5f       	subi	r16, 0xFE	; 254
    2694:	1f 4f       	sbci	r17, 0xFF	; 255
    2696:	c8 01       	movw	r24, r16
    2698:	0e 94 c2 04 	call	0x984	; 0x984 <uxListRemove>
    269c:	8c 89       	ldd	r24, Y+20	; 0x14
    269e:	9d 89       	ldd	r25, Y+21	; 0x15
    26a0:	89 2b       	or	r24, r25
    26a2:	21 f0       	breq	.+8      	; 0x26ac <xTaskIncrementTick+0xdc>
    26a4:	ce 01       	movw	r24, r28
    26a6:	0c 96       	adiw	r24, 0x0c	; 12
    26a8:	0e 94 c2 04 	call	0x984	; 0x984 <uxListRemove>
    26ac:	2e 89       	ldd	r18, Y+22	; 0x16
    26ae:	80 91 ef 08 	lds	r24, 0x08EF
    26b2:	82 17       	cp	r24, r18
    26b4:	10 f4       	brcc	.+4      	; 0x26ba <xTaskIncrementTick+0xea>
    26b6:	20 93 ef 08 	sts	0x08EF, r18
    26ba:	30 e0       	ldi	r19, 0x00	; 0
    26bc:	c9 01       	movw	r24, r18
    26be:	88 0f       	add	r24, r24
    26c0:	99 1f       	adc	r25, r25
    26c2:	88 0f       	add	r24, r24
    26c4:	99 1f       	adc	r25, r25
    26c6:	88 0f       	add	r24, r24
    26c8:	99 1f       	adc	r25, r25
    26ca:	82 0f       	add	r24, r18
    26cc:	93 1f       	adc	r25, r19
    26ce:	b8 01       	movw	r22, r16
    26d0:	84 5e       	subi	r24, 0xE4	; 228
    26d2:	96 4f       	sbci	r25, 0xF6	; 246
    26d4:	0e 94 70 04 	call	0x8e0	; 0x8e0 <vListInsertEnd>
    26d8:	e0 91 40 09 	lds	r30, 0x0940
    26dc:	f0 91 41 09 	lds	r31, 0x0941
    26e0:	9e 89       	ldd	r25, Y+22	; 0x16
    26e2:	86 89       	ldd	r24, Z+22	; 0x16
    26e4:	98 17       	cp	r25, r24
    26e6:	08 f0       	brcs	.+2      	; 0x26ea <xTaskIncrementTick+0x11a>
    26e8:	b1 cf       	rjmp	.-158    	; 0x264c <xTaskIncrementTick+0x7c>
    26ea:	b1 cf       	rjmp	.-158    	; 0x264e <xTaskIncrementTick+0x7e>
    26ec:	d1 2c       	mov	r13, r1
    26ee:	e0 91 40 09 	lds	r30, 0x0940
    26f2:	f0 91 41 09 	lds	r31, 0x0941
    26f6:	86 89       	ldd	r24, Z+22	; 0x16
    26f8:	90 e0       	ldi	r25, 0x00	; 0
    26fa:	fc 01       	movw	r30, r24
    26fc:	ee 0f       	add	r30, r30
    26fe:	ff 1f       	adc	r31, r31
    2700:	ee 0f       	add	r30, r30
    2702:	ff 1f       	adc	r31, r31
    2704:	ee 0f       	add	r30, r30
    2706:	ff 1f       	adc	r31, r31
    2708:	8e 0f       	add	r24, r30
    270a:	9f 1f       	adc	r25, r31
    270c:	fc 01       	movw	r30, r24
    270e:	e4 5e       	subi	r30, 0xE4	; 228
    2710:	f6 4f       	sbci	r31, 0xF6	; 246
    2712:	80 81       	ld	r24, Z
    2714:	82 30       	cpi	r24, 0x02	; 2
    2716:	40 f4       	brcc	.+16     	; 0x2728 <xTaskIncrementTick+0x158>
    2718:	09 c0       	rjmp	.+18     	; 0x272c <xTaskIncrementTick+0x15c>
    271a:	80 91 ed 08 	lds	r24, 0x08ED
    271e:	8f 5f       	subi	r24, 0xFF	; 255
    2720:	80 93 ed 08 	sts	0x08ED, r24
    2724:	d1 2c       	mov	r13, r1
    2726:	02 c0       	rjmp	.+4      	; 0x272c <xTaskIncrementTick+0x15c>
    2728:	dd 24       	eor	r13, r13
    272a:	d3 94       	inc	r13
    272c:	80 91 ec 08 	lds	r24, 0x08EC
    2730:	88 23       	and	r24, r24
    2732:	11 f0       	breq	.+4      	; 0x2738 <xTaskIncrementTick+0x168>
    2734:	dd 24       	eor	r13, r13
    2736:	d3 94       	inc	r13
    2738:	8d 2d       	mov	r24, r13
    273a:	df 91       	pop	r29
    273c:	cf 91       	pop	r28
    273e:	1f 91       	pop	r17
    2740:	0f 91       	pop	r16
    2742:	ff 90       	pop	r15
    2744:	ef 90       	pop	r14
    2746:	df 90       	pop	r13
    2748:	cf 90       	pop	r12
    274a:	08 95       	ret

0000274c <xTaskResumeAll>:
    274c:	df 92       	push	r13
    274e:	ef 92       	push	r14
    2750:	ff 92       	push	r15
    2752:	0f 93       	push	r16
    2754:	1f 93       	push	r17
    2756:	cf 93       	push	r28
    2758:	df 93       	push	r29
    275a:	0f b6       	in	r0, 0x3f	; 63
    275c:	f8 94       	cli
    275e:	0f 92       	push	r0
    2760:	80 91 e9 08 	lds	r24, 0x08E9
    2764:	81 50       	subi	r24, 0x01	; 1
    2766:	80 93 e9 08 	sts	0x08E9, r24
    276a:	80 91 e9 08 	lds	r24, 0x08E9
    276e:	81 11       	cpse	r24, r1
    2770:	5f c0       	rjmp	.+190    	; 0x2830 <xTaskResumeAll+0xe4>
    2772:	80 91 f2 08 	lds	r24, 0x08F2
    2776:	88 23       	and	r24, r24
    2778:	09 f4       	brne	.+2      	; 0x277c <xTaskResumeAll+0x30>
    277a:	5c c0       	rjmp	.+184    	; 0x2834 <xTaskResumeAll+0xe8>
    277c:	0f 2e       	mov	r0, r31
    277e:	fd ef       	ldi	r31, 0xFD	; 253
    2780:	ef 2e       	mov	r14, r31
    2782:	f8 e0       	ldi	r31, 0x08	; 8
    2784:	ff 2e       	mov	r15, r31
    2786:	f0 2d       	mov	r31, r0
    2788:	dd 24       	eor	r13, r13
    278a:	d3 94       	inc	r13
    278c:	30 c0       	rjmp	.+96     	; 0x27ee <xTaskResumeAll+0xa2>
    278e:	e0 91 02 09 	lds	r30, 0x0902
    2792:	f0 91 03 09 	lds	r31, 0x0903
    2796:	c6 81       	ldd	r28, Z+6	; 0x06
    2798:	d7 81       	ldd	r29, Z+7	; 0x07
    279a:	ce 01       	movw	r24, r28
    279c:	0c 96       	adiw	r24, 0x0c	; 12
    279e:	0e 94 c2 04 	call	0x984	; 0x984 <uxListRemove>
    27a2:	8e 01       	movw	r16, r28
    27a4:	0e 5f       	subi	r16, 0xFE	; 254
    27a6:	1f 4f       	sbci	r17, 0xFF	; 255
    27a8:	c8 01       	movw	r24, r16
    27aa:	0e 94 c2 04 	call	0x984	; 0x984 <uxListRemove>
    27ae:	8e 89       	ldd	r24, Y+22	; 0x16
    27b0:	90 91 ef 08 	lds	r25, 0x08EF
    27b4:	98 17       	cp	r25, r24
    27b6:	10 f4       	brcc	.+4      	; 0x27bc <xTaskResumeAll+0x70>
    27b8:	80 93 ef 08 	sts	0x08EF, r24
    27bc:	90 e0       	ldi	r25, 0x00	; 0
    27be:	9c 01       	movw	r18, r24
    27c0:	22 0f       	add	r18, r18
    27c2:	33 1f       	adc	r19, r19
    27c4:	22 0f       	add	r18, r18
    27c6:	33 1f       	adc	r19, r19
    27c8:	22 0f       	add	r18, r18
    27ca:	33 1f       	adc	r19, r19
    27cc:	82 0f       	add	r24, r18
    27ce:	93 1f       	adc	r25, r19
    27d0:	b8 01       	movw	r22, r16
    27d2:	84 5e       	subi	r24, 0xE4	; 228
    27d4:	96 4f       	sbci	r25, 0xF6	; 246
    27d6:	0e 94 70 04 	call	0x8e0	; 0x8e0 <vListInsertEnd>
    27da:	e0 91 40 09 	lds	r30, 0x0940
    27de:	f0 91 41 09 	lds	r31, 0x0941
    27e2:	9e 89       	ldd	r25, Y+22	; 0x16
    27e4:	86 89       	ldd	r24, Z+22	; 0x16
    27e6:	98 17       	cp	r25, r24
    27e8:	10 f0       	brcs	.+4      	; 0x27ee <xTaskResumeAll+0xa2>
    27ea:	d0 92 ec 08 	sts	0x08EC, r13
    27ee:	f7 01       	movw	r30, r14
    27f0:	80 81       	ld	r24, Z
    27f2:	81 11       	cpse	r24, r1
    27f4:	cc cf       	rjmp	.-104    	; 0x278e <xTaskResumeAll+0x42>
    27f6:	80 91 ed 08 	lds	r24, 0x08ED
    27fa:	88 23       	and	r24, r24
    27fc:	91 f0       	breq	.+36     	; 0x2822 <xTaskResumeAll+0xd6>
    27fe:	80 91 ed 08 	lds	r24, 0x08ED
    2802:	88 23       	and	r24, r24
    2804:	71 f0       	breq	.+28     	; 0x2822 <xTaskResumeAll+0xd6>
    2806:	c1 e0       	ldi	r28, 0x01	; 1
    2808:	e3 de       	rcall	.-570    	; 0x25d0 <xTaskIncrementTick>
    280a:	81 11       	cpse	r24, r1
    280c:	c0 93 ec 08 	sts	0x08EC, r28
    2810:	80 91 ed 08 	lds	r24, 0x08ED
    2814:	81 50       	subi	r24, 0x01	; 1
    2816:	80 93 ed 08 	sts	0x08ED, r24
    281a:	80 91 ed 08 	lds	r24, 0x08ED
    281e:	81 11       	cpse	r24, r1
    2820:	f3 cf       	rjmp	.-26     	; 0x2808 <xTaskResumeAll+0xbc>
    2822:	80 91 ec 08 	lds	r24, 0x08EC
    2826:	81 30       	cpi	r24, 0x01	; 1
    2828:	39 f4       	brne	.+14     	; 0x2838 <xTaskResumeAll+0xec>
    282a:	e6 d8       	rcall	.-3636   	; 0x19f8 <vPortYield>
    282c:	81 e0       	ldi	r24, 0x01	; 1
    282e:	05 c0       	rjmp	.+10     	; 0x283a <xTaskResumeAll+0xee>
    2830:	80 e0       	ldi	r24, 0x00	; 0
    2832:	03 c0       	rjmp	.+6      	; 0x283a <xTaskResumeAll+0xee>
    2834:	80 e0       	ldi	r24, 0x00	; 0
    2836:	01 c0       	rjmp	.+2      	; 0x283a <xTaskResumeAll+0xee>
    2838:	80 e0       	ldi	r24, 0x00	; 0
    283a:	0f 90       	pop	r0
    283c:	0f be       	out	0x3f, r0	; 63
    283e:	df 91       	pop	r29
    2840:	cf 91       	pop	r28
    2842:	1f 91       	pop	r17
    2844:	0f 91       	pop	r16
    2846:	ff 90       	pop	r15
    2848:	ef 90       	pop	r14
    284a:	df 90       	pop	r13
    284c:	08 95       	ret

0000284e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    284e:	cf 93       	push	r28
    2850:	df 93       	push	r29
    2852:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2854:	00 97       	sbiw	r24, 0x00	; 0
    2856:	99 f0       	breq	.+38     	; 0x287e <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2858:	b5 de       	rcall	.-662    	; 0x25c4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    285a:	80 91 f0 08 	lds	r24, 0x08F0
    285e:	90 91 f1 08 	lds	r25, 0x08F1
    2862:	c8 0f       	add	r28, r24
    2864:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2866:	80 91 40 09 	lds	r24, 0x0940
    286a:	90 91 41 09 	lds	r25, 0x0941
    286e:	02 96       	adiw	r24, 0x02	; 2
    2870:	0e 94 c2 04 	call	0x984	; 0x984 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2874:	ce 01       	movw	r24, r28
    2876:	3e dd       	rcall	.-1412   	; 0x22f4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2878:	69 df       	rcall	.-302    	; 0x274c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    287a:	81 11       	cpse	r24, r1
    287c:	01 c0       	rjmp	.+2      	; 0x2880 <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    287e:	bc d8       	rcall	.-3720   	; 0x19f8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2880:	df 91       	pop	r29
    2882:	cf 91       	pop	r28
    2884:	08 95       	ret

00002886 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2886:	0f 2e       	mov	r0, r31
    2888:	fc e1       	ldi	r31, 0x1C	; 28
    288a:	ef 2e       	mov	r14, r31
    288c:	f9 e0       	ldi	r31, 0x09	; 9
    288e:	ff 2e       	mov	r15, r31
    2890:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2892:	c4 ef       	ldi	r28, 0xF4	; 244
    2894:	d8 e0       	ldi	r29, 0x08	; 8
    2896:	26 c0       	rjmp	.+76     	; 0x28e4 <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2898:	95 de       	rcall	.-726    	; 0x25c4 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    289a:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    289c:	57 df       	rcall	.-338    	; 0x274c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    289e:	11 23       	and	r17, r17
    28a0:	09 f1       	breq	.+66     	; 0x28e4 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    28a8:	e0 91 f9 08 	lds	r30, 0x08F9
    28ac:	f0 91 fa 08 	lds	r31, 0x08FA
    28b0:	06 81       	ldd	r16, Z+6	; 0x06
    28b2:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    28b4:	c8 01       	movw	r24, r16
    28b6:	02 96       	adiw	r24, 0x02	; 2
    28b8:	0e 94 c2 04 	call	0x984	; 0x984 <uxListRemove>
					--uxCurrentNumberOfTasks;
    28bc:	80 91 f2 08 	lds	r24, 0x08F2
    28c0:	81 50       	subi	r24, 0x01	; 1
    28c2:	80 93 f2 08 	sts	0x08F2, r24
					--uxTasksDeleted;
    28c6:	80 91 f3 08 	lds	r24, 0x08F3
    28ca:	81 50       	subi	r24, 0x01	; 1
    28cc:	80 93 f3 08 	sts	0x08F3, r24
				}
				taskEXIT_CRITICAL();
    28d0:	0f 90       	pop	r0
    28d2:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    28d4:	f8 01       	movw	r30, r16
    28d6:	87 89       	ldd	r24, Z+23	; 0x17
    28d8:	90 8d       	ldd	r25, Z+24	; 0x18
    28da:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>
		vPortFree( pxTCB );
    28de:	c8 01       	movw	r24, r16
    28e0:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    28e4:	80 91 f3 08 	lds	r24, 0x08F3
    28e8:	81 11       	cpse	r24, r1
    28ea:	d6 cf       	rjmp	.-84     	; 0x2898 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    28ec:	f7 01       	movw	r30, r14
    28ee:	80 81       	ld	r24, Z
    28f0:	82 30       	cpi	r24, 0x02	; 2
    28f2:	c0 f3       	brcs	.-16     	; 0x28e4 <prvIdleTask+0x5e>
			{
				taskYIELD();
    28f4:	81 d8       	rcall	.-3838   	; 0x19f8 <vPortYield>
    28f6:	f6 cf       	rjmp	.-20     	; 0x28e4 <prvIdleTask+0x5e>

000028f8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    28f8:	80 91 e9 08 	lds	r24, 0x08E9
    28fc:	88 23       	and	r24, r24
    28fe:	21 f0       	breq	.+8      	; 0x2908 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	80 93 ec 08 	sts	0x08EC, r24
    2906:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2908:	10 92 ec 08 	sts	0x08EC, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    290c:	80 91 ef 08 	lds	r24, 0x08EF
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	fc 01       	movw	r30, r24
    2914:	ee 0f       	add	r30, r30
    2916:	ff 1f       	adc	r31, r31
    2918:	ee 0f       	add	r30, r30
    291a:	ff 1f       	adc	r31, r31
    291c:	ee 0f       	add	r30, r30
    291e:	ff 1f       	adc	r31, r31
    2920:	8e 0f       	add	r24, r30
    2922:	9f 1f       	adc	r25, r31
    2924:	fc 01       	movw	r30, r24
    2926:	e4 5e       	subi	r30, 0xE4	; 228
    2928:	f6 4f       	sbci	r31, 0xF6	; 246
    292a:	80 81       	ld	r24, Z
    292c:	81 11       	cpse	r24, r1
    292e:	17 c0       	rjmp	.+46     	; 0x295e <vTaskSwitchContext+0x66>
    2930:	80 91 ef 08 	lds	r24, 0x08EF
    2934:	81 50       	subi	r24, 0x01	; 1
    2936:	80 93 ef 08 	sts	0x08EF, r24
    293a:	80 91 ef 08 	lds	r24, 0x08EF
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	fc 01       	movw	r30, r24
    2942:	ee 0f       	add	r30, r30
    2944:	ff 1f       	adc	r31, r31
    2946:	ee 0f       	add	r30, r30
    2948:	ff 1f       	adc	r31, r31
    294a:	ee 0f       	add	r30, r30
    294c:	ff 1f       	adc	r31, r31
    294e:	8e 0f       	add	r24, r30
    2950:	9f 1f       	adc	r25, r31
    2952:	fc 01       	movw	r30, r24
    2954:	e4 5e       	subi	r30, 0xE4	; 228
    2956:	f6 4f       	sbci	r31, 0xF6	; 246
    2958:	80 81       	ld	r24, Z
    295a:	88 23       	and	r24, r24
    295c:	49 f3       	breq	.-46     	; 0x2930 <vTaskSwitchContext+0x38>
    295e:	e0 91 ef 08 	lds	r30, 0x08EF
    2962:	f0 e0       	ldi	r31, 0x00	; 0
    2964:	cf 01       	movw	r24, r30
    2966:	88 0f       	add	r24, r24
    2968:	99 1f       	adc	r25, r25
    296a:	88 0f       	add	r24, r24
    296c:	99 1f       	adc	r25, r25
    296e:	88 0f       	add	r24, r24
    2970:	99 1f       	adc	r25, r25
    2972:	e8 0f       	add	r30, r24
    2974:	f9 1f       	adc	r31, r25
    2976:	e4 5e       	subi	r30, 0xE4	; 228
    2978:	f6 4f       	sbci	r31, 0xF6	; 246
    297a:	a1 81       	ldd	r26, Z+1	; 0x01
    297c:	b2 81       	ldd	r27, Z+2	; 0x02
    297e:	12 96       	adiw	r26, 0x02	; 2
    2980:	0d 90       	ld	r0, X+
    2982:	bc 91       	ld	r27, X
    2984:	a0 2d       	mov	r26, r0
    2986:	b2 83       	std	Z+2, r27	; 0x02
    2988:	a1 83       	std	Z+1, r26	; 0x01
    298a:	cf 01       	movw	r24, r30
    298c:	03 96       	adiw	r24, 0x03	; 3
    298e:	a8 17       	cp	r26, r24
    2990:	b9 07       	cpc	r27, r25
    2992:	31 f4       	brne	.+12     	; 0x29a0 <vTaskSwitchContext+0xa8>
    2994:	12 96       	adiw	r26, 0x02	; 2
    2996:	8d 91       	ld	r24, X+
    2998:	9c 91       	ld	r25, X
    299a:	13 97       	sbiw	r26, 0x03	; 3
    299c:	92 83       	std	Z+2, r25	; 0x02
    299e:	81 83       	std	Z+1, r24	; 0x01
    29a0:	01 80       	ldd	r0, Z+1	; 0x01
    29a2:	f2 81       	ldd	r31, Z+2	; 0x02
    29a4:	e0 2d       	mov	r30, r0
    29a6:	86 81       	ldd	r24, Z+6	; 0x06
    29a8:	97 81       	ldd	r25, Z+7	; 0x07
    29aa:	90 93 41 09 	sts	0x0941, r25
    29ae:	80 93 40 09 	sts	0x0940, r24
    29b2:	08 95       	ret

000029b4 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    29b4:	10 92 af 09 	sts	0x09AF, r1
    29b8:	81 e0       	ldi	r24, 0x01	; 1
    29ba:	80 93 ad 09 	sts	0x09AD, r24
    29be:	10 92 ac 09 	sts	0x09AC, r1
    29c2:	61 e0       	ldi	r22, 0x01	; 1
    29c4:	84 e1       	ldi	r24, 0x14	; 20
    29c6:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    29ca:	61 e0       	ldi	r22, 0x01	; 1
    29cc:	85 e1       	ldi	r24, 0x15	; 21
    29ce:	0e 94 b8 20 	call	0x4170	; 0x4170 <digitalWrite>
    29d2:	e9 eb       	ldi	r30, 0xB9	; 185
    29d4:	f0 e0       	ldi	r31, 0x00	; 0
    29d6:	80 81       	ld	r24, Z
    29d8:	8e 7f       	andi	r24, 0xFE	; 254
    29da:	80 83       	st	Z, r24
    29dc:	80 81       	ld	r24, Z
    29de:	8d 7f       	andi	r24, 0xFD	; 253
    29e0:	80 83       	st	Z, r24
    29e2:	8d ef       	ldi	r24, 0xFD	; 253
    29e4:	80 93 b8 00 	sts	0x00B8, r24
    29e8:	85 e4       	ldi	r24, 0x45	; 69
    29ea:	80 93 bc 00 	sts	0x00BC, r24
    29ee:	08 95       	ret

000029f0 <twi_readFrom>:
    29f0:	41 32       	cpi	r20, 0x21	; 33
    29f2:	08 f0       	brcs	.+2      	; 0x29f6 <twi_readFrom+0x6>
    29f4:	45 c0       	rjmp	.+138    	; 0x2a80 <twi_readFrom+0x90>
    29f6:	90 91 af 09 	lds	r25, 0x09AF
    29fa:	91 11       	cpse	r25, r1
    29fc:	fc cf       	rjmp	.-8      	; 0x29f6 <twi_readFrom+0x6>
    29fe:	91 e0       	ldi	r25, 0x01	; 1
    2a00:	90 93 af 09 	sts	0x09AF, r25
    2a04:	20 93 ad 09 	sts	0x09AD, r18
    2a08:	2f ef       	ldi	r18, 0xFF	; 255
    2a0a:	20 93 42 09 	sts	0x0942, r18
    2a0e:	10 92 87 09 	sts	0x0987, r1
    2a12:	24 0f       	add	r18, r20
    2a14:	20 93 86 09 	sts	0x0986, r18
    2a18:	90 93 ae 09 	sts	0x09AE, r25
    2a1c:	90 91 ae 09 	lds	r25, 0x09AE
    2a20:	88 0f       	add	r24, r24
    2a22:	89 2b       	or	r24, r25
    2a24:	80 93 ae 09 	sts	0x09AE, r24
    2a28:	80 91 ac 09 	lds	r24, 0x09AC
    2a2c:	81 30       	cpi	r24, 0x01	; 1
    2a2e:	51 f4       	brne	.+20     	; 0x2a44 <twi_readFrom+0x54>
    2a30:	10 92 ac 09 	sts	0x09AC, r1
    2a34:	80 91 ae 09 	lds	r24, 0x09AE
    2a38:	80 93 bb 00 	sts	0x00BB, r24
    2a3c:	85 ec       	ldi	r24, 0xC5	; 197
    2a3e:	80 93 bc 00 	sts	0x00BC, r24
    2a42:	03 c0       	rjmp	.+6      	; 0x2a4a <twi_readFrom+0x5a>
    2a44:	85 ee       	ldi	r24, 0xE5	; 229
    2a46:	80 93 bc 00 	sts	0x00BC, r24
    2a4a:	80 91 af 09 	lds	r24, 0x09AF
    2a4e:	81 30       	cpi	r24, 0x01	; 1
    2a50:	e1 f3       	breq	.-8      	; 0x2a4a <twi_readFrom+0x5a>
    2a52:	80 91 87 09 	lds	r24, 0x0987
    2a56:	84 17       	cp	r24, r20
    2a58:	10 f4       	brcc	.+4      	; 0x2a5e <twi_readFrom+0x6e>
    2a5a:	40 91 87 09 	lds	r20, 0x0987
    2a5e:	44 23       	and	r20, r20
    2a60:	89 f0       	breq	.+34     	; 0x2a84 <twi_readFrom+0x94>
    2a62:	e8 e8       	ldi	r30, 0x88	; 136
    2a64:	f9 e0       	ldi	r31, 0x09	; 9
    2a66:	a6 2f       	mov	r26, r22
    2a68:	b7 2f       	mov	r27, r23
    2a6a:	2f ef       	ldi	r18, 0xFF	; 255
    2a6c:	24 0f       	add	r18, r20
    2a6e:	30 e0       	ldi	r19, 0x00	; 0
    2a70:	27 57       	subi	r18, 0x77	; 119
    2a72:	36 4f       	sbci	r19, 0xF6	; 246
    2a74:	91 91       	ld	r25, Z+
    2a76:	9d 93       	st	X+, r25
    2a78:	e2 17       	cp	r30, r18
    2a7a:	f3 07       	cpc	r31, r19
    2a7c:	d9 f7       	brne	.-10     	; 0x2a74 <twi_readFrom+0x84>
    2a7e:	04 c0       	rjmp	.+8      	; 0x2a88 <twi_readFrom+0x98>
    2a80:	80 e0       	ldi	r24, 0x00	; 0
    2a82:	08 95       	ret
    2a84:	84 2f       	mov	r24, r20
    2a86:	08 95       	ret
    2a88:	84 2f       	mov	r24, r20
    2a8a:	08 95       	ret

00002a8c <twi_writeTo>:
    2a8c:	0f 93       	push	r16
    2a8e:	41 32       	cpi	r20, 0x21	; 33
    2a90:	08 f0       	brcs	.+2      	; 0x2a94 <twi_writeTo+0x8>
    2a92:	50 c0       	rjmp	.+160    	; 0x2b34 <twi_writeTo+0xa8>
    2a94:	90 91 af 09 	lds	r25, 0x09AF
    2a98:	91 11       	cpse	r25, r1
    2a9a:	fc cf       	rjmp	.-8      	; 0x2a94 <twi_writeTo+0x8>
    2a9c:	92 e0       	ldi	r25, 0x02	; 2
    2a9e:	90 93 af 09 	sts	0x09AF, r25
    2aa2:	00 93 ad 09 	sts	0x09AD, r16
    2aa6:	9f ef       	ldi	r25, 0xFF	; 255
    2aa8:	90 93 42 09 	sts	0x0942, r25
    2aac:	10 92 87 09 	sts	0x0987, r1
    2ab0:	40 93 86 09 	sts	0x0986, r20
    2ab4:	44 23       	and	r20, r20
    2ab6:	69 f0       	breq	.+26     	; 0x2ad2 <twi_writeTo+0x46>
    2ab8:	fb 01       	movw	r30, r22
    2aba:	a8 e8       	ldi	r26, 0x88	; 136
    2abc:	b9 e0       	ldi	r27, 0x09	; 9
    2abe:	6f 5f       	subi	r22, 0xFF	; 255
    2ac0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ac2:	41 50       	subi	r20, 0x01	; 1
    2ac4:	64 0f       	add	r22, r20
    2ac6:	71 1d       	adc	r23, r1
    2ac8:	91 91       	ld	r25, Z+
    2aca:	9d 93       	st	X+, r25
    2acc:	e6 17       	cp	r30, r22
    2ace:	f7 07       	cpc	r31, r23
    2ad0:	d9 f7       	brne	.-10     	; 0x2ac8 <twi_writeTo+0x3c>
    2ad2:	10 92 ae 09 	sts	0x09AE, r1
    2ad6:	90 91 ae 09 	lds	r25, 0x09AE
    2ada:	88 0f       	add	r24, r24
    2adc:	89 2b       	or	r24, r25
    2ade:	80 93 ae 09 	sts	0x09AE, r24
    2ae2:	80 91 ac 09 	lds	r24, 0x09AC
    2ae6:	81 30       	cpi	r24, 0x01	; 1
    2ae8:	51 f4       	brne	.+20     	; 0x2afe <twi_writeTo+0x72>
    2aea:	10 92 ac 09 	sts	0x09AC, r1
    2aee:	80 91 ae 09 	lds	r24, 0x09AE
    2af2:	80 93 bb 00 	sts	0x00BB, r24
    2af6:	85 ec       	ldi	r24, 0xC5	; 197
    2af8:	80 93 bc 00 	sts	0x00BC, r24
    2afc:	03 c0       	rjmp	.+6      	; 0x2b04 <twi_writeTo+0x78>
    2afe:	85 ee       	ldi	r24, 0xE5	; 229
    2b00:	80 93 bc 00 	sts	0x00BC, r24
    2b04:	22 23       	and	r18, r18
    2b06:	41 f0       	breq	.+16     	; 0x2b18 <twi_writeTo+0x8c>
    2b08:	80 91 af 09 	lds	r24, 0x09AF
    2b0c:	82 30       	cpi	r24, 0x02	; 2
    2b0e:	21 f4       	brne	.+8      	; 0x2b18 <twi_writeTo+0x8c>
    2b10:	80 91 af 09 	lds	r24, 0x09AF
    2b14:	82 30       	cpi	r24, 0x02	; 2
    2b16:	e1 f3       	breq	.-8      	; 0x2b10 <twi_writeTo+0x84>
    2b18:	80 91 42 09 	lds	r24, 0x0942
    2b1c:	8f 3f       	cpi	r24, 0xFF	; 255
    2b1e:	61 f0       	breq	.+24     	; 0x2b38 <twi_writeTo+0xac>
    2b20:	80 91 42 09 	lds	r24, 0x0942
    2b24:	80 32       	cpi	r24, 0x20	; 32
    2b26:	51 f0       	breq	.+20     	; 0x2b3c <twi_writeTo+0xb0>
    2b28:	80 91 42 09 	lds	r24, 0x0942
    2b2c:	80 33       	cpi	r24, 0x30	; 48
    2b2e:	41 f4       	brne	.+16     	; 0x2b40 <twi_writeTo+0xb4>
    2b30:	83 e0       	ldi	r24, 0x03	; 3
    2b32:	07 c0       	rjmp	.+14     	; 0x2b42 <twi_writeTo+0xb6>
    2b34:	81 e0       	ldi	r24, 0x01	; 1
    2b36:	05 c0       	rjmp	.+10     	; 0x2b42 <twi_writeTo+0xb6>
    2b38:	80 e0       	ldi	r24, 0x00	; 0
    2b3a:	03 c0       	rjmp	.+6      	; 0x2b42 <twi_writeTo+0xb6>
    2b3c:	82 e0       	ldi	r24, 0x02	; 2
    2b3e:	01 c0       	rjmp	.+2      	; 0x2b42 <twi_writeTo+0xb6>
    2b40:	84 e0       	ldi	r24, 0x04	; 4
    2b42:	0f 91       	pop	r16
    2b44:	08 95       	ret

00002b46 <twi_transmit>:
    2b46:	61 32       	cpi	r22, 0x21	; 33
    2b48:	a8 f4       	brcc	.+42     	; 0x2b74 <twi_transmit+0x2e>
    2b4a:	20 91 af 09 	lds	r18, 0x09AF
    2b4e:	24 30       	cpi	r18, 0x04	; 4
    2b50:	99 f4       	brne	.+38     	; 0x2b78 <twi_transmit+0x32>
    2b52:	60 93 64 09 	sts	0x0964, r22
    2b56:	66 23       	and	r22, r22
    2b58:	89 f0       	breq	.+34     	; 0x2b7c <twi_transmit+0x36>
    2b5a:	fc 01       	movw	r30, r24
    2b5c:	a6 e6       	ldi	r26, 0x66	; 102
    2b5e:	b9 e0       	ldi	r27, 0x09	; 9
    2b60:	01 96       	adiw	r24, 0x01	; 1
    2b62:	61 50       	subi	r22, 0x01	; 1
    2b64:	86 0f       	add	r24, r22
    2b66:	91 1d       	adc	r25, r1
    2b68:	21 91       	ld	r18, Z+
    2b6a:	2d 93       	st	X+, r18
    2b6c:	e8 17       	cp	r30, r24
    2b6e:	f9 07       	cpc	r31, r25
    2b70:	d9 f7       	brne	.-10     	; 0x2b68 <twi_transmit+0x22>
    2b72:	06 c0       	rjmp	.+12     	; 0x2b80 <twi_transmit+0x3a>
    2b74:	81 e0       	ldi	r24, 0x01	; 1
    2b76:	08 95       	ret
    2b78:	82 e0       	ldi	r24, 0x02	; 2
    2b7a:	08 95       	ret
    2b7c:	80 e0       	ldi	r24, 0x00	; 0
    2b7e:	08 95       	ret
    2b80:	80 e0       	ldi	r24, 0x00	; 0
    2b82:	08 95       	ret

00002b84 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    2b84:	85 ed       	ldi	r24, 0xD5	; 213
    2b86:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    2b8a:	ec eb       	ldi	r30, 0xBC	; 188
    2b8c:	f0 e0       	ldi	r31, 0x00	; 0
    2b8e:	80 81       	ld	r24, Z
    2b90:	84 fd       	sbrc	r24, 4
    2b92:	fd cf       	rjmp	.-6      	; 0x2b8e <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    2b94:	10 92 af 09 	sts	0x09AF, r1
    2b98:	08 95       	ret

00002b9a <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2b9a:	85 ec       	ldi	r24, 0xC5	; 197
    2b9c:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2ba0:	10 92 af 09 	sts	0x09AF, r1
    2ba4:	08 95       	ret

00002ba6 <__vector_39>:
}

ISR(TWI_vect)
{
    2ba6:	1f 92       	push	r1
    2ba8:	0f 92       	push	r0
    2baa:	0f b6       	in	r0, 0x3f	; 63
    2bac:	0f 92       	push	r0
    2bae:	11 24       	eor	r1, r1
    2bb0:	0b b6       	in	r0, 0x3b	; 59
    2bb2:	0f 92       	push	r0
    2bb4:	2f 93       	push	r18
    2bb6:	3f 93       	push	r19
    2bb8:	4f 93       	push	r20
    2bba:	5f 93       	push	r21
    2bbc:	6f 93       	push	r22
    2bbe:	7f 93       	push	r23
    2bc0:	8f 93       	push	r24
    2bc2:	9f 93       	push	r25
    2bc4:	af 93       	push	r26
    2bc6:	bf 93       	push	r27
    2bc8:	ef 93       	push	r30
    2bca:	ff 93       	push	r31
  switch(TW_STATUS){
    2bcc:	80 91 b9 00 	lds	r24, 0x00B9
    2bd0:	88 7f       	andi	r24, 0xF8	; 248
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	89 3c       	cpi	r24, 0xC9	; 201
    2bd6:	91 05       	cpc	r25, r1
    2bd8:	08 f0       	brcs	.+2      	; 0x2bdc <__vector_39+0x36>
    2bda:	ee c0       	rjmp	.+476    	; 0x2db8 <__vector_39+0x212>
    2bdc:	fc 01       	movw	r30, r24
    2bde:	ee 58       	subi	r30, 0x8E	; 142
    2be0:	ff 4f       	sbci	r31, 0xFF	; 255
    2be2:	0c 94 5b 21 	jmp	0x42b6	; 0x42b6 <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    2be6:	80 91 ae 09 	lds	r24, 0x09AE
    2bea:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2bee:	85 ec       	ldi	r24, 0xC5	; 197
    2bf0:	80 93 bc 00 	sts	0x00BC, r24
    2bf4:	e1 c0       	rjmp	.+450    	; 0x2db8 <__vector_39+0x212>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2bf6:	90 91 87 09 	lds	r25, 0x0987
    2bfa:	80 91 86 09 	lds	r24, 0x0986
    2bfe:	98 17       	cp	r25, r24
    2c00:	80 f4       	brcc	.+32     	; 0x2c22 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    2c02:	e0 91 87 09 	lds	r30, 0x0987
    2c06:	81 e0       	ldi	r24, 0x01	; 1
    2c08:	8e 0f       	add	r24, r30
    2c0a:	80 93 87 09 	sts	0x0987, r24
    2c0e:	f0 e0       	ldi	r31, 0x00	; 0
    2c10:	e8 57       	subi	r30, 0x78	; 120
    2c12:	f6 4f       	sbci	r31, 0xF6	; 246
    2c14:	80 81       	ld	r24, Z
    2c16:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2c1a:	85 ec       	ldi	r24, 0xC5	; 197
    2c1c:	80 93 bc 00 	sts	0x00BC, r24
    2c20:	cb c0       	rjmp	.+406    	; 0x2db8 <__vector_39+0x212>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    2c22:	80 91 ad 09 	lds	r24, 0x09AD
    2c26:	88 23       	and	r24, r24
    2c28:	11 f0       	breq	.+4      	; 0x2c2e <__vector_39+0x88>
          twi_stop();
    2c2a:	ac df       	rcall	.-168    	; 0x2b84 <twi_stop>
    2c2c:	c5 c0       	rjmp	.+394    	; 0x2db8 <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2c2e:	81 e0       	ldi	r24, 0x01	; 1
    2c30:	80 93 ac 09 	sts	0x09AC, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2c34:	84 ea       	ldi	r24, 0xA4	; 164
    2c36:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    2c3a:	10 92 af 09 	sts	0x09AF, r1
    2c3e:	bc c0       	rjmp	.+376    	; 0x2db8 <__vector_39+0x212>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    2c40:	80 e2       	ldi	r24, 0x20	; 32
    2c42:	80 93 42 09 	sts	0x0942, r24
      twi_stop();
    2c46:	9e df       	rcall	.-196    	; 0x2b84 <twi_stop>
      break;
    2c48:	b7 c0       	rjmp	.+366    	; 0x2db8 <__vector_39+0x212>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    2c4a:	80 e3       	ldi	r24, 0x30	; 48
    2c4c:	80 93 42 09 	sts	0x0942, r24
      twi_stop();
    2c50:	99 df       	rcall	.-206    	; 0x2b84 <twi_stop>
      break;
    2c52:	b2 c0       	rjmp	.+356    	; 0x2db8 <__vector_39+0x212>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    2c54:	88 e3       	ldi	r24, 0x38	; 56
    2c56:	80 93 42 09 	sts	0x0942, r24
      twi_releaseBus();
    2c5a:	9f df       	rcall	.-194    	; 0x2b9a <twi_releaseBus>
      break;
    2c5c:	ad c0       	rjmp	.+346    	; 0x2db8 <__vector_39+0x212>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2c5e:	e0 91 87 09 	lds	r30, 0x0987
    2c62:	81 e0       	ldi	r24, 0x01	; 1
    2c64:	8e 0f       	add	r24, r30
    2c66:	80 93 87 09 	sts	0x0987, r24
    2c6a:	80 91 bb 00 	lds	r24, 0x00BB
    2c6e:	f0 e0       	ldi	r31, 0x00	; 0
    2c70:	e8 57       	subi	r30, 0x78	; 120
    2c72:	f6 4f       	sbci	r31, 0xF6	; 246
    2c74:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2c76:	90 91 87 09 	lds	r25, 0x0987
    2c7a:	80 91 86 09 	lds	r24, 0x0986
    2c7e:	98 17       	cp	r25, r24
    2c80:	20 f4       	brcc	.+8      	; 0x2c8a <__vector_39+0xe4>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2c82:	85 ec       	ldi	r24, 0xC5	; 197
    2c84:	80 93 bc 00 	sts	0x00BC, r24
    2c88:	97 c0       	rjmp	.+302    	; 0x2db8 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2c8a:	85 e8       	ldi	r24, 0x85	; 133
    2c8c:	80 93 bc 00 	sts	0x00BC, r24
    2c90:	93 c0       	rjmp	.+294    	; 0x2db8 <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2c92:	e0 91 87 09 	lds	r30, 0x0987
    2c96:	81 e0       	ldi	r24, 0x01	; 1
    2c98:	8e 0f       	add	r24, r30
    2c9a:	80 93 87 09 	sts	0x0987, r24
    2c9e:	80 91 bb 00 	lds	r24, 0x00BB
    2ca2:	f0 e0       	ldi	r31, 0x00	; 0
    2ca4:	e8 57       	subi	r30, 0x78	; 120
    2ca6:	f6 4f       	sbci	r31, 0xF6	; 246
    2ca8:	80 83       	st	Z, r24
	if (twi_sendStop)
    2caa:	80 91 ad 09 	lds	r24, 0x09AD
    2cae:	88 23       	and	r24, r24
    2cb0:	11 f0       	breq	.+4      	; 0x2cb6 <__vector_39+0x110>
          twi_stop();
    2cb2:	68 df       	rcall	.-304    	; 0x2b84 <twi_stop>
    2cb4:	81 c0       	rjmp	.+258    	; 0x2db8 <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2cb6:	81 e0       	ldi	r24, 0x01	; 1
    2cb8:	80 93 ac 09 	sts	0x09AC, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2cbc:	84 ea       	ldi	r24, 0xA4	; 164
    2cbe:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    2cc2:	10 92 af 09 	sts	0x09AF, r1
    2cc6:	78 c0       	rjmp	.+240    	; 0x2db8 <__vector_39+0x212>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    2cc8:	5d df       	rcall	.-326    	; 0x2b84 <twi_stop>
      break;
    2cca:	76 c0       	rjmp	.+236    	; 0x2db8 <__vector_39+0x212>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    2ccc:	83 e0       	ldi	r24, 0x03	; 3
    2cce:	80 93 af 09 	sts	0x09AF, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    2cd2:	10 92 43 09 	sts	0x0943, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2cd6:	85 ec       	ldi	r24, 0xC5	; 197
    2cd8:	80 93 bc 00 	sts	0x00BC, r24
    2cdc:	6d c0       	rjmp	.+218    	; 0x2db8 <__vector_39+0x212>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    2cde:	80 91 43 09 	lds	r24, 0x0943
    2ce2:	80 32       	cpi	r24, 0x20	; 32
    2ce4:	80 f4       	brcc	.+32     	; 0x2d06 <__vector_39+0x160>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    2ce6:	e0 91 43 09 	lds	r30, 0x0943
    2cea:	81 e0       	ldi	r24, 0x01	; 1
    2cec:	8e 0f       	add	r24, r30
    2cee:	80 93 43 09 	sts	0x0943, r24
    2cf2:	80 91 bb 00 	lds	r24, 0x00BB
    2cf6:	f0 e0       	ldi	r31, 0x00	; 0
    2cf8:	ec 5b       	subi	r30, 0xBC	; 188
    2cfa:	f6 4f       	sbci	r31, 0xF6	; 246
    2cfc:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2cfe:	85 ec       	ldi	r24, 0xC5	; 197
    2d00:	80 93 bc 00 	sts	0x00BC, r24
    2d04:	59 c0       	rjmp	.+178    	; 0x2db8 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2d06:	85 e8       	ldi	r24, 0x85	; 133
    2d08:	80 93 bc 00 	sts	0x00BC, r24
    2d0c:	55 c0       	rjmp	.+170    	; 0x2db8 <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    2d0e:	80 91 43 09 	lds	r24, 0x0943
    2d12:	80 32       	cpi	r24, 0x20	; 32
    2d14:	30 f4       	brcc	.+12     	; 0x2d22 <__vector_39+0x17c>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    2d16:	e0 91 43 09 	lds	r30, 0x0943
    2d1a:	f0 e0       	ldi	r31, 0x00	; 0
    2d1c:	ec 5b       	subi	r30, 0xBC	; 188
    2d1e:	f6 4f       	sbci	r31, 0xF6	; 246
    2d20:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    2d22:	30 df       	rcall	.-416    	; 0x2b84 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    2d24:	60 91 43 09 	lds	r22, 0x0943
    2d28:	70 e0       	ldi	r23, 0x00	; 0
    2d2a:	e0 91 a8 09 	lds	r30, 0x09A8
    2d2e:	f0 91 a9 09 	lds	r31, 0x09A9
    2d32:	84 e4       	ldi	r24, 0x44	; 68
    2d34:	99 e0       	ldi	r25, 0x09	; 9
    2d36:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    2d38:	10 92 43 09 	sts	0x0943, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    2d3c:	2e df       	rcall	.-420    	; 0x2b9a <twi_releaseBus>
      break;
    2d3e:	3c c0       	rjmp	.+120    	; 0x2db8 <__vector_39+0x212>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2d40:	85 e8       	ldi	r24, 0x85	; 133
    2d42:	80 93 bc 00 	sts	0x00BC, r24
    2d46:	38 c0       	rjmp	.+112    	; 0x2db8 <__vector_39+0x212>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    2d48:	84 e0       	ldi	r24, 0x04	; 4
    2d4a:	80 93 af 09 	sts	0x09AF, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    2d4e:	10 92 65 09 	sts	0x0965, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2d52:	10 92 64 09 	sts	0x0964, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    2d56:	e0 91 aa 09 	lds	r30, 0x09AA
    2d5a:	f0 91 ab 09 	lds	r31, 0x09AB
    2d5e:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2d60:	80 91 64 09 	lds	r24, 0x0964
    2d64:	81 11       	cpse	r24, r1
    2d66:	05 c0       	rjmp	.+10     	; 0x2d72 <__vector_39+0x1cc>
        twi_txBufferLength = 1;
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	80 93 64 09 	sts	0x0964, r24
        twi_txBuffer[0] = 0x00;
    2d6e:	10 92 66 09 	sts	0x0966, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2d72:	e0 91 65 09 	lds	r30, 0x0965
    2d76:	81 e0       	ldi	r24, 0x01	; 1
    2d78:	8e 0f       	add	r24, r30
    2d7a:	80 93 65 09 	sts	0x0965, r24
    2d7e:	f0 e0       	ldi	r31, 0x00	; 0
    2d80:	ea 59       	subi	r30, 0x9A	; 154
    2d82:	f6 4f       	sbci	r31, 0xF6	; 246
    2d84:	80 81       	ld	r24, Z
    2d86:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    2d8a:	90 91 65 09 	lds	r25, 0x0965
    2d8e:	80 91 64 09 	lds	r24, 0x0964
    2d92:	98 17       	cp	r25, r24
    2d94:	20 f4       	brcc	.+8      	; 0x2d9e <__vector_39+0x1f8>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2d96:	85 ec       	ldi	r24, 0xC5	; 197
    2d98:	80 93 bc 00 	sts	0x00BC, r24
    2d9c:	0d c0       	rjmp	.+26     	; 0x2db8 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2d9e:	85 e8       	ldi	r24, 0x85	; 133
    2da0:	80 93 bc 00 	sts	0x00BC, r24
    2da4:	09 c0       	rjmp	.+18     	; 0x2db8 <__vector_39+0x212>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2da6:	85 ec       	ldi	r24, 0xC5	; 197
    2da8:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    2dac:	10 92 af 09 	sts	0x09AF, r1
      break;
    2db0:	03 c0       	rjmp	.+6      	; 0x2db8 <__vector_39+0x212>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    2db2:	10 92 42 09 	sts	0x0942, r1
      twi_stop();
    2db6:	e6 de       	rcall	.-564    	; 0x2b84 <twi_stop>
      break;
  }
}
    2db8:	ff 91       	pop	r31
    2dba:	ef 91       	pop	r30
    2dbc:	bf 91       	pop	r27
    2dbe:	af 91       	pop	r26
    2dc0:	9f 91       	pop	r25
    2dc2:	8f 91       	pop	r24
    2dc4:	7f 91       	pop	r23
    2dc6:	6f 91       	pop	r22
    2dc8:	5f 91       	pop	r21
    2dca:	4f 91       	pop	r20
    2dcc:	3f 91       	pop	r19
    2dce:	2f 91       	pop	r18
    2dd0:	0f 90       	pop	r0
    2dd2:	0b be       	out	0x3b, r0	; 59
    2dd4:	0f 90       	pop	r0
    2dd6:	0f be       	out	0x3f, r0	; 63
    2dd8:	0f 90       	pop	r0
    2dda:	1f 90       	pop	r1
    2ddc:	18 95       	reti

00002dde <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    2dde:	80 91 e0 09 	lds	r24, 0x09E0
    2de2:	90 e0       	ldi	r25, 0x00	; 0
    2de4:	20 91 e1 09 	lds	r18, 0x09E1
    2de8:	82 1b       	sub	r24, r18
    2dea:	91 09       	sbc	r25, r1
    2dec:	08 95       	ret

00002dee <_ZN7TwoWire4readEv>:
    2dee:	20 91 e1 09 	lds	r18, 0x09E1
    2df2:	80 91 e0 09 	lds	r24, 0x09E0
    2df6:	28 17       	cp	r18, r24
    2df8:	50 f4       	brcc	.+20     	; 0x2e0e <_ZN7TwoWire4readEv+0x20>
    2dfa:	e2 2f       	mov	r30, r18
    2dfc:	f0 e0       	ldi	r31, 0x00	; 0
    2dfe:	ee 51       	subi	r30, 0x1E	; 30
    2e00:	f6 4f       	sbci	r31, 0xF6	; 246
    2e02:	80 81       	ld	r24, Z
    2e04:	90 e0       	ldi	r25, 0x00	; 0
    2e06:	2f 5f       	subi	r18, 0xFF	; 255
    2e08:	20 93 e1 09 	sts	0x09E1, r18
    2e0c:	08 95       	ret
    2e0e:	8f ef       	ldi	r24, 0xFF	; 255
    2e10:	9f ef       	ldi	r25, 0xFF	; 255
    2e12:	08 95       	ret

00002e14 <_ZN7TwoWire4peekEv>:
    2e14:	e0 91 e1 09 	lds	r30, 0x09E1
    2e18:	80 91 e0 09 	lds	r24, 0x09E0
    2e1c:	e8 17       	cp	r30, r24
    2e1e:	30 f4       	brcc	.+12     	; 0x2e2c <_ZN7TwoWire4peekEv+0x18>
    2e20:	f0 e0       	ldi	r31, 0x00	; 0
    2e22:	ee 51       	subi	r30, 0x1E	; 30
    2e24:	f6 4f       	sbci	r31, 0xF6	; 246
    2e26:	80 81       	ld	r24, Z
    2e28:	90 e0       	ldi	r25, 0x00	; 0
    2e2a:	08 95       	ret
    2e2c:	8f ef       	ldi	r24, 0xFF	; 255
    2e2e:	9f ef       	ldi	r25, 0xFF	; 255
    2e30:	08 95       	ret

00002e32 <_ZN7TwoWire5flushEv>:
    2e32:	08 95       	ret

00002e34 <_ZN7TwoWire5writeEPKhj>:
    2e34:	cf 92       	push	r12
    2e36:	df 92       	push	r13
    2e38:	ef 92       	push	r14
    2e3a:	ff 92       	push	r15
    2e3c:	0f 93       	push	r16
    2e3e:	1f 93       	push	r17
    2e40:	cf 93       	push	r28
    2e42:	df 93       	push	r29
    2e44:	8c 01       	movw	r16, r24
    2e46:	7b 01       	movw	r14, r22
    2e48:	6a 01       	movw	r12, r20
    2e4a:	80 91 bc 09 	lds	r24, 0x09BC
    2e4e:	88 23       	and	r24, r24
    2e50:	99 f0       	breq	.+38     	; 0x2e78 <_ZN7TwoWire5writeEPKhj+0x44>
    2e52:	41 15       	cp	r20, r1
    2e54:	51 05       	cpc	r21, r1
    2e56:	99 f0       	breq	.+38     	; 0x2e7e <_ZN7TwoWire5writeEPKhj+0x4a>
    2e58:	eb 01       	movw	r28, r22
    2e5a:	e4 0e       	add	r14, r20
    2e5c:	f5 1e       	adc	r15, r21
    2e5e:	69 91       	ld	r22, Y+
    2e60:	d8 01       	movw	r26, r16
    2e62:	ed 91       	ld	r30, X+
    2e64:	fc 91       	ld	r31, X
    2e66:	01 90       	ld	r0, Z+
    2e68:	f0 81       	ld	r31, Z
    2e6a:	e0 2d       	mov	r30, r0
    2e6c:	c8 01       	movw	r24, r16
    2e6e:	19 95       	eicall
    2e70:	ce 15       	cp	r28, r14
    2e72:	df 05       	cpc	r29, r15
    2e74:	a1 f7       	brne	.-24     	; 0x2e5e <_ZN7TwoWire5writeEPKhj+0x2a>
    2e76:	03 c0       	rjmp	.+6      	; 0x2e7e <_ZN7TwoWire5writeEPKhj+0x4a>
    2e78:	64 2f       	mov	r22, r20
    2e7a:	c7 01       	movw	r24, r14
    2e7c:	64 de       	rcall	.-824    	; 0x2b46 <twi_transmit>
    2e7e:	c6 01       	movw	r24, r12
    2e80:	df 91       	pop	r29
    2e82:	cf 91       	pop	r28
    2e84:	1f 91       	pop	r17
    2e86:	0f 91       	pop	r16
    2e88:	ff 90       	pop	r15
    2e8a:	ef 90       	pop	r14
    2e8c:	df 90       	pop	r13
    2e8e:	cf 90       	pop	r12
    2e90:	08 95       	ret

00002e92 <_ZN7TwoWire5writeEh>:
    2e92:	cf 93       	push	r28
    2e94:	df 93       	push	r29
    2e96:	1f 92       	push	r1
    2e98:	cd b7       	in	r28, 0x3d	; 61
    2e9a:	de b7       	in	r29, 0x3e	; 62
    2e9c:	69 83       	std	Y+1, r22	; 0x01
    2e9e:	20 91 bc 09 	lds	r18, 0x09BC
    2ea2:	22 23       	and	r18, r18
    2ea4:	e1 f0       	breq	.+56     	; 0x2ede <_ZN7TwoWire5writeEh+0x4c>
    2ea6:	20 91 bd 09 	lds	r18, 0x09BD
    2eaa:	20 32       	cpi	r18, 0x20	; 32
    2eac:	40 f0       	brcs	.+16     	; 0x2ebe <_ZN7TwoWire5writeEh+0x2c>
    2eae:	21 e0       	ldi	r18, 0x01	; 1
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	fc 01       	movw	r30, r24
    2eb4:	33 83       	std	Z+3, r19	; 0x03
    2eb6:	22 83       	std	Z+2, r18	; 0x02
    2eb8:	80 e0       	ldi	r24, 0x00	; 0
    2eba:	90 e0       	ldi	r25, 0x00	; 0
    2ebc:	16 c0       	rjmp	.+44     	; 0x2eea <_ZN7TwoWire5writeEh+0x58>
    2ebe:	80 91 be 09 	lds	r24, 0x09BE
    2ec2:	e8 2f       	mov	r30, r24
    2ec4:	f0 e0       	ldi	r31, 0x00	; 0
    2ec6:	e1 54       	subi	r30, 0x41	; 65
    2ec8:	f6 4f       	sbci	r31, 0xF6	; 246
    2eca:	99 81       	ldd	r25, Y+1	; 0x01
    2ecc:	90 83       	st	Z, r25
    2ece:	8f 5f       	subi	r24, 0xFF	; 255
    2ed0:	80 93 be 09 	sts	0x09BE, r24
    2ed4:	80 93 bd 09 	sts	0x09BD, r24
    2ed8:	81 e0       	ldi	r24, 0x01	; 1
    2eda:	90 e0       	ldi	r25, 0x00	; 0
    2edc:	06 c0       	rjmp	.+12     	; 0x2eea <_ZN7TwoWire5writeEh+0x58>
    2ede:	61 e0       	ldi	r22, 0x01	; 1
    2ee0:	ce 01       	movw	r24, r28
    2ee2:	01 96       	adiw	r24, 0x01	; 1
    2ee4:	30 de       	rcall	.-928    	; 0x2b46 <twi_transmit>
    2ee6:	81 e0       	ldi	r24, 0x01	; 1
    2ee8:	90 e0       	ldi	r25, 0x00	; 0
    2eea:	0f 90       	pop	r0
    2eec:	df 91       	pop	r29
    2eee:	cf 91       	pop	r28
    2ef0:	08 95       	ret

00002ef2 <_ZN7TwoWireC1Ev>:
    2ef2:	fc 01       	movw	r30, r24
    2ef4:	13 82       	std	Z+3, r1	; 0x03
    2ef6:	12 82       	std	Z+2, r1	; 0x02
    2ef8:	48 ee       	ldi	r20, 0xE8	; 232
    2efa:	53 e0       	ldi	r21, 0x03	; 3
    2efc:	60 e0       	ldi	r22, 0x00	; 0
    2efe:	70 e0       	ldi	r23, 0x00	; 0
    2f00:	44 83       	std	Z+4, r20	; 0x04
    2f02:	55 83       	std	Z+5, r21	; 0x05
    2f04:	66 83       	std	Z+6, r22	; 0x06
    2f06:	77 83       	std	Z+7, r23	; 0x07
    2f08:	89 e8       	ldi	r24, 0x89	; 137
    2f0a:	92 e0       	ldi	r25, 0x02	; 2
    2f0c:	91 83       	std	Z+1, r25	; 0x01
    2f0e:	80 83       	st	Z, r24
    2f10:	08 95       	ret

00002f12 <_ZN7TwoWire5beginEv>:
    2f12:	10 92 e1 09 	sts	0x09E1, r1
    2f16:	10 92 e0 09 	sts	0x09E0, r1
    2f1a:	10 92 be 09 	sts	0x09BE, r1
    2f1e:	10 92 bd 09 	sts	0x09BD, r1
    2f22:	48 cd       	rjmp	.-1392   	; 0x29b4 <twi_init>
    2f24:	08 95       	ret

00002f26 <_ZN7TwoWire11requestFromEhhh>:
    2f26:	86 2f       	mov	r24, r22
    2f28:	41 32       	cpi	r20, 0x21	; 33
    2f2a:	08 f0       	brcs	.+2      	; 0x2f2e <_ZN7TwoWire11requestFromEhhh+0x8>
    2f2c:	40 e2       	ldi	r20, 0x20	; 32
    2f2e:	62 ee       	ldi	r22, 0xE2	; 226
    2f30:	79 e0       	ldi	r23, 0x09	; 9
    2f32:	5e dd       	rcall	.-1348   	; 0x29f0 <twi_readFrom>
    2f34:	10 92 e1 09 	sts	0x09E1, r1
    2f38:	80 93 e0 09 	sts	0x09E0, r24
    2f3c:	08 95       	ret

00002f3e <_ZN7TwoWire11requestFromEhh>:
    2f3e:	21 e0       	ldi	r18, 0x01	; 1
    2f40:	f2 cf       	rjmp	.-28     	; 0x2f26 <_ZN7TwoWire11requestFromEhhh>
    2f42:	08 95       	ret

00002f44 <_ZN7TwoWire17beginTransmissionEh>:
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	80 93 bc 09 	sts	0x09BC, r24
    2f4a:	60 93 df 09 	sts	0x09DF, r22
    2f4e:	10 92 be 09 	sts	0x09BE, r1
    2f52:	10 92 bd 09 	sts	0x09BD, r1
    2f56:	08 95       	ret

00002f58 <_ZN7TwoWire15endTransmissionEh>:
    2f58:	0f 93       	push	r16
    2f5a:	06 2f       	mov	r16, r22
    2f5c:	21 e0       	ldi	r18, 0x01	; 1
    2f5e:	40 91 bd 09 	lds	r20, 0x09BD
    2f62:	6f eb       	ldi	r22, 0xBF	; 191
    2f64:	79 e0       	ldi	r23, 0x09	; 9
    2f66:	80 91 df 09 	lds	r24, 0x09DF
    2f6a:	90 dd       	rcall	.-1248   	; 0x2a8c <twi_writeTo>
    2f6c:	10 92 be 09 	sts	0x09BE, r1
    2f70:	10 92 bd 09 	sts	0x09BD, r1
    2f74:	10 92 bc 09 	sts	0x09BC, r1
    2f78:	0f 91       	pop	r16
    2f7a:	08 95       	ret

00002f7c <_ZN7TwoWire15endTransmissionEv>:
    2f7c:	61 e0       	ldi	r22, 0x01	; 1
    2f7e:	ec cf       	rjmp	.-40     	; 0x2f58 <_ZN7TwoWire15endTransmissionEh>
    2f80:	08 95       	ret

00002f82 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2f82:	80 eb       	ldi	r24, 0xB0	; 176
    2f84:	99 e0       	ldi	r25, 0x09	; 9
    2f86:	b5 cf       	rjmp	.-150    	; 0x2ef2 <_ZN7TwoWireC1Ev>
    2f88:	08 95       	ret

00002f8a <__subsf3>:
    2f8a:	50 58       	subi	r21, 0x80	; 128

00002f8c <__addsf3>:
    2f8c:	bb 27       	eor	r27, r27
    2f8e:	aa 27       	eor	r26, r26
    2f90:	0e d0       	rcall	.+28     	; 0x2fae <__addsf3x>
    2f92:	fc c1       	rjmp	.+1016   	; 0x338c <__fp_round>
    2f94:	ed d1       	rcall	.+986    	; 0x3370 <__fp_pscA>
    2f96:	30 f0       	brcs	.+12     	; 0x2fa4 <__addsf3+0x18>
    2f98:	f2 d1       	rcall	.+996    	; 0x337e <__fp_pscB>
    2f9a:	20 f0       	brcs	.+8      	; 0x2fa4 <__addsf3+0x18>
    2f9c:	31 f4       	brne	.+12     	; 0x2faa <__addsf3+0x1e>
    2f9e:	9f 3f       	cpi	r25, 0xFF	; 255
    2fa0:	11 f4       	brne	.+4      	; 0x2fa6 <__addsf3+0x1a>
    2fa2:	1e f4       	brtc	.+6      	; 0x2faa <__addsf3+0x1e>
    2fa4:	bd c1       	rjmp	.+890    	; 0x3320 <__fp_nan>
    2fa6:	0e f4       	brtc	.+2      	; 0x2faa <__addsf3+0x1e>
    2fa8:	e0 95       	com	r30
    2faa:	e7 fb       	bst	r30, 7
    2fac:	b3 c1       	rjmp	.+870    	; 0x3314 <__fp_inf>

00002fae <__addsf3x>:
    2fae:	e9 2f       	mov	r30, r25
    2fb0:	fe d1       	rcall	.+1020   	; 0x33ae <__fp_split3>
    2fb2:	80 f3       	brcs	.-32     	; 0x2f94 <__addsf3+0x8>
    2fb4:	ba 17       	cp	r27, r26
    2fb6:	62 07       	cpc	r22, r18
    2fb8:	73 07       	cpc	r23, r19
    2fba:	84 07       	cpc	r24, r20
    2fbc:	95 07       	cpc	r25, r21
    2fbe:	18 f0       	brcs	.+6      	; 0x2fc6 <__addsf3x+0x18>
    2fc0:	71 f4       	brne	.+28     	; 0x2fde <__addsf3x+0x30>
    2fc2:	9e f5       	brtc	.+102    	; 0x302a <__addsf3x+0x7c>
    2fc4:	16 c2       	rjmp	.+1068   	; 0x33f2 <__fp_zero>
    2fc6:	0e f4       	brtc	.+2      	; 0x2fca <__addsf3x+0x1c>
    2fc8:	e0 95       	com	r30
    2fca:	0b 2e       	mov	r0, r27
    2fcc:	ba 2f       	mov	r27, r26
    2fce:	a0 2d       	mov	r26, r0
    2fd0:	0b 01       	movw	r0, r22
    2fd2:	b9 01       	movw	r22, r18
    2fd4:	90 01       	movw	r18, r0
    2fd6:	0c 01       	movw	r0, r24
    2fd8:	ca 01       	movw	r24, r20
    2fda:	a0 01       	movw	r20, r0
    2fdc:	11 24       	eor	r1, r1
    2fde:	ff 27       	eor	r31, r31
    2fe0:	59 1b       	sub	r21, r25
    2fe2:	99 f0       	breq	.+38     	; 0x300a <__addsf3x+0x5c>
    2fe4:	59 3f       	cpi	r21, 0xF9	; 249
    2fe6:	50 f4       	brcc	.+20     	; 0x2ffc <__addsf3x+0x4e>
    2fe8:	50 3e       	cpi	r21, 0xE0	; 224
    2fea:	68 f1       	brcs	.+90     	; 0x3046 <__addsf3x+0x98>
    2fec:	1a 16       	cp	r1, r26
    2fee:	f0 40       	sbci	r31, 0x00	; 0
    2ff0:	a2 2f       	mov	r26, r18
    2ff2:	23 2f       	mov	r18, r19
    2ff4:	34 2f       	mov	r19, r20
    2ff6:	44 27       	eor	r20, r20
    2ff8:	58 5f       	subi	r21, 0xF8	; 248
    2ffa:	f3 cf       	rjmp	.-26     	; 0x2fe2 <__addsf3x+0x34>
    2ffc:	46 95       	lsr	r20
    2ffe:	37 95       	ror	r19
    3000:	27 95       	ror	r18
    3002:	a7 95       	ror	r26
    3004:	f0 40       	sbci	r31, 0x00	; 0
    3006:	53 95       	inc	r21
    3008:	c9 f7       	brne	.-14     	; 0x2ffc <__addsf3x+0x4e>
    300a:	7e f4       	brtc	.+30     	; 0x302a <__addsf3x+0x7c>
    300c:	1f 16       	cp	r1, r31
    300e:	ba 0b       	sbc	r27, r26
    3010:	62 0b       	sbc	r22, r18
    3012:	73 0b       	sbc	r23, r19
    3014:	84 0b       	sbc	r24, r20
    3016:	ba f0       	brmi	.+46     	; 0x3046 <__addsf3x+0x98>
    3018:	91 50       	subi	r25, 0x01	; 1
    301a:	a1 f0       	breq	.+40     	; 0x3044 <__addsf3x+0x96>
    301c:	ff 0f       	add	r31, r31
    301e:	bb 1f       	adc	r27, r27
    3020:	66 1f       	adc	r22, r22
    3022:	77 1f       	adc	r23, r23
    3024:	88 1f       	adc	r24, r24
    3026:	c2 f7       	brpl	.-16     	; 0x3018 <__addsf3x+0x6a>
    3028:	0e c0       	rjmp	.+28     	; 0x3046 <__addsf3x+0x98>
    302a:	ba 0f       	add	r27, r26
    302c:	62 1f       	adc	r22, r18
    302e:	73 1f       	adc	r23, r19
    3030:	84 1f       	adc	r24, r20
    3032:	48 f4       	brcc	.+18     	; 0x3046 <__addsf3x+0x98>
    3034:	87 95       	ror	r24
    3036:	77 95       	ror	r23
    3038:	67 95       	ror	r22
    303a:	b7 95       	ror	r27
    303c:	f7 95       	ror	r31
    303e:	9e 3f       	cpi	r25, 0xFE	; 254
    3040:	08 f0       	brcs	.+2      	; 0x3044 <__addsf3x+0x96>
    3042:	b3 cf       	rjmp	.-154    	; 0x2faa <__addsf3+0x1e>
    3044:	93 95       	inc	r25
    3046:	88 0f       	add	r24, r24
    3048:	08 f0       	brcs	.+2      	; 0x304c <__addsf3x+0x9e>
    304a:	99 27       	eor	r25, r25
    304c:	ee 0f       	add	r30, r30
    304e:	97 95       	ror	r25
    3050:	87 95       	ror	r24
    3052:	08 95       	ret
    3054:	8d d1       	rcall	.+794    	; 0x3370 <__fp_pscA>
    3056:	58 f0       	brcs	.+22     	; 0x306e <__addsf3x+0xc0>
    3058:	80 e8       	ldi	r24, 0x80	; 128
    305a:	91 e0       	ldi	r25, 0x01	; 1
    305c:	09 f4       	brne	.+2      	; 0x3060 <__addsf3x+0xb2>
    305e:	9e ef       	ldi	r25, 0xFE	; 254
    3060:	8e d1       	rcall	.+796    	; 0x337e <__fp_pscB>
    3062:	28 f0       	brcs	.+10     	; 0x306e <__addsf3x+0xc0>
    3064:	40 e8       	ldi	r20, 0x80	; 128
    3066:	51 e0       	ldi	r21, 0x01	; 1
    3068:	59 f4       	brne	.+22     	; 0x3080 <atan2+0xe>
    306a:	5e ef       	ldi	r21, 0xFE	; 254
    306c:	09 c0       	rjmp	.+18     	; 0x3080 <atan2+0xe>
    306e:	58 c1       	rjmp	.+688    	; 0x3320 <__fp_nan>
    3070:	c0 c1       	rjmp	.+896    	; 0x33f2 <__fp_zero>

00003072 <atan2>:
    3072:	e9 2f       	mov	r30, r25
    3074:	e0 78       	andi	r30, 0x80	; 128
    3076:	9b d1       	rcall	.+822    	; 0x33ae <__fp_split3>
    3078:	68 f3       	brcs	.-38     	; 0x3054 <__addsf3x+0xa6>
    307a:	09 2e       	mov	r0, r25
    307c:	05 2a       	or	r0, r21
    307e:	c1 f3       	breq	.-16     	; 0x3070 <__addsf3x+0xc2>
    3080:	26 17       	cp	r18, r22
    3082:	37 07       	cpc	r19, r23
    3084:	48 07       	cpc	r20, r24
    3086:	59 07       	cpc	r21, r25
    3088:	38 f0       	brcs	.+14     	; 0x3098 <atan2+0x26>
    308a:	0e 2e       	mov	r0, r30
    308c:	07 f8       	bld	r0, 7
    308e:	e0 25       	eor	r30, r0
    3090:	69 f0       	breq	.+26     	; 0x30ac <atan2+0x3a>
    3092:	e0 25       	eor	r30, r0
    3094:	e0 64       	ori	r30, 0x40	; 64
    3096:	0a c0       	rjmp	.+20     	; 0x30ac <atan2+0x3a>
    3098:	ef 63       	ori	r30, 0x3F	; 63
    309a:	07 f8       	bld	r0, 7
    309c:	00 94       	com	r0
    309e:	07 fa       	bst	r0, 7
    30a0:	db 01       	movw	r26, r22
    30a2:	b9 01       	movw	r22, r18
    30a4:	9d 01       	movw	r18, r26
    30a6:	dc 01       	movw	r26, r24
    30a8:	ca 01       	movw	r24, r20
    30aa:	ad 01       	movw	r20, r26
    30ac:	ef 93       	push	r30
    30ae:	47 d0       	rcall	.+142    	; 0x313e <__divsf3_pse>
    30b0:	6d d1       	rcall	.+730    	; 0x338c <__fp_round>
    30b2:	0a d0       	rcall	.+20     	; 0x30c8 <atan>
    30b4:	5f 91       	pop	r21
    30b6:	55 23       	and	r21, r21
    30b8:	31 f0       	breq	.+12     	; 0x30c6 <atan2+0x54>
    30ba:	2b ed       	ldi	r18, 0xDB	; 219
    30bc:	3f e0       	ldi	r19, 0x0F	; 15
    30be:	49 e4       	ldi	r20, 0x49	; 73
    30c0:	50 fd       	sbrc	r21, 0
    30c2:	49 ec       	ldi	r20, 0xC9	; 201
    30c4:	63 cf       	rjmp	.-314    	; 0x2f8c <__addsf3>
    30c6:	08 95       	ret

000030c8 <atan>:
    30c8:	df 93       	push	r29
    30ca:	dd 27       	eor	r29, r29
    30cc:	b9 2f       	mov	r27, r25
    30ce:	bf 77       	andi	r27, 0x7F	; 127
    30d0:	40 e8       	ldi	r20, 0x80	; 128
    30d2:	5f e3       	ldi	r21, 0x3F	; 63
    30d4:	16 16       	cp	r1, r22
    30d6:	17 06       	cpc	r1, r23
    30d8:	48 07       	cpc	r20, r24
    30da:	5b 07       	cpc	r21, r27
    30dc:	10 f4       	brcc	.+4      	; 0x30e2 <atan+0x1a>
    30de:	d9 2f       	mov	r29, r25
    30e0:	8f d1       	rcall	.+798    	; 0x3400 <inverse>
    30e2:	9f 93       	push	r25
    30e4:	8f 93       	push	r24
    30e6:	7f 93       	push	r23
    30e8:	6f 93       	push	r22
    30ea:	82 d2       	rcall	.+1284   	; 0x35f0 <square>
    30ec:	e6 e7       	ldi	r30, 0x76	; 118
    30ee:	f2 e0       	ldi	r31, 0x02	; 2
    30f0:	1a d1       	rcall	.+564    	; 0x3326 <__fp_powser>
    30f2:	4c d1       	rcall	.+664    	; 0x338c <__fp_round>
    30f4:	2f 91       	pop	r18
    30f6:	3f 91       	pop	r19
    30f8:	4f 91       	pop	r20
    30fa:	5f 91       	pop	r21
    30fc:	94 d1       	rcall	.+808    	; 0x3426 <__mulsf3x>
    30fe:	dd 23       	and	r29, r29
    3100:	49 f0       	breq	.+18     	; 0x3114 <atan+0x4c>
    3102:	90 58       	subi	r25, 0x80	; 128
    3104:	a2 ea       	ldi	r26, 0xA2	; 162
    3106:	2a ed       	ldi	r18, 0xDA	; 218
    3108:	3f e0       	ldi	r19, 0x0F	; 15
    310a:	49 ec       	ldi	r20, 0xC9	; 201
    310c:	5f e3       	ldi	r21, 0x3F	; 63
    310e:	d0 78       	andi	r29, 0x80	; 128
    3110:	5d 27       	eor	r21, r29
    3112:	4d df       	rcall	.-358    	; 0x2fae <__addsf3x>
    3114:	df 91       	pop	r29
    3116:	3a c1       	rjmp	.+628    	; 0x338c <__fp_round>

00003118 <__cmpsf2>:
    3118:	d9 d0       	rcall	.+434    	; 0x32cc <__fp_cmp>
    311a:	08 f4       	brcc	.+2      	; 0x311e <__cmpsf2+0x6>
    311c:	81 e0       	ldi	r24, 0x01	; 1
    311e:	08 95       	ret

00003120 <__divsf3>:
    3120:	0c d0       	rcall	.+24     	; 0x313a <__divsf3x>
    3122:	34 c1       	rjmp	.+616    	; 0x338c <__fp_round>
    3124:	2c d1       	rcall	.+600    	; 0x337e <__fp_pscB>
    3126:	40 f0       	brcs	.+16     	; 0x3138 <__divsf3+0x18>
    3128:	23 d1       	rcall	.+582    	; 0x3370 <__fp_pscA>
    312a:	30 f0       	brcs	.+12     	; 0x3138 <__divsf3+0x18>
    312c:	21 f4       	brne	.+8      	; 0x3136 <__divsf3+0x16>
    312e:	5f 3f       	cpi	r21, 0xFF	; 255
    3130:	19 f0       	breq	.+6      	; 0x3138 <__divsf3+0x18>
    3132:	f0 c0       	rjmp	.+480    	; 0x3314 <__fp_inf>
    3134:	51 11       	cpse	r21, r1
    3136:	5e c1       	rjmp	.+700    	; 0x33f4 <__fp_szero>
    3138:	f3 c0       	rjmp	.+486    	; 0x3320 <__fp_nan>

0000313a <__divsf3x>:
    313a:	39 d1       	rcall	.+626    	; 0x33ae <__fp_split3>
    313c:	98 f3       	brcs	.-26     	; 0x3124 <__divsf3+0x4>

0000313e <__divsf3_pse>:
    313e:	99 23       	and	r25, r25
    3140:	c9 f3       	breq	.-14     	; 0x3134 <__divsf3+0x14>
    3142:	55 23       	and	r21, r21
    3144:	b1 f3       	breq	.-20     	; 0x3132 <__divsf3+0x12>
    3146:	95 1b       	sub	r25, r21
    3148:	55 0b       	sbc	r21, r21
    314a:	bb 27       	eor	r27, r27
    314c:	aa 27       	eor	r26, r26
    314e:	62 17       	cp	r22, r18
    3150:	73 07       	cpc	r23, r19
    3152:	84 07       	cpc	r24, r20
    3154:	38 f0       	brcs	.+14     	; 0x3164 <__divsf3_pse+0x26>
    3156:	9f 5f       	subi	r25, 0xFF	; 255
    3158:	5f 4f       	sbci	r21, 0xFF	; 255
    315a:	22 0f       	add	r18, r18
    315c:	33 1f       	adc	r19, r19
    315e:	44 1f       	adc	r20, r20
    3160:	aa 1f       	adc	r26, r26
    3162:	a9 f3       	breq	.-22     	; 0x314e <__divsf3_pse+0x10>
    3164:	33 d0       	rcall	.+102    	; 0x31cc <__divsf3_pse+0x8e>
    3166:	0e 2e       	mov	r0, r30
    3168:	3a f0       	brmi	.+14     	; 0x3178 <__divsf3_pse+0x3a>
    316a:	e0 e8       	ldi	r30, 0x80	; 128
    316c:	30 d0       	rcall	.+96     	; 0x31ce <__divsf3_pse+0x90>
    316e:	91 50       	subi	r25, 0x01	; 1
    3170:	50 40       	sbci	r21, 0x00	; 0
    3172:	e6 95       	lsr	r30
    3174:	00 1c       	adc	r0, r0
    3176:	ca f7       	brpl	.-14     	; 0x316a <__divsf3_pse+0x2c>
    3178:	29 d0       	rcall	.+82     	; 0x31cc <__divsf3_pse+0x8e>
    317a:	fe 2f       	mov	r31, r30
    317c:	27 d0       	rcall	.+78     	; 0x31cc <__divsf3_pse+0x8e>
    317e:	66 0f       	add	r22, r22
    3180:	77 1f       	adc	r23, r23
    3182:	88 1f       	adc	r24, r24
    3184:	bb 1f       	adc	r27, r27
    3186:	26 17       	cp	r18, r22
    3188:	37 07       	cpc	r19, r23
    318a:	48 07       	cpc	r20, r24
    318c:	ab 07       	cpc	r26, r27
    318e:	b0 e8       	ldi	r27, 0x80	; 128
    3190:	09 f0       	breq	.+2      	; 0x3194 <__divsf3_pse+0x56>
    3192:	bb 0b       	sbc	r27, r27
    3194:	80 2d       	mov	r24, r0
    3196:	bf 01       	movw	r22, r30
    3198:	ff 27       	eor	r31, r31
    319a:	93 58       	subi	r25, 0x83	; 131
    319c:	5f 4f       	sbci	r21, 0xFF	; 255
    319e:	2a f0       	brmi	.+10     	; 0x31aa <__divsf3_pse+0x6c>
    31a0:	9e 3f       	cpi	r25, 0xFE	; 254
    31a2:	51 05       	cpc	r21, r1
    31a4:	68 f0       	brcs	.+26     	; 0x31c0 <__divsf3_pse+0x82>
    31a6:	b6 c0       	rjmp	.+364    	; 0x3314 <__fp_inf>
    31a8:	25 c1       	rjmp	.+586    	; 0x33f4 <__fp_szero>
    31aa:	5f 3f       	cpi	r21, 0xFF	; 255
    31ac:	ec f3       	brlt	.-6      	; 0x31a8 <__divsf3_pse+0x6a>
    31ae:	98 3e       	cpi	r25, 0xE8	; 232
    31b0:	dc f3       	brlt	.-10     	; 0x31a8 <__divsf3_pse+0x6a>
    31b2:	86 95       	lsr	r24
    31b4:	77 95       	ror	r23
    31b6:	67 95       	ror	r22
    31b8:	b7 95       	ror	r27
    31ba:	f7 95       	ror	r31
    31bc:	9f 5f       	subi	r25, 0xFF	; 255
    31be:	c9 f7       	brne	.-14     	; 0x31b2 <__divsf3_pse+0x74>
    31c0:	88 0f       	add	r24, r24
    31c2:	91 1d       	adc	r25, r1
    31c4:	96 95       	lsr	r25
    31c6:	87 95       	ror	r24
    31c8:	97 f9       	bld	r25, 7
    31ca:	08 95       	ret
    31cc:	e1 e0       	ldi	r30, 0x01	; 1
    31ce:	66 0f       	add	r22, r22
    31d0:	77 1f       	adc	r23, r23
    31d2:	88 1f       	adc	r24, r24
    31d4:	bb 1f       	adc	r27, r27
    31d6:	62 17       	cp	r22, r18
    31d8:	73 07       	cpc	r23, r19
    31da:	84 07       	cpc	r24, r20
    31dc:	ba 07       	cpc	r27, r26
    31de:	20 f0       	brcs	.+8      	; 0x31e8 <__divsf3_pse+0xaa>
    31e0:	62 1b       	sub	r22, r18
    31e2:	73 0b       	sbc	r23, r19
    31e4:	84 0b       	sbc	r24, r20
    31e6:	ba 0b       	sbc	r27, r26
    31e8:	ee 1f       	adc	r30, r30
    31ea:	88 f7       	brcc	.-30     	; 0x31ce <__divsf3_pse+0x90>
    31ec:	e0 95       	com	r30
    31ee:	08 95       	ret

000031f0 <__fixsfsi>:
    31f0:	04 d0       	rcall	.+8      	; 0x31fa <__fixunssfsi>
    31f2:	68 94       	set
    31f4:	b1 11       	cpse	r27, r1
    31f6:	fe c0       	rjmp	.+508    	; 0x33f4 <__fp_szero>
    31f8:	08 95       	ret

000031fa <__fixunssfsi>:
    31fa:	e1 d0       	rcall	.+450    	; 0x33be <__fp_splitA>
    31fc:	88 f0       	brcs	.+34     	; 0x3220 <__fixunssfsi+0x26>
    31fe:	9f 57       	subi	r25, 0x7F	; 127
    3200:	90 f0       	brcs	.+36     	; 0x3226 <__fixunssfsi+0x2c>
    3202:	b9 2f       	mov	r27, r25
    3204:	99 27       	eor	r25, r25
    3206:	b7 51       	subi	r27, 0x17	; 23
    3208:	a0 f0       	brcs	.+40     	; 0x3232 <__fixunssfsi+0x38>
    320a:	d1 f0       	breq	.+52     	; 0x3240 <__fixunssfsi+0x46>
    320c:	66 0f       	add	r22, r22
    320e:	77 1f       	adc	r23, r23
    3210:	88 1f       	adc	r24, r24
    3212:	99 1f       	adc	r25, r25
    3214:	1a f0       	brmi	.+6      	; 0x321c <__fixunssfsi+0x22>
    3216:	ba 95       	dec	r27
    3218:	c9 f7       	brne	.-14     	; 0x320c <__fixunssfsi+0x12>
    321a:	12 c0       	rjmp	.+36     	; 0x3240 <__fixunssfsi+0x46>
    321c:	b1 30       	cpi	r27, 0x01	; 1
    321e:	81 f0       	breq	.+32     	; 0x3240 <__fixunssfsi+0x46>
    3220:	e8 d0       	rcall	.+464    	; 0x33f2 <__fp_zero>
    3222:	b1 e0       	ldi	r27, 0x01	; 1
    3224:	08 95       	ret
    3226:	e5 c0       	rjmp	.+458    	; 0x33f2 <__fp_zero>
    3228:	67 2f       	mov	r22, r23
    322a:	78 2f       	mov	r23, r24
    322c:	88 27       	eor	r24, r24
    322e:	b8 5f       	subi	r27, 0xF8	; 248
    3230:	39 f0       	breq	.+14     	; 0x3240 <__fixunssfsi+0x46>
    3232:	b9 3f       	cpi	r27, 0xF9	; 249
    3234:	cc f3       	brlt	.-14     	; 0x3228 <__fixunssfsi+0x2e>
    3236:	86 95       	lsr	r24
    3238:	77 95       	ror	r23
    323a:	67 95       	ror	r22
    323c:	b3 95       	inc	r27
    323e:	d9 f7       	brne	.-10     	; 0x3236 <__fixunssfsi+0x3c>
    3240:	3e f4       	brtc	.+14     	; 0x3250 <__fixunssfsi+0x56>
    3242:	90 95       	com	r25
    3244:	80 95       	com	r24
    3246:	70 95       	com	r23
    3248:	61 95       	neg	r22
    324a:	7f 4f       	sbci	r23, 0xFF	; 255
    324c:	8f 4f       	sbci	r24, 0xFF	; 255
    324e:	9f 4f       	sbci	r25, 0xFF	; 255
    3250:	08 95       	ret

00003252 <__floatunsisf>:
    3252:	e8 94       	clt
    3254:	09 c0       	rjmp	.+18     	; 0x3268 <__floatsisf+0x12>

00003256 <__floatsisf>:
    3256:	97 fb       	bst	r25, 7
    3258:	3e f4       	brtc	.+14     	; 0x3268 <__floatsisf+0x12>
    325a:	90 95       	com	r25
    325c:	80 95       	com	r24
    325e:	70 95       	com	r23
    3260:	61 95       	neg	r22
    3262:	7f 4f       	sbci	r23, 0xFF	; 255
    3264:	8f 4f       	sbci	r24, 0xFF	; 255
    3266:	9f 4f       	sbci	r25, 0xFF	; 255
    3268:	99 23       	and	r25, r25
    326a:	a9 f0       	breq	.+42     	; 0x3296 <__floatsisf+0x40>
    326c:	f9 2f       	mov	r31, r25
    326e:	96 e9       	ldi	r25, 0x96	; 150
    3270:	bb 27       	eor	r27, r27
    3272:	93 95       	inc	r25
    3274:	f6 95       	lsr	r31
    3276:	87 95       	ror	r24
    3278:	77 95       	ror	r23
    327a:	67 95       	ror	r22
    327c:	b7 95       	ror	r27
    327e:	f1 11       	cpse	r31, r1
    3280:	f8 cf       	rjmp	.-16     	; 0x3272 <__floatsisf+0x1c>
    3282:	fa f4       	brpl	.+62     	; 0x32c2 <__floatsisf+0x6c>
    3284:	bb 0f       	add	r27, r27
    3286:	11 f4       	brne	.+4      	; 0x328c <__floatsisf+0x36>
    3288:	60 ff       	sbrs	r22, 0
    328a:	1b c0       	rjmp	.+54     	; 0x32c2 <__floatsisf+0x6c>
    328c:	6f 5f       	subi	r22, 0xFF	; 255
    328e:	7f 4f       	sbci	r23, 0xFF	; 255
    3290:	8f 4f       	sbci	r24, 0xFF	; 255
    3292:	9f 4f       	sbci	r25, 0xFF	; 255
    3294:	16 c0       	rjmp	.+44     	; 0x32c2 <__floatsisf+0x6c>
    3296:	88 23       	and	r24, r24
    3298:	11 f0       	breq	.+4      	; 0x329e <__floatsisf+0x48>
    329a:	96 e9       	ldi	r25, 0x96	; 150
    329c:	11 c0       	rjmp	.+34     	; 0x32c0 <__floatsisf+0x6a>
    329e:	77 23       	and	r23, r23
    32a0:	21 f0       	breq	.+8      	; 0x32aa <__floatsisf+0x54>
    32a2:	9e e8       	ldi	r25, 0x8E	; 142
    32a4:	87 2f       	mov	r24, r23
    32a6:	76 2f       	mov	r23, r22
    32a8:	05 c0       	rjmp	.+10     	; 0x32b4 <__floatsisf+0x5e>
    32aa:	66 23       	and	r22, r22
    32ac:	71 f0       	breq	.+28     	; 0x32ca <__floatsisf+0x74>
    32ae:	96 e8       	ldi	r25, 0x86	; 134
    32b0:	86 2f       	mov	r24, r22
    32b2:	70 e0       	ldi	r23, 0x00	; 0
    32b4:	60 e0       	ldi	r22, 0x00	; 0
    32b6:	2a f0       	brmi	.+10     	; 0x32c2 <__floatsisf+0x6c>
    32b8:	9a 95       	dec	r25
    32ba:	66 0f       	add	r22, r22
    32bc:	77 1f       	adc	r23, r23
    32be:	88 1f       	adc	r24, r24
    32c0:	da f7       	brpl	.-10     	; 0x32b8 <__floatsisf+0x62>
    32c2:	88 0f       	add	r24, r24
    32c4:	96 95       	lsr	r25
    32c6:	87 95       	ror	r24
    32c8:	97 f9       	bld	r25, 7
    32ca:	08 95       	ret

000032cc <__fp_cmp>:
    32cc:	99 0f       	add	r25, r25
    32ce:	00 08       	sbc	r0, r0
    32d0:	55 0f       	add	r21, r21
    32d2:	aa 0b       	sbc	r26, r26
    32d4:	e0 e8       	ldi	r30, 0x80	; 128
    32d6:	fe ef       	ldi	r31, 0xFE	; 254
    32d8:	16 16       	cp	r1, r22
    32da:	17 06       	cpc	r1, r23
    32dc:	e8 07       	cpc	r30, r24
    32de:	f9 07       	cpc	r31, r25
    32e0:	c0 f0       	brcs	.+48     	; 0x3312 <__fp_cmp+0x46>
    32e2:	12 16       	cp	r1, r18
    32e4:	13 06       	cpc	r1, r19
    32e6:	e4 07       	cpc	r30, r20
    32e8:	f5 07       	cpc	r31, r21
    32ea:	98 f0       	brcs	.+38     	; 0x3312 <__fp_cmp+0x46>
    32ec:	62 1b       	sub	r22, r18
    32ee:	73 0b       	sbc	r23, r19
    32f0:	84 0b       	sbc	r24, r20
    32f2:	95 0b       	sbc	r25, r21
    32f4:	39 f4       	brne	.+14     	; 0x3304 <__fp_cmp+0x38>
    32f6:	0a 26       	eor	r0, r26
    32f8:	61 f0       	breq	.+24     	; 0x3312 <__fp_cmp+0x46>
    32fa:	23 2b       	or	r18, r19
    32fc:	24 2b       	or	r18, r20
    32fe:	25 2b       	or	r18, r21
    3300:	21 f4       	brne	.+8      	; 0x330a <__fp_cmp+0x3e>
    3302:	08 95       	ret
    3304:	0a 26       	eor	r0, r26
    3306:	09 f4       	brne	.+2      	; 0x330a <__fp_cmp+0x3e>
    3308:	a1 40       	sbci	r26, 0x01	; 1
    330a:	a6 95       	lsr	r26
    330c:	8f ef       	ldi	r24, 0xFF	; 255
    330e:	81 1d       	adc	r24, r1
    3310:	81 1d       	adc	r24, r1
    3312:	08 95       	ret

00003314 <__fp_inf>:
    3314:	97 f9       	bld	r25, 7
    3316:	9f 67       	ori	r25, 0x7F	; 127
    3318:	80 e8       	ldi	r24, 0x80	; 128
    331a:	70 e0       	ldi	r23, 0x00	; 0
    331c:	60 e0       	ldi	r22, 0x00	; 0
    331e:	08 95       	ret

00003320 <__fp_nan>:
    3320:	9f ef       	ldi	r25, 0xFF	; 255
    3322:	80 ec       	ldi	r24, 0xC0	; 192
    3324:	08 95       	ret

00003326 <__fp_powser>:
    3326:	df 93       	push	r29
    3328:	cf 93       	push	r28
    332a:	1f 93       	push	r17
    332c:	0f 93       	push	r16
    332e:	ff 92       	push	r15
    3330:	ef 92       	push	r14
    3332:	df 92       	push	r13
    3334:	7b 01       	movw	r14, r22
    3336:	8c 01       	movw	r16, r24
    3338:	68 94       	set
    333a:	05 c0       	rjmp	.+10     	; 0x3346 <__fp_powser+0x20>
    333c:	da 2e       	mov	r13, r26
    333e:	ef 01       	movw	r28, r30
    3340:	72 d0       	rcall	.+228    	; 0x3426 <__mulsf3x>
    3342:	fe 01       	movw	r30, r28
    3344:	e8 94       	clt
    3346:	a5 91       	lpm	r26, Z+
    3348:	25 91       	lpm	r18, Z+
    334a:	35 91       	lpm	r19, Z+
    334c:	45 91       	lpm	r20, Z+
    334e:	55 91       	lpm	r21, Z+
    3350:	ae f3       	brts	.-22     	; 0x333c <__fp_powser+0x16>
    3352:	ef 01       	movw	r28, r30
    3354:	2c de       	rcall	.-936    	; 0x2fae <__addsf3x>
    3356:	fe 01       	movw	r30, r28
    3358:	97 01       	movw	r18, r14
    335a:	a8 01       	movw	r20, r16
    335c:	da 94       	dec	r13
    335e:	79 f7       	brne	.-34     	; 0x333e <__fp_powser+0x18>
    3360:	df 90       	pop	r13
    3362:	ef 90       	pop	r14
    3364:	ff 90       	pop	r15
    3366:	0f 91       	pop	r16
    3368:	1f 91       	pop	r17
    336a:	cf 91       	pop	r28
    336c:	df 91       	pop	r29
    336e:	08 95       	ret

00003370 <__fp_pscA>:
    3370:	00 24       	eor	r0, r0
    3372:	0a 94       	dec	r0
    3374:	16 16       	cp	r1, r22
    3376:	17 06       	cpc	r1, r23
    3378:	18 06       	cpc	r1, r24
    337a:	09 06       	cpc	r0, r25
    337c:	08 95       	ret

0000337e <__fp_pscB>:
    337e:	00 24       	eor	r0, r0
    3380:	0a 94       	dec	r0
    3382:	12 16       	cp	r1, r18
    3384:	13 06       	cpc	r1, r19
    3386:	14 06       	cpc	r1, r20
    3388:	05 06       	cpc	r0, r21
    338a:	08 95       	ret

0000338c <__fp_round>:
    338c:	09 2e       	mov	r0, r25
    338e:	03 94       	inc	r0
    3390:	00 0c       	add	r0, r0
    3392:	11 f4       	brne	.+4      	; 0x3398 <__fp_round+0xc>
    3394:	88 23       	and	r24, r24
    3396:	52 f0       	brmi	.+20     	; 0x33ac <__fp_round+0x20>
    3398:	bb 0f       	add	r27, r27
    339a:	40 f4       	brcc	.+16     	; 0x33ac <__fp_round+0x20>
    339c:	bf 2b       	or	r27, r31
    339e:	11 f4       	brne	.+4      	; 0x33a4 <__fp_round+0x18>
    33a0:	60 ff       	sbrs	r22, 0
    33a2:	04 c0       	rjmp	.+8      	; 0x33ac <__fp_round+0x20>
    33a4:	6f 5f       	subi	r22, 0xFF	; 255
    33a6:	7f 4f       	sbci	r23, 0xFF	; 255
    33a8:	8f 4f       	sbci	r24, 0xFF	; 255
    33aa:	9f 4f       	sbci	r25, 0xFF	; 255
    33ac:	08 95       	ret

000033ae <__fp_split3>:
    33ae:	57 fd       	sbrc	r21, 7
    33b0:	90 58       	subi	r25, 0x80	; 128
    33b2:	44 0f       	add	r20, r20
    33b4:	55 1f       	adc	r21, r21
    33b6:	59 f0       	breq	.+22     	; 0x33ce <__fp_splitA+0x10>
    33b8:	5f 3f       	cpi	r21, 0xFF	; 255
    33ba:	71 f0       	breq	.+28     	; 0x33d8 <__fp_splitA+0x1a>
    33bc:	47 95       	ror	r20

000033be <__fp_splitA>:
    33be:	88 0f       	add	r24, r24
    33c0:	97 fb       	bst	r25, 7
    33c2:	99 1f       	adc	r25, r25
    33c4:	61 f0       	breq	.+24     	; 0x33de <__fp_splitA+0x20>
    33c6:	9f 3f       	cpi	r25, 0xFF	; 255
    33c8:	79 f0       	breq	.+30     	; 0x33e8 <__fp_splitA+0x2a>
    33ca:	87 95       	ror	r24
    33cc:	08 95       	ret
    33ce:	12 16       	cp	r1, r18
    33d0:	13 06       	cpc	r1, r19
    33d2:	14 06       	cpc	r1, r20
    33d4:	55 1f       	adc	r21, r21
    33d6:	f2 cf       	rjmp	.-28     	; 0x33bc <__fp_split3+0xe>
    33d8:	46 95       	lsr	r20
    33da:	f1 df       	rcall	.-30     	; 0x33be <__fp_splitA>
    33dc:	08 c0       	rjmp	.+16     	; 0x33ee <__fp_splitA+0x30>
    33de:	16 16       	cp	r1, r22
    33e0:	17 06       	cpc	r1, r23
    33e2:	18 06       	cpc	r1, r24
    33e4:	99 1f       	adc	r25, r25
    33e6:	f1 cf       	rjmp	.-30     	; 0x33ca <__fp_splitA+0xc>
    33e8:	86 95       	lsr	r24
    33ea:	71 05       	cpc	r23, r1
    33ec:	61 05       	cpc	r22, r1
    33ee:	08 94       	sec
    33f0:	08 95       	ret

000033f2 <__fp_zero>:
    33f2:	e8 94       	clt

000033f4 <__fp_szero>:
    33f4:	bb 27       	eor	r27, r27
    33f6:	66 27       	eor	r22, r22
    33f8:	77 27       	eor	r23, r23
    33fa:	cb 01       	movw	r24, r22
    33fc:	97 f9       	bld	r25, 7
    33fe:	08 95       	ret

00003400 <inverse>:
    3400:	9b 01       	movw	r18, r22
    3402:	ac 01       	movw	r20, r24
    3404:	60 e0       	ldi	r22, 0x00	; 0
    3406:	70 e0       	ldi	r23, 0x00	; 0
    3408:	80 e8       	ldi	r24, 0x80	; 128
    340a:	9f e3       	ldi	r25, 0x3F	; 63
    340c:	89 ce       	rjmp	.-750    	; 0x3120 <__divsf3>

0000340e <__mulsf3>:
    340e:	0b d0       	rcall	.+22     	; 0x3426 <__mulsf3x>
    3410:	bd cf       	rjmp	.-134    	; 0x338c <__fp_round>
    3412:	ae df       	rcall	.-164    	; 0x3370 <__fp_pscA>
    3414:	28 f0       	brcs	.+10     	; 0x3420 <__mulsf3+0x12>
    3416:	b3 df       	rcall	.-154    	; 0x337e <__fp_pscB>
    3418:	18 f0       	brcs	.+6      	; 0x3420 <__mulsf3+0x12>
    341a:	95 23       	and	r25, r21
    341c:	09 f0       	breq	.+2      	; 0x3420 <__mulsf3+0x12>
    341e:	7a cf       	rjmp	.-268    	; 0x3314 <__fp_inf>
    3420:	7f cf       	rjmp	.-258    	; 0x3320 <__fp_nan>
    3422:	11 24       	eor	r1, r1
    3424:	e7 cf       	rjmp	.-50     	; 0x33f4 <__fp_szero>

00003426 <__mulsf3x>:
    3426:	c3 df       	rcall	.-122    	; 0x33ae <__fp_split3>
    3428:	a0 f3       	brcs	.-24     	; 0x3412 <__mulsf3+0x4>

0000342a <__mulsf3_pse>:
    342a:	95 9f       	mul	r25, r21
    342c:	d1 f3       	breq	.-12     	; 0x3422 <__mulsf3+0x14>
    342e:	95 0f       	add	r25, r21
    3430:	50 e0       	ldi	r21, 0x00	; 0
    3432:	55 1f       	adc	r21, r21
    3434:	62 9f       	mul	r22, r18
    3436:	f0 01       	movw	r30, r0
    3438:	72 9f       	mul	r23, r18
    343a:	bb 27       	eor	r27, r27
    343c:	f0 0d       	add	r31, r0
    343e:	b1 1d       	adc	r27, r1
    3440:	63 9f       	mul	r22, r19
    3442:	aa 27       	eor	r26, r26
    3444:	f0 0d       	add	r31, r0
    3446:	b1 1d       	adc	r27, r1
    3448:	aa 1f       	adc	r26, r26
    344a:	64 9f       	mul	r22, r20
    344c:	66 27       	eor	r22, r22
    344e:	b0 0d       	add	r27, r0
    3450:	a1 1d       	adc	r26, r1
    3452:	66 1f       	adc	r22, r22
    3454:	82 9f       	mul	r24, r18
    3456:	22 27       	eor	r18, r18
    3458:	b0 0d       	add	r27, r0
    345a:	a1 1d       	adc	r26, r1
    345c:	62 1f       	adc	r22, r18
    345e:	73 9f       	mul	r23, r19
    3460:	b0 0d       	add	r27, r0
    3462:	a1 1d       	adc	r26, r1
    3464:	62 1f       	adc	r22, r18
    3466:	83 9f       	mul	r24, r19
    3468:	a0 0d       	add	r26, r0
    346a:	61 1d       	adc	r22, r1
    346c:	22 1f       	adc	r18, r18
    346e:	74 9f       	mul	r23, r20
    3470:	33 27       	eor	r19, r19
    3472:	a0 0d       	add	r26, r0
    3474:	61 1d       	adc	r22, r1
    3476:	23 1f       	adc	r18, r19
    3478:	84 9f       	mul	r24, r20
    347a:	60 0d       	add	r22, r0
    347c:	21 1d       	adc	r18, r1
    347e:	82 2f       	mov	r24, r18
    3480:	76 2f       	mov	r23, r22
    3482:	6a 2f       	mov	r22, r26
    3484:	11 24       	eor	r1, r1
    3486:	9f 57       	subi	r25, 0x7F	; 127
    3488:	50 40       	sbci	r21, 0x00	; 0
    348a:	8a f0       	brmi	.+34     	; 0x34ae <__mulsf3_pse+0x84>
    348c:	e1 f0       	breq	.+56     	; 0x34c6 <__mulsf3_pse+0x9c>
    348e:	88 23       	and	r24, r24
    3490:	4a f0       	brmi	.+18     	; 0x34a4 <__mulsf3_pse+0x7a>
    3492:	ee 0f       	add	r30, r30
    3494:	ff 1f       	adc	r31, r31
    3496:	bb 1f       	adc	r27, r27
    3498:	66 1f       	adc	r22, r22
    349a:	77 1f       	adc	r23, r23
    349c:	88 1f       	adc	r24, r24
    349e:	91 50       	subi	r25, 0x01	; 1
    34a0:	50 40       	sbci	r21, 0x00	; 0
    34a2:	a9 f7       	brne	.-22     	; 0x348e <__mulsf3_pse+0x64>
    34a4:	9e 3f       	cpi	r25, 0xFE	; 254
    34a6:	51 05       	cpc	r21, r1
    34a8:	70 f0       	brcs	.+28     	; 0x34c6 <__mulsf3_pse+0x9c>
    34aa:	34 cf       	rjmp	.-408    	; 0x3314 <__fp_inf>
    34ac:	a3 cf       	rjmp	.-186    	; 0x33f4 <__fp_szero>
    34ae:	5f 3f       	cpi	r21, 0xFF	; 255
    34b0:	ec f3       	brlt	.-6      	; 0x34ac <__mulsf3_pse+0x82>
    34b2:	98 3e       	cpi	r25, 0xE8	; 232
    34b4:	dc f3       	brlt	.-10     	; 0x34ac <__mulsf3_pse+0x82>
    34b6:	86 95       	lsr	r24
    34b8:	77 95       	ror	r23
    34ba:	67 95       	ror	r22
    34bc:	b7 95       	ror	r27
    34be:	f7 95       	ror	r31
    34c0:	e7 95       	ror	r30
    34c2:	9f 5f       	subi	r25, 0xFF	; 255
    34c4:	c1 f7       	brne	.-16     	; 0x34b6 <__mulsf3_pse+0x8c>
    34c6:	fe 2b       	or	r31, r30
    34c8:	88 0f       	add	r24, r24
    34ca:	91 1d       	adc	r25, r1
    34cc:	96 95       	lsr	r25
    34ce:	87 95       	ror	r24
    34d0:	97 f9       	bld	r25, 7
    34d2:	08 95       	ret

000034d4 <pow>:
    34d4:	fa 01       	movw	r30, r20
    34d6:	ee 0f       	add	r30, r30
    34d8:	ff 1f       	adc	r31, r31
    34da:	30 96       	adiw	r30, 0x00	; 0
    34dc:	21 05       	cpc	r18, r1
    34de:	31 05       	cpc	r19, r1
    34e0:	99 f1       	breq	.+102    	; 0x3548 <pow+0x74>
    34e2:	61 15       	cp	r22, r1
    34e4:	71 05       	cpc	r23, r1
    34e6:	61 f4       	brne	.+24     	; 0x3500 <pow+0x2c>
    34e8:	80 38       	cpi	r24, 0x80	; 128
    34ea:	bf e3       	ldi	r27, 0x3F	; 63
    34ec:	9b 07       	cpc	r25, r27
    34ee:	49 f1       	breq	.+82     	; 0x3542 <pow+0x6e>
    34f0:	68 94       	set
    34f2:	90 38       	cpi	r25, 0x80	; 128
    34f4:	81 05       	cpc	r24, r1
    34f6:	61 f0       	breq	.+24     	; 0x3510 <pow+0x3c>
    34f8:	80 38       	cpi	r24, 0x80	; 128
    34fa:	bf ef       	ldi	r27, 0xFF	; 255
    34fc:	9b 07       	cpc	r25, r27
    34fe:	41 f0       	breq	.+16     	; 0x3510 <pow+0x3c>
    3500:	99 23       	and	r25, r25
    3502:	42 f5       	brpl	.+80     	; 0x3554 <pow+0x80>
    3504:	ff 3f       	cpi	r31, 0xFF	; 255
    3506:	e1 05       	cpc	r30, r1
    3508:	31 05       	cpc	r19, r1
    350a:	21 05       	cpc	r18, r1
    350c:	11 f1       	breq	.+68     	; 0x3552 <pow+0x7e>
    350e:	e8 94       	clt
    3510:	08 94       	sec
    3512:	e7 95       	ror	r30
    3514:	d9 01       	movw	r26, r18
    3516:	aa 23       	and	r26, r26
    3518:	29 f4       	brne	.+10     	; 0x3524 <pow+0x50>
    351a:	ab 2f       	mov	r26, r27
    351c:	be 2f       	mov	r27, r30
    351e:	f8 5f       	subi	r31, 0xF8	; 248
    3520:	d0 f3       	brcs	.-12     	; 0x3516 <pow+0x42>
    3522:	10 c0       	rjmp	.+32     	; 0x3544 <pow+0x70>
    3524:	ff 5f       	subi	r31, 0xFF	; 255
    3526:	70 f4       	brcc	.+28     	; 0x3544 <pow+0x70>
    3528:	a6 95       	lsr	r26
    352a:	e0 f7       	brcc	.-8      	; 0x3524 <pow+0x50>
    352c:	f7 39       	cpi	r31, 0x97	; 151
    352e:	50 f0       	brcs	.+20     	; 0x3544 <pow+0x70>
    3530:	19 f0       	breq	.+6      	; 0x3538 <pow+0x64>
    3532:	ff 3a       	cpi	r31, 0xAF	; 175
    3534:	38 f4       	brcc	.+14     	; 0x3544 <pow+0x70>
    3536:	9f 77       	andi	r25, 0x7F	; 127
    3538:	9f 93       	push	r25
    353a:	0c d0       	rcall	.+24     	; 0x3554 <pow+0x80>
    353c:	0f 90       	pop	r0
    353e:	07 fc       	sbrc	r0, 7
    3540:	90 58       	subi	r25, 0x80	; 128
    3542:	08 95       	ret
    3544:	3e f0       	brts	.+14     	; 0x3554 <pow+0x80>
    3546:	ec ce       	rjmp	.-552    	; 0x3320 <__fp_nan>
    3548:	60 e0       	ldi	r22, 0x00	; 0
    354a:	70 e0       	ldi	r23, 0x00	; 0
    354c:	80 e8       	ldi	r24, 0x80	; 128
    354e:	9f e3       	ldi	r25, 0x3F	; 63
    3550:	08 95       	ret
    3552:	4f e7       	ldi	r20, 0x7F	; 127
    3554:	9f 77       	andi	r25, 0x7F	; 127
    3556:	5f 93       	push	r21
    3558:	4f 93       	push	r20
    355a:	3f 93       	push	r19
    355c:	2f 93       	push	r18
    355e:	cc d0       	rcall	.+408    	; 0x36f8 <log>
    3560:	2f 91       	pop	r18
    3562:	3f 91       	pop	r19
    3564:	4f 91       	pop	r20
    3566:	5f 91       	pop	r21
    3568:	52 df       	rcall	.-348    	; 0x340e <__mulsf3>
    356a:	4a c0       	rjmp	.+148    	; 0x3600 <exp>
    356c:	11 f4       	brne	.+4      	; 0x3572 <pow+0x9e>
    356e:	0e f4       	brtc	.+2      	; 0x3572 <pow+0x9e>
    3570:	d7 ce       	rjmp	.-594    	; 0x3320 <__fp_nan>
    3572:	72 c0       	rjmp	.+228    	; 0x3658 <__fp_mpack>

00003574 <sqrt>:
    3574:	24 df       	rcall	.-440    	; 0x33be <__fp_splitA>
    3576:	d0 f3       	brcs	.-12     	; 0x356c <pow+0x98>
    3578:	99 23       	and	r25, r25
    357a:	d9 f3       	breq	.-10     	; 0x3572 <pow+0x9e>
    357c:	ce f3       	brts	.-14     	; 0x3570 <pow+0x9c>
    357e:	9f 57       	subi	r25, 0x7F	; 127
    3580:	55 0b       	sbc	r21, r21
    3582:	87 ff       	sbrs	r24, 7
    3584:	77 d0       	rcall	.+238    	; 0x3674 <__fp_norm2>
    3586:	00 24       	eor	r0, r0
    3588:	a0 e6       	ldi	r26, 0x60	; 96
    358a:	40 ea       	ldi	r20, 0xA0	; 160
    358c:	90 01       	movw	r18, r0
    358e:	80 58       	subi	r24, 0x80	; 128
    3590:	56 95       	lsr	r21
    3592:	97 95       	ror	r25
    3594:	28 f4       	brcc	.+10     	; 0x35a0 <sqrt+0x2c>
    3596:	80 5c       	subi	r24, 0xC0	; 192
    3598:	66 0f       	add	r22, r22
    359a:	77 1f       	adc	r23, r23
    359c:	88 1f       	adc	r24, r24
    359e:	20 f0       	brcs	.+8      	; 0x35a8 <sqrt+0x34>
    35a0:	26 17       	cp	r18, r22
    35a2:	37 07       	cpc	r19, r23
    35a4:	48 07       	cpc	r20, r24
    35a6:	30 f4       	brcc	.+12     	; 0x35b4 <sqrt+0x40>
    35a8:	62 1b       	sub	r22, r18
    35aa:	73 0b       	sbc	r23, r19
    35ac:	84 0b       	sbc	r24, r20
    35ae:	20 29       	or	r18, r0
    35b0:	31 29       	or	r19, r1
    35b2:	4a 2b       	or	r20, r26
    35b4:	a6 95       	lsr	r26
    35b6:	17 94       	ror	r1
    35b8:	07 94       	ror	r0
    35ba:	20 25       	eor	r18, r0
    35bc:	31 25       	eor	r19, r1
    35be:	4a 27       	eor	r20, r26
    35c0:	58 f7       	brcc	.-42     	; 0x3598 <sqrt+0x24>
    35c2:	66 0f       	add	r22, r22
    35c4:	77 1f       	adc	r23, r23
    35c6:	88 1f       	adc	r24, r24
    35c8:	20 f0       	brcs	.+8      	; 0x35d2 <sqrt+0x5e>
    35ca:	26 17       	cp	r18, r22
    35cc:	37 07       	cpc	r19, r23
    35ce:	48 07       	cpc	r20, r24
    35d0:	30 f4       	brcc	.+12     	; 0x35de <sqrt+0x6a>
    35d2:	62 0b       	sbc	r22, r18
    35d4:	73 0b       	sbc	r23, r19
    35d6:	84 0b       	sbc	r24, r20
    35d8:	20 0d       	add	r18, r0
    35da:	31 1d       	adc	r19, r1
    35dc:	41 1d       	adc	r20, r1
    35de:	a0 95       	com	r26
    35e0:	81 f7       	brne	.-32     	; 0x35c2 <sqrt+0x4e>
    35e2:	b9 01       	movw	r22, r18
    35e4:	84 2f       	mov	r24, r20
    35e6:	91 58       	subi	r25, 0x81	; 129
    35e8:	88 0f       	add	r24, r24
    35ea:	96 95       	lsr	r25
    35ec:	87 95       	ror	r24
    35ee:	08 95       	ret

000035f0 <square>:
    35f0:	9b 01       	movw	r18, r22
    35f2:	ac 01       	movw	r20, r24
    35f4:	0c cf       	rjmp	.-488    	; 0x340e <__mulsf3>
    35f6:	19 f4       	brne	.+6      	; 0x35fe <square+0xe>
    35f8:	0e f0       	brts	.+2      	; 0x35fc <square+0xc>
    35fa:	8c ce       	rjmp	.-744    	; 0x3314 <__fp_inf>
    35fc:	fa ce       	rjmp	.-524    	; 0x33f2 <__fp_zero>
    35fe:	90 ce       	rjmp	.-736    	; 0x3320 <__fp_nan>

00003600 <exp>:
    3600:	de de       	rcall	.-580    	; 0x33be <__fp_splitA>
    3602:	c8 f3       	brcs	.-14     	; 0x35f6 <square+0x6>
    3604:	96 38       	cpi	r25, 0x86	; 134
    3606:	c0 f7       	brcc	.-16     	; 0x35f8 <square+0x8>
    3608:	07 f8       	bld	r0, 7
    360a:	0f 92       	push	r0
    360c:	e8 94       	clt
    360e:	2b e3       	ldi	r18, 0x3B	; 59
    3610:	3a ea       	ldi	r19, 0xAA	; 170
    3612:	48 eb       	ldi	r20, 0xB8	; 184
    3614:	5f e7       	ldi	r21, 0x7F	; 127
    3616:	09 df       	rcall	.-494    	; 0x342a <__mulsf3_pse>
    3618:	0f 92       	push	r0
    361a:	0f 92       	push	r0
    361c:	0f 92       	push	r0
    361e:	4d b7       	in	r20, 0x3d	; 61
    3620:	5e b7       	in	r21, 0x3e	; 62
    3622:	0f 92       	push	r0
    3624:	a9 d0       	rcall	.+338    	; 0x3778 <modf>
    3626:	e3 ea       	ldi	r30, 0xA3	; 163
    3628:	f2 e0       	ldi	r31, 0x02	; 2
    362a:	7d de       	rcall	.-774    	; 0x3326 <__fp_powser>
    362c:	4f 91       	pop	r20
    362e:	5f 91       	pop	r21
    3630:	ef 91       	pop	r30
    3632:	ff 91       	pop	r31
    3634:	e5 95       	asr	r30
    3636:	ee 1f       	adc	r30, r30
    3638:	ff 1f       	adc	r31, r31
    363a:	49 f0       	breq	.+18     	; 0x364e <exp+0x4e>
    363c:	fe 57       	subi	r31, 0x7E	; 126
    363e:	e0 68       	ori	r30, 0x80	; 128
    3640:	44 27       	eor	r20, r20
    3642:	ee 0f       	add	r30, r30
    3644:	44 1f       	adc	r20, r20
    3646:	fa 95       	dec	r31
    3648:	e1 f7       	brne	.-8      	; 0x3642 <exp+0x42>
    364a:	41 95       	neg	r20
    364c:	55 0b       	sbc	r21, r21
    364e:	1b d0       	rcall	.+54     	; 0x3686 <ldexp>
    3650:	0f 90       	pop	r0
    3652:	07 fe       	sbrs	r0, 7
    3654:	d5 ce       	rjmp	.-598    	; 0x3400 <inverse>
    3656:	08 95       	ret

00003658 <__fp_mpack>:
    3658:	9f 3f       	cpi	r25, 0xFF	; 255
    365a:	31 f0       	breq	.+12     	; 0x3668 <__fp_mpack_finite+0xc>

0000365c <__fp_mpack_finite>:
    365c:	91 50       	subi	r25, 0x01	; 1
    365e:	20 f4       	brcc	.+8      	; 0x3668 <__fp_mpack_finite+0xc>
    3660:	87 95       	ror	r24
    3662:	77 95       	ror	r23
    3664:	67 95       	ror	r22
    3666:	b7 95       	ror	r27
    3668:	88 0f       	add	r24, r24
    366a:	91 1d       	adc	r25, r1
    366c:	96 95       	lsr	r25
    366e:	87 95       	ror	r24
    3670:	97 f9       	bld	r25, 7
    3672:	08 95       	ret

00003674 <__fp_norm2>:
    3674:	91 50       	subi	r25, 0x01	; 1
    3676:	50 40       	sbci	r21, 0x00	; 0
    3678:	66 0f       	add	r22, r22
    367a:	77 1f       	adc	r23, r23
    367c:	88 1f       	adc	r24, r24
    367e:	d2 f7       	brpl	.-12     	; 0x3674 <__fp_norm2>
    3680:	08 95       	ret
    3682:	48 ce       	rjmp	.-880    	; 0x3314 <__fp_inf>
    3684:	e9 cf       	rjmp	.-46     	; 0x3658 <__fp_mpack>

00003686 <ldexp>:
    3686:	9b de       	rcall	.-714    	; 0x33be <__fp_splitA>
    3688:	e8 f3       	brcs	.-6      	; 0x3684 <__fp_norm2+0x10>
    368a:	99 23       	and	r25, r25
    368c:	d9 f3       	breq	.-10     	; 0x3684 <__fp_norm2+0x10>
    368e:	94 0f       	add	r25, r20
    3690:	51 1d       	adc	r21, r1
    3692:	bb f3       	brvs	.-18     	; 0x3682 <__fp_norm2+0xe>
    3694:	91 50       	subi	r25, 0x01	; 1
    3696:	50 40       	sbci	r21, 0x00	; 0
    3698:	94 f0       	brlt	.+36     	; 0x36be <ldexp+0x38>
    369a:	59 f0       	breq	.+22     	; 0x36b2 <ldexp+0x2c>
    369c:	88 23       	and	r24, r24
    369e:	32 f0       	brmi	.+12     	; 0x36ac <ldexp+0x26>
    36a0:	66 0f       	add	r22, r22
    36a2:	77 1f       	adc	r23, r23
    36a4:	88 1f       	adc	r24, r24
    36a6:	91 50       	subi	r25, 0x01	; 1
    36a8:	50 40       	sbci	r21, 0x00	; 0
    36aa:	c1 f7       	brne	.-16     	; 0x369c <ldexp+0x16>
    36ac:	9e 3f       	cpi	r25, 0xFE	; 254
    36ae:	51 05       	cpc	r21, r1
    36b0:	44 f7       	brge	.-48     	; 0x3682 <__fp_norm2+0xe>
    36b2:	88 0f       	add	r24, r24
    36b4:	91 1d       	adc	r25, r1
    36b6:	96 95       	lsr	r25
    36b8:	87 95       	ror	r24
    36ba:	97 f9       	bld	r25, 7
    36bc:	08 95       	ret
    36be:	5f 3f       	cpi	r21, 0xFF	; 255
    36c0:	ac f0       	brlt	.+42     	; 0x36ec <ldexp+0x66>
    36c2:	98 3e       	cpi	r25, 0xE8	; 232
    36c4:	9c f0       	brlt	.+38     	; 0x36ec <ldexp+0x66>
    36c6:	bb 27       	eor	r27, r27
    36c8:	86 95       	lsr	r24
    36ca:	77 95       	ror	r23
    36cc:	67 95       	ror	r22
    36ce:	b7 95       	ror	r27
    36d0:	08 f4       	brcc	.+2      	; 0x36d4 <ldexp+0x4e>
    36d2:	b1 60       	ori	r27, 0x01	; 1
    36d4:	93 95       	inc	r25
    36d6:	c1 f7       	brne	.-16     	; 0x36c8 <ldexp+0x42>
    36d8:	bb 0f       	add	r27, r27
    36da:	58 f7       	brcc	.-42     	; 0x36b2 <ldexp+0x2c>
    36dc:	11 f4       	brne	.+4      	; 0x36e2 <ldexp+0x5c>
    36de:	60 ff       	sbrs	r22, 0
    36e0:	e8 cf       	rjmp	.-48     	; 0x36b2 <ldexp+0x2c>
    36e2:	6f 5f       	subi	r22, 0xFF	; 255
    36e4:	7f 4f       	sbci	r23, 0xFF	; 255
    36e6:	8f 4f       	sbci	r24, 0xFF	; 255
    36e8:	9f 4f       	sbci	r25, 0xFF	; 255
    36ea:	e3 cf       	rjmp	.-58     	; 0x36b2 <ldexp+0x2c>
    36ec:	83 ce       	rjmp	.-762    	; 0x33f4 <__fp_szero>
    36ee:	0e f0       	brts	.+2      	; 0x36f2 <ldexp+0x6c>
    36f0:	b3 cf       	rjmp	.-154    	; 0x3658 <__fp_mpack>
    36f2:	16 ce       	rjmp	.-980    	; 0x3320 <__fp_nan>
    36f4:	68 94       	set
    36f6:	0e ce       	rjmp	.-996    	; 0x3314 <__fp_inf>

000036f8 <log>:
    36f8:	62 de       	rcall	.-828    	; 0x33be <__fp_splitA>
    36fa:	c8 f3       	brcs	.-14     	; 0x36ee <ldexp+0x68>
    36fc:	99 23       	and	r25, r25
    36fe:	d1 f3       	breq	.-12     	; 0x36f4 <ldexp+0x6e>
    3700:	c6 f3       	brts	.-16     	; 0x36f2 <ldexp+0x6c>
    3702:	df 93       	push	r29
    3704:	cf 93       	push	r28
    3706:	1f 93       	push	r17
    3708:	0f 93       	push	r16
    370a:	ff 92       	push	r15
    370c:	c9 2f       	mov	r28, r25
    370e:	dd 27       	eor	r29, r29
    3710:	88 23       	and	r24, r24
    3712:	2a f0       	brmi	.+10     	; 0x371e <log+0x26>
    3714:	21 97       	sbiw	r28, 0x01	; 1
    3716:	66 0f       	add	r22, r22
    3718:	77 1f       	adc	r23, r23
    371a:	88 1f       	adc	r24, r24
    371c:	da f7       	brpl	.-10     	; 0x3714 <log+0x1c>
    371e:	20 e0       	ldi	r18, 0x00	; 0
    3720:	30 e0       	ldi	r19, 0x00	; 0
    3722:	40 e8       	ldi	r20, 0x80	; 128
    3724:	5f eb       	ldi	r21, 0xBF	; 191
    3726:	9f e3       	ldi	r25, 0x3F	; 63
    3728:	88 39       	cpi	r24, 0x98	; 152
    372a:	20 f0       	brcs	.+8      	; 0x3734 <log+0x3c>
    372c:	80 3e       	cpi	r24, 0xE0	; 224
    372e:	30 f0       	brcs	.+12     	; 0x373c <log+0x44>
    3730:	21 96       	adiw	r28, 0x01	; 1
    3732:	8f 77       	andi	r24, 0x7F	; 127
    3734:	2b dc       	rcall	.-1962   	; 0x2f8c <__addsf3>
    3736:	eb ec       	ldi	r30, 0xCB	; 203
    3738:	f2 e0       	ldi	r31, 0x02	; 2
    373a:	03 c0       	rjmp	.+6      	; 0x3742 <log+0x4a>
    373c:	27 dc       	rcall	.-1970   	; 0x2f8c <__addsf3>
    373e:	e8 ef       	ldi	r30, 0xF8	; 248
    3740:	f2 e0       	ldi	r31, 0x02	; 2
    3742:	f1 dd       	rcall	.-1054   	; 0x3326 <__fp_powser>
    3744:	8b 01       	movw	r16, r22
    3746:	be 01       	movw	r22, r28
    3748:	ec 01       	movw	r28, r24
    374a:	fb 2e       	mov	r15, r27
    374c:	6f 57       	subi	r22, 0x7F	; 127
    374e:	71 09       	sbc	r23, r1
    3750:	75 95       	asr	r23
    3752:	77 1f       	adc	r23, r23
    3754:	88 0b       	sbc	r24, r24
    3756:	99 0b       	sbc	r25, r25
    3758:	7e dd       	rcall	.-1284   	; 0x3256 <__floatsisf>
    375a:	28 e1       	ldi	r18, 0x18	; 24
    375c:	32 e7       	ldi	r19, 0x72	; 114
    375e:	41 e3       	ldi	r20, 0x31	; 49
    3760:	5f e3       	ldi	r21, 0x3F	; 63
    3762:	61 de       	rcall	.-830    	; 0x3426 <__mulsf3x>
    3764:	af 2d       	mov	r26, r15
    3766:	98 01       	movw	r18, r16
    3768:	ae 01       	movw	r20, r28
    376a:	ff 90       	pop	r15
    376c:	0f 91       	pop	r16
    376e:	1f 91       	pop	r17
    3770:	cf 91       	pop	r28
    3772:	df 91       	pop	r29
    3774:	1c dc       	rcall	.-1992   	; 0x2fae <__addsf3x>
    3776:	0a ce       	rjmp	.-1004   	; 0x338c <__fp_round>

00003778 <modf>:
    3778:	fa 01       	movw	r30, r20
    377a:	dc 01       	movw	r26, r24
    377c:	aa 0f       	add	r26, r26
    377e:	bb 1f       	adc	r27, r27
    3780:	9b 01       	movw	r18, r22
    3782:	ac 01       	movw	r20, r24
    3784:	bf 57       	subi	r27, 0x7F	; 127
    3786:	28 f4       	brcc	.+10     	; 0x3792 <modf+0x1a>
    3788:	22 27       	eor	r18, r18
    378a:	33 27       	eor	r19, r19
    378c:	44 27       	eor	r20, r20
    378e:	50 78       	andi	r21, 0x80	; 128
    3790:	1f c0       	rjmp	.+62     	; 0x37d0 <modf+0x58>
    3792:	b7 51       	subi	r27, 0x17	; 23
    3794:	88 f4       	brcc	.+34     	; 0x37b8 <modf+0x40>
    3796:	ab 2f       	mov	r26, r27
    3798:	00 24       	eor	r0, r0
    379a:	46 95       	lsr	r20
    379c:	37 95       	ror	r19
    379e:	27 95       	ror	r18
    37a0:	01 1c       	adc	r0, r1
    37a2:	a3 95       	inc	r26
    37a4:	d2 f3       	brmi	.-12     	; 0x379a <modf+0x22>
    37a6:	00 20       	and	r0, r0
    37a8:	69 f0       	breq	.+26     	; 0x37c4 <modf+0x4c>
    37aa:	22 0f       	add	r18, r18
    37ac:	33 1f       	adc	r19, r19
    37ae:	44 1f       	adc	r20, r20
    37b0:	b3 95       	inc	r27
    37b2:	da f3       	brmi	.-10     	; 0x37aa <modf+0x32>
    37b4:	0d d0       	rcall	.+26     	; 0x37d0 <modf+0x58>
    37b6:	e9 cb       	rjmp	.-2094   	; 0x2f8a <__subsf3>
    37b8:	61 30       	cpi	r22, 0x01	; 1
    37ba:	71 05       	cpc	r23, r1
    37bc:	a0 e8       	ldi	r26, 0x80	; 128
    37be:	8a 07       	cpc	r24, r26
    37c0:	b9 46       	sbci	r27, 0x69	; 105
    37c2:	30 f4       	brcc	.+12     	; 0x37d0 <modf+0x58>
    37c4:	9b 01       	movw	r18, r22
    37c6:	ac 01       	movw	r20, r24
    37c8:	66 27       	eor	r22, r22
    37ca:	77 27       	eor	r23, r23
    37cc:	88 27       	eor	r24, r24
    37ce:	90 78       	andi	r25, 0x80	; 128
    37d0:	30 96       	adiw	r30, 0x00	; 0
    37d2:	21 f0       	breq	.+8      	; 0x37dc <modf+0x64>
    37d4:	20 83       	st	Z, r18
    37d6:	31 83       	std	Z+1, r19	; 0x01
    37d8:	42 83       	std	Z+2, r20	; 0x02
    37da:	53 83       	std	Z+3, r21	; 0x03
    37dc:	08 95       	ret

000037de <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    37de:	fc 01       	movw	r30, r24
    37e0:	81 8d       	ldd	r24, Z+25	; 0x19
    37e2:	22 8d       	ldd	r18, Z+26	; 0x1a
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	80 5c       	subi	r24, 0xC0	; 192
    37e8:	9f 4f       	sbci	r25, 0xFF	; 255
    37ea:	82 1b       	sub	r24, r18
    37ec:	91 09       	sbc	r25, r1
    37ee:	8f 73       	andi	r24, 0x3F	; 63
    37f0:	99 27       	eor	r25, r25
    37f2:	08 95       	ret

000037f4 <_ZN14HardwareSerial4peekEv>:
    37f4:	fc 01       	movw	r30, r24
    37f6:	91 8d       	ldd	r25, Z+25	; 0x19
    37f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    37fa:	98 17       	cp	r25, r24
    37fc:	31 f0       	breq	.+12     	; 0x380a <_ZN14HardwareSerial4peekEv+0x16>
    37fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3800:	e8 0f       	add	r30, r24
    3802:	f1 1d       	adc	r31, r1
    3804:	85 8d       	ldd	r24, Z+29	; 0x1d
    3806:	90 e0       	ldi	r25, 0x00	; 0
    3808:	08 95       	ret
    380a:	8f ef       	ldi	r24, 0xFF	; 255
    380c:	9f ef       	ldi	r25, 0xFF	; 255
    380e:	08 95       	ret

00003810 <_ZN14HardwareSerial4readEv>:
    3810:	fc 01       	movw	r30, r24
    3812:	91 8d       	ldd	r25, Z+25	; 0x19
    3814:	82 8d       	ldd	r24, Z+26	; 0x1a
    3816:	98 17       	cp	r25, r24
    3818:	61 f0       	breq	.+24     	; 0x3832 <_ZN14HardwareSerial4readEv+0x22>
    381a:	82 8d       	ldd	r24, Z+26	; 0x1a
    381c:	df 01       	movw	r26, r30
    381e:	a8 0f       	add	r26, r24
    3820:	b1 1d       	adc	r27, r1
    3822:	5d 96       	adiw	r26, 0x1d	; 29
    3824:	8c 91       	ld	r24, X
    3826:	92 8d       	ldd	r25, Z+26	; 0x1a
    3828:	9f 5f       	subi	r25, 0xFF	; 255
    382a:	9f 73       	andi	r25, 0x3F	; 63
    382c:	92 8f       	std	Z+26, r25	; 0x1a
    382e:	90 e0       	ldi	r25, 0x00	; 0
    3830:	08 95       	ret
    3832:	8f ef       	ldi	r24, 0xFF	; 255
    3834:	9f ef       	ldi	r25, 0xFF	; 255
    3836:	08 95       	ret

00003838 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    3838:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    383a:	84 8d       	ldd	r24, Z+28	; 0x1c
    383c:	df 01       	movw	r26, r30
    383e:	a8 0f       	add	r26, r24
    3840:	b1 1d       	adc	r27, r1
    3842:	a3 5a       	subi	r26, 0xA3	; 163
    3844:	bf 4f       	sbci	r27, 0xFF	; 255
    3846:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    3848:	84 8d       	ldd	r24, Z+28	; 0x1c
    384a:	90 e0       	ldi	r25, 0x00	; 0
    384c:	01 96       	adiw	r24, 0x01	; 1
    384e:	8f 73       	andi	r24, 0x3F	; 63
    3850:	90 78       	andi	r25, 0x80	; 128
    3852:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    3854:	a6 89       	ldd	r26, Z+22	; 0x16
    3856:	b7 89       	ldd	r27, Z+23	; 0x17
    3858:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    385a:	a0 89       	ldd	r26, Z+16	; 0x10
    385c:	b1 89       	ldd	r27, Z+17	; 0x11
    385e:	8c 91       	ld	r24, X
    3860:	80 64       	ori	r24, 0x40	; 64
    3862:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    3864:	93 8d       	ldd	r25, Z+27	; 0x1b
    3866:	84 8d       	ldd	r24, Z+28	; 0x1c
    3868:	98 13       	cpse	r25, r24
    386a:	06 c0       	rjmp	.+12     	; 0x3878 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    386c:	02 88       	ldd	r0, Z+18	; 0x12
    386e:	f3 89       	ldd	r31, Z+19	; 0x13
    3870:	e0 2d       	mov	r30, r0
    3872:	80 81       	ld	r24, Z
    3874:	8f 7d       	andi	r24, 0xDF	; 223
    3876:	80 83       	st	Z, r24
    3878:	08 95       	ret

0000387a <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    387a:	cf 93       	push	r28
    387c:	df 93       	push	r29
    387e:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    3880:	88 8d       	ldd	r24, Y+24	; 0x18
    3882:	81 11       	cpse	r24, r1
    3884:	0a c0       	rjmp	.+20     	; 0x389a <_ZN14HardwareSerial5flushEv+0x20>
    3886:	1a c0       	rjmp	.+52     	; 0x38bc <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    3888:	0f b6       	in	r0, 0x3f	; 63
    388a:	07 fc       	sbrc	r0, 7
    388c:	08 c0       	rjmp	.+16     	; 0x389e <_ZN14HardwareSerial5flushEv+0x24>
    388e:	80 81       	ld	r24, Z
    3890:	85 ff       	sbrs	r24, 5
    3892:	05 c0       	rjmp	.+10     	; 0x389e <_ZN14HardwareSerial5flushEv+0x24>
    3894:	0d c0       	rjmp	.+26     	; 0x38b0 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    3896:	ce 01       	movw	r24, r28
    3898:	cf df       	rcall	.-98     	; 0x3838 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    389a:	ea 89       	ldd	r30, Y+18	; 0x12
    389c:	fb 89       	ldd	r31, Y+19	; 0x13
    389e:	80 81       	ld	r24, Z
    38a0:	85 fd       	sbrc	r24, 5
    38a2:	f2 cf       	rjmp	.-28     	; 0x3888 <_ZN14HardwareSerial5flushEv+0xe>
    38a4:	a8 89       	ldd	r26, Y+16	; 0x10
    38a6:	b9 89       	ldd	r27, Y+17	; 0x11
    38a8:	8c 91       	ld	r24, X
    38aa:	86 ff       	sbrs	r24, 6
    38ac:	ed cf       	rjmp	.-38     	; 0x3888 <_ZN14HardwareSerial5flushEv+0xe>
    38ae:	06 c0       	rjmp	.+12     	; 0x38bc <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    38b0:	a8 89       	ldd	r26, Y+16	; 0x10
    38b2:	b9 89       	ldd	r27, Y+17	; 0x11
    38b4:	8c 91       	ld	r24, X
    38b6:	85 ff       	sbrs	r24, 5
    38b8:	f2 cf       	rjmp	.-28     	; 0x389e <_ZN14HardwareSerial5flushEv+0x24>
    38ba:	ed cf       	rjmp	.-38     	; 0x3896 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    38bc:	df 91       	pop	r29
    38be:	cf 91       	pop	r28
    38c0:	08 95       	ret

000038c2 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    38c2:	0f 93       	push	r16
    38c4:	1f 93       	push	r17
    38c6:	cf 93       	push	r28
    38c8:	df 93       	push	r29
    38ca:	ec 01       	movw	r28, r24
    38cc:	16 2f       	mov	r17, r22
  _written = true;
    38ce:	81 e0       	ldi	r24, 0x01	; 1
    38d0:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    38d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    38d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    38d6:	98 13       	cpse	r25, r24
    38d8:	21 c0       	rjmp	.+66     	; 0x391c <_ZN14HardwareSerial5writeEh+0x5a>
    38da:	e8 89       	ldd	r30, Y+16	; 0x10
    38dc:	f9 89       	ldd	r31, Y+17	; 0x11
    38de:	80 81       	ld	r24, Z
    38e0:	85 fd       	sbrc	r24, 5
    38e2:	23 c0       	rjmp	.+70     	; 0x392a <_ZN14HardwareSerial5writeEh+0x68>
    38e4:	1b c0       	rjmp	.+54     	; 0x391c <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    38e6:	0f b6       	in	r0, 0x3f	; 63
    38e8:	07 fc       	sbrc	r0, 7
    38ea:	07 c0       	rjmp	.+14     	; 0x38fa <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    38ec:	e8 89       	ldd	r30, Y+16	; 0x10
    38ee:	f9 89       	ldd	r31, Y+17	; 0x11
    38f0:	80 81       	ld	r24, Z
    38f2:	85 ff       	sbrs	r24, 5
    38f4:	02 c0       	rjmp	.+4      	; 0x38fa <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    38f6:	ce 01       	movw	r24, r28
    38f8:	9f df       	rcall	.-194    	; 0x3838 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    38fa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    38fc:	09 17       	cp	r16, r25
    38fe:	99 f3       	breq	.-26     	; 0x38e6 <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    3900:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3902:	fe 01       	movw	r30, r28
    3904:	e8 0f       	add	r30, r24
    3906:	f1 1d       	adc	r31, r1
    3908:	e3 5a       	subi	r30, 0xA3	; 163
    390a:	ff 4f       	sbci	r31, 0xFF	; 255
    390c:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    390e:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    3910:	ea 89       	ldd	r30, Y+18	; 0x12
    3912:	fb 89       	ldd	r31, Y+19	; 0x13
    3914:	80 81       	ld	r24, Z
    3916:	80 62       	ori	r24, 0x20	; 32
    3918:	80 83       	st	Z, r24
  
  return 1;
    391a:	0f c0       	rjmp	.+30     	; 0x393a <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    391c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    391e:	90 e0       	ldi	r25, 0x00	; 0
    3920:	01 96       	adiw	r24, 0x01	; 1
    3922:	8f 73       	andi	r24, 0x3F	; 63
    3924:	90 78       	andi	r25, 0x80	; 128
    3926:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3928:	e8 cf       	rjmp	.-48     	; 0x38fa <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    392a:	ee 89       	ldd	r30, Y+22	; 0x16
    392c:	ff 89       	ldd	r31, Y+23	; 0x17
    392e:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    3930:	e8 89       	ldd	r30, Y+16	; 0x10
    3932:	f9 89       	ldd	r31, Y+17	; 0x11
    3934:	80 81       	ld	r24, Z
    3936:	80 64       	ori	r24, 0x40	; 64
    3938:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    393a:	81 e0       	ldi	r24, 0x01	; 1
    393c:	90 e0       	ldi	r25, 0x00	; 0
    393e:	df 91       	pop	r29
    3940:	cf 91       	pop	r28
    3942:	1f 91       	pop	r17
    3944:	0f 91       	pop	r16
    3946:	08 95       	ret

00003948 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    3948:	cf 92       	push	r12
    394a:	df 92       	push	r13
    394c:	ef 92       	push	r14
    394e:	ff 92       	push	r15
    3950:	1f 93       	push	r17
    3952:	cf 93       	push	r28
    3954:	df 93       	push	r29
    3956:	ec 01       	movw	r28, r24
    3958:	6a 01       	movw	r12, r20
    395a:	7b 01       	movw	r14, r22
    395c:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    395e:	e8 89       	ldd	r30, Y+16	; 0x10
    3960:	f9 89       	ldd	r31, Y+17	; 0x11
    3962:	82 e0       	ldi	r24, 0x02	; 2
    3964:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3966:	41 15       	cp	r20, r1
    3968:	81 ee       	ldi	r24, 0xE1	; 225
    396a:	58 07       	cpc	r21, r24
    396c:	61 05       	cpc	r22, r1
    396e:	71 05       	cpc	r23, r1
    3970:	a9 f0       	breq	.+42     	; 0x399c <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3972:	60 e0       	ldi	r22, 0x00	; 0
    3974:	79 e0       	ldi	r23, 0x09	; 9
    3976:	8d e3       	ldi	r24, 0x3D	; 61
    3978:	90 e0       	ldi	r25, 0x00	; 0
    397a:	a7 01       	movw	r20, r14
    397c:	96 01       	movw	r18, r12
    397e:	79 d4       	rcall	.+2290   	; 0x4272 <__udivmodsi4>
    3980:	ba 01       	movw	r22, r20
    3982:	a9 01       	movw	r20, r18
    3984:	41 50       	subi	r20, 0x01	; 1
    3986:	51 09       	sbc	r21, r1
    3988:	61 09       	sbc	r22, r1
    398a:	71 09       	sbc	r23, r1
    398c:	76 95       	lsr	r23
    398e:	67 95       	ror	r22
    3990:	57 95       	ror	r21
    3992:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3994:	41 15       	cp	r20, r1
    3996:	80 e1       	ldi	r24, 0x10	; 16
    3998:	58 07       	cpc	r21, r24
    399a:	a0 f0       	brcs	.+40     	; 0x39c4 <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    399c:	e8 89       	ldd	r30, Y+16	; 0x10
    399e:	f9 89       	ldd	r31, Y+17	; 0x11
    39a0:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    39a2:	60 e8       	ldi	r22, 0x80	; 128
    39a4:	74 e8       	ldi	r23, 0x84	; 132
    39a6:	8e e1       	ldi	r24, 0x1E	; 30
    39a8:	90 e0       	ldi	r25, 0x00	; 0
    39aa:	a7 01       	movw	r20, r14
    39ac:	96 01       	movw	r18, r12
    39ae:	61 d4       	rcall	.+2242   	; 0x4272 <__udivmodsi4>
    39b0:	ba 01       	movw	r22, r20
    39b2:	a9 01       	movw	r20, r18
    39b4:	41 50       	subi	r20, 0x01	; 1
    39b6:	51 09       	sbc	r21, r1
    39b8:	61 09       	sbc	r22, r1
    39ba:	71 09       	sbc	r23, r1
    39bc:	76 95       	lsr	r23
    39be:	67 95       	ror	r22
    39c0:	57 95       	ror	r21
    39c2:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    39c4:	ec 85       	ldd	r30, Y+12	; 0x0c
    39c6:	fd 85       	ldd	r31, Y+13	; 0x0d
    39c8:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    39ca:	ee 85       	ldd	r30, Y+14	; 0x0e
    39cc:	ff 85       	ldd	r31, Y+15	; 0x0f
    39ce:	40 83       	st	Z, r20

  _written = false;
    39d0:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    39d2:	ec 89       	ldd	r30, Y+20	; 0x14
    39d4:	fd 89       	ldd	r31, Y+21	; 0x15
    39d6:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    39d8:	ea 89       	ldd	r30, Y+18	; 0x12
    39da:	fb 89       	ldd	r31, Y+19	; 0x13
    39dc:	80 81       	ld	r24, Z
    39de:	80 61       	ori	r24, 0x10	; 16
    39e0:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    39e2:	ea 89       	ldd	r30, Y+18	; 0x12
    39e4:	fb 89       	ldd	r31, Y+19	; 0x13
    39e6:	80 81       	ld	r24, Z
    39e8:	88 60       	ori	r24, 0x08	; 8
    39ea:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    39ec:	ea 89       	ldd	r30, Y+18	; 0x12
    39ee:	fb 89       	ldd	r31, Y+19	; 0x13
    39f0:	80 81       	ld	r24, Z
    39f2:	80 68       	ori	r24, 0x80	; 128
    39f4:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    39f6:	ea 89       	ldd	r30, Y+18	; 0x12
    39f8:	fb 89       	ldd	r31, Y+19	; 0x13
    39fa:	80 81       	ld	r24, Z
    39fc:	8f 7d       	andi	r24, 0xDF	; 223
    39fe:	80 83       	st	Z, r24
}
    3a00:	df 91       	pop	r29
    3a02:	cf 91       	pop	r28
    3a04:	1f 91       	pop	r17
    3a06:	ff 90       	pop	r15
    3a08:	ef 90       	pop	r14
    3a0a:	df 90       	pop	r13
    3a0c:	cf 90       	pop	r12
    3a0e:	08 95       	ret

00003a10 <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    3a10:	1f 92       	push	r1
    3a12:	0f 92       	push	r0
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	0f 92       	push	r0
    3a18:	11 24       	eor	r1, r1
    3a1a:	0b b6       	in	r0, 0x3b	; 59
    3a1c:	0f 92       	push	r0
    3a1e:	2f 93       	push	r18
    3a20:	8f 93       	push	r24
    3a22:	9f 93       	push	r25
    3a24:	af 93       	push	r26
    3a26:	bf 93       	push	r27
    3a28:	ef 93       	push	r30
    3a2a:	ff 93       	push	r31
    3a2c:	e0 91 12 0a 	lds	r30, 0x0A12
    3a30:	f0 91 13 0a 	lds	r31, 0x0A13
    3a34:	80 81       	ld	r24, Z
    3a36:	82 fd       	sbrc	r24, 2
    3a38:	17 c0       	rjmp	.+46     	; 0x3a68 <__vector_25+0x58>
    3a3a:	e0 91 18 0a 	lds	r30, 0x0A18
    3a3e:	f0 91 19 0a 	lds	r31, 0x0A19
    3a42:	20 81       	ld	r18, Z
    3a44:	80 91 1b 0a 	lds	r24, 0x0A1B
    3a48:	8f 5f       	subi	r24, 0xFF	; 255
    3a4a:	8f 73       	andi	r24, 0x3F	; 63
    3a4c:	90 91 1c 0a 	lds	r25, 0x0A1C
    3a50:	89 17       	cp	r24, r25
    3a52:	79 f0       	breq	.+30     	; 0x3a72 <__vector_25+0x62>
    3a54:	eb e1       	ldi	r30, 0x1B	; 27
    3a56:	fa e0       	ldi	r31, 0x0A	; 10
    3a58:	a0 81       	ld	r26, Z
    3a5a:	b0 e0       	ldi	r27, 0x00	; 0
    3a5c:	ae 5f       	subi	r26, 0xFE	; 254
    3a5e:	b5 4f       	sbci	r27, 0xF5	; 245
    3a60:	5d 96       	adiw	r26, 0x1d	; 29
    3a62:	2c 93       	st	X, r18
    3a64:	80 83       	st	Z, r24
    3a66:	05 c0       	rjmp	.+10     	; 0x3a72 <__vector_25+0x62>
    3a68:	e0 91 18 0a 	lds	r30, 0x0A18
    3a6c:	f0 91 19 0a 	lds	r31, 0x0A19
    3a70:	80 81       	ld	r24, Z
    3a72:	ff 91       	pop	r31
    3a74:	ef 91       	pop	r30
    3a76:	bf 91       	pop	r27
    3a78:	af 91       	pop	r26
    3a7a:	9f 91       	pop	r25
    3a7c:	8f 91       	pop	r24
    3a7e:	2f 91       	pop	r18
    3a80:	0f 90       	pop	r0
    3a82:	0b be       	out	0x3b, r0	; 59
    3a84:	0f 90       	pop	r0
    3a86:	0f be       	out	0x3f, r0	; 63
    3a88:	0f 90       	pop	r0
    3a8a:	1f 90       	pop	r1
    3a8c:	18 95       	reti

00003a8e <__vector_26>:
    3a8e:	1f 92       	push	r1
    3a90:	0f 92       	push	r0
    3a92:	0f b6       	in	r0, 0x3f	; 63
    3a94:	0f 92       	push	r0
    3a96:	11 24       	eor	r1, r1
    3a98:	0b b6       	in	r0, 0x3b	; 59
    3a9a:	0f 92       	push	r0
    3a9c:	2f 93       	push	r18
    3a9e:	3f 93       	push	r19
    3aa0:	4f 93       	push	r20
    3aa2:	5f 93       	push	r21
    3aa4:	6f 93       	push	r22
    3aa6:	7f 93       	push	r23
    3aa8:	8f 93       	push	r24
    3aaa:	9f 93       	push	r25
    3aac:	af 93       	push	r26
    3aae:	bf 93       	push	r27
    3ab0:	ef 93       	push	r30
    3ab2:	ff 93       	push	r31
    3ab4:	82 e0       	ldi	r24, 0x02	; 2
    3ab6:	9a e0       	ldi	r25, 0x0A	; 10
    3ab8:	bf de       	rcall	.-642    	; 0x3838 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3aba:	ff 91       	pop	r31
    3abc:	ef 91       	pop	r30
    3abe:	bf 91       	pop	r27
    3ac0:	af 91       	pop	r26
    3ac2:	9f 91       	pop	r25
    3ac4:	8f 91       	pop	r24
    3ac6:	7f 91       	pop	r23
    3ac8:	6f 91       	pop	r22
    3aca:	5f 91       	pop	r21
    3acc:	4f 91       	pop	r20
    3ace:	3f 91       	pop	r19
    3ad0:	2f 91       	pop	r18
    3ad2:	0f 90       	pop	r0
    3ad4:	0b be       	out	0x3b, r0	; 59
    3ad6:	0f 90       	pop	r0
    3ad8:	0f be       	out	0x3f, r0	; 63
    3ada:	0f 90       	pop	r0
    3adc:	1f 90       	pop	r1
    3ade:	18 95       	reti

00003ae0 <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    3ae0:	10 92 05 0a 	sts	0x0A05, r1
    3ae4:	10 92 04 0a 	sts	0x0A04, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    3ae8:	88 ee       	ldi	r24, 0xE8	; 232
    3aea:	93 e0       	ldi	r25, 0x03	; 3
    3aec:	a0 e0       	ldi	r26, 0x00	; 0
    3aee:	b0 e0       	ldi	r27, 0x00	; 0
    3af0:	80 93 06 0a 	sts	0x0A06, r24
    3af4:	90 93 07 0a 	sts	0x0A07, r25
    3af8:	a0 93 08 0a 	sts	0x0A08, r26
    3afc:	b0 93 09 0a 	sts	0x0A09, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    3b00:	89 e9       	ldi	r24, 0x99	; 153
    3b02:	92 e0       	ldi	r25, 0x02	; 2
    3b04:	90 93 03 0a 	sts	0x0A03, r25
    3b08:	80 93 02 0a 	sts	0x0A02, r24
    3b0c:	85 ec       	ldi	r24, 0xC5	; 197
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	90 93 0f 0a 	sts	0x0A0F, r25
    3b14:	80 93 0e 0a 	sts	0x0A0E, r24
    3b18:	84 ec       	ldi	r24, 0xC4	; 196
    3b1a:	90 e0       	ldi	r25, 0x00	; 0
    3b1c:	90 93 11 0a 	sts	0x0A11, r25
    3b20:	80 93 10 0a 	sts	0x0A10, r24
    3b24:	80 ec       	ldi	r24, 0xC0	; 192
    3b26:	90 e0       	ldi	r25, 0x00	; 0
    3b28:	90 93 13 0a 	sts	0x0A13, r25
    3b2c:	80 93 12 0a 	sts	0x0A12, r24
    3b30:	81 ec       	ldi	r24, 0xC1	; 193
    3b32:	90 e0       	ldi	r25, 0x00	; 0
    3b34:	90 93 15 0a 	sts	0x0A15, r25
    3b38:	80 93 14 0a 	sts	0x0A14, r24
    3b3c:	82 ec       	ldi	r24, 0xC2	; 194
    3b3e:	90 e0       	ldi	r25, 0x00	; 0
    3b40:	90 93 17 0a 	sts	0x0A17, r25
    3b44:	80 93 16 0a 	sts	0x0A16, r24
    3b48:	86 ec       	ldi	r24, 0xC6	; 198
    3b4a:	90 e0       	ldi	r25, 0x00	; 0
    3b4c:	90 93 19 0a 	sts	0x0A19, r25
    3b50:	80 93 18 0a 	sts	0x0A18, r24
    3b54:	10 92 1b 0a 	sts	0x0A1B, r1
    3b58:	10 92 1c 0a 	sts	0x0A1C, r1
    3b5c:	10 92 1d 0a 	sts	0x0A1D, r1
    3b60:	10 92 1e 0a 	sts	0x0A1E, r1
    3b64:	08 95       	ret

00003b66 <__vector_36>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial1_available() {
  return Serial1.available();
}
    3b66:	1f 92       	push	r1
    3b68:	0f 92       	push	r0
    3b6a:	0f b6       	in	r0, 0x3f	; 63
    3b6c:	0f 92       	push	r0
    3b6e:	11 24       	eor	r1, r1
    3b70:	0b b6       	in	r0, 0x3b	; 59
    3b72:	0f 92       	push	r0
    3b74:	2f 93       	push	r18
    3b76:	8f 93       	push	r24
    3b78:	9f 93       	push	r25
    3b7a:	af 93       	push	r26
    3b7c:	bf 93       	push	r27
    3b7e:	ef 93       	push	r30
    3b80:	ff 93       	push	r31
    3b82:	e0 91 af 0a 	lds	r30, 0x0AAF
    3b86:	f0 91 b0 0a 	lds	r31, 0x0AB0
    3b8a:	80 81       	ld	r24, Z
    3b8c:	82 fd       	sbrc	r24, 2
    3b8e:	17 c0       	rjmp	.+46     	; 0x3bbe <__vector_36+0x58>
    3b90:	e0 91 b5 0a 	lds	r30, 0x0AB5
    3b94:	f0 91 b6 0a 	lds	r31, 0x0AB6
    3b98:	20 81       	ld	r18, Z
    3b9a:	80 91 b8 0a 	lds	r24, 0x0AB8
    3b9e:	8f 5f       	subi	r24, 0xFF	; 255
    3ba0:	8f 73       	andi	r24, 0x3F	; 63
    3ba2:	90 91 b9 0a 	lds	r25, 0x0AB9
    3ba6:	89 17       	cp	r24, r25
    3ba8:	79 f0       	breq	.+30     	; 0x3bc8 <__vector_36+0x62>
    3baa:	e8 eb       	ldi	r30, 0xB8	; 184
    3bac:	fa e0       	ldi	r31, 0x0A	; 10
    3bae:	a0 81       	ld	r26, Z
    3bb0:	b0 e0       	ldi	r27, 0x00	; 0
    3bb2:	a1 56       	subi	r26, 0x61	; 97
    3bb4:	b5 4f       	sbci	r27, 0xF5	; 245
    3bb6:	5d 96       	adiw	r26, 0x1d	; 29
    3bb8:	2c 93       	st	X, r18
    3bba:	80 83       	st	Z, r24
    3bbc:	05 c0       	rjmp	.+10     	; 0x3bc8 <__vector_36+0x62>
    3bbe:	e0 91 b5 0a 	lds	r30, 0x0AB5
    3bc2:	f0 91 b6 0a 	lds	r31, 0x0AB6
    3bc6:	80 81       	ld	r24, Z
    3bc8:	ff 91       	pop	r31
    3bca:	ef 91       	pop	r30
    3bcc:	bf 91       	pop	r27
    3bce:	af 91       	pop	r26
    3bd0:	9f 91       	pop	r25
    3bd2:	8f 91       	pop	r24
    3bd4:	2f 91       	pop	r18
    3bd6:	0f 90       	pop	r0
    3bd8:	0b be       	out	0x3b, r0	; 59
    3bda:	0f 90       	pop	r0
    3bdc:	0f be       	out	0x3f, r0	; 63
    3bde:	0f 90       	pop	r0
    3be0:	1f 90       	pop	r1
    3be2:	18 95       	reti

00003be4 <__vector_37>:
    3be4:	1f 92       	push	r1
    3be6:	0f 92       	push	r0
    3be8:	0f b6       	in	r0, 0x3f	; 63
    3bea:	0f 92       	push	r0
    3bec:	11 24       	eor	r1, r1
    3bee:	0b b6       	in	r0, 0x3b	; 59
    3bf0:	0f 92       	push	r0
    3bf2:	2f 93       	push	r18
    3bf4:	3f 93       	push	r19
    3bf6:	4f 93       	push	r20
    3bf8:	5f 93       	push	r21
    3bfa:	6f 93       	push	r22
    3bfc:	7f 93       	push	r23
    3bfe:	8f 93       	push	r24
    3c00:	9f 93       	push	r25
    3c02:	af 93       	push	r26
    3c04:	bf 93       	push	r27
    3c06:	ef 93       	push	r30
    3c08:	ff 93       	push	r31
    3c0a:	8f e9       	ldi	r24, 0x9F	; 159
    3c0c:	9a e0       	ldi	r25, 0x0A	; 10
    3c0e:	14 de       	rcall	.-984    	; 0x3838 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3c10:	ff 91       	pop	r31
    3c12:	ef 91       	pop	r30
    3c14:	bf 91       	pop	r27
    3c16:	af 91       	pop	r26
    3c18:	9f 91       	pop	r25
    3c1a:	8f 91       	pop	r24
    3c1c:	7f 91       	pop	r23
    3c1e:	6f 91       	pop	r22
    3c20:	5f 91       	pop	r21
    3c22:	4f 91       	pop	r20
    3c24:	3f 91       	pop	r19
    3c26:	2f 91       	pop	r18
    3c28:	0f 90       	pop	r0
    3c2a:	0b be       	out	0x3b, r0	; 59
    3c2c:	0f 90       	pop	r0
    3c2e:	0f be       	out	0x3f, r0	; 63
    3c30:	0f 90       	pop	r0
    3c32:	1f 90       	pop	r1
    3c34:	18 95       	reti

00003c36 <_GLOBAL__sub_I___vector_36>:
    3c36:	10 92 a2 0a 	sts	0x0AA2, r1
    3c3a:	10 92 a1 0a 	sts	0x0AA1, r1
    3c3e:	88 ee       	ldi	r24, 0xE8	; 232
    3c40:	93 e0       	ldi	r25, 0x03	; 3
    3c42:	a0 e0       	ldi	r26, 0x00	; 0
    3c44:	b0 e0       	ldi	r27, 0x00	; 0
    3c46:	80 93 a3 0a 	sts	0x0AA3, r24
    3c4a:	90 93 a4 0a 	sts	0x0AA4, r25
    3c4e:	a0 93 a5 0a 	sts	0x0AA5, r26
    3c52:	b0 93 a6 0a 	sts	0x0AA6, r27
    3c56:	89 e9       	ldi	r24, 0x99	; 153
    3c58:	92 e0       	ldi	r25, 0x02	; 2
    3c5a:	90 93 a0 0a 	sts	0x0AA0, r25
    3c5e:	80 93 9f 0a 	sts	0x0A9F, r24
    3c62:	8d ec       	ldi	r24, 0xCD	; 205
    3c64:	90 e0       	ldi	r25, 0x00	; 0
    3c66:	90 93 ac 0a 	sts	0x0AAC, r25
    3c6a:	80 93 ab 0a 	sts	0x0AAB, r24
    3c6e:	8c ec       	ldi	r24, 0xCC	; 204
    3c70:	90 e0       	ldi	r25, 0x00	; 0
    3c72:	90 93 ae 0a 	sts	0x0AAE, r25
    3c76:	80 93 ad 0a 	sts	0x0AAD, r24
    3c7a:	88 ec       	ldi	r24, 0xC8	; 200
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	90 93 b0 0a 	sts	0x0AB0, r25
    3c82:	80 93 af 0a 	sts	0x0AAF, r24
    3c86:	89 ec       	ldi	r24, 0xC9	; 201
    3c88:	90 e0       	ldi	r25, 0x00	; 0
    3c8a:	90 93 b2 0a 	sts	0x0AB2, r25
    3c8e:	80 93 b1 0a 	sts	0x0AB1, r24
    3c92:	8a ec       	ldi	r24, 0xCA	; 202
    3c94:	90 e0       	ldi	r25, 0x00	; 0
    3c96:	90 93 b4 0a 	sts	0x0AB4, r25
    3c9a:	80 93 b3 0a 	sts	0x0AB3, r24
    3c9e:	8e ec       	ldi	r24, 0xCE	; 206
    3ca0:	90 e0       	ldi	r25, 0x00	; 0
    3ca2:	90 93 b6 0a 	sts	0x0AB6, r25
    3ca6:	80 93 b5 0a 	sts	0x0AB5, r24
    3caa:	10 92 b8 0a 	sts	0x0AB8, r1
    3cae:	10 92 b9 0a 	sts	0x0AB9, r1
    3cb2:	10 92 ba 0a 	sts	0x0ABA, r1
    3cb6:	10 92 bb 0a 	sts	0x0ABB, r1
    3cba:	08 95       	ret

00003cbc <_ZN5Print5writeEPKhj>:
size_t Print::println(const Printable& x)
{
  size_t n = print(x);
  n += println();
  return n;
}
    3cbc:	cf 92       	push	r12
    3cbe:	df 92       	push	r13
    3cc0:	ef 92       	push	r14
    3cc2:	ff 92       	push	r15
    3cc4:	0f 93       	push	r16
    3cc6:	1f 93       	push	r17
    3cc8:	cf 93       	push	r28
    3cca:	df 93       	push	r29
    3ccc:	6c 01       	movw	r12, r24
    3cce:	41 15       	cp	r20, r1
    3cd0:	51 05       	cpc	r21, r1
    3cd2:	b1 f0       	breq	.+44     	; 0x3d00 <_ZN5Print5writeEPKhj+0x44>
    3cd4:	06 2f       	mov	r16, r22
    3cd6:	17 2f       	mov	r17, r23
    3cd8:	ea 01       	movw	r28, r20
    3cda:	e1 2c       	mov	r14, r1
    3cdc:	f1 2c       	mov	r15, r1
    3cde:	d8 01       	movw	r26, r16
    3ce0:	6d 91       	ld	r22, X+
    3ce2:	8d 01       	movw	r16, r26
    3ce4:	d6 01       	movw	r26, r12
    3ce6:	ed 91       	ld	r30, X+
    3ce8:	fc 91       	ld	r31, X
    3cea:	01 90       	ld	r0, Z+
    3cec:	f0 81       	ld	r31, Z
    3cee:	e0 2d       	mov	r30, r0
    3cf0:	c6 01       	movw	r24, r12
    3cf2:	19 95       	eicall
    3cf4:	e8 0e       	add	r14, r24
    3cf6:	f9 1e       	adc	r15, r25
    3cf8:	21 97       	sbiw	r28, 0x01	; 1
    3cfa:	20 97       	sbiw	r28, 0x00	; 0
    3cfc:	81 f7       	brne	.-32     	; 0x3cde <_ZN5Print5writeEPKhj+0x22>
    3cfe:	02 c0       	rjmp	.+4      	; 0x3d04 <_ZN5Print5writeEPKhj+0x48>
    3d00:	e1 2c       	mov	r14, r1
    3d02:	f1 2c       	mov	r15, r1
    3d04:	c7 01       	movw	r24, r14
    3d06:	df 91       	pop	r29
    3d08:	cf 91       	pop	r28
    3d0a:	1f 91       	pop	r17
    3d0c:	0f 91       	pop	r16
    3d0e:	ff 90       	pop	r15
    3d10:	ef 90       	pop	r14
    3d12:	df 90       	pop	r13
    3d14:	cf 90       	pop	r12
    3d16:	08 95       	ret

00003d18 <_ZN5Print5printEc>:
    3d18:	dc 01       	movw	r26, r24
    3d1a:	ed 91       	ld	r30, X+
    3d1c:	fc 91       	ld	r31, X
    3d1e:	01 90       	ld	r0, Z+
    3d20:	f0 81       	ld	r31, Z
    3d22:	e0 2d       	mov	r30, r0
    3d24:	19 95       	eicall
    3d26:	08 95       	ret

00003d28 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
    3d28:	6f 92       	push	r6
    3d2a:	7f 92       	push	r7
    3d2c:	8f 92       	push	r8
    3d2e:	9f 92       	push	r9
    3d30:	af 92       	push	r10
    3d32:	bf 92       	push	r11
    3d34:	cf 92       	push	r12
    3d36:	df 92       	push	r13
    3d38:	ef 92       	push	r14
    3d3a:	ff 92       	push	r15
    3d3c:	0f 93       	push	r16
    3d3e:	1f 93       	push	r17
    3d40:	cf 93       	push	r28
    3d42:	df 93       	push	r29
    3d44:	cd b7       	in	r28, 0x3d	; 61
    3d46:	de b7       	in	r29, 0x3e	; 62
    3d48:	a1 97       	sbiw	r28, 0x21	; 33
    3d4a:	0f b6       	in	r0, 0x3f	; 63
    3d4c:	f8 94       	cli
    3d4e:	de bf       	out	0x3e, r29	; 62
    3d50:	0f be       	out	0x3f, r0	; 63
    3d52:	cd bf       	out	0x3d, r28	; 61
    3d54:	6c 01       	movw	r12, r24
    3d56:	74 2e       	mov	r7, r20
    3d58:	35 2f       	mov	r19, r21
    3d5a:	86 2f       	mov	r24, r22
    3d5c:	97 2f       	mov	r25, r23
    3d5e:	62 2e       	mov	r6, r18
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    3d60:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    3d62:	21 e0       	ldi	r18, 0x01	; 1
    3d64:	26 15       	cp	r18, r6
    3d66:	20 f0       	brcs	.+8      	; 0x3d70 <_ZN5Print11printNumberEmh+0x48>
    3d68:	0f 2e       	mov	r0, r31
    3d6a:	fa e0       	ldi	r31, 0x0A	; 10
    3d6c:	6f 2e       	mov	r6, r31
    3d6e:	f0 2d       	mov	r31, r0
    3d70:	7e 01       	movw	r14, r28
    3d72:	a1 e2       	ldi	r26, 0x21	; 33
    3d74:	ea 0e       	add	r14, r26
    3d76:	f1 1c       	adc	r15, r1

  do {
    unsigned long m = n;
    n /= base;
    3d78:	86 2c       	mov	r8, r6
    3d7a:	91 2c       	mov	r9, r1
    3d7c:	a1 2c       	mov	r10, r1
    3d7e:	b1 2c       	mov	r11, r1
    3d80:	67 2d       	mov	r22, r7
    3d82:	73 2f       	mov	r23, r19
    3d84:	a5 01       	movw	r20, r10
    3d86:	94 01       	movw	r18, r8
    3d88:	74 d2       	rcall	.+1256   	; 0x4272 <__udivmodsi4>
    3d8a:	e2 2f       	mov	r30, r18
    3d8c:	73 2f       	mov	r23, r19
    3d8e:	02 2f       	mov	r16, r18
    3d90:	13 2f       	mov	r17, r19
    3d92:	24 2f       	mov	r18, r20
    3d94:	35 2f       	mov	r19, r21
    char c = m - base * n;
    3d96:	f7 2d       	mov	r31, r7
    3d98:	6e 9e       	mul	r6, r30
    3d9a:	f0 19       	sub	r31, r0
    3d9c:	11 24       	eor	r1, r1
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    3d9e:	b1 e0       	ldi	r27, 0x01	; 1
    3da0:	eb 1a       	sub	r14, r27
    3da2:	f1 08       	sbc	r15, r1
    3da4:	fa 30       	cpi	r31, 0x0A	; 10
    3da6:	10 f4       	brcc	.+4      	; 0x3dac <_ZN5Print11printNumberEmh+0x84>
    3da8:	f0 5d       	subi	r31, 0xD0	; 208
    3daa:	01 c0       	rjmp	.+2      	; 0x3dae <_ZN5Print11printNumberEmh+0x86>
    3dac:	f9 5c       	subi	r31, 0xC9	; 201
    3dae:	d7 01       	movw	r26, r14
    3db0:	fc 93       	st	X, r31
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    3db2:	01 2b       	or	r16, r17
    3db4:	02 2b       	or	r16, r18
    3db6:	03 2b       	or	r16, r19
    3db8:	29 f0       	breq	.+10     	; 0x3dc4 <_ZN5Print11printNumberEmh+0x9c>
    unsigned long m = n;
    n /= base;
    3dba:	7e 2e       	mov	r7, r30
    3dbc:	37 2f       	mov	r19, r23
    3dbe:	84 2f       	mov	r24, r20
    3dc0:	95 2f       	mov	r25, r21
    3dc2:	de cf       	rjmp	.-68     	; 0x3d80 <_ZN5Print11printNumberEmh+0x58>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    3dc4:	e1 14       	cp	r14, r1
    3dc6:	f1 04       	cpc	r15, r1
    3dc8:	91 f0       	breq	.+36     	; 0x3dee <_ZN5Print11printNumberEmh+0xc6>
      return write((const uint8_t *)str, strlen(str));
    3dca:	f7 01       	movw	r30, r14
    3dcc:	01 90       	ld	r0, Z+
    3dce:	00 20       	and	r0, r0
    3dd0:	e9 f7       	brne	.-6      	; 0x3dcc <_ZN5Print11printNumberEmh+0xa4>
    3dd2:	31 97       	sbiw	r30, 0x01	; 1
    3dd4:	af 01       	movw	r20, r30
    3dd6:	4e 19       	sub	r20, r14
    3dd8:	5f 09       	sbc	r21, r15
    3dda:	d6 01       	movw	r26, r12
    3ddc:	ed 91       	ld	r30, X+
    3dde:	fc 91       	ld	r31, X
    3de0:	02 80       	ldd	r0, Z+2	; 0x02
    3de2:	f3 81       	ldd	r31, Z+3	; 0x03
    3de4:	e0 2d       	mov	r30, r0
    3de6:	b7 01       	movw	r22, r14
    3de8:	c6 01       	movw	r24, r12
    3dea:	19 95       	eicall
    3dec:	02 c0       	rjmp	.+4      	; 0x3df2 <_ZN5Print11printNumberEmh+0xca>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    3dee:	80 e0       	ldi	r24, 0x00	; 0
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
}
    3df2:	a1 96       	adiw	r28, 0x21	; 33
    3df4:	0f b6       	in	r0, 0x3f	; 63
    3df6:	f8 94       	cli
    3df8:	de bf       	out	0x3e, r29	; 62
    3dfa:	0f be       	out	0x3f, r0	; 63
    3dfc:	cd bf       	out	0x3d, r28	; 61
    3dfe:	df 91       	pop	r29
    3e00:	cf 91       	pop	r28
    3e02:	1f 91       	pop	r17
    3e04:	0f 91       	pop	r16
    3e06:	ff 90       	pop	r15
    3e08:	ef 90       	pop	r14
    3e0a:	df 90       	pop	r13
    3e0c:	cf 90       	pop	r12
    3e0e:	bf 90       	pop	r11
    3e10:	af 90       	pop	r10
    3e12:	9f 90       	pop	r9
    3e14:	8f 90       	pop	r8
    3e16:	7f 90       	pop	r7
    3e18:	6f 90       	pop	r6
    3e1a:	08 95       	ret

00003e1c <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    3e1c:	cf 92       	push	r12
    3e1e:	df 92       	push	r13
    3e20:	ef 92       	push	r14
    3e22:	ff 92       	push	r15
    3e24:	0f 93       	push	r16
    3e26:	1f 93       	push	r17
    3e28:	cf 93       	push	r28
    3e2a:	df 93       	push	r29
    3e2c:	ec 01       	movw	r28, r24
    3e2e:	6a 01       	movw	r12, r20
    3e30:	7b 01       	movw	r14, r22
  if (base == 0) {
    3e32:	21 15       	cp	r18, r1
    3e34:	31 05       	cpc	r19, r1
    3e36:	41 f4       	brne	.+16     	; 0x3e48 <_ZN5Print5printEli+0x2c>
    return write(n);
    3e38:	e8 81       	ld	r30, Y
    3e3a:	f9 81       	ldd	r31, Y+1	; 0x01
    3e3c:	01 90       	ld	r0, Z+
    3e3e:	f0 81       	ld	r31, Z
    3e40:	e0 2d       	mov	r30, r0
    3e42:	64 2f       	mov	r22, r20
    3e44:	19 95       	eicall
    3e46:	19 c0       	rjmp	.+50     	; 0x3e7a <_ZN5Print5printEli+0x5e>
  } else if (base == 10) {
    3e48:	2a 30       	cpi	r18, 0x0A	; 10
    3e4a:	31 05       	cpc	r19, r1
    3e4c:	a9 f4       	brne	.+42     	; 0x3e78 <_ZN5Print5printEli+0x5c>
    if (n < 0) {
    3e4e:	77 23       	and	r23, r23
    3e50:	84 f4       	brge	.+32     	; 0x3e72 <_ZN5Print5printEli+0x56>
      int t = print('-');
    3e52:	6d e2       	ldi	r22, 0x2D	; 45
    3e54:	61 df       	rcall	.-318    	; 0x3d18 <_ZN5Print5printEc>
    3e56:	8c 01       	movw	r16, r24
      n = -n;
    3e58:	44 27       	eor	r20, r20
    3e5a:	55 27       	eor	r21, r21
    3e5c:	ba 01       	movw	r22, r20
    3e5e:	4c 19       	sub	r20, r12
    3e60:	5d 09       	sbc	r21, r13
    3e62:	6e 09       	sbc	r22, r14
    3e64:	7f 09       	sbc	r23, r15
      return printNumber(n, 10) + t;
    3e66:	2a e0       	ldi	r18, 0x0A	; 10
    3e68:	ce 01       	movw	r24, r28
    3e6a:	5e df       	rcall	.-324    	; 0x3d28 <_ZN5Print11printNumberEmh>
    3e6c:	80 0f       	add	r24, r16
    3e6e:	91 1f       	adc	r25, r17
    3e70:	04 c0       	rjmp	.+8      	; 0x3e7a <_ZN5Print5printEli+0x5e>
    }
    return printNumber(n, 10);
    3e72:	2a e0       	ldi	r18, 0x0A	; 10
    3e74:	59 df       	rcall	.-334    	; 0x3d28 <_ZN5Print11printNumberEmh>
    3e76:	01 c0       	rjmp	.+2      	; 0x3e7a <_ZN5Print5printEli+0x5e>
  } else {
    return printNumber(n, base);
    3e78:	57 df       	rcall	.-338    	; 0x3d28 <_ZN5Print11printNumberEmh>
  }
}
    3e7a:	df 91       	pop	r29
    3e7c:	cf 91       	pop	r28
    3e7e:	1f 91       	pop	r17
    3e80:	0f 91       	pop	r16
    3e82:	ff 90       	pop	r15
    3e84:	ef 90       	pop	r14
    3e86:	df 90       	pop	r13
    3e88:	cf 90       	pop	r12
    3e8a:	08 95       	ret

00003e8c <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    3e8c:	9a 01       	movw	r18, r20
  return print((long) n, base);
    3e8e:	ab 01       	movw	r20, r22
    3e90:	66 27       	eor	r22, r22
    3e92:	57 fd       	sbrc	r21, 7
    3e94:	60 95       	com	r22
    3e96:	76 2f       	mov	r23, r22
    3e98:	c1 cf       	rjmp	.-126    	; 0x3e1c <_ZN5Print5printEli>
}
    3e9a:	08 95       	ret

00003e9c <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    3e9c:	1f 92       	push	r1
    3e9e:	0f 92       	push	r0
    3ea0:	0f b6       	in	r0, 0x3f	; 63
    3ea2:	0f 92       	push	r0
    3ea4:	11 24       	eor	r1, r1
    3ea6:	2f 93       	push	r18
    3ea8:	3f 93       	push	r19
    3eaa:	8f 93       	push	r24
    3eac:	9f 93       	push	r25
    3eae:	af 93       	push	r26
    3eb0:	bf 93       	push	r27
    3eb2:	80 91 3d 0b 	lds	r24, 0x0B3D
    3eb6:	90 91 3e 0b 	lds	r25, 0x0B3E
    3eba:	a0 91 3f 0b 	lds	r26, 0x0B3F
    3ebe:	b0 91 40 0b 	lds	r27, 0x0B40
    3ec2:	30 91 3c 0b 	lds	r19, 0x0B3C
    3ec6:	23 e0       	ldi	r18, 0x03	; 3
    3ec8:	23 0f       	add	r18, r19
    3eca:	2d 37       	cpi	r18, 0x7D	; 125
    3ecc:	20 f4       	brcc	.+8      	; 0x3ed6 <__vector_23+0x3a>
    3ece:	01 96       	adiw	r24, 0x01	; 1
    3ed0:	a1 1d       	adc	r26, r1
    3ed2:	b1 1d       	adc	r27, r1
    3ed4:	05 c0       	rjmp	.+10     	; 0x3ee0 <__vector_23+0x44>
    3ed6:	26 e8       	ldi	r18, 0x86	; 134
    3ed8:	23 0f       	add	r18, r19
    3eda:	02 96       	adiw	r24, 0x02	; 2
    3edc:	a1 1d       	adc	r26, r1
    3ede:	b1 1d       	adc	r27, r1
    3ee0:	20 93 3c 0b 	sts	0x0B3C, r18
    3ee4:	80 93 3d 0b 	sts	0x0B3D, r24
    3ee8:	90 93 3e 0b 	sts	0x0B3E, r25
    3eec:	a0 93 3f 0b 	sts	0x0B3F, r26
    3ef0:	b0 93 40 0b 	sts	0x0B40, r27
    3ef4:	80 91 41 0b 	lds	r24, 0x0B41
    3ef8:	90 91 42 0b 	lds	r25, 0x0B42
    3efc:	a0 91 43 0b 	lds	r26, 0x0B43
    3f00:	b0 91 44 0b 	lds	r27, 0x0B44
    3f04:	01 96       	adiw	r24, 0x01	; 1
    3f06:	a1 1d       	adc	r26, r1
    3f08:	b1 1d       	adc	r27, r1
    3f0a:	80 93 41 0b 	sts	0x0B41, r24
    3f0e:	90 93 42 0b 	sts	0x0B42, r25
    3f12:	a0 93 43 0b 	sts	0x0B43, r26
    3f16:	b0 93 44 0b 	sts	0x0B44, r27
    3f1a:	bf 91       	pop	r27
    3f1c:	af 91       	pop	r26
    3f1e:	9f 91       	pop	r25
    3f20:	8f 91       	pop	r24
    3f22:	3f 91       	pop	r19
    3f24:	2f 91       	pop	r18
    3f26:	0f 90       	pop	r0
    3f28:	0f be       	out	0x3f, r0	; 63
    3f2a:	0f 90       	pop	r0
    3f2c:	1f 90       	pop	r1
    3f2e:	18 95       	reti

00003f30 <millis>:
    3f30:	2f b7       	in	r18, 0x3f	; 63
    3f32:	f8 94       	cli
    3f34:	60 91 3d 0b 	lds	r22, 0x0B3D
    3f38:	70 91 3e 0b 	lds	r23, 0x0B3E
    3f3c:	80 91 3f 0b 	lds	r24, 0x0B3F
    3f40:	90 91 40 0b 	lds	r25, 0x0B40
    3f44:	2f bf       	out	0x3f, r18	; 63
    3f46:	08 95       	ret

00003f48 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    3f48:	82 30       	cpi	r24, 0x02	; 2
    3f4a:	91 05       	cpc	r25, r1
    3f4c:	38 f0       	brcs	.+14     	; 0x3f5c <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    3f4e:	88 0f       	add	r24, r24
    3f50:	99 1f       	adc	r25, r25
    3f52:	88 0f       	add	r24, r24
    3f54:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    3f56:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    3f58:	01 97       	sbiw	r24, 0x01	; 1
    3f5a:	f1 f7       	brne	.-4      	; 0x3f58 <delayMicroseconds+0x10>
    3f5c:	08 95       	ret

00003f5e <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    3f5e:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    3f60:	84 b5       	in	r24, 0x24	; 36
    3f62:	82 60       	ori	r24, 0x02	; 2
    3f64:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    3f66:	84 b5       	in	r24, 0x24	; 36
    3f68:	81 60       	ori	r24, 0x01	; 1
    3f6a:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    3f6c:	85 b5       	in	r24, 0x25	; 37
    3f6e:	82 60       	ori	r24, 0x02	; 2
    3f70:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    3f72:	85 b5       	in	r24, 0x25	; 37
    3f74:	81 60       	ori	r24, 0x01	; 1
    3f76:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    3f78:	ee e6       	ldi	r30, 0x6E	; 110
    3f7a:	f0 e0       	ldi	r31, 0x00	; 0
    3f7c:	80 81       	ld	r24, Z
    3f7e:	81 60       	ori	r24, 0x01	; 1
    3f80:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    3f82:	e1 e8       	ldi	r30, 0x81	; 129
    3f84:	f0 e0       	ldi	r31, 0x00	; 0
    3f86:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    3f88:	80 81       	ld	r24, Z
    3f8a:	82 60       	ori	r24, 0x02	; 2
    3f8c:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    3f8e:	80 81       	ld	r24, Z
    3f90:	81 60       	ori	r24, 0x01	; 1
    3f92:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    3f94:	e0 e8       	ldi	r30, 0x80	; 128
    3f96:	f0 e0       	ldi	r31, 0x00	; 0
    3f98:	80 81       	ld	r24, Z
    3f9a:	81 60       	ori	r24, 0x01	; 1
    3f9c:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    3f9e:	e1 eb       	ldi	r30, 0xB1	; 177
    3fa0:	f0 e0       	ldi	r31, 0x00	; 0
    3fa2:	80 81       	ld	r24, Z
    3fa4:	84 60       	ori	r24, 0x04	; 4
    3fa6:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    3fa8:	e0 eb       	ldi	r30, 0xB0	; 176
    3faa:	f0 e0       	ldi	r31, 0x00	; 0
    3fac:	80 81       	ld	r24, Z
    3fae:	81 60       	ori	r24, 0x01	; 1
    3fb0:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    3fb2:	e1 e9       	ldi	r30, 0x91	; 145
    3fb4:	f0 e0       	ldi	r31, 0x00	; 0
    3fb6:	80 81       	ld	r24, Z
    3fb8:	82 60       	ori	r24, 0x02	; 2
    3fba:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    3fbc:	80 81       	ld	r24, Z
    3fbe:	81 60       	ori	r24, 0x01	; 1
    3fc0:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    3fc2:	e0 e9       	ldi	r30, 0x90	; 144
    3fc4:	f0 e0       	ldi	r31, 0x00	; 0
    3fc6:	80 81       	ld	r24, Z
    3fc8:	81 60       	ori	r24, 0x01	; 1
    3fca:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    3fcc:	e1 ea       	ldi	r30, 0xA1	; 161
    3fce:	f0 e0       	ldi	r31, 0x00	; 0
    3fd0:	80 81       	ld	r24, Z
    3fd2:	82 60       	ori	r24, 0x02	; 2
    3fd4:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    3fd6:	80 81       	ld	r24, Z
    3fd8:	81 60       	ori	r24, 0x01	; 1
    3fda:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    3fdc:	e0 ea       	ldi	r30, 0xA0	; 160
    3fde:	f0 e0       	ldi	r31, 0x00	; 0
    3fe0:	80 81       	ld	r24, Z
    3fe2:	81 60       	ori	r24, 0x01	; 1
    3fe4:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    3fe6:	e1 e2       	ldi	r30, 0x21	; 33
    3fe8:	f1 e0       	ldi	r31, 0x01	; 1
    3fea:	80 81       	ld	r24, Z
    3fec:	82 60       	ori	r24, 0x02	; 2
    3fee:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    3ff0:	80 81       	ld	r24, Z
    3ff2:	81 60       	ori	r24, 0x01	; 1
    3ff4:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    3ff6:	e0 e2       	ldi	r30, 0x20	; 32
    3ff8:	f1 e0       	ldi	r31, 0x01	; 1
    3ffa:	80 81       	ld	r24, Z
    3ffc:	81 60       	ori	r24, 0x01	; 1
    3ffe:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    4000:	ea e7       	ldi	r30, 0x7A	; 122
    4002:	f0 e0       	ldi	r31, 0x00	; 0
    4004:	80 81       	ld	r24, Z
    4006:	84 60       	ori	r24, 0x04	; 4
    4008:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    400a:	80 81       	ld	r24, Z
    400c:	82 60       	ori	r24, 0x02	; 2
    400e:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    4010:	80 81       	ld	r24, Z
    4012:	81 60       	ori	r24, 0x01	; 1
    4014:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    4016:	80 81       	ld	r24, Z
    4018:	80 68       	ori	r24, 0x80	; 128
    401a:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    401c:	10 92 c1 00 	sts	0x00C1, r1
    4020:	08 95       	ret

00004022 <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
    4022:	80 93 12 02 	sts	0x0212, r24
    4026:	08 95       	ret

00004028 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    4028:	90 e0       	ldi	r25, 0x00	; 0
    402a:	fc 01       	movw	r30, r24
    402c:	31 97       	sbiw	r30, 0x01	; 1
    402e:	e2 31       	cpi	r30, 0x12	; 18
    4030:	f1 05       	cpc	r31, r1
    4032:	08 f0       	brcs	.+2      	; 0x4036 <turnOffPWM+0xe>
    4034:	5e c0       	rjmp	.+188    	; 0x40f2 <turnOffPWM+0xca>
    4036:	ed 56       	subi	r30, 0x6D	; 109
    4038:	fe 4f       	sbci	r31, 0xFE	; 254
    403a:	3d c1       	rjmp	.+634    	; 0x42b6 <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    403c:	e0 e8       	ldi	r30, 0x80	; 128
    403e:	f0 e0       	ldi	r31, 0x00	; 0
    4040:	80 81       	ld	r24, Z
    4042:	8f 77       	andi	r24, 0x7F	; 127
    4044:	80 83       	st	Z, r24
    4046:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    4048:	e0 e8       	ldi	r30, 0x80	; 128
    404a:	f0 e0       	ldi	r31, 0x00	; 0
    404c:	80 81       	ld	r24, Z
    404e:	8f 7d       	andi	r24, 0xDF	; 223
    4050:	80 83       	st	Z, r24
    4052:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    4054:	e0 e8       	ldi	r30, 0x80	; 128
    4056:	f0 e0       	ldi	r31, 0x00	; 0
    4058:	80 81       	ld	r24, Z
    405a:	87 7f       	andi	r24, 0xF7	; 247
    405c:	80 83       	st	Z, r24
    405e:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    4060:	84 b5       	in	r24, 0x24	; 36
    4062:	8f 77       	andi	r24, 0x7F	; 127
    4064:	84 bd       	out	0x24, r24	; 36
    4066:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    4068:	84 b5       	in	r24, 0x24	; 36
    406a:	8f 7d       	andi	r24, 0xDF	; 223
    406c:	84 bd       	out	0x24, r24	; 36
    406e:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    4070:	e0 eb       	ldi	r30, 0xB0	; 176
    4072:	f0 e0       	ldi	r31, 0x00	; 0
    4074:	80 81       	ld	r24, Z
    4076:	8f 77       	andi	r24, 0x7F	; 127
    4078:	80 83       	st	Z, r24
    407a:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    407c:	e0 eb       	ldi	r30, 0xB0	; 176
    407e:	f0 e0       	ldi	r31, 0x00	; 0
    4080:	80 81       	ld	r24, Z
    4082:	8f 7d       	andi	r24, 0xDF	; 223
    4084:	80 83       	st	Z, r24
    4086:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    4088:	e0 e9       	ldi	r30, 0x90	; 144
    408a:	f0 e0       	ldi	r31, 0x00	; 0
    408c:	80 81       	ld	r24, Z
    408e:	8f 77       	andi	r24, 0x7F	; 127
    4090:	80 83       	st	Z, r24
    4092:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    4094:	e0 e9       	ldi	r30, 0x90	; 144
    4096:	f0 e0       	ldi	r31, 0x00	; 0
    4098:	80 81       	ld	r24, Z
    409a:	8f 7d       	andi	r24, 0xDF	; 223
    409c:	80 83       	st	Z, r24
    409e:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    40a0:	e0 e9       	ldi	r30, 0x90	; 144
    40a2:	f0 e0       	ldi	r31, 0x00	; 0
    40a4:	80 81       	ld	r24, Z
    40a6:	87 7f       	andi	r24, 0xF7	; 247
    40a8:	80 83       	st	Z, r24
    40aa:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    40ac:	e0 ea       	ldi	r30, 0xA0	; 160
    40ae:	f0 e0       	ldi	r31, 0x00	; 0
    40b0:	80 81       	ld	r24, Z
    40b2:	8f 77       	andi	r24, 0x7F	; 127
    40b4:	80 83       	st	Z, r24
    40b6:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    40b8:	e0 ea       	ldi	r30, 0xA0	; 160
    40ba:	f0 e0       	ldi	r31, 0x00	; 0
    40bc:	80 81       	ld	r24, Z
    40be:	8f 7d       	andi	r24, 0xDF	; 223
    40c0:	80 83       	st	Z, r24
    40c2:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    40c4:	e0 ea       	ldi	r30, 0xA0	; 160
    40c6:	f0 e0       	ldi	r31, 0x00	; 0
    40c8:	80 81       	ld	r24, Z
    40ca:	87 7f       	andi	r24, 0xF7	; 247
    40cc:	80 83       	st	Z, r24
    40ce:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    40d0:	e0 e2       	ldi	r30, 0x20	; 32
    40d2:	f1 e0       	ldi	r31, 0x01	; 1
    40d4:	80 81       	ld	r24, Z
    40d6:	8f 77       	andi	r24, 0x7F	; 127
    40d8:	80 83       	st	Z, r24
    40da:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    40dc:	e0 e2       	ldi	r30, 0x20	; 32
    40de:	f1 e0       	ldi	r31, 0x01	; 1
    40e0:	80 81       	ld	r24, Z
    40e2:	8f 7d       	andi	r24, 0xDF	; 223
    40e4:	80 83       	st	Z, r24
    40e6:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    40e8:	e0 e2       	ldi	r30, 0x20	; 32
    40ea:	f1 e0       	ldi	r31, 0x01	; 1
    40ec:	80 81       	ld	r24, Z
    40ee:	87 7f       	andi	r24, 0xF7	; 247
    40f0:	80 83       	st	Z, r24
    40f2:	08 95       	ret

000040f4 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    40f4:	cf 93       	push	r28
    40f6:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    40f8:	90 e0       	ldi	r25, 0x00	; 0
    40fa:	fc 01       	movw	r30, r24
    40fc:	e0 57       	subi	r30, 0x70	; 112
    40fe:	fc 4f       	sbci	r31, 0xFC	; 252
    4100:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    4102:	fc 01       	movw	r30, r24
    4104:	ea 52       	subi	r30, 0x2A	; 42
    4106:	fc 4f       	sbci	r31, 0xFC	; 252
    4108:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    410a:	88 23       	and	r24, r24
    410c:	71 f1       	breq	.+92     	; 0x416a <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    410e:	90 e0       	ldi	r25, 0x00	; 0
    4110:	88 0f       	add	r24, r24
    4112:	99 1f       	adc	r25, r25
    4114:	fc 01       	movw	r30, r24
    4116:	e0 5b       	subi	r30, 0xB0	; 176
    4118:	fb 4f       	sbci	r31, 0xFB	; 251
    411a:	a5 91       	lpm	r26, Z+
    411c:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    411e:	8a 5c       	subi	r24, 0xCA	; 202
    4120:	9b 4f       	sbci	r25, 0xFB	; 251
    4122:	fc 01       	movw	r30, r24
    4124:	c5 91       	lpm	r28, Z+
    4126:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    4128:	61 11       	cpse	r22, r1
    412a:	0b c0       	rjmp	.+22     	; 0x4142 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    412c:	8f b7       	in	r24, 0x3f	; 63
                cli();
    412e:	f8 94       	cli
		*reg &= ~bit;
    4130:	9c 91       	ld	r25, X
    4132:	20 95       	com	r18
    4134:	92 23       	and	r25, r18
    4136:	9c 93       	st	X, r25
		*out &= ~bit;
    4138:	e8 81       	ld	r30, Y
    413a:	2e 23       	and	r18, r30
    413c:	28 83       	st	Y, r18
		SREG = oldSREG;
    413e:	8f bf       	out	0x3f, r24	; 63
    4140:	14 c0       	rjmp	.+40     	; 0x416a <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    4142:	62 30       	cpi	r22, 0x02	; 2
    4144:	61 f4       	brne	.+24     	; 0x415e <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    4146:	8f b7       	in	r24, 0x3f	; 63
                cli();
    4148:	f8 94       	cli
		*reg &= ~bit;
    414a:	3c 91       	ld	r19, X
    414c:	92 2f       	mov	r25, r18
    414e:	90 95       	com	r25
    4150:	93 23       	and	r25, r19
    4152:	9c 93       	st	X, r25
		*out |= bit;
    4154:	e8 81       	ld	r30, Y
    4156:	2e 2b       	or	r18, r30
    4158:	28 83       	st	Y, r18
		SREG = oldSREG;
    415a:	8f bf       	out	0x3f, r24	; 63
    415c:	06 c0       	rjmp	.+12     	; 0x416a <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    415e:	8f b7       	in	r24, 0x3f	; 63
                cli();
    4160:	f8 94       	cli
		*reg |= bit;
    4162:	ec 91       	ld	r30, X
    4164:	2e 2b       	or	r18, r30
    4166:	2c 93       	st	X, r18
		SREG = oldSREG;
    4168:	8f bf       	out	0x3f, r24	; 63
	}
}
    416a:	df 91       	pop	r29
    416c:	cf 91       	pop	r28
    416e:	08 95       	ret

00004170 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    4170:	1f 93       	push	r17
    4172:	cf 93       	push	r28
    4174:	df 93       	push	r29
    4176:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    4178:	28 2f       	mov	r18, r24
    417a:	30 e0       	ldi	r19, 0x00	; 0
    417c:	f9 01       	movw	r30, r18
    417e:	e6 5b       	subi	r30, 0xB6	; 182
    4180:	fc 4f       	sbci	r31, 0xFC	; 252
    4182:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    4184:	f9 01       	movw	r30, r18
    4186:	e0 57       	subi	r30, 0x70	; 112
    4188:	fc 4f       	sbci	r31, 0xFC	; 252
    418a:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    418c:	f9 01       	movw	r30, r18
    418e:	ea 52       	subi	r30, 0x2A	; 42
    4190:	fc 4f       	sbci	r31, 0xFC	; 252
    4192:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    4194:	dd 23       	and	r29, r29
    4196:	c1 f0       	breq	.+48     	; 0x41c8 <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    4198:	81 11       	cpse	r24, r1
    419a:	46 df       	rcall	.-372    	; 0x4028 <turnOffPWM>

	out = portOutputRegister(port);
    419c:	2d 2f       	mov	r18, r29
    419e:	30 e0       	ldi	r19, 0x00	; 0
    41a0:	f9 01       	movw	r30, r18
    41a2:	ee 0f       	add	r30, r30
    41a4:	ff 1f       	adc	r31, r31
    41a6:	ea 5c       	subi	r30, 0xCA	; 202
    41a8:	fb 4f       	sbci	r31, 0xFB	; 251
    41aa:	a5 91       	lpm	r26, Z+
    41ac:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    41ae:	8f b7       	in	r24, 0x3f	; 63
	cli();
    41b0:	f8 94       	cli

	if (val == LOW) {
    41b2:	c1 11       	cpse	r28, r1
    41b4:	05 c0       	rjmp	.+10     	; 0x41c0 <digitalWrite+0x50>
		*out &= ~bit;
    41b6:	ec 91       	ld	r30, X
    41b8:	10 95       	com	r17
    41ba:	1e 23       	and	r17, r30
    41bc:	1c 93       	st	X, r17
    41be:	03 c0       	rjmp	.+6      	; 0x41c6 <digitalWrite+0x56>
	} else {
		*out |= bit;
    41c0:	ec 91       	ld	r30, X
    41c2:	1e 2b       	or	r17, r30
    41c4:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    41c6:	8f bf       	out	0x3f, r24	; 63
}
    41c8:	df 91       	pop	r29
    41ca:	cf 91       	pop	r28
    41cc:	1f 91       	pop	r17
    41ce:	08 95       	ret

000041d0 <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    41d0:	0f 93       	push	r16
    41d2:	1f 93       	push	r17
    41d4:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    41d6:	90 e0       	ldi	r25, 0x00	; 0
    41d8:	fc 01       	movw	r30, r24
    41da:	e0 57       	subi	r30, 0x70	; 112
    41dc:	fc 4f       	sbci	r31, 0xFC	; 252
    41de:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    41e0:	fc 01       	movw	r30, r24
    41e2:	ea 52       	subi	r30, 0x2A	; 42
    41e4:	fc 4f       	sbci	r31, 0xFC	; 252
    41e6:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    41e8:	71 11       	cpse	r23, r1
    41ea:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    41ec:	f0 e0       	ldi	r31, 0x00	; 0
    41ee:	ee 0f       	add	r30, r30
    41f0:	ff 1f       	adc	r31, r31
    41f2:	e4 5e       	subi	r30, 0xE4	; 228
    41f4:	fb 4f       	sbci	r31, 0xFB	; 251
    41f6:	85 91       	lpm	r24, Z+
    41f8:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    41fa:	89 01       	movw	r16, r18
    41fc:	9a 01       	movw	r18, r20
    41fe:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    4200:	47 2f       	mov	r20, r23
    4202:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    4206:	61 15       	cp	r22, r1
    4208:	71 05       	cpc	r23, r1
    420a:	81 05       	cpc	r24, r1
    420c:	91 05       	cpc	r25, r1
    420e:	49 f0       	breq	.+18     	; 0x4222 <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    4210:	dc 01       	movw	r26, r24
    4212:	cb 01       	movw	r24, r22
    4214:	01 96       	adiw	r24, 0x01	; 1
    4216:	a1 1d       	adc	r26, r1
    4218:	b1 1d       	adc	r27, r1
    421a:	bc 01       	movw	r22, r24
    421c:	cd 01       	movw	r24, r26
    421e:	9f 70       	andi	r25, 0x0F	; 15
    4220:	03 c0       	rjmp	.+6      	; 0x4228 <pulseIn+0x58>
	else
		return 0;
    4222:	60 e0       	ldi	r22, 0x00	; 0
    4224:	70 e0       	ldi	r23, 0x00	; 0
    4226:	cb 01       	movw	r24, r22
}
    4228:	1f 91       	pop	r17
    422a:	0f 91       	pop	r16
    422c:	08 95       	ret

0000422e <__mulsi3>:
    422e:	db 01       	movw	r26, r22
    4230:	8f 93       	push	r24
    4232:	9f 93       	push	r25
    4234:	46 d0       	rcall	.+140    	; 0x42c2 <__muluhisi3>
    4236:	bf 91       	pop	r27
    4238:	af 91       	pop	r26
    423a:	a2 9f       	mul	r26, r18
    423c:	80 0d       	add	r24, r0
    423e:	91 1d       	adc	r25, r1
    4240:	a3 9f       	mul	r26, r19
    4242:	90 0d       	add	r25, r0
    4244:	b2 9f       	mul	r27, r18
    4246:	90 0d       	add	r25, r0
    4248:	11 24       	eor	r1, r1
    424a:	08 95       	ret

0000424c <__divmodhi4>:
    424c:	97 fb       	bst	r25, 7
    424e:	07 2e       	mov	r0, r23
    4250:	16 f4       	brtc	.+4      	; 0x4256 <__divmodhi4+0xa>
    4252:	00 94       	com	r0
    4254:	06 d0       	rcall	.+12     	; 0x4262 <__divmodhi4_neg1>
    4256:	77 fd       	sbrc	r23, 7
    4258:	08 d0       	rcall	.+16     	; 0x426a <__divmodhi4_neg2>
    425a:	41 d0       	rcall	.+130    	; 0x42de <__udivmodhi4>
    425c:	07 fc       	sbrc	r0, 7
    425e:	05 d0       	rcall	.+10     	; 0x426a <__divmodhi4_neg2>
    4260:	3e f4       	brtc	.+14     	; 0x4270 <__divmodhi4_exit>

00004262 <__divmodhi4_neg1>:
    4262:	90 95       	com	r25
    4264:	81 95       	neg	r24
    4266:	9f 4f       	sbci	r25, 0xFF	; 255
    4268:	08 95       	ret

0000426a <__divmodhi4_neg2>:
    426a:	70 95       	com	r23
    426c:	61 95       	neg	r22
    426e:	7f 4f       	sbci	r23, 0xFF	; 255

00004270 <__divmodhi4_exit>:
    4270:	08 95       	ret

00004272 <__udivmodsi4>:
    4272:	a1 e2       	ldi	r26, 0x21	; 33
    4274:	1a 2e       	mov	r1, r26
    4276:	aa 1b       	sub	r26, r26
    4278:	bb 1b       	sub	r27, r27
    427a:	fd 01       	movw	r30, r26
    427c:	0d c0       	rjmp	.+26     	; 0x4298 <__udivmodsi4_ep>

0000427e <__udivmodsi4_loop>:
    427e:	aa 1f       	adc	r26, r26
    4280:	bb 1f       	adc	r27, r27
    4282:	ee 1f       	adc	r30, r30
    4284:	ff 1f       	adc	r31, r31
    4286:	a2 17       	cp	r26, r18
    4288:	b3 07       	cpc	r27, r19
    428a:	e4 07       	cpc	r30, r20
    428c:	f5 07       	cpc	r31, r21
    428e:	20 f0       	brcs	.+8      	; 0x4298 <__udivmodsi4_ep>
    4290:	a2 1b       	sub	r26, r18
    4292:	b3 0b       	sbc	r27, r19
    4294:	e4 0b       	sbc	r30, r20
    4296:	f5 0b       	sbc	r31, r21

00004298 <__udivmodsi4_ep>:
    4298:	66 1f       	adc	r22, r22
    429a:	77 1f       	adc	r23, r23
    429c:	88 1f       	adc	r24, r24
    429e:	99 1f       	adc	r25, r25
    42a0:	1a 94       	dec	r1
    42a2:	69 f7       	brne	.-38     	; 0x427e <__udivmodsi4_loop>
    42a4:	60 95       	com	r22
    42a6:	70 95       	com	r23
    42a8:	80 95       	com	r24
    42aa:	90 95       	com	r25
    42ac:	9b 01       	movw	r18, r22
    42ae:	ac 01       	movw	r20, r24
    42b0:	bd 01       	movw	r22, r26
    42b2:	cf 01       	movw	r24, r30
    42b4:	08 95       	ret

000042b6 <__tablejump2__>:
    42b6:	ee 0f       	add	r30, r30
    42b8:	ff 1f       	adc	r31, r31

000042ba <__tablejump__>:
    42ba:	05 90       	lpm	r0, Z+
    42bc:	f4 91       	lpm	r31, Z
    42be:	e0 2d       	mov	r30, r0
    42c0:	19 94       	eijmp

000042c2 <__muluhisi3>:
    42c2:	21 d0       	rcall	.+66     	; 0x4306 <__umulhisi3>
    42c4:	a5 9f       	mul	r26, r21
    42c6:	90 0d       	add	r25, r0
    42c8:	b4 9f       	mul	r27, r20
    42ca:	90 0d       	add	r25, r0
    42cc:	a4 9f       	mul	r26, r20
    42ce:	80 0d       	add	r24, r0
    42d0:	91 1d       	adc	r25, r1
    42d2:	11 24       	eor	r1, r1
    42d4:	08 95       	ret

000042d6 <__tablejump_elpm__>:
    42d6:	07 90       	elpm	r0, Z+
    42d8:	f6 91       	elpm	r31, Z
    42da:	e0 2d       	mov	r30, r0
    42dc:	19 94       	eijmp

000042de <__udivmodhi4>:
    42de:	aa 1b       	sub	r26, r26
    42e0:	bb 1b       	sub	r27, r27
    42e2:	51 e1       	ldi	r21, 0x11	; 17
    42e4:	07 c0       	rjmp	.+14     	; 0x42f4 <__udivmodhi4_ep>

000042e6 <__udivmodhi4_loop>:
    42e6:	aa 1f       	adc	r26, r26
    42e8:	bb 1f       	adc	r27, r27
    42ea:	a6 17       	cp	r26, r22
    42ec:	b7 07       	cpc	r27, r23
    42ee:	10 f0       	brcs	.+4      	; 0x42f4 <__udivmodhi4_ep>
    42f0:	a6 1b       	sub	r26, r22
    42f2:	b7 0b       	sbc	r27, r23

000042f4 <__udivmodhi4_ep>:
    42f4:	88 1f       	adc	r24, r24
    42f6:	99 1f       	adc	r25, r25
    42f8:	5a 95       	dec	r21
    42fa:	a9 f7       	brne	.-22     	; 0x42e6 <__udivmodhi4_loop>
    42fc:	80 95       	com	r24
    42fe:	90 95       	com	r25
    4300:	bc 01       	movw	r22, r24
    4302:	cd 01       	movw	r24, r26
    4304:	08 95       	ret

00004306 <__umulhisi3>:
    4306:	a2 9f       	mul	r26, r18
    4308:	b0 01       	movw	r22, r0
    430a:	b3 9f       	mul	r27, r19
    430c:	c0 01       	movw	r24, r0
    430e:	a3 9f       	mul	r26, r19
    4310:	70 0d       	add	r23, r0
    4312:	81 1d       	adc	r24, r1
    4314:	11 24       	eor	r1, r1
    4316:	91 1d       	adc	r25, r1
    4318:	b2 9f       	mul	r27, r18
    431a:	70 0d       	add	r23, r0
    431c:	81 1d       	adc	r24, r1
    431e:	11 24       	eor	r1, r1
    4320:	91 1d       	adc	r25, r1
    4322:	08 95       	ret

00004324 <_exit>:
    4324:	f8 94       	cli

00004326 <__stop_program>:
    4326:	ff cf       	rjmp	.-2      	; 0x4326 <__stop_program>
