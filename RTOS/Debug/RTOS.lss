
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009e  00800200  0000370e  000037a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000370e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007f1  0080029e  0080029e  00003840  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003840  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000760  00000000  00000000  00003870  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000f4a6  00000000  00000000  00003fd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002d70  00000000  00000000  00013476  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005181  00000000  00000000  000161e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000015cc  00000000  00000000  0001b368  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000036db  00000000  00000000  0001c934  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00007913  00000000  00000000  0002000f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000720  00000000  00000000  00027922  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c2       	rjmp	.+1088   	; 0x442 <__ctors_end>
       2:	00 00       	nop
       4:	4f c2       	rjmp	.+1182   	; 0x4a4 <__bad_interrupt>
       6:	00 00       	nop
       8:	4d c2       	rjmp	.+1178   	; 0x4a4 <__bad_interrupt>
       a:	00 00       	nop
       c:	4b c2       	rjmp	.+1174   	; 0x4a4 <__bad_interrupt>
       e:	00 00       	nop
      10:	49 c2       	rjmp	.+1170   	; 0x4a4 <__bad_interrupt>
      12:	00 00       	nop
      14:	47 c2       	rjmp	.+1166   	; 0x4a4 <__bad_interrupt>
      16:	00 00       	nop
      18:	45 c2       	rjmp	.+1162   	; 0x4a4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	43 c2       	rjmp	.+1158   	; 0x4a4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	41 c2       	rjmp	.+1154   	; 0x4a4 <__bad_interrupt>
      22:	00 00       	nop
      24:	3f c2       	rjmp	.+1150   	; 0x4a4 <__bad_interrupt>
      26:	00 00       	nop
      28:	3d c2       	rjmp	.+1146   	; 0x4a4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3b c2       	rjmp	.+1142   	; 0x4a4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	39 c2       	rjmp	.+1138   	; 0x4a4 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 2e 09 	jmp	0x125c	; 0x125c <__vector_13>
      38:	35 c2       	rjmp	.+1130   	; 0x4a4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	33 c2       	rjmp	.+1126   	; 0x4a4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	31 c2       	rjmp	.+1122   	; 0x4a4 <__bad_interrupt>
      42:	00 00       	nop
      44:	2f c2       	rjmp	.+1118   	; 0x4a4 <__bad_interrupt>
      46:	00 00       	nop
      48:	2d c2       	rjmp	.+1114   	; 0x4a4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2b c2       	rjmp	.+1110   	; 0x4a4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	29 c2       	rjmp	.+1106   	; 0x4a4 <__bad_interrupt>
      52:	00 00       	nop
      54:	27 c2       	rjmp	.+1102   	; 0x4a4 <__bad_interrupt>
      56:	00 00       	nop
      58:	25 c2       	rjmp	.+1098   	; 0x4a4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 c2 18 	jmp	0x3184	; 0x3184 <__vector_23>
      60:	21 c2       	rjmp	.+1090   	; 0x4a4 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 0d 17 	jmp	0x2e1a	; 0x2e1a <__vector_25>
      68:	0c 94 4c 17 	jmp	0x2e98	; 0x2e98 <__vector_26>
      6c:	1b c2       	rjmp	.+1078   	; 0x4a4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	19 c2       	rjmp	.+1074   	; 0x4a4 <__bad_interrupt>
      72:	00 00       	nop
      74:	17 c2       	rjmp	.+1070   	; 0x4a4 <__bad_interrupt>
      76:	00 00       	nop
      78:	15 c2       	rjmp	.+1066   	; 0x4a4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	13 c2       	rjmp	.+1062   	; 0x4a4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	11 c2       	rjmp	.+1058   	; 0x4a4 <__bad_interrupt>
      82:	00 00       	nop
      84:	0f c2       	rjmp	.+1054   	; 0x4a4 <__bad_interrupt>
      86:	00 00       	nop
      88:	0d c2       	rjmp	.+1050   	; 0x4a4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0b c2       	rjmp	.+1046   	; 0x4a4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	09 c2       	rjmp	.+1042   	; 0x4a4 <__bad_interrupt>
      92:	00 00       	nop
      94:	07 c2       	rjmp	.+1038   	; 0x4a4 <__bad_interrupt>
      96:	00 00       	nop
      98:	05 c2       	rjmp	.+1034   	; 0x4a4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 ae 10 	jmp	0x215c	; 0x215c <__vector_39>
      a0:	01 c2       	rjmp	.+1026   	; 0x4a4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ff c1       	rjmp	.+1022   	; 0x4a4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	fd c1       	rjmp	.+1018   	; 0x4a4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	fb c1       	rjmp	.+1014   	; 0x4a4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	f9 c1       	rjmp	.+1010   	; 0x4a4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	f7 c1       	rjmp	.+1006   	; 0x4a4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	f5 c1       	rjmp	.+1002   	; 0x4a4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	f3 c1       	rjmp	.+998    	; 0x4a4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	f1 c1       	rjmp	.+994    	; 0x4a4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	ef c1       	rjmp	.+990    	; 0x4a4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	ed c1       	rjmp	.+986    	; 0x4a4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	eb c1       	rjmp	.+982    	; 0x4a4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	e9 c1       	rjmp	.+978    	; 0x4a4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	e7 c1       	rjmp	.+974    	; 0x4a4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	e5 c1       	rjmp	.+970    	; 0x4a4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	e3 c1       	rjmp	.+966    	; 0x4a4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	e1 c1       	rjmp	.+962    	; 0x4a4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	b4 11       	cpse	r27, r4
      e6:	b7 11       	cpse	r27, r7
      e8:	b7 11       	cpse	r27, r7
      ea:	b7 11       	cpse	r27, r7
      ec:	b7 11       	cpse	r27, r7
      ee:	b7 11       	cpse	r27, r7
      f0:	b7 11       	cpse	r27, r7
      f2:	b7 11       	cpse	r27, r7
      f4:	ce 10       	cpse	r12, r14
      f6:	b7 11       	cpse	r27, r7
      f8:	b7 11       	cpse	r27, r7
      fa:	b7 11       	cpse	r27, r7
      fc:	b7 11       	cpse	r27, r7
      fe:	b7 11       	cpse	r27, r7
     100:	b7 11       	cpse	r27, r7
     102:	b7 11       	cpse	r27, r7
     104:	ce 10       	cpse	r12, r14
     106:	b7 11       	cpse	r27, r7
     108:	b7 11       	cpse	r27, r7
     10a:	b7 11       	cpse	r27, r7
     10c:	b7 11       	cpse	r27, r7
     10e:	b7 11       	cpse	r27, r7
     110:	b7 11       	cpse	r27, r7
     112:	b7 11       	cpse	r27, r7
     114:	d6 10       	cpse	r13, r6
     116:	b7 11       	cpse	r27, r7
     118:	b7 11       	cpse	r27, r7
     11a:	b7 11       	cpse	r27, r7
     11c:	b7 11       	cpse	r27, r7
     11e:	b7 11       	cpse	r27, r7
     120:	b7 11       	cpse	r27, r7
     122:	b7 11       	cpse	r27, r7
     124:	fb 10       	cpse	r15, r11
     126:	b7 11       	cpse	r27, r7
     128:	b7 11       	cpse	r27, r7
     12a:	b7 11       	cpse	r27, r7
     12c:	b7 11       	cpse	r27, r7
     12e:	b7 11       	cpse	r27, r7
     130:	b7 11       	cpse	r27, r7
     132:	b7 11       	cpse	r27, r7
     134:	d6 10       	cpse	r13, r6
     136:	b7 11       	cpse	r27, r7
     138:	b7 11       	cpse	r27, r7
     13a:	b7 11       	cpse	r27, r7
     13c:	b7 11       	cpse	r27, r7
     13e:	b7 11       	cpse	r27, r7
     140:	b7 11       	cpse	r27, r7
     142:	b7 11       	cpse	r27, r7
     144:	00 11       	cpse	r16, r0
     146:	b7 11       	cpse	r27, r7
     148:	b7 11       	cpse	r27, r7
     14a:	b7 11       	cpse	r27, r7
     14c:	b7 11       	cpse	r27, r7
     14e:	b7 11       	cpse	r27, r7
     150:	b7 11       	cpse	r27, r7
     152:	b7 11       	cpse	r27, r7
     154:	05 11       	cpse	r16, r5
     156:	b7 11       	cpse	r27, r7
     158:	b7 11       	cpse	r27, r7
     15a:	b7 11       	cpse	r27, r7
     15c:	b7 11       	cpse	r27, r7
     15e:	b7 11       	cpse	r27, r7
     160:	b7 11       	cpse	r27, r7
     162:	b7 11       	cpse	r27, r7
     164:	16 11       	cpse	r17, r6
     166:	b7 11       	cpse	r27, r7
     168:	b7 11       	cpse	r27, r7
     16a:	b7 11       	cpse	r27, r7
     16c:	b7 11       	cpse	r27, r7
     16e:	b7 11       	cpse	r27, r7
     170:	b7 11       	cpse	r27, r7
     172:	b7 11       	cpse	r27, r7
     174:	3f 11       	cpse	r19, r15
     176:	b7 11       	cpse	r27, r7
     178:	b7 11       	cpse	r27, r7
     17a:	b7 11       	cpse	r27, r7
     17c:	b7 11       	cpse	r27, r7
     17e:	b7 11       	cpse	r27, r7
     180:	b7 11       	cpse	r27, r7
     182:	b7 11       	cpse	r27, r7
     184:	0a 11       	cpse	r16, r10
     186:	b7 11       	cpse	r27, r7
     188:	b7 11       	cpse	r27, r7
     18a:	b7 11       	cpse	r27, r7
     18c:	b7 11       	cpse	r27, r7
     18e:	b7 11       	cpse	r27, r7
     190:	b7 11       	cpse	r27, r7
     192:	b7 11       	cpse	r27, r7
     194:	24 11       	cpse	r18, r4
     196:	b7 11       	cpse	r27, r7
     198:	b7 11       	cpse	r27, r7
     19a:	b7 11       	cpse	r27, r7
     19c:	b7 11       	cpse	r27, r7
     19e:	b7 11       	cpse	r27, r7
     1a0:	b7 11       	cpse	r27, r7
     1a2:	b7 11       	cpse	r27, r7
     1a4:	41 11       	cpse	r20, r1
     1a6:	b7 11       	cpse	r27, r7
     1a8:	b7 11       	cpse	r27, r7
     1aa:	b7 11       	cpse	r27, r7
     1ac:	b7 11       	cpse	r27, r7
     1ae:	b7 11       	cpse	r27, r7
     1b0:	b7 11       	cpse	r27, r7
     1b2:	b7 11       	cpse	r27, r7
     1b4:	41 11       	cpse	r20, r1
     1b6:	b7 11       	cpse	r27, r7
     1b8:	b7 11       	cpse	r27, r7
     1ba:	b7 11       	cpse	r27, r7
     1bc:	b7 11       	cpse	r27, r7
     1be:	b7 11       	cpse	r27, r7
     1c0:	b7 11       	cpse	r27, r7
     1c2:	b7 11       	cpse	r27, r7
     1c4:	41 11       	cpse	r20, r1
     1c6:	b7 11       	cpse	r27, r7
     1c8:	b7 11       	cpse	r27, r7
     1ca:	b7 11       	cpse	r27, r7
     1cc:	b7 11       	cpse	r27, r7
     1ce:	b7 11       	cpse	r27, r7
     1d0:	b7 11       	cpse	r27, r7
     1d2:	b7 11       	cpse	r27, r7
     1d4:	41 11       	cpse	r20, r1
     1d6:	b7 11       	cpse	r27, r7
     1d8:	b7 11       	cpse	r27, r7
     1da:	b7 11       	cpse	r27, r7
     1dc:	b7 11       	cpse	r27, r7
     1de:	b7 11       	cpse	r27, r7
     1e0:	b7 11       	cpse	r27, r7
     1e2:	b7 11       	cpse	r27, r7
     1e4:	4a 11       	cpse	r20, r10
     1e6:	b7 11       	cpse	r27, r7
     1e8:	b7 11       	cpse	r27, r7
     1ea:	b7 11       	cpse	r27, r7
     1ec:	b7 11       	cpse	r27, r7
     1ee:	b7 11       	cpse	r27, r7
     1f0:	b7 11       	cpse	r27, r7
     1f2:	b7 11       	cpse	r27, r7
     1f4:	7b 11       	cpse	r23, r11
     1f6:	b7 11       	cpse	r27, r7
     1f8:	b7 11       	cpse	r27, r7
     1fa:	b7 11       	cpse	r27, r7
     1fc:	b7 11       	cpse	r27, r7
     1fe:	b7 11       	cpse	r27, r7
     200:	b7 11       	cpse	r27, r7
     202:	b7 11       	cpse	r27, r7
     204:	4a 11       	cpse	r20, r10
     206:	b7 11       	cpse	r27, r7
     208:	b7 11       	cpse	r27, r7
     20a:	b7 11       	cpse	r27, r7
     20c:	b7 11       	cpse	r27, r7
     20e:	b7 11       	cpse	r27, r7
     210:	b7 11       	cpse	r27, r7
     212:	b7 11       	cpse	r27, r7
     214:	7b 11       	cpse	r23, r11
     216:	b7 11       	cpse	r27, r7
     218:	b7 11       	cpse	r27, r7
     21a:	b7 11       	cpse	r27, r7
     21c:	b7 11       	cpse	r27, r7
     21e:	b7 11       	cpse	r27, r7
     220:	b7 11       	cpse	r27, r7
     222:	b7 11       	cpse	r27, r7
     224:	62 11       	cpse	r22, r2
     226:	b7 11       	cpse	r27, r7
     228:	b7 11       	cpse	r27, r7
     22a:	b7 11       	cpse	r27, r7
     22c:	b7 11       	cpse	r27, r7
     22e:	b7 11       	cpse	r27, r7
     230:	b7 11       	cpse	r27, r7
     232:	b7 11       	cpse	r27, r7
     234:	7f 11       	cpse	r23, r15
     236:	b7 11       	cpse	r27, r7
     238:	b7 11       	cpse	r27, r7
     23a:	b7 11       	cpse	r27, r7
     23c:	b7 11       	cpse	r27, r7
     23e:	b7 11       	cpse	r27, r7
     240:	b7 11       	cpse	r27, r7
     242:	b7 11       	cpse	r27, r7
     244:	7f 11       	cpse	r23, r15
     246:	b7 11       	cpse	r27, r7
     248:	b7 11       	cpse	r27, r7
     24a:	b7 11       	cpse	r27, r7
     24c:	b7 11       	cpse	r27, r7
     24e:	b7 11       	cpse	r27, r7
     250:	b7 11       	cpse	r27, r7
     252:	b7 11       	cpse	r27, r7
     254:	94 11       	cpse	r25, r4
     256:	b7 11       	cpse	r27, r7
     258:	b7 11       	cpse	r27, r7
     25a:	b7 11       	cpse	r27, r7
     25c:	b7 11       	cpse	r27, r7
     25e:	b7 11       	cpse	r27, r7
     260:	b7 11       	cpse	r27, r7
     262:	b7 11       	cpse	r27, r7
     264:	ae 11       	cpse	r26, r14
     266:	b7 11       	cpse	r27, r7
     268:	b7 11       	cpse	r27, r7
     26a:	b7 11       	cpse	r27, r7
     26c:	b7 11       	cpse	r27, r7
     26e:	b7 11       	cpse	r27, r7
     270:	b7 11       	cpse	r27, r7
     272:	b7 11       	cpse	r27, r7
     274:	ae 11       	cpse	r26, r14
     276:	07 63       	ori	r16, 0x37	; 55
     278:	42 36       	cpi	r20, 0x62	; 98
     27a:	b7 9b       	sbis	0x16, 7	; 22
     27c:	d8 a7       	std	Y+40, r29	; 0x28
     27e:	1a 39       	cpi	r17, 0x9A	; 154
     280:	68 56       	subi	r22, 0x68	; 104
     282:	18 ae       	std	Y+56, r1	; 0x38
     284:	ba ab       	std	Y+50, r27	; 0x32
     286:	55 8c       	ldd	r5, Z+29	; 0x1d
     288:	1d 3c       	cpi	r17, 0xCD	; 205
     28a:	b7 cc       	rjmp	.-1682   	; 0xfffffbfa <__eeprom_end+0xff7efbfa>
     28c:	57 63       	ori	r21, 0x37	; 55
     28e:	bd 6d       	ori	r27, 0xDD	; 221
     290:	ed fd       	.word	0xfded	; ????
     292:	75 3e       	cpi	r23, 0xE5	; 229
     294:	f6 17       	cp	r31, r22
     296:	72 31       	cpi	r23, 0x12	; 18
     298:	bf 00       	.word	0x00bf	; ????
     29a:	00 00       	nop
     29c:	80 3f       	cpi	r24, 0xF0	; 240
     29e:	08 00       	.word	0x0008	; ????
     2a0:	00 00       	nop
     2a2:	be 92       	st	-X, r11
     2a4:	24 49       	sbci	r18, 0x94	; 148
     2a6:	12 3e       	cpi	r17, 0xE2	; 226
     2a8:	ab aa       	std	Y+51, r10	; 0x33
     2aa:	aa 2a       	or	r10, r26
     2ac:	be cd       	rjmp	.-1156   	; 0xfffffe2a <__eeprom_end+0xff7efe2a>
     2ae:	cc cc       	rjmp	.-1640   	; 0xfffffc48 <__eeprom_end+0xff7efc48>
     2b0:	4c 3e       	cpi	r20, 0xEC	; 236
     2b2:	00 00       	nop
     2b4:	00 80       	ld	r0, Z
     2b6:	be ab       	std	Y+54, r27	; 0x36
     2b8:	aa aa       	std	Y+50, r10	; 0x32
     2ba:	aa 3e       	cpi	r26, 0xEA	; 234
     2bc:	00 00       	nop
     2be:	00 00       	nop
     2c0:	bf 00       	.word	0x00bf	; ????
     2c2:	00 00       	nop
     2c4:	80 3f       	cpi	r24, 0xF0	; 240
     2c6:	00 00       	nop
     2c8:	00 00       	nop
     2ca:	00 08       	sbc	r0, r0
     2cc:	41 78       	andi	r20, 0x81	; 129
     2ce:	d3 bb       	out	0x13, r29	; 19
     2d0:	43 87       	std	Z+11, r20	; 0x0b
     2d2:	d1 13       	cpse	r29, r17
     2d4:	3d 19       	sub	r19, r13
     2d6:	0e 3c       	cpi	r16, 0xCE	; 206
     2d8:	c3 bd       	out	0x23, r28	; 35
     2da:	42 82       	std	Z+2, r4	; 0x02
     2dc:	ad 2b       	or	r26, r29
     2de:	3e 68       	ori	r19, 0x8E	; 142
     2e0:	ec 82       	std	Y+4, r14	; 0x04
     2e2:	76 be       	out	0x36, r7	; 54
     2e4:	d9 8f       	std	Y+25, r29	; 0x19
     2e6:	e1 a9       	ldd	r30, Z+49	; 0x31
     2e8:	3e 4c       	sbci	r19, 0xCE	; 206
     2ea:	80 ef       	ldi	r24, 0xF0	; 240
     2ec:	ff be       	out	0x3f, r15	; 63
     2ee:	01 c4       	rjmp	.+2050   	; 0xaf2 <_ZN6LSM3037readAccEv+0xa>
     2f0:	ff 7f       	andi	r31, 0xFF	; 255
     2f2:	3f 00       	.word	0x003f	; ????
     2f4:	00 00       	nop
     2f6:	00 00       	nop
     2f8:	c8 19       	sub	r28, r8
     2fa:	cc 19       	sub	r28, r12
     2fc:	b6 19       	sub	r27, r6
     2fe:	bc 19       	sub	r27, r12
     300:	c2 19       	sub	r28, r2
     302:	11 1a       	sub	r1, r17
     304:	d0 19       	sub	r29, r0
     306:	d6 19       	sub	r29, r6
     308:	dc 19       	sub	r29, r12
     30a:	e2 19       	sub	r30, r2
     30c:	e8 19       	sub	r30, r8
     30e:	ee 19       	sub	r30, r14
     310:	f4 19       	sub	r31, r4
     312:	fa 19       	sub	r31, r10
     314:	11 1a       	sub	r1, r17
     316:	00 1a       	sub	r0, r16
     318:	06 1a       	sub	r0, r22
     31a:	0c 1a       	sub	r0, r28

0000031c <__trampolines_end>:
     31c:	00 00       	nop
     31e:	0a 0b       	sbc	r16, r26
     320:	02 09       	sbc	r16, r2
     322:	0c 0d       	add	r16, r12
     324:	0e 08       	sbc	r0, r14
     326:	07 03       	mulsu	r16, r23
     328:	04 01       	movw	r0, r8
	...
     346:	00 00       	nop
     348:	12 11       	cpse	r17, r2
     34a:	10 00       	.word	0x0010	; ????
	...

00000362 <digital_pin_to_bit_mask_PGM>:
     362:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     372:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     382:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     392:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     3a2:	04 08 10 20 40 80                                   ... @.

000003a8 <digital_pin_to_port_PGM>:
     3a8:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     3b8:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     3c8:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     3d8:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     3e8:	0b 0b 0b 0b 0b 0b                                   ......

000003ee <port_to_input_PGM>:
     3ee:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     3fe:	00 01 00 00 03 01 06 01 09 01                       ..........

00000408 <port_to_output_PGM>:
     408:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     418:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000422 <port_to_mode_PGM>:
     422:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     432:	01 01 00 00 04 01 07 01 0a 01                       ..........

0000043c <__ctors_start>:
     43c:	32 0b       	sbc	r19, r18
     43e:	9c 12       	cpse	r9, r28
     440:	75 17       	cp	r23, r21

00000442 <__ctors_end>:
     442:	11 24       	eor	r1, r1
     444:	1f be       	out	0x3f, r1	; 63
     446:	cf ef       	ldi	r28, 0xFF	; 255
     448:	d1 e2       	ldi	r29, 0x21	; 33
     44a:	de bf       	out	0x3e, r29	; 62
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	00 e0       	ldi	r16, 0x00	; 0
     450:	0c bf       	out	0x3c, r16	; 60

00000452 <__do_copy_data>:
     452:	12 e0       	ldi	r17, 0x02	; 2
     454:	a0 e0       	ldi	r26, 0x00	; 0
     456:	b2 e0       	ldi	r27, 0x02	; 2
     458:	ee e0       	ldi	r30, 0x0E	; 14
     45a:	f7 e3       	ldi	r31, 0x37	; 55
     45c:	00 e0       	ldi	r16, 0x00	; 0
     45e:	0b bf       	out	0x3b, r16	; 59
     460:	02 c0       	rjmp	.+4      	; 0x466 <__do_copy_data+0x14>
     462:	07 90       	elpm	r0, Z+
     464:	0d 92       	st	X+, r0
     466:	ae 39       	cpi	r26, 0x9E	; 158
     468:	b1 07       	cpc	r27, r17
     46a:	d9 f7       	brne	.-10     	; 0x462 <__do_copy_data+0x10>

0000046c <__do_clear_bss>:
     46c:	2a e0       	ldi	r18, 0x0A	; 10
     46e:	ae e9       	ldi	r26, 0x9E	; 158
     470:	b2 e0       	ldi	r27, 0x02	; 2
     472:	01 c0       	rjmp	.+2      	; 0x476 <.do_clear_bss_start>

00000474 <.do_clear_bss_loop>:
     474:	1d 92       	st	X+, r1

00000476 <.do_clear_bss_start>:
     476:	af 38       	cpi	r26, 0x8F	; 143
     478:	b2 07       	cpc	r27, r18
     47a:	e1 f7       	brne	.-8      	; 0x474 <.do_clear_bss_loop>

0000047c <__do_global_ctors>:
     47c:	14 e0       	ldi	r17, 0x04	; 4
     47e:	c2 e4       	ldi	r28, 0x42	; 66
     480:	d4 e0       	ldi	r29, 0x04	; 4
     482:	00 e0       	ldi	r16, 0x00	; 0
     484:	06 c0       	rjmp	.+12     	; 0x492 <__do_global_ctors+0x16>
     486:	22 97       	sbiw	r28, 0x02	; 2
     488:	01 09       	sbc	r16, r1
     48a:	fe 01       	movw	r30, r28
     48c:	0b bf       	out	0x3b, r16	; 59
     48e:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__tablejump_elpm__>
     492:	cc 33       	cpi	r28, 0x3C	; 60
     494:	d1 07       	cpc	r29, r17
     496:	80 e0       	ldi	r24, 0x00	; 0
     498:	08 07       	cpc	r16, r24
     49a:	a9 f7       	brne	.-22     	; 0x486 <__do_global_ctors+0xa>
     49c:	0e 94 c6 0a 	call	0x158c	; 0x158c <main>
     4a0:	0c 94 85 1b 	jmp	0x370a	; 0x370a <_exit>

000004a4 <__bad_interrupt>:
     4a4:	ad cd       	rjmp	.-1190   	; 0x0 <__vectors>

000004a6 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     4a6:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     4a8:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     4aa:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     4ac:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     4ae:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     4b0:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     4b2:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     4b4:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     4b6:	05 c0       	rjmp	.+10     	; 0x4c2 <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     4b8:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4ba:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4bc:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     4be:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     4c0:	61 f1       	breq	.+88     	; 0x51a <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     4c2:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     4c4:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     4c6:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     4c8:	b9 f3       	breq	.-18     	; 0x4b8 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     4ca:	05 c0       	rjmp	.+10     	; 0x4d6 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     4cc:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4ce:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4d0:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     4d2:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     4d4:	11 f1       	breq	.+68     	; 0x51a <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     4d6:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     4d8:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     4da:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     4dc:	f7 cf       	rjmp	.-18     	; 0x4cc <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     4de:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     4e0:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     4e2:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     4e4:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     4e6:	0a c0       	rjmp	.+20     	; 0x4fc <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     4e8:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     4ea:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     4ec:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     4ee:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     4f0:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     4f2:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     4f4:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     4f6:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     4f8:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     4fa:	79 f0       	breq	.+30     	; 0x51a <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     4fc:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     4fe:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     500:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     502:	91 f3       	breq	.-28     	; 0x4e8 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     504:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     506:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     508:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     50a:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     50c:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     50e:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     510:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     512:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     514:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     516:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     518:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     51a:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     51c:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     51e:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     520:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     522:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     524:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     526:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     528:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     52a:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     52c:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     52e:	08 95       	ret

00000530 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
     534:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     536:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     53a:	80 91 9e 02 	lds	r24, 0x029E
     53e:	90 91 9f 02 	lds	r25, 0x029F
     542:	89 2b       	or	r24, r25
     544:	31 f4       	brne	.+12     	; 0x552 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     546:	83 ea       	ldi	r24, 0xA3	; 163
     548:	92 e0       	ldi	r25, 0x02	; 2
     54a:	90 93 9f 02 	sts	0x029F, r25
     54e:	80 93 9e 02 	sts	0x029E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     552:	40 91 a0 02 	lds	r20, 0x02A0
     556:	50 91 a1 02 	lds	r21, 0x02A1
     55a:	9e 01       	movw	r18, r28
     55c:	24 0f       	add	r18, r20
     55e:	35 1f       	adc	r19, r21
     560:	2b 3d       	cpi	r18, 0xDB	; 219
     562:	85 e0       	ldi	r24, 0x05	; 5
     564:	38 07       	cpc	r19, r24
     566:	70 f4       	brcc	.+28     	; 0x584 <pvPortMalloc+0x54>
     568:	42 17       	cp	r20, r18
     56a:	53 07       	cpc	r21, r19
     56c:	70 f4       	brcc	.+28     	; 0x58a <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     56e:	c0 91 9e 02 	lds	r28, 0x029E
     572:	d0 91 9f 02 	lds	r29, 0x029F
     576:	c4 0f       	add	r28, r20
     578:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     57a:	30 93 a1 02 	sts	0x02A1, r19
     57e:	20 93 a0 02 	sts	0x02A0, r18
     582:	05 c0       	rjmp	.+10     	; 0x58e <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     584:	c0 e0       	ldi	r28, 0x00	; 0
     586:	d0 e0       	ldi	r29, 0x00	; 0
     588:	02 c0       	rjmp	.+4      	; 0x58e <pvPortMalloc+0x5e>
     58a:	c0 e0       	ldi	r28, 0x00	; 0
     58c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     58e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     592:	ce 01       	movw	r24, r28
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	08 95       	ret

0000059a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     59a:	08 95       	ret

0000059c <_ZN3L3GC1Ev>:
  Wire.requestFrom(address, (byte)1);
  value = Wire.read();
  Wire.endTransmission();

  return value;
}
     59c:	fc 01       	movw	r30, r24
     59e:	83 e0       	ldi	r24, 0x03	; 3
     5a0:	87 83       	std	Z+7, r24	; 0x07
     5a2:	12 86       	std	Z+10, r1	; 0x0a
     5a4:	11 86       	std	Z+9, r1	; 0x09
     5a6:	13 86       	std	Z+11, r1	; 0x0b
     5a8:	08 95       	ret

000005aa <_ZN3L3G8writeRegEhh>:
     5aa:	0f 93       	push	r16
     5ac:	1f 93       	push	r17
     5ae:	cf 93       	push	r28
     5b0:	df 93       	push	r29
     5b2:	ec 01       	movw	r28, r24
     5b4:	06 2f       	mov	r16, r22
     5b6:	14 2f       	mov	r17, r20
     5b8:	68 85       	ldd	r22, Y+8	; 0x08
     5ba:	87 e9       	ldi	r24, 0x97	; 151
     5bc:	99 e0       	ldi	r25, 0x09	; 9
     5be:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
     5c2:	60 2f       	mov	r22, r16
     5c4:	87 e9       	ldi	r24, 0x97	; 151
     5c6:	99 e0       	ldi	r25, 0x09	; 9
     5c8:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
     5cc:	61 2f       	mov	r22, r17
     5ce:	87 e9       	ldi	r24, 0x97	; 151
     5d0:	99 e0       	ldi	r25, 0x09	; 9
     5d2:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
     5d6:	87 e9       	ldi	r24, 0x97	; 151
     5d8:	99 e0       	ldi	r25, 0x09	; 9
     5da:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     5de:	8e 83       	std	Y+6, r24	; 0x06
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	1f 91       	pop	r17
     5e6:	0f 91       	pop	r16
     5e8:	08 95       	ret

000005ea <_ZN3L3G13enableDefaultEv>:
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	ec 01       	movw	r28, r24
     5f0:	8f 81       	ldd	r24, Y+7	; 0x07
     5f2:	82 30       	cpi	r24, 0x02	; 2
     5f4:	21 f4       	brne	.+8      	; 0x5fe <_ZN3L3G13enableDefaultEv+0x14>
     5f6:	40 e0       	ldi	r20, 0x00	; 0
     5f8:	69 e3       	ldi	r22, 0x39	; 57
     5fa:	ce 01       	movw	r24, r28
     5fc:	d6 df       	rcall	.-84     	; 0x5aa <_ZN3L3G8writeRegEhh>
     5fe:	40 e0       	ldi	r20, 0x00	; 0
     600:	63 e2       	ldi	r22, 0x23	; 35
     602:	ce 01       	movw	r24, r28
     604:	d2 df       	rcall	.-92     	; 0x5aa <_ZN3L3G8writeRegEhh>
     606:	4f e6       	ldi	r20, 0x6F	; 111
     608:	60 e2       	ldi	r22, 0x20	; 32
     60a:	ce 01       	movw	r24, r28
     60c:	ce df       	rcall	.-100    	; 0x5aa <_ZN3L3G8writeRegEhh>
     60e:	df 91       	pop	r29
     610:	cf 91       	pop	r28
     612:	08 95       	ret

00000614 <_ZN3L3G4readEv>:

// Reads the 3 gyro channels and stores them in vector g
void L3G::read()
{
     614:	9f 92       	push	r9
     616:	af 92       	push	r10
     618:	bf 92       	push	r11
     61a:	cf 92       	push	r12
     61c:	df 92       	push	r13
     61e:	ef 92       	push	r14
     620:	ff 92       	push	r15
     622:	0f 93       	push	r16
     624:	1f 93       	push	r17
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     62c:	68 85       	ldd	r22, Y+8	; 0x08
     62e:	87 e9       	ldi	r24, 0x97	; 151
     630:	99 e0       	ldi	r25, 0x09	; 9
     632:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     636:	e0 91 97 09 	lds	r30, 0x0997
     63a:	f0 91 98 09 	lds	r31, 0x0998
     63e:	01 90       	ld	r0, Z+
     640:	f0 81       	ld	r31, Z
     642:	e0 2d       	mov	r30, r0
     644:	68 ea       	ldi	r22, 0xA8	; 168
     646:	87 e9       	ldi	r24, 0x97	; 151
     648:	99 e0       	ldi	r25, 0x09	; 9
     64a:	19 95       	eicall
  // assert the MSB of the address to get the gyro
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
     64c:	87 e9       	ldi	r24, 0x97	; 151
     64e:	99 e0       	ldi	r25, 0x09	; 9
     650:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)6);
     654:	46 e0       	ldi	r20, 0x06	; 6
     656:	68 85       	ldd	r22, Y+8	; 0x08
     658:	87 e9       	ldi	r24, 0x97	; 151
     65a:	99 e0       	ldi	r25, 0x09	; 9
     65c:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <_ZN7TwoWire11requestFromEhh>
  
  unsigned int millis_start = millis();
     660:	0e 94 0c 19 	call	0x3218	; 0x3218 <millis>
     664:	8b 01       	movw	r16, r22
  while (Wire.available() < 6)
     666:	10 c0       	rjmp	.+32     	; 0x688 <_ZN3L3G4readEv+0x74>
  {
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     668:	89 85       	ldd	r24, Y+9	; 0x09
     66a:	9a 85       	ldd	r25, Y+10	; 0x0a
     66c:	89 2b       	or	r24, r25
     66e:	61 f0       	breq	.+24     	; 0x688 <_ZN3L3G4readEv+0x74>
     670:	0e 94 0c 19 	call	0x3218	; 0x3218 <millis>
     674:	60 1b       	sub	r22, r16
     676:	71 0b       	sbc	r23, r17
     678:	89 85       	ldd	r24, Y+9	; 0x09
     67a:	9a 85       	ldd	r25, Y+10	; 0x0a
     67c:	86 17       	cp	r24, r22
     67e:	97 07       	cpc	r25, r23
     680:	18 f4       	brcc	.+6      	; 0x688 <_ZN3L3G4readEv+0x74>
    {
      did_timeout = true;
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	8b 87       	std	Y+11, r24	; 0x0b
      return;
     686:	32 c0       	rjmp	.+100    	; 0x6ec <_ZN3L3G4readEv+0xd8>
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
  Wire.requestFrom(address, (byte)6);
  
  unsigned int millis_start = millis();
  while (Wire.available() < 6)
     688:	87 e9       	ldi	r24, 0x97	; 151
     68a:	99 e0       	ldi	r25, 0x09	; 9
     68c:	0e 94 ca 11 	call	0x2394	; 0x2394 <_ZN7TwoWire9availableEv>
     690:	06 97       	sbiw	r24, 0x06	; 6
     692:	54 f3       	brlt	.-44     	; 0x668 <_ZN3L3G4readEv+0x54>
      did_timeout = true;
      return;
    }
  }

  uint8_t xlg = Wire.read();
     694:	87 e9       	ldi	r24, 0x97	; 151
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     69c:	a8 2e       	mov	r10, r24
  uint8_t xhg = Wire.read();
     69e:	87 e9       	ldi	r24, 0x97	; 151
     6a0:	99 e0       	ldi	r25, 0x09	; 9
     6a2:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     6a6:	98 2e       	mov	r9, r24
  uint8_t ylg = Wire.read();
     6a8:	87 e9       	ldi	r24, 0x97	; 151
     6aa:	99 e0       	ldi	r25, 0x09	; 9
     6ac:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     6b0:	08 2f       	mov	r16, r24
  uint8_t yhg = Wire.read();
     6b2:	87 e9       	ldi	r24, 0x97	; 151
     6b4:	99 e0       	ldi	r25, 0x09	; 9
     6b6:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     6ba:	b8 2e       	mov	r11, r24
  uint8_t zlg = Wire.read();
     6bc:	87 e9       	ldi	r24, 0x97	; 151
     6be:	99 e0       	ldi	r25, 0x09	; 9
     6c0:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     6c4:	18 2f       	mov	r17, r24
  uint8_t zhg = Wire.read();
     6c6:	87 e9       	ldi	r24, 0x97	; 151
     6c8:	99 e0       	ldi	r25, 0x09	; 9
     6ca:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
     6ce:	d9 2c       	mov	r13, r9
     6d0:	c1 2c       	mov	r12, r1
     6d2:	ca 28       	or	r12, r10
     6d4:	d9 82       	std	Y+1, r13	; 0x01
     6d6:	c8 82       	st	Y, r12
  g.y = (int16_t)(yhg << 8 | ylg);
     6d8:	fb 2c       	mov	r15, r11
     6da:	e1 2c       	mov	r14, r1
     6dc:	e0 2a       	or	r14, r16
     6de:	fb 82       	std	Y+3, r15	; 0x03
     6e0:	ea 82       	std	Y+2, r14	; 0x02
  g.z = (int16_t)(zhg << 8 | zlg);
     6e2:	98 2f       	mov	r25, r24
     6e4:	88 27       	eor	r24, r24
     6e6:	81 2b       	or	r24, r17
     6e8:	9d 83       	std	Y+5, r25	; 0x05
     6ea:	8c 83       	std	Y+4, r24	; 0x04
}
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	1f 91       	pop	r17
     6f2:	0f 91       	pop	r16
     6f4:	ff 90       	pop	r15
     6f6:	ef 90       	pop	r14
     6f8:	df 90       	pop	r13
     6fa:	cf 90       	pop	r12
     6fc:	bf 90       	pop	r11
     6fe:	af 90       	pop	r10
     700:	9f 90       	pop	r9
     702:	08 95       	ret

00000704 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	c6 2f       	mov	r28, r22
     70a:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     70c:	87 e9       	ldi	r24, 0x97	; 151
     70e:	99 e0       	ldi	r25, 0x09	; 9
     710:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     714:	6d 2f       	mov	r22, r29
     716:	87 e9       	ldi	r24, 0x97	; 151
     718:	99 e0       	ldi	r25, 0x09	; 9
     71a:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     71e:	87 e9       	ldi	r24, 0x97	; 151
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     726:	81 11       	cpse	r24, r1
     728:	11 c0       	rjmp	.+34     	; 0x74c <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     72a:	41 e0       	ldi	r20, 0x01	; 1
     72c:	6c 2f       	mov	r22, r28
     72e:	87 e9       	ldi	r24, 0x97	; 151
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     736:	87 e9       	ldi	r24, 0x97	; 151
     738:	99 e0       	ldi	r25, 0x09	; 9
     73a:	0e 94 ca 11 	call	0x2394	; 0x2394 <_ZN7TwoWire9availableEv>
     73e:	89 2b       	or	r24, r25
     740:	41 f0       	breq	.+16     	; 0x752 <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     742:	87 e9       	ldi	r24, 0x97	; 151
     744:	99 e0       	ldi	r25, 0x09	; 9
     746:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     74a:	05 c0       	rjmp	.+10     	; 0x756 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     74c:	8f ef       	ldi	r24, 0xFF	; 255
     74e:	9f ef       	ldi	r25, 0xFF	; 255
     750:	02 c0       	rjmp	.+4      	; 0x756 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     752:	8f ef       	ldi	r24, 0xFF	; 255
     754:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	08 95       	ret

0000075c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     75c:	0f 93       	push	r16
     75e:	1f 93       	push	r17
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
     766:	16 2f       	mov	r17, r22
     768:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     76a:	63 30       	cpi	r22, 0x03	; 3
     76c:	09 f4       	brne	.+2      	; 0x770 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     76e:	56 c0       	rjmp	.+172    	; 0x81c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     770:	42 30       	cpi	r20, 0x02	; 2
     772:	c9 f5       	brne	.+114    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     774:	56 c0       	rjmp	.+172    	; 0x822 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     776:	13 30       	cpi	r17, 0x03	; 3
     778:	09 f0       	breq	.+2      	; 0x77c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     77a:	58 c0       	rjmp	.+176    	; 0x82c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     77c:	87 3d       	cpi	r24, 0xD7	; 215
     77e:	91 05       	cpc	r25, r1
     780:	09 f4       	brne	.+2      	; 0x784 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     782:	58 c0       	rjmp	.+176    	; 0x834 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     784:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     786:	11 e0       	ldi	r17, 0x01	; 1
     788:	2c c0       	rjmp	.+88     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     78a:	01 30       	cpi	r16, 0x01	; 1
     78c:	91 f0       	breq	.+36     	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     78e:	4f e0       	ldi	r20, 0x0F	; 15
     790:	6a e6       	ldi	r22, 0x6A	; 106
     792:	ce 01       	movw	r24, r28
     794:	b7 df       	rcall	.-146    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     796:	8f 3f       	cpi	r24, 0xFF	; 255
     798:	2f ef       	ldi	r18, 0xFF	; 255
     79a:	92 07       	cpc	r25, r18
     79c:	51 f0       	breq	.+20     	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     79e:	13 30       	cpi	r17, 0x03	; 3
     7a0:	09 f0       	breq	.+2      	; 0x7a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     7a2:	46 c0       	rjmp	.+140    	; 0x830 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7a4:	87 3d       	cpi	r24, 0xD7	; 215
     7a6:	91 05       	cpc	r25, r1
     7a8:	09 f0       	breq	.+2      	; 0x7ac <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     7aa:	47 c0       	rjmp	.+142    	; 0x83a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7ac:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7ae:	12 e0       	ldi	r17, 0x02	; 2
     7b0:	18 c0       	rjmp	.+48     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     7b2:	13 30       	cpi	r17, 0x03	; 3
     7b4:	11 f0       	breq	.+4      	; 0x7ba <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     7b6:	11 11       	cpse	r17, r1
     7b8:	14 c0       	rjmp	.+40     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7ba:	00 23       	and	r16, r16
     7bc:	49 f0       	breq	.+18     	; 0x7d0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     7be:	4f e0       	ldi	r20, 0x0F	; 15
     7c0:	69 e6       	ldi	r22, 0x69	; 105
     7c2:	ce 01       	movw	r24, r28
     7c4:	9f df       	rcall	.-194    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     7c6:	83 3d       	cpi	r24, 0xD3	; 211
     7c8:	91 05       	cpc	r25, r1
     7ca:	d1 f1       	breq	.+116    	; 0x840 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7cc:	01 30       	cpi	r16, 0x01	; 1
     7ce:	39 f0       	breq	.+14     	; 0x7de <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     7d0:	4f e0       	ldi	r20, 0x0F	; 15
     7d2:	68 e6       	ldi	r22, 0x68	; 104
     7d4:	ce 01       	movw	r24, r28
     7d6:	96 df       	rcall	.-212    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     7d8:	83 3d       	cpi	r24, 0xD3	; 211
     7da:	91 05       	cpc	r25, r1
     7dc:	99 f1       	breq	.+102    	; 0x844 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     7de:	13 30       	cpi	r17, 0x03	; 3
     7e0:	b9 f0       	breq	.+46     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     7e2:	02 30       	cpi	r16, 0x02	; 2
     7e4:	b9 f0       	breq	.+46     	; 0x814 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     7e6:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     7e8:	11 23       	and	r17, r17
     7ea:	51 f0       	breq	.+20     	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     7ec:	13 30       	cpi	r17, 0x03	; 3
     7ee:	a0 f4       	brcc	.+40     	; 0x818 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     7f0:	01 30       	cpi	r16, 0x01	; 1
     7f2:	11 f4       	brne	.+4      	; 0x7f8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     7f4:	8b e6       	ldi	r24, 0x6B	; 107
     7f6:	01 c0       	rjmp	.+2      	; 0x7fa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     7f8:	8a e6       	ldi	r24, 0x6A	; 106
     7fa:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     7fc:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     7fe:	41 c0       	rjmp	.+130    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     800:	01 30       	cpi	r16, 0x01	; 1
     802:	11 f4       	brne	.+4      	; 0x808 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     804:	89 e6       	ldi	r24, 0x69	; 105
     806:	01 c0       	rjmp	.+2      	; 0x80a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     808:	88 e6       	ldi	r24, 0x68	; 104
     80a:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     80c:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     80e:	39 c0       	rjmp	.+114    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	37 c0       	rjmp	.+110    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	35 c0       	rjmp	.+106    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	33 c0       	rjmp	.+102    	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     81c:	44 23       	and	r20, r20
     81e:	41 f1       	breq	.+80     	; 0x870 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     820:	1e c0       	rjmp	.+60     	; 0x85e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     822:	8f ef       	ldi	r24, 0xFF	; 255
     824:	86 0f       	add	r24, r22
     826:	83 30       	cpi	r24, 0x03	; 3
     828:	30 f6       	brcc	.-116    	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     82a:	0f c0       	rjmp	.+30     	; 0x84a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     82c:	01 e0       	ldi	r16, 0x01	; 1
     82e:	c3 cf       	rjmp	.-122    	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     830:	00 e0       	ldi	r16, 0x00	; 0
     832:	c1 cf       	rjmp	.-126    	; 0x7b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     834:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     836:	12 e0       	ldi	r17, 0x02	; 2
     838:	d4 cf       	rjmp	.-88     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     83a:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     83c:	11 e0       	ldi	r17, 0x01	; 1
     83e:	d1 cf       	rjmp	.-94     	; 0x7e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     840:	01 e0       	ldi	r16, 0x01	; 1
     842:	01 c0       	rjmp	.+2      	; 0x846 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     844:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     846:	1f 82       	std	Y+7, r1	; 0x07
     848:	db cf       	rjmp	.-74     	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     84a:	4f e0       	ldi	r20, 0x0F	; 15
     84c:	6b e6       	ldi	r22, 0x6B	; 107
     84e:	ce 01       	movw	r24, r28
     850:	59 df       	rcall	.-334    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     852:	8f 3f       	cpi	r24, 0xFF	; 255
     854:	2f ef       	ldi	r18, 0xFF	; 255
     856:	92 07       	cpc	r25, r18
     858:	09 f0       	breq	.+2      	; 0x85c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     85a:	8d cf       	rjmp	.-230    	; 0x776 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     85c:	98 cf       	rjmp	.-208    	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     85e:	4f e0       	ldi	r20, 0x0F	; 15
     860:	6b e6       	ldi	r22, 0x6B	; 107
     862:	50 df       	rcall	.-352    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     864:	8f 3f       	cpi	r24, 0xFF	; 255
     866:	2f ef       	ldi	r18, 0xFF	; 255
     868:	92 07       	cpc	r25, r18
     86a:	09 f0       	breq	.+2      	; 0x86e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     86c:	87 cf       	rjmp	.-242    	; 0x77c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     86e:	8d cf       	rjmp	.-230    	; 0x78a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     870:	4f e0       	ldi	r20, 0x0F	; 15
     872:	6a e6       	ldi	r22, 0x6A	; 106
     874:	47 df       	rcall	.-370    	; 0x704 <_ZN3L3G7testRegEhNS_7regAddrE>
     876:	8f 3f       	cpi	r24, 0xFF	; 255
     878:	2f ef       	ldi	r18, 0xFF	; 255
     87a:	92 07       	cpc	r25, r18
     87c:	09 f0       	breq	.+2      	; 0x880 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     87e:	92 cf       	rjmp	.-220    	; 0x7a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     880:	98 cf       	rjmp	.-208    	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	1f 91       	pop	r17
     888:	0f 91       	pop	r16
     88a:	08 95       	ret

0000088c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     88c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     88e:	03 96       	adiw	r24, 0x03	; 3
     890:	92 83       	std	Z+2, r25	; 0x02
     892:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     894:	2f ef       	ldi	r18, 0xFF	; 255
     896:	3f ef       	ldi	r19, 0xFF	; 255
     898:	34 83       	std	Z+4, r19	; 0x04
     89a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     89c:	96 83       	std	Z+6, r25	; 0x06
     89e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a0:	90 87       	std	Z+8, r25	; 0x08
     8a2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8a4:	10 82       	st	Z, r1
     8a6:	08 95       	ret

000008a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8a8:	fc 01       	movw	r30, r24
     8aa:	11 86       	std	Z+9, r1	; 0x09
     8ac:	10 86       	std	Z+8, r1	; 0x08
     8ae:	08 95       	ret

000008b0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8b0:	cf 93       	push	r28
     8b2:	df 93       	push	r29
     8b4:	9c 01       	movw	r18, r24
     8b6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8b8:	dc 01       	movw	r26, r24
     8ba:	11 96       	adiw	r26, 0x01	; 1
     8bc:	cd 91       	ld	r28, X+
     8be:	dc 91       	ld	r29, X
     8c0:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8c2:	d3 83       	std	Z+3, r29	; 0x03
     8c4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8c6:	8c 81       	ldd	r24, Y+4	; 0x04
     8c8:	9d 81       	ldd	r25, Y+5	; 0x05
     8ca:	95 83       	std	Z+5, r25	; 0x05
     8cc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8ce:	8c 81       	ldd	r24, Y+4	; 0x04
     8d0:	9d 81       	ldd	r25, Y+5	; 0x05
     8d2:	dc 01       	movw	r26, r24
     8d4:	13 96       	adiw	r26, 0x03	; 3
     8d6:	7c 93       	st	X, r23
     8d8:	6e 93       	st	-X, r22
     8da:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     8dc:	7d 83       	std	Y+5, r23	; 0x05
     8de:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8e0:	31 87       	std	Z+9, r19	; 0x09
     8e2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     8e4:	f9 01       	movw	r30, r18
     8e6:	80 81       	ld	r24, Z
     8e8:	8f 5f       	subi	r24, 0xFF	; 255
     8ea:	80 83       	st	Z, r24
}
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	08 95       	ret

000008f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8f2:	cf 93       	push	r28
     8f4:	df 93       	push	r29
     8f6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     8f8:	48 81       	ld	r20, Y
     8fa:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     8fc:	4f 3f       	cpi	r20, 0xFF	; 255
     8fe:	2f ef       	ldi	r18, 0xFF	; 255
     900:	52 07       	cpc	r21, r18
     902:	21 f4       	brne	.+8      	; 0x90c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     904:	fc 01       	movw	r30, r24
     906:	a7 81       	ldd	r26, Z+7	; 0x07
     908:	b0 85       	ldd	r27, Z+8	; 0x08
     90a:	0d c0       	rjmp	.+26     	; 0x926 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     90c:	dc 01       	movw	r26, r24
     90e:	13 96       	adiw	r26, 0x03	; 3
     910:	12 96       	adiw	r26, 0x02	; 2
     912:	ed 91       	ld	r30, X+
     914:	fc 91       	ld	r31, X
     916:	13 97       	sbiw	r26, 0x03	; 3
     918:	20 81       	ld	r18, Z
     91a:	31 81       	ldd	r19, Z+1	; 0x01
     91c:	42 17       	cp	r20, r18
     91e:	53 07       	cpc	r21, r19
     920:	10 f0       	brcs	.+4      	; 0x926 <vListInsert+0x34>
     922:	df 01       	movw	r26, r30
     924:	f5 cf       	rjmp	.-22     	; 0x910 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     926:	12 96       	adiw	r26, 0x02	; 2
     928:	ed 91       	ld	r30, X+
     92a:	fc 91       	ld	r31, X
     92c:	13 97       	sbiw	r26, 0x03	; 3
     92e:	fb 83       	std	Y+3, r31	; 0x03
     930:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     932:	d5 83       	std	Z+5, r29	; 0x05
     934:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     936:	bd 83       	std	Y+5, r27	; 0x05
     938:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     93a:	13 96       	adiw	r26, 0x03	; 3
     93c:	dc 93       	st	X, r29
     93e:	ce 93       	st	-X, r28
     940:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     942:	99 87       	std	Y+9, r25	; 0x09
     944:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     946:	fc 01       	movw	r30, r24
     948:	20 81       	ld	r18, Z
     94a:	2f 5f       	subi	r18, 0xFF	; 255
     94c:	20 83       	st	Z, r18
}
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	08 95       	ret

00000954 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     95a:	a0 85       	ldd	r26, Z+8	; 0x08
     95c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     95e:	c2 81       	ldd	r28, Z+2	; 0x02
     960:	d3 81       	ldd	r29, Z+3	; 0x03
     962:	84 81       	ldd	r24, Z+4	; 0x04
     964:	95 81       	ldd	r25, Z+5	; 0x05
     966:	9d 83       	std	Y+5, r25	; 0x05
     968:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     96a:	c4 81       	ldd	r28, Z+4	; 0x04
     96c:	d5 81       	ldd	r29, Z+5	; 0x05
     96e:	82 81       	ldd	r24, Z+2	; 0x02
     970:	93 81       	ldd	r25, Z+3	; 0x03
     972:	9b 83       	std	Y+3, r25	; 0x03
     974:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     976:	11 96       	adiw	r26, 0x01	; 1
     978:	cd 91       	ld	r28, X+
     97a:	dc 91       	ld	r29, X
     97c:	12 97       	sbiw	r26, 0x02	; 2
     97e:	ce 17       	cp	r28, r30
     980:	df 07       	cpc	r29, r31
     982:	31 f4       	brne	.+12     	; 0x990 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     984:	8c 81       	ldd	r24, Y+4	; 0x04
     986:	9d 81       	ldd	r25, Y+5	; 0x05
     988:	12 96       	adiw	r26, 0x02	; 2
     98a:	9c 93       	st	X, r25
     98c:	8e 93       	st	-X, r24
     98e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     990:	11 86       	std	Z+9, r1	; 0x09
     992:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     994:	8c 91       	ld	r24, X
     996:	81 50       	subi	r24, 0x01	; 1
     998:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	08 95       	ret

000009a0 <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	ec 01       	movw	r28, r24
     9a6:	86 e0       	ldi	r24, 0x06	; 6
     9a8:	e9 e0       	ldi	r30, 0x09	; 9
     9aa:	f2 e0       	ldi	r31, 0x02	; 2
     9ac:	de 01       	movw	r26, r28
     9ae:	52 96       	adiw	r26, 0x12	; 18
     9b0:	01 90       	ld	r0, Z+
     9b2:	0d 92       	st	X+, r0
     9b4:	8a 95       	dec	r24
     9b6:	e1 f7       	brne	.-8      	; 0x9b0 <_ZN6LSM303C1Ev+0x10>
     9b8:	86 e0       	ldi	r24, 0x06	; 6
     9ba:	ef e0       	ldi	r30, 0x0F	; 15
     9bc:	f2 e0       	ldi	r31, 0x02	; 2
     9be:	de 01       	movw	r26, r28
     9c0:	1c 96       	adiw	r26, 0x0c	; 12
     9c2:	01 90       	ld	r0, Z+
     9c4:	0d 92       	st	X+, r0
     9c6:	8a 95       	dec	r24
     9c8:	e1 f7       	brne	.-8      	; 0x9c2 <_ZN6LSM303C1Ev+0x22>
     9ca:	84 e0       	ldi	r24, 0x04	; 4
     9cc:	89 8f       	std	Y+25, r24	; 0x19
     9ce:	1c a2       	std	Y+36, r1	; 0x24
     9d0:	1b a2       	std	Y+35, r1	; 0x23
     9d2:	1d a2       	std	Y+37, r1	; 0x25
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	08 95       	ret

000009da <_ZN6LSM30311writeAccRegEhh>:
     9da:	0f 93       	push	r16
     9dc:	1f 93       	push	r17
     9de:	cf 93       	push	r28
     9e0:	df 93       	push	r29
     9e2:	ec 01       	movw	r28, r24
     9e4:	06 2f       	mov	r16, r22
     9e6:	14 2f       	mov	r17, r20
     9e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
     9ea:	87 e9       	ldi	r24, 0x97	; 151
     9ec:	99 e0       	ldi	r25, 0x09	; 9
     9ee:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
     9f2:	60 2f       	mov	r22, r16
     9f4:	87 e9       	ldi	r24, 0x97	; 151
     9f6:	99 e0       	ldi	r25, 0x09	; 9
     9f8:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
     9fc:	61 2f       	mov	r22, r17
     9fe:	87 e9       	ldi	r24, 0x97	; 151
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
     a06:	87 e9       	ldi	r24, 0x97	; 151
     a08:	99 e0       	ldi	r25, 0x09	; 9
     a0a:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     a0e:	88 8f       	std	Y+24, r24	; 0x18
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	1f 91       	pop	r17
     a16:	0f 91       	pop	r16
     a18:	08 95       	ret

00000a1a <_ZN6LSM30311writeMagRegEhh>:
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	ec 01       	movw	r28, r24
     a24:	06 2f       	mov	r16, r22
     a26:	14 2f       	mov	r17, r20
     a28:	6b 8d       	ldd	r22, Y+27	; 0x1b
     a2a:	87 e9       	ldi	r24, 0x97	; 151
     a2c:	99 e0       	ldi	r25, 0x09	; 9
     a2e:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
     a32:	60 2f       	mov	r22, r16
     a34:	87 e9       	ldi	r24, 0x97	; 151
     a36:	99 e0       	ldi	r25, 0x09	; 9
     a38:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
     a3c:	61 2f       	mov	r22, r17
     a3e:	87 e9       	ldi	r24, 0x97	; 151
     a40:	99 e0       	ldi	r25, 0x09	; 9
     a42:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
     a46:	87 e9       	ldi	r24, 0x97	; 151
     a48:	99 e0       	ldi	r25, 0x09	; 9
     a4a:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     a4e:	88 8f       	std	Y+24, r24	; 0x18
     a50:	df 91       	pop	r29
     a52:	cf 91       	pop	r28
     a54:	1f 91       	pop	r17
     a56:	0f 91       	pop	r16
     a58:	08 95       	ret

00000a5a <_ZN6LSM3038writeRegEhh>:
     a5a:	fc 01       	movw	r30, r24
     a5c:	21 8d       	ldd	r18, Z+25	; 0x19
     a5e:	23 30       	cpi	r18, 0x03	; 3
     a60:	11 f0       	breq	.+4      	; 0xa66 <_ZN6LSM3038writeRegEhh+0xc>
     a62:	60 32       	cpi	r22, 0x20	; 32
     a64:	10 f4       	brcc	.+4      	; 0xa6a <_ZN6LSM3038writeRegEhh+0x10>
     a66:	d9 cf       	rjmp	.-78     	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     a68:	08 95       	ret
     a6a:	b7 cf       	rjmp	.-146    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     a6c:	08 95       	ret

00000a6e <_ZN6LSM30313enableDefaultEv>:
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	ec 01       	movw	r28, r24
     a74:	89 8d       	ldd	r24, Y+25	; 0x19
     a76:	83 30       	cpi	r24, 0x03	; 3
     a78:	a9 f4       	brne	.+42     	; 0xaa4 <_ZN6LSM30313enableDefaultEv+0x36>
     a7a:	40 e0       	ldi	r20, 0x00	; 0
     a7c:	61 e2       	ldi	r22, 0x21	; 33
     a7e:	ce 01       	movw	r24, r28
     a80:	ec df       	rcall	.-40     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a82:	47 e5       	ldi	r20, 0x57	; 87
     a84:	60 e2       	ldi	r22, 0x20	; 32
     a86:	ce 01       	movw	r24, r28
     a88:	e8 df       	rcall	.-48     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a8a:	44 e6       	ldi	r20, 0x64	; 100
     a8c:	64 e2       	ldi	r22, 0x24	; 36
     a8e:	ce 01       	movw	r24, r28
     a90:	e4 df       	rcall	.-56     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a92:	40 e2       	ldi	r20, 0x20	; 32
     a94:	65 e2       	ldi	r22, 0x25	; 37
     a96:	ce 01       	movw	r24, r28
     a98:	e0 df       	rcall	.-64     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     a9a:	40 e0       	ldi	r20, 0x00	; 0
     a9c:	66 e2       	ldi	r22, 0x26	; 38
     a9e:	ce 01       	movw	r24, r28
     aa0:	dc df       	rcall	.-72     	; 0xa5a <_ZN6LSM3038writeRegEhh>
     aa2:	1f c0       	rjmp	.+62     	; 0xae2 <_ZN6LSM30313enableDefaultEv+0x74>
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	49 f4       	brne	.+18     	; 0xaba <_ZN6LSM30313enableDefaultEv+0x4c>
     aa8:	48 e0       	ldi	r20, 0x08	; 8
     aaa:	63 e2       	ldi	r22, 0x23	; 35
     aac:	ce 01       	movw	r24, r28
     aae:	95 df       	rcall	.-214    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     ab0:	47 e4       	ldi	r20, 0x47	; 71
     ab2:	60 e2       	ldi	r22, 0x20	; 32
     ab4:	ce 01       	movw	r24, r28
     ab6:	91 df       	rcall	.-222    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     ab8:	08 c0       	rjmp	.+16     	; 0xaca <_ZN6LSM30313enableDefaultEv+0x5c>
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	63 e2       	ldi	r22, 0x23	; 35
     abe:	ce 01       	movw	r24, r28
     ac0:	8c df       	rcall	.-232    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     ac2:	47 e2       	ldi	r20, 0x27	; 39
     ac4:	60 e2       	ldi	r22, 0x20	; 32
     ac6:	ce 01       	movw	r24, r28
     ac8:	88 df       	rcall	.-240    	; 0x9da <_ZN6LSM30311writeAccRegEhh>
     aca:	4c e0       	ldi	r20, 0x0C	; 12
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	ce 01       	movw	r24, r28
     ad0:	a4 df       	rcall	.-184    	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     ad2:	40 e2       	ldi	r20, 0x20	; 32
     ad4:	61 e0       	ldi	r22, 0x01	; 1
     ad6:	ce 01       	movw	r24, r28
     ad8:	a0 df       	rcall	.-192    	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     ada:	40 e0       	ldi	r20, 0x00	; 0
     adc:	62 e0       	ldi	r22, 0x02	; 2
     ade:	ce 01       	movw	r24, r28
     ae0:	9c df       	rcall	.-200    	; 0xa1a <_ZN6LSM30311writeMagRegEhh>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
     ae8:	9f 92       	push	r9
     aea:	af 92       	push	r10
     aec:	bf 92       	push	r11
     aee:	cf 92       	push	r12
     af0:	df 92       	push	r13
     af2:	ef 92       	push	r14
     af4:	ff 92       	push	r15
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
     b00:	6a 8d       	ldd	r22, Y+26	; 0x1a
     b02:	87 e9       	ldi	r24, 0x97	; 151
     b04:	99 e0       	ldi	r25, 0x09	; 9
     b06:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
     b0a:	e0 91 97 09 	lds	r30, 0x0997
     b0e:	f0 91 98 09 	lds	r31, 0x0998
     b12:	01 90       	ld	r0, Z+
     b14:	f0 81       	ld	r31, Z
     b16:	e0 2d       	mov	r30, r0
     b18:	68 ea       	ldi	r22, 0xA8	; 168
     b1a:	87 e9       	ldi	r24, 0x97	; 151
     b1c:	99 e0       	ldi	r25, 0x09	; 9
     b1e:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
     b20:	87 e9       	ldi	r24, 0x97	; 151
     b22:	99 e0       	ldi	r25, 0x09	; 9
     b24:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     b28:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
     b2a:	46 e0       	ldi	r20, 0x06	; 6
     b2c:	6a 8d       	ldd	r22, Y+26	; 0x1a
     b2e:	87 e9       	ldi	r24, 0x97	; 151
     b30:	99 e0       	ldi	r25, 0x09	; 9
     b32:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     b36:	0e 94 0c 19 	call	0x3218	; 0x3218 <millis>
     b3a:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     b3c:	10 c0       	rjmp	.+32     	; 0xb5e <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     b3e:	8b a1       	ldd	r24, Y+35	; 0x23
     b40:	9c a1       	ldd	r25, Y+36	; 0x24
     b42:	89 2b       	or	r24, r25
     b44:	61 f0       	breq	.+24     	; 0xb5e <_ZN6LSM3037readAccEv+0x76>
     b46:	0e 94 0c 19 	call	0x3218	; 0x3218 <millis>
     b4a:	60 1b       	sub	r22, r16
     b4c:	71 0b       	sbc	r23, r17
     b4e:	8b a1       	ldd	r24, Y+35	; 0x23
     b50:	9c a1       	ldd	r25, Y+36	; 0x24
     b52:	86 17       	cp	r24, r22
     b54:	97 07       	cpc	r25, r23
     b56:	18 f4       	brcc	.+6      	; 0xb5e <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	8d a3       	std	Y+37, r24	; 0x25
      return;
     b5c:	32 c0       	rjmp	.+100    	; 0xbc2 <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     b5e:	87 e9       	ldi	r24, 0x97	; 151
     b60:	99 e0       	ldi	r25, 0x09	; 9
     b62:	0e 94 ca 11 	call	0x2394	; 0x2394 <_ZN7TwoWire9availableEv>
     b66:	06 97       	sbiw	r24, 0x06	; 6
     b68:	54 f3       	brlt	.-44     	; 0xb3e <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
     b6a:	87 e9       	ldi	r24, 0x97	; 151
     b6c:	99 e0       	ldi	r25, 0x09	; 9
     b6e:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     b72:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
     b74:	87 e9       	ldi	r24, 0x97	; 151
     b76:	99 e0       	ldi	r25, 0x09	; 9
     b78:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     b7c:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
     b7e:	87 e9       	ldi	r24, 0x97	; 151
     b80:	99 e0       	ldi	r25, 0x09	; 9
     b82:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     b86:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
     b88:	87 e9       	ldi	r24, 0x97	; 151
     b8a:	99 e0       	ldi	r25, 0x09	; 9
     b8c:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     b90:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
     b92:	87 e9       	ldi	r24, 0x97	; 151
     b94:	99 e0       	ldi	r25, 0x09	; 9
     b96:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     b9a:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
     b9c:	87 e9       	ldi	r24, 0x97	; 151
     b9e:	99 e0       	ldi	r25, 0x09	; 9
     ba0:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
     ba4:	d9 2c       	mov	r13, r9
     ba6:	c1 2c       	mov	r12, r1
     ba8:	ca 28       	or	r12, r10
     baa:	d9 82       	std	Y+1, r13	; 0x01
     bac:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
     bae:	fb 2c       	mov	r15, r11
     bb0:	e1 2c       	mov	r14, r1
     bb2:	e0 2a       	or	r14, r16
     bb4:	fb 82       	std	Y+3, r15	; 0x03
     bb6:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
     bb8:	98 2f       	mov	r25, r24
     bba:	88 27       	eor	r24, r24
     bbc:	81 2b       	or	r24, r17
     bbe:	9d 83       	std	Y+5, r25	; 0x05
     bc0:	8c 83       	std	Y+4, r24	; 0x04
}
     bc2:	df 91       	pop	r29
     bc4:	cf 91       	pop	r28
     bc6:	1f 91       	pop	r17
     bc8:	0f 91       	pop	r16
     bca:	ff 90       	pop	r15
     bcc:	ef 90       	pop	r14
     bce:	df 90       	pop	r13
     bd0:	cf 90       	pop	r12
     bd2:	bf 90       	pop	r11
     bd4:	af 90       	pop	r10
     bd6:	9f 90       	pop	r9
     bd8:	08 95       	ret

00000bda <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
     bec:	6b 8d       	ldd	r22, Y+27	; 0x1b
     bee:	87 e9       	ldi	r24, 0x97	; 151
     bf0:	99 e0       	ldi	r25, 0x09	; 9
     bf2:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
     bf6:	89 8d       	ldd	r24, Y+25	; 0x19
     bf8:	83 30       	cpi	r24, 0x03	; 3
     bfa:	31 f4       	brne	.+12     	; 0xc08 <_ZN6LSM3037readMagEv+0x2e>
     bfc:	6e 8d       	ldd	r22, Y+30	; 0x1e
     bfe:	77 27       	eor	r23, r23
     c00:	67 fd       	sbrc	r22, 7
     c02:	70 95       	com	r23
     c04:	60 68       	ori	r22, 0x80	; 128
     c06:	04 c0       	rjmp	.+8      	; 0xc10 <_ZN6LSM3037readMagEv+0x36>
     c08:	6d 8d       	ldd	r22, Y+29	; 0x1d
     c0a:	77 27       	eor	r23, r23
     c0c:	67 fd       	sbrc	r22, 7
     c0e:	70 95       	com	r23
     c10:	e0 91 97 09 	lds	r30, 0x0997
     c14:	f0 91 98 09 	lds	r31, 0x0998
     c18:	01 90       	ld	r0, Z+
     c1a:	f0 81       	ld	r31, Z
     c1c:	e0 2d       	mov	r30, r0
     c1e:	87 e9       	ldi	r24, 0x97	; 151
     c20:	99 e0       	ldi	r25, 0x09	; 9
     c22:	19 95       	eicall
  last_status = Wire.endTransmission();
     c24:	87 e9       	ldi	r24, 0x97	; 151
     c26:	99 e0       	ldi	r25, 0x09	; 9
     c28:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     c2c:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
     c2e:	46 e0       	ldi	r20, 0x06	; 6
     c30:	6b 8d       	ldd	r22, Y+27	; 0x1b
     c32:	87 e9       	ldi	r24, 0x97	; 151
     c34:	99 e0       	ldi	r25, 0x09	; 9
     c36:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     c3a:	0e 94 0c 19 	call	0x3218	; 0x3218 <millis>
     c3e:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     c40:	10 c0       	rjmp	.+32     	; 0xc62 <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     c42:	8b a1       	ldd	r24, Y+35	; 0x23
     c44:	9c a1       	ldd	r25, Y+36	; 0x24
     c46:	89 2b       	or	r24, r25
     c48:	61 f0       	breq	.+24     	; 0xc62 <_ZN6LSM3037readMagEv+0x88>
     c4a:	0e 94 0c 19 	call	0x3218	; 0x3218 <millis>
     c4e:	60 1b       	sub	r22, r16
     c50:	71 0b       	sbc	r23, r17
     c52:	8b a1       	ldd	r24, Y+35	; 0x23
     c54:	9c a1       	ldd	r25, Y+36	; 0x24
     c56:	86 17       	cp	r24, r22
     c58:	97 07       	cpc	r25, r23
     c5a:	18 f4       	brcc	.+6      	; 0xc62 <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	8d a3       	std	Y+37, r24	; 0x25
      return;
     c60:	6e c0       	rjmp	.+220    	; 0xd3e <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     c62:	87 e9       	ldi	r24, 0x97	; 151
     c64:	99 e0       	ldi	r25, 0x09	; 9
     c66:	0e 94 ca 11 	call	0x2394	; 0x2394 <_ZN7TwoWire9availableEv>
     c6a:	06 97       	sbiw	r24, 0x06	; 6
     c6c:	54 f3       	brlt	.-44     	; 0xc42 <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
     c6e:	89 8d       	ldd	r24, Y+25	; 0x19
     c70:	83 30       	cpi	r24, 0x03	; 3
     c72:	f9 f4       	brne	.+62     	; 0xcb2 <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
     c74:	87 e9       	ldi	r24, 0x97	; 151
     c76:	99 e0       	ldi	r25, 0x09	; 9
     c78:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     c7c:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
     c7e:	87 e9       	ldi	r24, 0x97	; 151
     c80:	99 e0       	ldi	r25, 0x09	; 9
     c82:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     c86:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
     c88:	87 e9       	ldi	r24, 0x97	; 151
     c8a:	99 e0       	ldi	r25, 0x09	; 9
     c8c:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     c90:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
     c92:	87 e9       	ldi	r24, 0x97	; 151
     c94:	99 e0       	ldi	r25, 0x09	; 9
     c96:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     c9a:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
     c9c:	87 e9       	ldi	r24, 0x97	; 151
     c9e:	99 e0       	ldi	r25, 0x09	; 9
     ca0:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     ca4:	08 2f       	mov	r16, r24
    zhm = Wire.read();
     ca6:	87 e9       	ldi	r24, 0x97	; 151
     ca8:	99 e0       	ldi	r25, 0x09	; 9
     caa:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cae:	18 2f       	mov	r17, r24
     cb0:	36 c0       	rjmp	.+108    	; 0xd1e <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
     cb2:	87 e9       	ldi	r24, 0x97	; 151
     cb4:	99 e0       	ldi	r25, 0x09	; 9
     cb6:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cba:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
     cbc:	87 e9       	ldi	r24, 0x97	; 151
     cbe:	99 e0       	ldi	r25, 0x09	; 9
     cc0:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cc4:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
     cc6:	89 8d       	ldd	r24, Y+25	; 0x19
     cc8:	81 11       	cpse	r24, r1
     cca:	15 c0       	rjmp	.+42     	; 0xcf6 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
     ccc:	87 e9       	ldi	r24, 0x97	; 151
     cce:	99 e0       	ldi	r25, 0x09	; 9
     cd0:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cd4:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
     cd6:	87 e9       	ldi	r24, 0x97	; 151
     cd8:	99 e0       	ldi	r25, 0x09	; 9
     cda:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cde:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
     ce0:	87 e9       	ldi	r24, 0x97	; 151
     ce2:	99 e0       	ldi	r25, 0x09	; 9
     ce4:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     ce8:	18 2f       	mov	r17, r24
      zlm = Wire.read();
     cea:	87 e9       	ldi	r24, 0x97	; 151
     cec:	99 e0       	ldi	r25, 0x09	; 9
     cee:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cf2:	08 2f       	mov	r16, r24
     cf4:	14 c0       	rjmp	.+40     	; 0xd1e <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
     cf6:	87 e9       	ldi	r24, 0x97	; 151
     cf8:	99 e0       	ldi	r25, 0x09	; 9
     cfa:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     cfe:	18 2f       	mov	r17, r24
      zlm = Wire.read();
     d00:	87 e9       	ldi	r24, 0x97	; 151
     d02:	99 e0       	ldi	r25, 0x09	; 9
     d04:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     d08:	08 2f       	mov	r16, r24
      yhm = Wire.read();
     d0a:	87 e9       	ldi	r24, 0x97	; 151
     d0c:	99 e0       	ldi	r25, 0x09	; 9
     d0e:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     d12:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
     d14:	87 e9       	ldi	r24, 0x97	; 151
     d16:	99 e0       	ldi	r25, 0x09	; 9
     d18:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     d1c:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
     d1e:	6c 2d       	mov	r22, r12
     d20:	70 e0       	ldi	r23, 0x00	; 0
     d22:	7d 29       	or	r23, r13
     d24:	7f 83       	std	Y+7, r23	; 0x07
     d26:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
     d28:	4e 2d       	mov	r20, r14
     d2a:	50 e0       	ldi	r21, 0x00	; 0
     d2c:	5f 29       	or	r21, r15
     d2e:	59 87       	std	Y+9, r21	; 0x09
     d30:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
     d32:	20 2f       	mov	r18, r16
     d34:	30 e0       	ldi	r19, 0x00	; 0
     d36:	c9 01       	movw	r24, r18
     d38:	91 2b       	or	r25, r17
     d3a:	9b 87       	std	Y+11, r25	; 0x0b
     d3c:	8a 87       	std	Y+10, r24	; 0x0a
}
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	ff 90       	pop	r15
     d48:	ef 90       	pop	r14
     d4a:	df 90       	pop	r13
     d4c:	cf 90       	pop	r12
     d4e:	08 95       	ret

00000d50 <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	ec 01       	movw	r28, r24
  readAcc();
     d56:	c8 de       	rcall	.-624    	; 0xae8 <_ZN6LSM3037readAccEv>
  readMag();
     d58:	ce 01       	movw	r24, r28
     d5a:	3f df       	rcall	.-386    	; 0xbda <_ZN6LSM3037readMagEv>
}
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	08 95       	ret

00000d62 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
     d62:	cf 93       	push	r28
     d64:	df 93       	push	r29
     d66:	c6 2f       	mov	r28, r22
     d68:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     d6a:	87 e9       	ldi	r24, 0x97	; 151
     d6c:	99 e0       	ldi	r25, 0x09	; 9
     d6e:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     d72:	6d 2f       	mov	r22, r29
     d74:	87 e9       	ldi	r24, 0x97	; 151
     d76:	99 e0       	ldi	r25, 0x09	; 9
     d78:	0e 94 24 12 	call	0x2448	; 0x2448 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     d7c:	87 e9       	ldi	r24, 0x97	; 151
     d7e:	99 e0       	ldi	r25, 0x09	; 9
     d80:	0e 94 99 12 	call	0x2532	; 0x2532 <_ZN7TwoWire15endTransmissionEv>
     d84:	81 11       	cpse	r24, r1
     d86:	11 c0       	rjmp	.+34     	; 0xdaa <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     d88:	41 e0       	ldi	r20, 0x01	; 1
     d8a:	6c 2f       	mov	r22, r28
     d8c:	87 e9       	ldi	r24, 0x97	; 151
     d8e:	99 e0       	ldi	r25, 0x09	; 9
     d90:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     d94:	87 e9       	ldi	r24, 0x97	; 151
     d96:	99 e0       	ldi	r25, 0x09	; 9
     d98:	0e 94 ca 11 	call	0x2394	; 0x2394 <_ZN7TwoWire9availableEv>
     d9c:	89 2b       	or	r24, r25
     d9e:	41 f0       	breq	.+16     	; 0xdb0 <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     da0:	87 e9       	ldi	r24, 0x97	; 151
     da2:	99 e0       	ldi	r25, 0x09	; 9
     da4:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <_ZN7TwoWire4readEv>
     da8:	05 c0       	rjmp	.+10     	; 0xdb4 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     daa:	8f ef       	ldi	r24, 0xFF	; 255
     dac:	9f ef       	ldi	r25, 0xFF	; 255
     dae:	02 c0       	rjmp	.+4      	; 0xdb4 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     db0:	8f ef       	ldi	r24, 0xFF	; 255
     db2:	9f ef       	ldi	r25, 0xFF	; 255
  }
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	08 95       	ret

00000dba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
     dba:	0f 93       	push	r16
     dbc:	1f 93       	push	r17
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	ec 01       	movw	r28, r24
     dc4:	16 2f       	mov	r17, r22
     dc6:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     dc8:	64 30       	cpi	r22, 0x04	; 4
     dca:	09 f4       	brne	.+2      	; 0xdce <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
     dcc:	ad c0       	rjmp	.+346    	; 0xf28 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
     dce:	42 30       	cpi	r20, 0x02	; 2
     dd0:	09 f0       	breq	.+2      	; 0xdd4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
     dd2:	47 c0       	rjmp	.+142    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     dd4:	ad c0       	rjmp	.+346    	; 0xf30 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     dd6:	4f e0       	ldi	r20, 0x0F	; 15
     dd8:	6d e1       	ldi	r22, 0x1D	; 29
     dda:	ce 01       	movw	r24, r28
     ddc:	c2 df       	rcall	.-124    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     dde:	89 34       	cpi	r24, 0x49	; 73
     de0:	91 05       	cpc	r25, r1
     de2:	09 f4       	brne	.+2      	; 0xde6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
     de4:	ab c0       	rjmp	.+342    	; 0xf3c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
     de6:	01 30       	cpi	r16, 0x01	; 1
     de8:	41 f0       	breq	.+16     	; 0xdfa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     dea:	4f e0       	ldi	r20, 0x0F	; 15
     dec:	6e e1       	ldi	r22, 0x1E	; 30
     dee:	ce 01       	movw	r24, r28
     df0:	b8 df       	rcall	.-144    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     df2:	89 34       	cpi	r24, 0x49	; 73
     df4:	91 05       	cpc	r25, r1
     df6:	09 f4       	brne	.+2      	; 0xdfa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     df8:	a3 c0       	rjmp	.+326    	; 0xf40 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
     dfa:	14 30       	cpi	r17, 0x04	; 4
     dfc:	11 f0       	breq	.+4      	; 0xe02 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
     dfe:	13 30       	cpi	r17, 0x03	; 3
     e00:	68 f5       	brcc	.+90     	; 0xe5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     e02:	00 23       	and	r16, r16
     e04:	a9 f0       	breq	.+42     	; 0xe30 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
     e06:	40 e2       	ldi	r20, 0x20	; 32
     e08:	69 e1       	ldi	r22, 0x19	; 25
     e0a:	ce 01       	movw	r24, r28
     e0c:	aa df       	rcall	.-172    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e0e:	01 96       	adiw	r24, 0x01	; 1
     e10:	69 f0       	breq	.+26     	; 0xe2c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
     e12:	14 30       	cpi	r17, 0x04	; 4
     e14:	09 f0       	breq	.+2      	; 0xe18 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
     e16:	99 c0       	rjmp	.+306    	; 0xf4a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     e18:	4f e0       	ldi	r20, 0x0F	; 15
     e1a:	6e e1       	ldi	r22, 0x1E	; 30
     e1c:	ce 01       	movw	r24, r28
     e1e:	a1 df       	rcall	.-190    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e20:	cc 97       	sbiw	r24, 0x3c	; 60
     e22:	09 f0       	breq	.+2      	; 0xe26 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
     e24:	94 c0       	rjmp	.+296    	; 0xf4e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     e26:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     e28:	12 e0       	ldi	r17, 0x02	; 2
     e2a:	1b c0       	rjmp	.+54     	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     e2c:	01 30       	cpi	r16, 0x01	; 1
     e2e:	99 f0       	breq	.+38     	; 0xe56 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
     e30:	40 e2       	ldi	r20, 0x20	; 32
     e32:	68 e1       	ldi	r22, 0x18	; 24
     e34:	ce 01       	movw	r24, r28
     e36:	95 df       	rcall	.-214    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e38:	01 96       	adiw	r24, 0x01	; 1
     e3a:	69 f0       	breq	.+26     	; 0xe56 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
     e3c:	14 30       	cpi	r17, 0x04	; 4
     e3e:	09 f0       	breq	.+2      	; 0xe42 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
     e40:	89 c0       	rjmp	.+274    	; 0xf54 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
     e42:	4f e0       	ldi	r20, 0x0F	; 15
     e44:	6e e1       	ldi	r22, 0x1E	; 30
     e46:	ce 01       	movw	r24, r28
     e48:	8c df       	rcall	.-232    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e4a:	11 e0       	ldi	r17, 0x01	; 1
     e4c:	cc 97       	sbiw	r24, 0x3c	; 60
     e4e:	09 f0       	breq	.+2      	; 0xe52 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
     e50:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     e52:	00 e0       	ldi	r16, 0x00	; 0
     e54:	06 c0       	rjmp	.+12     	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     e56:	14 30       	cpi	r17, 0x04	; 4
     e58:	09 f4       	brne	.+2      	; 0xe5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
     e5a:	60 c0       	rjmp	.+192    	; 0xf1c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
     e5c:	02 30       	cpi	r16, 0x02	; 2
     e5e:	09 f4       	brne	.+2      	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     e60:	5f c0       	rjmp	.+190    	; 0xf20 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
     e62:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
     e64:	11 30       	cpi	r17, 0x01	; 1
     e66:	71 f1       	breq	.+92     	; 0xec4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
     e68:	08 f4       	brcc	.+2      	; 0xe6c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
     e6a:	42 c0       	rjmp	.+132    	; 0xef0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
     e6c:	12 30       	cpi	r17, 0x02	; 2
     e6e:	c1 f0       	breq	.+48     	; 0xea0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
     e70:	13 30       	cpi	r17, 0x03	; 3
     e72:	09 f0       	breq	.+2      	; 0xe76 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
     e74:	57 c0       	rjmp	.+174    	; 0xf24 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
     e76:	01 30       	cpi	r16, 0x01	; 1
     e78:	11 f4       	brne	.+4      	; 0xe7e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
     e7a:	8d e1       	ldi	r24, 0x1D	; 29
     e7c:	01 c0       	rjmp	.+2      	; 0xe80 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
     e7e:	8e e1       	ldi	r24, 0x1E	; 30
     e80:	8b 8f       	std	Y+27, r24	; 0x1b
     e82:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
     e84:	88 e0       	ldi	r24, 0x08	; 8
     e86:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
     e88:	89 e0       	ldi	r24, 0x09	; 9
     e8a:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
     e8c:	8a e0       	ldi	r24, 0x0A	; 10
     e8e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
     e90:	8b e0       	ldi	r24, 0x0B	; 11
     e92:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
     e94:	8c e0       	ldi	r24, 0x0C	; 12
     e96:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
     e98:	8d e0       	ldi	r24, 0x0D	; 13
     e9a:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     e9c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
     e9e:	64 c0       	rjmp	.+200    	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
     ea0:	89 e1       	ldi	r24, 0x19	; 25
     ea2:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     ea4:	8e e1       	ldi	r24, 0x1E	; 30
     ea6:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
     ea8:	83 e0       	ldi	r24, 0x03	; 3
     eaa:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
     eac:	84 e0       	ldi	r24, 0x04	; 4
     eae:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
     eb0:	87 e0       	ldi	r24, 0x07	; 7
     eb2:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
     eb4:	88 e0       	ldi	r24, 0x08	; 8
     eb6:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
     eb8:	85 e0       	ldi	r24, 0x05	; 5
     eba:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
     ebc:	86 e0       	ldi	r24, 0x06	; 6
     ebe:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     ec0:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
     ec2:	52 c0       	rjmp	.+164    	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     ec4:	01 30       	cpi	r16, 0x01	; 1
     ec6:	11 f4       	brne	.+4      	; 0xecc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
     ec8:	89 e1       	ldi	r24, 0x19	; 25
     eca:	01 c0       	rjmp	.+2      	; 0xece <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
     ecc:	88 e1       	ldi	r24, 0x18	; 24
     ece:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     ed0:	8e e1       	ldi	r24, 0x1E	; 30
     ed2:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
     ed4:	83 e0       	ldi	r24, 0x03	; 3
     ed6:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
     ed8:	84 e0       	ldi	r24, 0x04	; 4
     eda:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
     edc:	87 e0       	ldi	r24, 0x07	; 7
     ede:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
     ee0:	88 e0       	ldi	r24, 0x08	; 8
     ee2:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
     ee4:	85 e0       	ldi	r24, 0x05	; 5
     ee6:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
     ee8:	86 e0       	ldi	r24, 0x06	; 6
     eea:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     eec:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
     eee:	3c c0       	rjmp	.+120    	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     ef0:	01 30       	cpi	r16, 0x01	; 1
     ef2:	11 f4       	brne	.+4      	; 0xef8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
     ef4:	89 e1       	ldi	r24, 0x19	; 25
     ef6:	01 c0       	rjmp	.+2      	; 0xefa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
     ef8:	88 e1       	ldi	r24, 0x18	; 24
     efa:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     efc:	8e e1       	ldi	r24, 0x1E	; 30
     efe:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
     f00:	83 e0       	ldi	r24, 0x03	; 3
     f02:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
     f04:	84 e0       	ldi	r24, 0x04	; 4
     f06:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
     f08:	85 e0       	ldi	r24, 0x05	; 5
     f0a:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
     f0c:	86 e0       	ldi	r24, 0x06	; 6
     f0e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
     f10:	87 e0       	ldi	r24, 0x07	; 7
     f12:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
     f14:	88 e0       	ldi	r24, 0x08	; 8
     f16:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
     f18:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
     f1a:	26 c0       	rjmp	.+76     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	24 c0       	rjmp	.+72     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
     f20:	80 e0       	ldi	r24, 0x00	; 0
     f22:	22 c0       	rjmp	.+68     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	20 c0       	rjmp	.+64     	; 0xf68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     f28:	44 23       	and	r20, r20
     f2a:	09 f4       	brne	.+2      	; 0xf2e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
     f2c:	5e cf       	rjmp	.-324    	; 0xdea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
     f2e:	53 cf       	rjmp	.-346    	; 0xdd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
     f30:	8d ef       	ldi	r24, 0xFD	; 253
     f32:	86 0f       	add	r24, r22
     f34:	82 30       	cpi	r24, 0x02	; 2
     f36:	08 f0       	brcs	.+2      	; 0xf3a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
     f38:	62 cf       	rjmp	.-316    	; 0xdfe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
     f3a:	0e c0       	rjmp	.+28     	; 0xf58 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     f3c:	01 e0       	ldi	r16, 0x01	; 1
     f3e:	03 c0       	rjmp	.+6      	; 0xf46 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
     f40:	00 e0       	ldi	r16, 0x00	; 0
     f42:	01 c0       	rjmp	.+2      	; 0xf46 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     f44:	01 e0       	ldi	r16, 0x01	; 1
     f46:	13 e0       	ldi	r17, 0x03	; 3
     f48:	89 cf       	rjmp	.-238    	; 0xe5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     f4a:	01 e0       	ldi	r16, 0x01	; 1
     f4c:	8a cf       	rjmp	.-236    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     f4e:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     f50:	10 e0       	ldi	r17, 0x00	; 0
     f52:	87 cf       	rjmp	.-242    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     f54:	00 e0       	ldi	r16, 0x00	; 0
     f56:	85 cf       	rjmp	.-246    	; 0xe62 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     f58:	4f e0       	ldi	r20, 0x0F	; 15
     f5a:	6d e1       	ldi	r22, 0x1D	; 29
     f5c:	ce 01       	movw	r24, r28
     f5e:	01 df       	rcall	.-510    	; 0xd62 <_ZN6LSM3037testRegEhNS_7regAddrE>
     f60:	89 34       	cpi	r24, 0x49	; 73
     f62:	91 05       	cpc	r25, r1
     f64:	79 f3       	breq	.-34     	; 0xf44 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
     f66:	41 cf       	rjmp	.-382    	; 0xdea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
     f68:	df 91       	pop	r29
     f6a:	cf 91       	pop	r28
     f6c:	1f 91       	pop	r17
     f6e:	0f 91       	pop	r16
     f70:	08 95       	ret

00000f72 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     f72:	31 e1       	ldi	r19, 0x11	; 17
     f74:	fc 01       	movw	r30, r24
     f76:	30 83       	st	Z, r19
     f78:	31 97       	sbiw	r30, 0x01	; 1
     f7a:	22 e2       	ldi	r18, 0x22	; 34
     f7c:	20 83       	st	Z, r18
     f7e:	31 97       	sbiw	r30, 0x01	; 1
     f80:	a3 e3       	ldi	r26, 0x33	; 51
     f82:	a0 83       	st	Z, r26
     f84:	31 97       	sbiw	r30, 0x01	; 1
     f86:	60 83       	st	Z, r22
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	70 83       	st	Z, r23
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	10 82       	st	Z, r1
     f90:	31 97       	sbiw	r30, 0x01	; 1
     f92:	10 82       	st	Z, r1
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	60 e8       	ldi	r22, 0x80	; 128
     f98:	60 83       	st	Z, r22
     f9a:	31 97       	sbiw	r30, 0x01	; 1
     f9c:	10 82       	st	Z, r1
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	10 82       	st	Z, r1
     fa2:	31 97       	sbiw	r30, 0x01	; 1
     fa4:	10 82       	st	Z, r1
     fa6:	31 97       	sbiw	r30, 0x01	; 1
     fa8:	62 e0       	ldi	r22, 0x02	; 2
     faa:	60 83       	st	Z, r22
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	63 e0       	ldi	r22, 0x03	; 3
     fb0:	60 83       	st	Z, r22
     fb2:	31 97       	sbiw	r30, 0x01	; 1
     fb4:	64 e0       	ldi	r22, 0x04	; 4
     fb6:	60 83       	st	Z, r22
     fb8:	31 97       	sbiw	r30, 0x01	; 1
     fba:	65 e0       	ldi	r22, 0x05	; 5
     fbc:	60 83       	st	Z, r22
     fbe:	31 97       	sbiw	r30, 0x01	; 1
     fc0:	66 e0       	ldi	r22, 0x06	; 6
     fc2:	60 83       	st	Z, r22
     fc4:	31 97       	sbiw	r30, 0x01	; 1
     fc6:	67 e0       	ldi	r22, 0x07	; 7
     fc8:	60 83       	st	Z, r22
     fca:	31 97       	sbiw	r30, 0x01	; 1
     fcc:	68 e0       	ldi	r22, 0x08	; 8
     fce:	60 83       	st	Z, r22
     fd0:	31 97       	sbiw	r30, 0x01	; 1
     fd2:	69 e0       	ldi	r22, 0x09	; 9
     fd4:	60 83       	st	Z, r22
     fd6:	31 97       	sbiw	r30, 0x01	; 1
     fd8:	60 e1       	ldi	r22, 0x10	; 16
     fda:	60 83       	st	Z, r22
     fdc:	31 97       	sbiw	r30, 0x01	; 1
     fde:	30 83       	st	Z, r19
     fe0:	31 97       	sbiw	r30, 0x01	; 1
     fe2:	32 e1       	ldi	r19, 0x12	; 18
     fe4:	30 83       	st	Z, r19
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	33 e1       	ldi	r19, 0x13	; 19
     fea:	30 83       	st	Z, r19
     fec:	31 97       	sbiw	r30, 0x01	; 1
     fee:	34 e1       	ldi	r19, 0x14	; 20
     ff0:	30 83       	st	Z, r19
     ff2:	31 97       	sbiw	r30, 0x01	; 1
     ff4:	35 e1       	ldi	r19, 0x15	; 21
     ff6:	30 83       	st	Z, r19
     ff8:	31 97       	sbiw	r30, 0x01	; 1
     ffa:	36 e1       	ldi	r19, 0x16	; 22
     ffc:	30 83       	st	Z, r19
     ffe:	31 97       	sbiw	r30, 0x01	; 1
    1000:	37 e1       	ldi	r19, 0x17	; 23
    1002:	30 83       	st	Z, r19
    1004:	31 97       	sbiw	r30, 0x01	; 1
    1006:	38 e1       	ldi	r19, 0x18	; 24
    1008:	30 83       	st	Z, r19
    100a:	31 97       	sbiw	r30, 0x01	; 1
    100c:	39 e1       	ldi	r19, 0x19	; 25
    100e:	30 83       	st	Z, r19
    1010:	31 97       	sbiw	r30, 0x01	; 1
    1012:	30 e2       	ldi	r19, 0x20	; 32
    1014:	30 83       	st	Z, r19
    1016:	31 97       	sbiw	r30, 0x01	; 1
    1018:	31 e2       	ldi	r19, 0x21	; 33
    101a:	30 83       	st	Z, r19
    101c:	31 97       	sbiw	r30, 0x01	; 1
    101e:	20 83       	st	Z, r18
    1020:	31 97       	sbiw	r30, 0x01	; 1
    1022:	23 e2       	ldi	r18, 0x23	; 35
    1024:	20 83       	st	Z, r18
    1026:	31 97       	sbiw	r30, 0x01	; 1
    1028:	40 83       	st	Z, r20
    102a:	31 97       	sbiw	r30, 0x01	; 1
    102c:	50 83       	st	Z, r21
    102e:	31 97       	sbiw	r30, 0x01	; 1
    1030:	26 e2       	ldi	r18, 0x26	; 38
    1032:	20 83       	st	Z, r18
    1034:	31 97       	sbiw	r30, 0x01	; 1
    1036:	27 e2       	ldi	r18, 0x27	; 39
    1038:	20 83       	st	Z, r18
    103a:	31 97       	sbiw	r30, 0x01	; 1
    103c:	28 e2       	ldi	r18, 0x28	; 40
    103e:	20 83       	st	Z, r18
    1040:	31 97       	sbiw	r30, 0x01	; 1
    1042:	29 e2       	ldi	r18, 0x29	; 41
    1044:	20 83       	st	Z, r18
    1046:	31 97       	sbiw	r30, 0x01	; 1
    1048:	20 e3       	ldi	r18, 0x30	; 48
    104a:	20 83       	st	Z, r18
    104c:	31 97       	sbiw	r30, 0x01	; 1
    104e:	21 e3       	ldi	r18, 0x31	; 49
    1050:	20 83       	st	Z, r18
    1052:	89 97       	sbiw	r24, 0x29	; 41
    1054:	08 95       	ret

00001056 <xPortStartScheduler>:
    1056:	82 e0       	ldi	r24, 0x02	; 2
    1058:	80 93 b0 00 	sts	0x00B0, r24
    105c:	10 92 b2 00 	sts	0x00B2, r1
    1060:	80 e3       	ldi	r24, 0x30	; 48
    1062:	80 93 b3 00 	sts	0x00B3, r24
    1066:	e0 e7       	ldi	r30, 0x70	; 112
    1068:	f0 e0       	ldi	r31, 0x00	; 0
    106a:	80 81       	ld	r24, Z
    106c:	82 60       	ori	r24, 0x02	; 2
    106e:	80 83       	st	Z, r24
    1070:	84 e0       	ldi	r24, 0x04	; 4
    1072:	80 93 b1 00 	sts	0x00B1, r24
    1076:	a0 91 27 09 	lds	r26, 0x0927
    107a:	b0 91 28 09 	lds	r27, 0x0928
    107e:	cd 91       	ld	r28, X+
    1080:	cd bf       	out	0x3d, r28	; 61
    1082:	dd 91       	ld	r29, X+
    1084:	de bf       	out	0x3e, r29	; 62
    1086:	ff 91       	pop	r31
    1088:	ef 91       	pop	r30
    108a:	df 91       	pop	r29
    108c:	cf 91       	pop	r28
    108e:	bf 91       	pop	r27
    1090:	af 91       	pop	r26
    1092:	9f 91       	pop	r25
    1094:	8f 91       	pop	r24
    1096:	7f 91       	pop	r23
    1098:	6f 91       	pop	r22
    109a:	5f 91       	pop	r21
    109c:	4f 91       	pop	r20
    109e:	3f 91       	pop	r19
    10a0:	2f 91       	pop	r18
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
    10a6:	ff 90       	pop	r15
    10a8:	ef 90       	pop	r14
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	bf 90       	pop	r11
    10b0:	af 90       	pop	r10
    10b2:	9f 90       	pop	r9
    10b4:	8f 90       	pop	r8
    10b6:	7f 90       	pop	r7
    10b8:	6f 90       	pop	r6
    10ba:	5f 90       	pop	r5
    10bc:	4f 90       	pop	r4
    10be:	3f 90       	pop	r3
    10c0:	2f 90       	pop	r2
    10c2:	1f 90       	pop	r1
    10c4:	0f 90       	pop	r0
    10c6:	0c be       	out	0x3c, r0	; 60
    10c8:	0f 90       	pop	r0
    10ca:	0b be       	out	0x3b, r0	; 59
    10cc:	0f 90       	pop	r0
    10ce:	0f be       	out	0x3f, r0	; 63
    10d0:	0f 90       	pop	r0
    10d2:	08 95       	ret
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	08 95       	ret

000010d8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    10d8:	0f 92       	push	r0
    10da:	0f b6       	in	r0, 0x3f	; 63
    10dc:	f8 94       	cli
    10de:	0f 92       	push	r0
    10e0:	0c b6       	in	r0, 0x3c	; 60
    10e2:	0f 92       	push	r0
    10e4:	0b b6       	in	r0, 0x3b	; 59
    10e6:	0f 92       	push	r0
    10e8:	1f 92       	push	r1
    10ea:	11 24       	eor	r1, r1
    10ec:	2f 92       	push	r2
    10ee:	3f 92       	push	r3
    10f0:	4f 92       	push	r4
    10f2:	5f 92       	push	r5
    10f4:	6f 92       	push	r6
    10f6:	7f 92       	push	r7
    10f8:	8f 92       	push	r8
    10fa:	9f 92       	push	r9
    10fc:	af 92       	push	r10
    10fe:	bf 92       	push	r11
    1100:	cf 92       	push	r12
    1102:	df 92       	push	r13
    1104:	ef 92       	push	r14
    1106:	ff 92       	push	r15
    1108:	0f 93       	push	r16
    110a:	1f 93       	push	r17
    110c:	2f 93       	push	r18
    110e:	3f 93       	push	r19
    1110:	4f 93       	push	r20
    1112:	5f 93       	push	r21
    1114:	6f 93       	push	r22
    1116:	7f 93       	push	r23
    1118:	8f 93       	push	r24
    111a:	9f 93       	push	r25
    111c:	af 93       	push	r26
    111e:	bf 93       	push	r27
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	ef 93       	push	r30
    1126:	ff 93       	push	r31
    1128:	a0 91 27 09 	lds	r26, 0x0927
    112c:	b0 91 28 09 	lds	r27, 0x0928
    1130:	0d b6       	in	r0, 0x3d	; 61
    1132:	0d 92       	st	X+, r0
    1134:	0e b6       	in	r0, 0x3e	; 62
    1136:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1138:	ba d6       	rcall	.+3444   	; 0x1eae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    113a:	a0 91 27 09 	lds	r26, 0x0927
    113e:	b0 91 28 09 	lds	r27, 0x0928
    1142:	cd 91       	ld	r28, X+
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	dd 91       	ld	r29, X+
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	ff 91       	pop	r31
    114c:	ef 91       	pop	r30
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	bf 91       	pop	r27
    1154:	af 91       	pop	r26
    1156:	9f 91       	pop	r25
    1158:	8f 91       	pop	r24
    115a:	7f 91       	pop	r23
    115c:	6f 91       	pop	r22
    115e:	5f 91       	pop	r21
    1160:	4f 91       	pop	r20
    1162:	3f 91       	pop	r19
    1164:	2f 91       	pop	r18
    1166:	1f 91       	pop	r17
    1168:	0f 91       	pop	r16
    116a:	ff 90       	pop	r15
    116c:	ef 90       	pop	r14
    116e:	df 90       	pop	r13
    1170:	cf 90       	pop	r12
    1172:	bf 90       	pop	r11
    1174:	af 90       	pop	r10
    1176:	9f 90       	pop	r9
    1178:	8f 90       	pop	r8
    117a:	7f 90       	pop	r7
    117c:	6f 90       	pop	r6
    117e:	5f 90       	pop	r5
    1180:	4f 90       	pop	r4
    1182:	3f 90       	pop	r3
    1184:	2f 90       	pop	r2
    1186:	1f 90       	pop	r1
    1188:	0f 90       	pop	r0
    118a:	0c be       	out	0x3c, r0	; 60
    118c:	0f 90       	pop	r0
    118e:	0b be       	out	0x3b, r0	; 59
    1190:	0f 90       	pop	r0
    1192:	0f be       	out	0x3f, r0	; 63
    1194:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1196:	08 95       	ret

00001198 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1198:	0f 92       	push	r0
    119a:	0f b6       	in	r0, 0x3f	; 63
    119c:	f8 94       	cli
    119e:	0f 92       	push	r0
    11a0:	0c b6       	in	r0, 0x3c	; 60
    11a2:	0f 92       	push	r0
    11a4:	0b b6       	in	r0, 0x3b	; 59
    11a6:	0f 92       	push	r0
    11a8:	1f 92       	push	r1
    11aa:	11 24       	eor	r1, r1
    11ac:	2f 92       	push	r2
    11ae:	3f 92       	push	r3
    11b0:	4f 92       	push	r4
    11b2:	5f 92       	push	r5
    11b4:	6f 92       	push	r6
    11b6:	7f 92       	push	r7
    11b8:	8f 92       	push	r8
    11ba:	9f 92       	push	r9
    11bc:	af 92       	push	r10
    11be:	bf 92       	push	r11
    11c0:	cf 92       	push	r12
    11c2:	df 92       	push	r13
    11c4:	ef 92       	push	r14
    11c6:	ff 92       	push	r15
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	2f 93       	push	r18
    11ce:	3f 93       	push	r19
    11d0:	4f 93       	push	r20
    11d2:	5f 93       	push	r21
    11d4:	6f 93       	push	r22
    11d6:	7f 93       	push	r23
    11d8:	8f 93       	push	r24
    11da:	9f 93       	push	r25
    11dc:	af 93       	push	r26
    11de:	bf 93       	push	r27
    11e0:	cf 93       	push	r28
    11e2:	df 93       	push	r29
    11e4:	ef 93       	push	r30
    11e6:	ff 93       	push	r31
    11e8:	a0 91 27 09 	lds	r26, 0x0927
    11ec:	b0 91 28 09 	lds	r27, 0x0928
    11f0:	0d b6       	in	r0, 0x3d	; 61
    11f2:	0d 92       	st	X+, r0
    11f4:	0e b6       	in	r0, 0x3e	; 62
    11f6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    11f8:	c6 d4       	rcall	.+2444   	; 0x1b86 <xTaskIncrementTick>
    11fa:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    11fc:	58 d6       	rcall	.+3248   	; 0x1eae <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    11fe:	a0 91 27 09 	lds	r26, 0x0927
    1202:	b0 91 28 09 	lds	r27, 0x0928
    1206:	cd 91       	ld	r28, X+
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	dd 91       	ld	r29, X+
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	ff 91       	pop	r31
    1210:	ef 91       	pop	r30
    1212:	df 91       	pop	r29
    1214:	cf 91       	pop	r28
    1216:	bf 91       	pop	r27
    1218:	af 91       	pop	r26
    121a:	9f 91       	pop	r25
    121c:	8f 91       	pop	r24
    121e:	7f 91       	pop	r23
    1220:	6f 91       	pop	r22
    1222:	5f 91       	pop	r21
    1224:	4f 91       	pop	r20
    1226:	3f 91       	pop	r19
    1228:	2f 91       	pop	r18
    122a:	1f 91       	pop	r17
    122c:	0f 91       	pop	r16
    122e:	ff 90       	pop	r15
    1230:	ef 90       	pop	r14
    1232:	df 90       	pop	r13
    1234:	cf 90       	pop	r12
    1236:	bf 90       	pop	r11
    1238:	af 90       	pop	r10
    123a:	9f 90       	pop	r9
    123c:	8f 90       	pop	r8
    123e:	7f 90       	pop	r7
    1240:	6f 90       	pop	r6
    1242:	5f 90       	pop	r5
    1244:	4f 90       	pop	r4
    1246:	3f 90       	pop	r3
    1248:	2f 90       	pop	r2
    124a:	1f 90       	pop	r1
    124c:	0f 90       	pop	r0
    124e:	0c be       	out	0x3c, r0	; 60
    1250:	0f 90       	pop	r0
    1252:	0b be       	out	0x3b, r0	; 59
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	0f 90       	pop	r0

	asm volatile ( "ret" );
    125a:	08 95       	ret

0000125c <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    125c:	9d df       	rcall	.-198    	; 0x1198 <vPortYieldFromTick>
	asm volatile ( "reti" );
    125e:	18 95       	reti

00001260 <_Z16taskReadInfraredPv>:
		//}
	}
}

void vApplicationIdleHook()
{
    1260:	ce e8       	ldi	r28, 0x8E	; 142
    1262:	d8 e0       	ldi	r29, 0x08	; 8
    1264:	80 e9       	ldi	r24, 0x90	; 144
    1266:	98 e0       	ldi	r25, 0x08	; 8
    1268:	c2 d2       	rcall	.+1412   	; 0x17ee <_ZN7SharpIR8distanceEv>
    126a:	99 83       	std	Y+1, r25	; 0x01
    126c:	88 83       	st	Y, r24
    126e:	88 ee       	ldi	r24, 0xE8	; 232
    1270:	93 e0       	ldi	r25, 0x03	; 3
    1272:	c8 d5       	rcall	.+2960   	; 0x1e04 <vTaskDelay>
    1274:	f7 cf       	rjmp	.-18     	; 0x1264 <_Z16taskReadInfraredPv+0x4>

00001276 <_Z13taskReadSonarPv>:
    1276:	c2 e0       	ldi	r28, 0x02	; 2
    1278:	d2 e0       	ldi	r29, 0x02	; 2
    127a:	04 e0       	ldi	r16, 0x04	; 4
    127c:	12 e0       	ldi	r17, 0x02	; 2
    127e:	0f 2e       	mov	r0, r31
    1280:	f0 e8       	ldi	r31, 0x80	; 128
    1282:	ef 2e       	mov	r14, r31
    1284:	f8 e0       	ldi	r31, 0x08	; 8
    1286:	ff 2e       	mov	r15, r31
    1288:	f0 2d       	mov	r31, r0
    128a:	60 e0       	ldi	r22, 0x00	; 0
    128c:	88 81       	ld	r24, Y
    128e:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <digitalWrite>
    1292:	85 e0       	ldi	r24, 0x05	; 5
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	0e 94 18 19 	call	0x3230	; 0x3230 <delayMicroseconds>
    129a:	61 e0       	ldi	r22, 0x01	; 1
    129c:	88 81       	ld	r24, Y
    129e:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <digitalWrite>
    12a2:	8a e0       	ldi	r24, 0x0A	; 10
    12a4:	90 e0       	ldi	r25, 0x00	; 0
    12a6:	0e 94 18 19 	call	0x3230	; 0x3230 <delayMicroseconds>
    12aa:	60 e0       	ldi	r22, 0x00	; 0
    12ac:	88 81       	ld	r24, Y
    12ae:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <digitalWrite>
    12b2:	60 e0       	ldi	r22, 0x00	; 0
    12b4:	f8 01       	movw	r30, r16
    12b6:	80 81       	ld	r24, Z
    12b8:	0e 94 12 1a 	call	0x3424	; 0x3424 <pinMode>
    12bc:	20 e4       	ldi	r18, 0x40	; 64
    12be:	32 e4       	ldi	r19, 0x42	; 66
    12c0:	4f e0       	ldi	r20, 0x0F	; 15
    12c2:	50 e0       	ldi	r21, 0x00	; 0
    12c4:	61 e0       	ldi	r22, 0x01	; 1
    12c6:	f8 01       	movw	r30, r16
    12c8:	80 81       	ld	r24, Z
    12ca:	0e 94 80 1a 	call	0x3500	; 0x3500 <pulseIn>
    12ce:	9b 01       	movw	r18, r22
    12d0:	77 23       	and	r23, r23
    12d2:	14 f4       	brge	.+4      	; 0x12d8 <_Z13taskReadSonarPv+0x62>
    12d4:	2f 5f       	subi	r18, 0xFF	; 255
    12d6:	3f 4f       	sbci	r19, 0xFF	; 255
    12d8:	b9 01       	movw	r22, r18
    12da:	75 95       	asr	r23
    12dc:	67 95       	ror	r22
    12de:	88 27       	eor	r24, r24
    12e0:	77 fd       	sbrc	r23, 7
    12e2:	80 95       	com	r24
    12e4:	98 2f       	mov	r25, r24
    12e6:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    12ea:	2d ec       	ldi	r18, 0xCD	; 205
    12ec:	3c ec       	ldi	r19, 0xCC	; 204
    12ee:	48 ee       	ldi	r20, 0xE8	; 232
    12f0:	51 e4       	ldi	r21, 0x41	; 65
    12f2:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    12f6:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    12fa:	f7 01       	movw	r30, r14
    12fc:	71 83       	std	Z+1, r23	; 0x01
    12fe:	60 83       	st	Z, r22
    1300:	88 e8       	ldi	r24, 0x88	; 136
    1302:	93 e1       	ldi	r25, 0x13	; 19
    1304:	7f d5       	rcall	.+2814   	; 0x1e04 <vTaskDelay>
    1306:	c1 cf       	rjmp	.-126    	; 0x128a <_Z13taskReadSonarPv+0x14>

00001308 <_Z11taskReadAccPv>:
    1308:	0f 2e       	mov	r0, r31
    130a:	fc ea       	ldi	r31, 0xAC	; 172
    130c:	af 2e       	mov	r10, r31
    130e:	f8 e0       	ldi	r31, 0x08	; 8
    1310:	bf 2e       	mov	r11, r31
    1312:	f0 2d       	mov	r31, r0
    1314:	0e ea       	ldi	r16, 0xAE	; 174
    1316:	18 e0       	ldi	r17, 0x08	; 8
    1318:	c2 e8       	ldi	r28, 0x82	; 130
    131a:	d8 e0       	ldi	r29, 0x08	; 8
    131c:	0f 2e       	mov	r0, r31
    131e:	f4 e8       	ldi	r31, 0x84	; 132
    1320:	8f 2e       	mov	r8, r31
    1322:	f8 e0       	ldi	r31, 0x08	; 8
    1324:	9f 2e       	mov	r9, r31
    1326:	f0 2d       	mov	r31, r0
    1328:	0f 2e       	mov	r0, r31
    132a:	f6 e8       	ldi	r31, 0x86	; 134
    132c:	2f 2e       	mov	r2, r31
    132e:	f8 e0       	ldi	r31, 0x08	; 8
    1330:	3f 2e       	mov	r3, r31
    1332:	f0 2d       	mov	r31, r0
    1334:	8a ea       	ldi	r24, 0xAA	; 170
    1336:	98 e0       	ldi	r25, 0x08	; 8
    1338:	0b dd       	rcall	.-1514   	; 0xd50 <_ZN6LSM3034readEv>
    133a:	f5 01       	movw	r30, r10
    133c:	60 81       	ld	r22, Z
    133e:	71 81       	ldd	r23, Z+1	; 0x01
    1340:	88 27       	eor	r24, r24
    1342:	77 fd       	sbrc	r23, 7
    1344:	80 95       	com	r24
    1346:	98 2f       	mov	r25, r24
    1348:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    134c:	20 e0       	ldi	r18, 0x00	; 0
    134e:	30 e0       	ldi	r19, 0x00	; 0
    1350:	4a e7       	ldi	r20, 0x7A	; 122
    1352:	54 e4       	ldi	r21, 0x44	; 68
    1354:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    1358:	20 e0       	ldi	r18, 0x00	; 0
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	44 e7       	ldi	r20, 0x74	; 116
    135e:	52 e4       	ldi	r21, 0x42	; 66
    1360:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    1364:	2f e6       	ldi	r18, 0x6F	; 111
    1366:	32 e1       	ldi	r19, 0x12	; 18
    1368:	43 e8       	ldi	r20, 0x83	; 131
    136a:	5a e3       	ldi	r21, 0x3A	; 58
    136c:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    1370:	2d ec       	ldi	r18, 0xCD	; 205
    1372:	3c ec       	ldi	r19, 0xCC	; 204
    1374:	4c e1       	ldi	r20, 0x1C	; 28
    1376:	51 e4       	ldi	r21, 0x41	; 65
    1378:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    137c:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    1380:	2b 01       	movw	r4, r22
    1382:	3c 01       	movw	r6, r24
    1384:	f8 01       	movw	r30, r16
    1386:	60 81       	ld	r22, Z
    1388:	71 81       	ldd	r23, Z+1	; 0x01
    138a:	88 27       	eor	r24, r24
    138c:	77 fd       	sbrc	r23, 7
    138e:	80 95       	com	r24
    1390:	98 2f       	mov	r25, r24
    1392:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    1396:	20 e0       	ldi	r18, 0x00	; 0
    1398:	30 e0       	ldi	r19, 0x00	; 0
    139a:	4a e7       	ldi	r20, 0x7A	; 122
    139c:	54 e4       	ldi	r21, 0x44	; 68
    139e:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    13a2:	20 e0       	ldi	r18, 0x00	; 0
    13a4:	30 e0       	ldi	r19, 0x00	; 0
    13a6:	44 e7       	ldi	r20, 0x74	; 116
    13a8:	52 e4       	ldi	r21, 0x42	; 66
    13aa:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    13ae:	2f e6       	ldi	r18, 0x6F	; 111
    13b0:	32 e1       	ldi	r19, 0x12	; 18
    13b2:	43 e8       	ldi	r20, 0x83	; 131
    13b4:	5a e3       	ldi	r21, 0x3A	; 58
    13b6:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    13ba:	2d ec       	ldi	r18, 0xCD	; 205
    13bc:	3c ec       	ldi	r19, 0xCC	; 204
    13be:	4c e1       	ldi	r20, 0x1C	; 28
    13c0:	51 e4       	ldi	r21, 0x41	; 65
    13c2:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    13c6:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    13ca:	6b 01       	movw	r12, r22
    13cc:	7c 01       	movw	r14, r24
    13ce:	80 91 aa 08 	lds	r24, 0x08AA
    13d2:	90 91 ab 08 	lds	r25, 0x08AB
    13d6:	bc 01       	movw	r22, r24
    13d8:	88 27       	eor	r24, r24
    13da:	77 fd       	sbrc	r23, 7
    13dc:	80 95       	com	r24
    13de:	98 2f       	mov	r25, r24
    13e0:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    13e4:	20 e0       	ldi	r18, 0x00	; 0
    13e6:	30 e0       	ldi	r19, 0x00	; 0
    13e8:	4a e7       	ldi	r20, 0x7A	; 122
    13ea:	54 e4       	ldi	r21, 0x44	; 68
    13ec:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    13f0:	20 e0       	ldi	r18, 0x00	; 0
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	44 e7       	ldi	r20, 0x74	; 116
    13f6:	52 e4       	ldi	r21, 0x42	; 66
    13f8:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    13fc:	2f e6       	ldi	r18, 0x6F	; 111
    13fe:	32 e1       	ldi	r19, 0x12	; 18
    1400:	43 e8       	ldi	r20, 0x83	; 131
    1402:	5a e3       	ldi	r21, 0x3A	; 58
    1404:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    1408:	2d ec       	ldi	r18, 0xCD	; 205
    140a:	3c ec       	ldi	r19, 0xCC	; 204
    140c:	4c e1       	ldi	r20, 0x1C	; 28
    140e:	51 e4       	ldi	r21, 0x41	; 65
    1410:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    1414:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    1418:	79 83       	std	Y+1, r23	; 0x01
    141a:	68 83       	st	Y, r22
    141c:	f4 01       	movw	r30, r8
    141e:	51 82       	std	Z+1, r5	; 0x01
    1420:	40 82       	st	Z, r4
    1422:	f1 01       	movw	r30, r2
    1424:	d1 82       	std	Z+1, r13	; 0x01
    1426:	c0 82       	st	Z, r12
    1428:	88 ee       	ldi	r24, 0xE8	; 232
    142a:	93 e0       	ldi	r25, 0x03	; 3
    142c:	eb d4       	rcall	.+2518   	; 0x1e04 <vTaskDelay>
    142e:	82 cf       	rjmp	.-252    	; 0x1334 <_Z11taskReadAccPv+0x2c>

00001430 <_Z12taskReadGyroPv>:
    1430:	0f 2e       	mov	r0, r31
    1432:	f0 ea       	ldi	r31, 0xA0	; 160
    1434:	af 2e       	mov	r10, r31
    1436:	f8 e0       	ldi	r31, 0x08	; 8
    1438:	bf 2e       	mov	r11, r31
    143a:	f0 2d       	mov	r31, r0
    143c:	02 ea       	ldi	r16, 0xA2	; 162
    143e:	18 e0       	ldi	r17, 0x08	; 8
    1440:	c8 e8       	ldi	r28, 0x88	; 136
    1442:	d8 e0       	ldi	r29, 0x08	; 8
    1444:	0f 2e       	mov	r0, r31
    1446:	fa e8       	ldi	r31, 0x8A	; 138
    1448:	8f 2e       	mov	r8, r31
    144a:	f8 e0       	ldi	r31, 0x08	; 8
    144c:	9f 2e       	mov	r9, r31
    144e:	f0 2d       	mov	r31, r0
    1450:	0f 2e       	mov	r0, r31
    1452:	fc e8       	ldi	r31, 0x8C	; 140
    1454:	2f 2e       	mov	r2, r31
    1456:	f8 e0       	ldi	r31, 0x08	; 8
    1458:	3f 2e       	mov	r3, r31
    145a:	f0 2d       	mov	r31, r0
    145c:	8e e9       	ldi	r24, 0x9E	; 158
    145e:	98 e0       	ldi	r25, 0x08	; 8
    1460:	d9 d8       	rcall	.-3662   	; 0x614 <_ZN3L3G4readEv>
    1462:	f5 01       	movw	r30, r10
    1464:	60 81       	ld	r22, Z
    1466:	71 81       	ldd	r23, Z+1	; 0x01
    1468:	88 27       	eor	r24, r24
    146a:	77 fd       	sbrc	r23, 7
    146c:	80 95       	com	r24
    146e:	98 2f       	mov	r25, r24
    1470:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    1474:	20 e0       	ldi	r18, 0x00	; 0
    1476:	30 e0       	ldi	r19, 0x00	; 0
    1478:	4c e0       	ldi	r20, 0x0C	; 12
    147a:	51 e4       	ldi	r21, 0x41	; 65
    147c:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    1480:	20 e0       	ldi	r18, 0x00	; 0
    1482:	30 e0       	ldi	r19, 0x00	; 0
    1484:	4a e7       	ldi	r20, 0x7A	; 122
    1486:	54 e4       	ldi	r21, 0x44	; 68
    1488:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    148c:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    1490:	2b 01       	movw	r4, r22
    1492:	3c 01       	movw	r6, r24
    1494:	f8 01       	movw	r30, r16
    1496:	60 81       	ld	r22, Z
    1498:	71 81       	ldd	r23, Z+1	; 0x01
    149a:	88 27       	eor	r24, r24
    149c:	77 fd       	sbrc	r23, 7
    149e:	80 95       	com	r24
    14a0:	98 2f       	mov	r25, r24
    14a2:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    14a6:	20 e0       	ldi	r18, 0x00	; 0
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	4c e0       	ldi	r20, 0x0C	; 12
    14ac:	51 e4       	ldi	r21, 0x41	; 65
    14ae:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    14b2:	20 e0       	ldi	r18, 0x00	; 0
    14b4:	30 e0       	ldi	r19, 0x00	; 0
    14b6:	4a e7       	ldi	r20, 0x7A	; 122
    14b8:	54 e4       	ldi	r21, 0x44	; 68
    14ba:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    14be:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    14c2:	6b 01       	movw	r12, r22
    14c4:	7c 01       	movw	r14, r24
    14c6:	80 91 9e 08 	lds	r24, 0x089E
    14ca:	90 91 9f 08 	lds	r25, 0x089F
    14ce:	bc 01       	movw	r22, r24
    14d0:	88 27       	eor	r24, r24
    14d2:	77 fd       	sbrc	r23, 7
    14d4:	80 95       	com	r24
    14d6:	98 2f       	mov	r25, r24
    14d8:	0e 94 a0 13 	call	0x2740	; 0x2740 <__floatsisf>
    14dc:	20 e0       	ldi	r18, 0x00	; 0
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	4c e0       	ldi	r20, 0x0C	; 12
    14e2:	51 e4       	ldi	r21, 0x41	; 65
    14e4:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    14e8:	20 e0       	ldi	r18, 0x00	; 0
    14ea:	30 e0       	ldi	r19, 0x00	; 0
    14ec:	4a e7       	ldi	r20, 0x7A	; 122
    14ee:	54 e4       	ldi	r21, 0x44	; 68
    14f0:	0e 94 05 13 	call	0x260a	; 0x260a <__divsf3>
    14f4:	0e 94 6d 13 	call	0x26da	; 0x26da <__fixsfsi>
    14f8:	79 83       	std	Y+1, r23	; 0x01
    14fa:	68 83       	st	Y, r22
    14fc:	f4 01       	movw	r30, r8
    14fe:	51 82       	std	Z+1, r5	; 0x01
    1500:	40 82       	st	Z, r4
    1502:	f1 01       	movw	r30, r2
    1504:	d1 82       	std	Z+1, r13	; 0x01
    1506:	c0 82       	st	Z, r12
    1508:	88 ee       	ldi	r24, 0xE8	; 232
    150a:	93 e0       	ldi	r25, 0x03	; 3
    150c:	7b d4       	rcall	.+2294   	; 0x1e04 <vTaskDelay>
    150e:	a6 cf       	rjmp	.-180    	; 0x145c <_Z12taskReadGyroPv+0x2c>

00001510 <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1510:	26 e0       	ldi	r18, 0x06	; 6
    1512:	40 e8       	ldi	r20, 0x80	; 128
    1514:	55 e2       	ldi	r21, 0x25	; 37
    1516:	60 e0       	ldi	r22, 0x00	; 0
    1518:	70 e0       	ldi	r23, 0x00	; 0
    151a:	89 ee       	ldi	r24, 0xE9	; 233
    151c:	99 e0       	ldi	r25, 0x09	; 9
    151e:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <_ZN14HardwareSerial5beginEmh>
	vSemaphoreCreateBinary(analogSema);
	xSemaphoreGive(gyroSema);*/
	// Starting up serial monitor
	Serial.begin(9600);
	// Setting up compass
	Wire.begin();
    1522:	87 e9       	ldi	r24, 0x97	; 151
    1524:	99 e0       	ldi	r25, 0x09	; 9
    1526:	d0 d7       	rcall	.+4000   	; 0x24c8 <_ZN7TwoWire5beginEv>
	compass.init();
    1528:	42 e0       	ldi	r20, 0x02	; 2
    152a:	64 e0       	ldi	r22, 0x04	; 4
    152c:	8a ea       	ldi	r24, 0xAA	; 170
    152e:	98 e0       	ldi	r25, 0x08	; 8
    1530:	44 dc       	rcall	.-1912   	; 0xdba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    1532:	8a ea       	ldi	r24, 0xAA	; 170
    1534:	98 e0       	ldi	r25, 0x08	; 8
    1536:	9b da       	rcall	.-2762   	; 0xa6e <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    1538:	86 e0       	ldi	r24, 0x06	; 6
    153a:	e5 e1       	ldi	r30, 0x15	; 21
    153c:	f2 e0       	ldi	r31, 0x02	; 2
    153e:	ac eb       	ldi	r26, 0xBC	; 188
    1540:	b8 e0       	ldi	r27, 0x08	; 8
    1542:	01 90       	ld	r0, Z+
    1544:	0d 92       	st	X+, r0
    1546:	8a 95       	dec	r24
    1548:	e1 f7       	brne	.-8      	; 0x1542 <setup+0x32>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    154a:	86 e0       	ldi	r24, 0x06	; 6
    154c:	eb e1       	ldi	r30, 0x1B	; 27
    154e:	f2 e0       	ldi	r31, 0x02	; 2
    1550:	a6 eb       	ldi	r26, 0xB6	; 182
    1552:	b8 e0       	ldi	r27, 0x08	; 8
    1554:	01 90       	ld	r0, Z+
    1556:	0d 92       	st	X+, r0
    1558:	8a 95       	dec	r24
    155a:	e1 f7       	brne	.-8      	; 0x1554 <setup+0x44>
	gyro.init();
    155c:	42 e0       	ldi	r20, 0x02	; 2
    155e:	63 e0       	ldi	r22, 0x03	; 3
    1560:	8e e9       	ldi	r24, 0x9E	; 158
    1562:	98 e0       	ldi	r25, 0x08	; 8
    1564:	fb d8       	rcall	.-3594   	; 0x75c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
	gyro.enableDefault();
    1566:	8e e9       	ldi	r24, 0x9E	; 158
    1568:	98 e0       	ldi	r25, 0x08	; 8
    156a:	3f d8       	rcall	.-3970   	; 0x5ea <_ZN3L3G13enableDefaultEv>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    156c:	61 e0       	ldi	r22, 0x01	; 1
    156e:	80 91 02 02 	lds	r24, 0x0202
    1572:	0e 94 12 1a 	call	0x3424	; 0x3424 <pinMode>
	pinMode(echo_1, INPUT);
    1576:	60 e0       	ldi	r22, 0x00	; 0
    1578:	80 91 04 02 	lds	r24, 0x0204
    157c:	0e 94 12 1a 	call	0x3424	; 0x3424 <pinMode>
	pinMode(analog_1, INPUT);
    1580:	60 e0       	ldi	r22, 0x00	; 0
    1582:	80 91 00 02 	lds	r24, 0x0200
    1586:	0c 94 12 1a 	jmp	0x3424	; 0x3424 <pinMode>
    158a:	08 95       	ret

0000158c <main>:
}

int main(void)
{
    158c:	af 92       	push	r10
    158e:	bf 92       	push	r11
    1590:	cf 92       	push	r12
    1592:	df 92       	push	r13
    1594:	ef 92       	push	r14
    1596:	ff 92       	push	r15
    1598:	0f 93       	push	r16
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	cd b7       	in	r28, 0x3d	; 61
    15a0:	de b7       	in	r29, 0x3e	; 62
    15a2:	2a 97       	sbiw	r28, 0x0a	; 10
    15a4:	0f b6       	in	r0, 0x3f	; 63
    15a6:	f8 94       	cli
    15a8:	de bf       	out	0x3e, r29	; 62
    15aa:	0f be       	out	0x3f, r0	; 63
    15ac:	cd bf       	out	0x3d, r28	; 61
	init();
    15ae:	0e 94 23 19 	call	0x3246	; 0x3246 <init>
	setup();
    15b2:	ae df       	rcall	.-164    	; 0x1510 <setup>
	TaskHandle_t t1, t2, t3, t4, t5, t6;
	// Create tasks
	xTaskCreate(printArray, "printA", STACK_DEPTH, NULL, 10, &t1);
    15b4:	a1 2c       	mov	r10, r1
    15b6:	b1 2c       	mov	r11, r1
    15b8:	c1 2c       	mov	r12, r1
    15ba:	d1 2c       	mov	r13, r1
    15bc:	ce 01       	movw	r24, r28
    15be:	09 96       	adiw	r24, 0x09	; 9
    15c0:	7c 01       	movw	r14, r24
    15c2:	0a e0       	ldi	r16, 0x0A	; 10
    15c4:	20 e0       	ldi	r18, 0x00	; 0
    15c6:	30 e0       	ldi	r19, 0x00	; 0
    15c8:	40 e8       	ldi	r20, 0x80	; 128
    15ca:	50 e0       	ldi	r21, 0x00	; 0
    15cc:	61 e2       	ldi	r22, 0x21	; 33
    15ce:	72 e0       	ldi	r23, 0x02	; 2
    15d0:	89 e4       	ldi	r24, 0x49	; 73
    15d2:	9b e0       	ldi	r25, 0x0B	; 11
    15d4:	a1 d1       	rcall	.+834    	; 0x1918 <xTaskGenericCreate>
	xTaskCreate(taskReadGyro, "Read Gyrometer", STACK_DEPTH, NULL, 9, &t2);
    15d6:	ce 01       	movw	r24, r28
    15d8:	07 96       	adiw	r24, 0x07	; 7
    15da:	7c 01       	movw	r14, r24
    15dc:	09 e0       	ldi	r16, 0x09	; 9
    15de:	20 e0       	ldi	r18, 0x00	; 0
    15e0:	30 e0       	ldi	r19, 0x00	; 0
    15e2:	40 e8       	ldi	r20, 0x80	; 128
    15e4:	50 e0       	ldi	r21, 0x00	; 0
    15e6:	68 e2       	ldi	r22, 0x28	; 40
    15e8:	72 e0       	ldi	r23, 0x02	; 2
    15ea:	88 e1       	ldi	r24, 0x18	; 24
    15ec:	9a e0       	ldi	r25, 0x0A	; 10
    15ee:	94 d1       	rcall	.+808    	; 0x1918 <xTaskGenericCreate>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
    15f0:	ce 01       	movw	r24, r28
    15f2:	05 96       	adiw	r24, 0x05	; 5
    15f4:	7c 01       	movw	r14, r24
    15f6:	08 e0       	ldi	r16, 0x08	; 8
    15f8:	20 e0       	ldi	r18, 0x00	; 0
    15fa:	30 e0       	ldi	r19, 0x00	; 0
    15fc:	40 e8       	ldi	r20, 0x80	; 128
    15fe:	50 e0       	ldi	r21, 0x00	; 0
    1600:	67 e3       	ldi	r22, 0x37	; 55
    1602:	72 e0       	ldi	r23, 0x02	; 2
    1604:	84 e8       	ldi	r24, 0x84	; 132
    1606:	99 e0       	ldi	r25, 0x09	; 9
    1608:	87 d1       	rcall	.+782    	; 0x1918 <xTaskGenericCreate>
	xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
    160a:	ce 01       	movw	r24, r28
    160c:	03 96       	adiw	r24, 0x03	; 3
    160e:	7c 01       	movw	r14, r24
    1610:	07 e0       	ldi	r16, 0x07	; 7
    1612:	20 e0       	ldi	r18, 0x00	; 0
    1614:	30 e0       	ldi	r19, 0x00	; 0
    1616:	40 e8       	ldi	r20, 0x80	; 128
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	6a e4       	ldi	r22, 0x4A	; 74
    161c:	72 e0       	ldi	r23, 0x02	; 2
    161e:	80 e3       	ldi	r24, 0x30	; 48
    1620:	99 e0       	ldi	r25, 0x09	; 9
    1622:	7a d1       	rcall	.+756    	; 0x1918 <xTaskGenericCreate>
	//xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
    1624:	ce 01       	movw	r24, r28
    1626:	01 96       	adiw	r24, 0x01	; 1
    1628:	7c 01       	movw	r14, r24
    162a:	05 e0       	ldi	r16, 0x05	; 5
    162c:	20 e0       	ldi	r18, 0x00	; 0
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	40 e8       	ldi	r20, 0x80	; 128
    1632:	50 e0       	ldi	r21, 0x00	; 0
    1634:	68 e5       	ldi	r22, 0x58	; 88
    1636:	72 e0       	ldi	r23, 0x02	; 2
    1638:	8b e3       	ldi	r24, 0x3B	; 59
    163a:	99 e0       	ldi	r25, 0x09	; 9
    163c:	6d d1       	rcall	.+730    	; 0x1918 <xTaskGenericCreate>
	vTaskStartScheduler();
    163e:	74 d2       	rcall	.+1256   	; 0x1b28 <vTaskStartScheduler>
}
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	2a 96       	adiw	r28, 0x0a	; 10
    1646:	0f b6       	in	r0, 0x3f	; 63
    1648:	f8 94       	cli
    164a:	de bf       	out	0x3e, r29	; 62
    164c:	0f be       	out	0x3f, r0	; 63
    164e:	cd bf       	out	0x3d, r28	; 61
    1650:	df 91       	pop	r29
    1652:	cf 91       	pop	r28
    1654:	0f 91       	pop	r16
    1656:	ff 90       	pop	r15
    1658:	ef 90       	pop	r14
    165a:	df 90       	pop	r13
    165c:	cf 90       	pop	r12
    165e:	bf 90       	pop	r11
    1660:	af 90       	pop	r10
    1662:	08 95       	ret

00001664 <_GLOBAL__sub_I_echo_1>:
    1664:	0f 93       	push	r16
    1666:	1f 93       	push	r17
// xSemaphoreHandle sonarSema, magnetoSema, gyroSema, acceSema, analogSema = 0;
int echo_1 = 3; //pin 3 for sonar echo
int trigger_1 = 4; //pin 4 for sonar trigger
int analog_1 = A0; 
int numOfData = 8;
LSM303 compass;
    1668:	8a ea       	ldi	r24, 0xAA	; 170
    166a:	98 e0       	ldi	r25, 0x08	; 8
    166c:	99 d9       	rcall	.-3278   	; 0x9a0 <_ZN6LSM303C1Ev>
L3G gyro;
    166e:	8e e9       	ldi	r24, 0x9E	; 158
    1670:	98 e0       	ldi	r25, 0x08	; 8
    1672:	0e 94 ce 02 	call	0x59c	; 0x59c <_ZN3L3GC1Ev>
SharpIR sharp(A0, 25, 93, 20150);
    1676:	06 eb       	ldi	r16, 0xB6	; 182
    1678:	1e e4       	ldi	r17, 0x4E	; 78
    167a:	2d e5       	ldi	r18, 0x5D	; 93
    167c:	30 e0       	ldi	r19, 0x00	; 0
    167e:	49 e1       	ldi	r20, 0x19	; 25
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	66 e3       	ldi	r22, 0x36	; 54
    1684:	70 e0       	ldi	r23, 0x00	; 0
    1686:	80 e9       	ldi	r24, 0x90	; 144
    1688:	98 e0       	ldi	r25, 0x08	; 8
    168a:	2f d0       	rcall	.+94     	; 0x16ea <_ZN7SharpIRC1Eiiii>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
	xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	//xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
	vTaskStartScheduler();
}
    168c:	1f 91       	pop	r17
    168e:	0f 91       	pop	r16
    1690:	08 95       	ret

00001692 <_Z10printArrayPv>:
index 9 for compass heading
*/

void printArray(void *p) {
	int i;
	char canRead = '0';
    1692:	c0 e3       	ldi	r28, 0x30	; 48
    1694:	0f 2e       	mov	r0, r31
    1696:	f0 e8       	ldi	r31, 0x80	; 128
    1698:	ef 2e       	mov	r14, r31
    169a:	f8 e0       	ldi	r31, 0x08	; 8
    169c:	ff 2e       	mov	r15, r31
    169e:	f0 2d       	mov	r31, r0
    16a0:	00 e9       	ldi	r16, 0x90	; 144
    16a2:	18 e0       	ldi	r17, 0x08	; 8
	while(1) {
		if(Serial.available()){
    16a4:	89 ee       	ldi	r24, 0xE9	; 233
    16a6:	99 e0       	ldi	r25, 0x09	; 9
    16a8:	0e 94 f4 15 	call	0x2be8	; 0x2be8 <_ZN14HardwareSerial9availableEv>
    16ac:	89 2b       	or	r24, r25
    16ae:	29 f0       	breq	.+10     	; 0x16ba <_Z10printArrayPv+0x28>
			canRead = Serial.read();
    16b0:	89 ee       	ldi	r24, 0xE9	; 233
    16b2:	99 e0       	ldi	r25, 0x09	; 9
    16b4:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <_ZN14HardwareSerial4readEv>
    16b8:	c8 2f       	mov	r28, r24
		}
		if(canRead - '0'){
    16ba:	c0 33       	cpi	r28, 0x30	; 48
    16bc:	91 f0       	breq	.+36     	; 0x16e2 <_Z10printArrayPv+0x50>
    16be:	e7 01       	movw	r28, r14
			//Serial.print(numOfData);
			//Serial.print('\r');
			for(i = 1; i < 9; i++) {
				Serial.println(data[i]);
    16c0:	69 91       	ld	r22, Y+
    16c2:	79 91       	ld	r23, Y+
    16c4:	4a e0       	ldi	r20, 0x0A	; 10
    16c6:	50 e0       	ldi	r21, 0x00	; 0
    16c8:	89 ee       	ldi	r24, 0xE9	; 233
    16ca:	99 e0       	ldi	r25, 0x09	; 9
    16cc:	0e 94 ac 18 	call	0x3158	; 0x3158 <_ZN5Print7printlnEii>
				Serial.print('\r');
    16d0:	6d e0       	ldi	r22, 0x0D	; 13
    16d2:	89 ee       	ldi	r24, 0xE9	; 233
    16d4:	99 e0       	ldi	r25, 0x09	; 9
    16d6:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <_ZN5Print5printEc>
			canRead = Serial.read();
		}
		if(canRead - '0'){
			//Serial.print(numOfData);
			//Serial.print('\r');
			for(i = 1; i < 9; i++) {
    16da:	c0 17       	cp	r28, r16
    16dc:	d1 07       	cpc	r29, r17
    16de:	81 f7       	brne	.-32     	; 0x16c0 <_Z10printArrayPv+0x2e>
				Serial.println(data[i]);
				Serial.print('\r');
			}
			canRead = '0';
    16e0:	c0 e3       	ldi	r28, 0x30	; 48
		/*if(canRead - '0') {
			i = canRead - '0';
			Serial.print(data[i]);
			canRead = '0';
		}*/
		vTaskDelay(1000);
    16e2:	88 ee       	ldi	r24, 0xE8	; 232
    16e4:	93 e0       	ldi	r25, 0x03	; 3
    16e6:	8e d3       	rcall	.+1820   	; 0x1e04 <vTaskDelay>
	}
    16e8:	dd cf       	rjmp	.-70     	; 0x16a4 <_Z10printArrayPv+0x12>

000016ea <_ZN7SharpIRC1Eiiii>:
#include "Arduino.h"
#include "SharpIR.h"



SharpIR::SharpIR(int irPin, int avg, int tolerance, int sensorModel) {
    16ea:	0f 93       	push	r16
    16ec:	1f 93       	push	r17
    16ee:	fc 01       	movw	r30, r24
    16f0:	c9 01       	movw	r24, r18
  
    _irPin=irPin;
    16f2:	71 83       	std	Z+1, r23	; 0x01
    16f4:	60 83       	st	Z, r22
    _avg=avg;
    16f6:	55 83       	std	Z+5, r21	; 0x05
    16f8:	44 83       	std	Z+4, r20	; 0x04
    _tol=tolerance/100;
    16fa:	64 e6       	ldi	r22, 0x64	; 100
    16fc:	70 e0       	ldi	r23, 0x00	; 0
    16fe:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <__divmodhi4>
    1702:	75 87       	std	Z+13, r23	; 0x0d
    1704:	64 87       	std	Z+12, r22	; 0x0c
    _model=sensorModel;
    1706:	13 83       	std	Z+3, r17	; 0x03
    1708:	02 83       	std	Z+2, r16	; 0x02
    
    analogReference(DEFAULT);
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	0e 94 85 19 	call	0x330a	; 0x330a <analogReference>
 
}
    1710:	1f 91       	pop	r17
    1712:	0f 91       	pop	r16
    1714:	08 95       	ret

00001716 <_ZN7SharpIR2cmEv>:
//    distance range they are designed for (in cm)
 



int SharpIR::cm() {
    1716:	8f 92       	push	r8
    1718:	9f 92       	push	r9
    171a:	af 92       	push	r10
    171c:	bf 92       	push	r11
    171e:	cf 92       	push	r12
    1720:	df 92       	push	r13
    1722:	ef 92       	push	r14
    1724:	ff 92       	push	r15
    1726:	0f 93       	push	r16
    1728:	1f 93       	push	r17
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	ec 01       	movw	r28, r24
    
    int raw=analogRead(_irPin);
    1730:	88 81       	ld	r24, Y
    1732:	0e 94 88 19 	call	0x3310	; 0x3310 <analogRead>
    float voltFromRaw=map(raw, 0, 1023, 0, 5000);
    1736:	bc 01       	movw	r22, r24
    1738:	88 27       	eor	r24, r24
    173a:	77 fd       	sbrc	r23, 7
    173c:	80 95       	com	r24
    173e:	98 2f       	mov	r25, r24
    1740:	1f 92       	push	r1
    1742:	1f 92       	push	r1
    1744:	23 e1       	ldi	r18, 0x13	; 19
    1746:	2f 93       	push	r18
    1748:	28 e8       	ldi	r18, 0x88	; 136
    174a:	2f 93       	push	r18
    174c:	a1 2c       	mov	r10, r1
    174e:	b1 2c       	mov	r11, r1
    1750:	65 01       	movw	r12, r10
    1752:	ee 24       	eor	r14, r14
    1754:	ea 94       	dec	r14
    1756:	13 e0       	ldi	r17, 0x03	; 3
    1758:	f1 2e       	mov	r15, r17
    175a:	00 e0       	ldi	r16, 0x00	; 0
    175c:	10 e0       	ldi	r17, 0x00	; 0
    175e:	20 e0       	ldi	r18, 0x00	; 0
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	a9 01       	movw	r20, r18
    1764:	0e 94 af 1a 	call	0x355e	; 0x355e <_Z3maplllll>
    1768:	eb d7       	rcall	.+4054   	; 0x2740 <__floatsisf>
    
    int puntualDistance;
    
    if (_model==1080) {
    176a:	2a 81       	ldd	r18, Y+2	; 0x02
    176c:	3b 81       	ldd	r19, Y+3	; 0x03
    176e:	0f 90       	pop	r0
    1770:	0f 90       	pop	r0
    1772:	0f 90       	pop	r0
    1774:	0f 90       	pop	r0
    1776:	28 33       	cpi	r18, 0x38	; 56
    1778:	44 e0       	ldi	r20, 0x04	; 4
    177a:	34 07       	cpc	r19, r20
    177c:	a1 f4       	brne	.+40     	; 0x17a6 <_ZN7SharpIR2cmEv+0x90>
        
        puntualDistance=27.728*pow(voltFromRaw/1000, -1.2045);
    177e:	20 e0       	ldi	r18, 0x00	; 0
    1780:	30 e0       	ldi	r19, 0x00	; 0
    1782:	4a e7       	ldi	r20, 0x7A	; 122
    1784:	54 e4       	ldi	r21, 0x44	; 68
    1786:	41 d7       	rcall	.+3714   	; 0x260a <__divsf3>
    1788:	2e e0       	ldi	r18, 0x0E	; 14
    178a:	3d e2       	ldi	r19, 0x2D	; 45
    178c:	4a e9       	ldi	r20, 0x9A	; 154
    178e:	5f eb       	ldi	r21, 0xBF	; 191
    1790:	0e 94 bb 14 	call	0x2976	; 0x2976 <pow>
    1794:	22 ef       	ldi	r18, 0xF2	; 242
    1796:	32 ed       	ldi	r19, 0xD2	; 210
    1798:	4d ed       	ldi	r20, 0xDD	; 221
    179a:	51 e4       	ldi	r21, 0x41	; 65
    179c:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    17a0:	9c d7       	rcall	.+3896   	; 0x26da <__fixsfsi>
    17a2:	4b 01       	movw	r8, r22
    17a4:	16 c0       	rjmp	.+44     	; 0x17d2 <_ZN7SharpIR2cmEv+0xbc>
        
    }else if (_model==20150){
    17a6:	26 3b       	cpi	r18, 0xB6	; 182
    17a8:	3e 44       	sbci	r19, 0x4E	; 78
    17aa:	99 f4       	brne	.+38     	; 0x17d2 <_ZN7SharpIR2cmEv+0xbc>
    
        puntualDistance=61.573*pow(voltFromRaw/1000, -1.1068);
    17ac:	20 e0       	ldi	r18, 0x00	; 0
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	4a e7       	ldi	r20, 0x7A	; 122
    17b2:	54 e4       	ldi	r21, 0x44	; 68
    17b4:	2a d7       	rcall	.+3668   	; 0x260a <__divsf3>
    17b6:	2f e9       	ldi	r18, 0x9F	; 159
    17b8:	3b ea       	ldi	r19, 0xAB	; 171
    17ba:	4d e8       	ldi	r20, 0x8D	; 141
    17bc:	5f eb       	ldi	r21, 0xBF	; 191
    17be:	0e 94 bb 14 	call	0x2976	; 0x2976 <pow>
    17c2:	21 ec       	ldi	r18, 0xC1	; 193
    17c4:	3a e4       	ldi	r19, 0x4A	; 74
    17c6:	46 e7       	ldi	r20, 0x76	; 118
    17c8:	52 e4       	ldi	r21, 0x42	; 66
    17ca:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__mulsf3>
    17ce:	85 d7       	rcall	.+3850   	; 0x26da <__fixsfsi>
    17d0:	4b 01       	movw	r8, r22
    
    
    return puntualDistance;


}
    17d2:	c4 01       	movw	r24, r8
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	1f 91       	pop	r17
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	cf 90       	pop	r12
    17e4:	bf 90       	pop	r11
    17e6:	af 90       	pop	r10
    17e8:	9f 90       	pop	r9
    17ea:	8f 90       	pop	r8
    17ec:	08 95       	ret

000017ee <_ZN7SharpIR8distanceEv>:



int SharpIR::distance() {
    17ee:	0f 93       	push	r16
    17f0:	1f 93       	push	r17
    17f2:	cf 93       	push	r28
    17f4:	df 93       	push	r29
    17f6:	ec 01       	movw	r28, r24

    _p=0;
    17f8:	1f 82       	std	Y+7, r1	; 0x07
    17fa:	1e 82       	std	Y+6, r1	; 0x06
    _sum=0;
    17fc:	19 86       	std	Y+9, r1	; 0x09
    17fe:	18 86       	std	Y+8, r1	; 0x08

    
    for (int i=0; i<_avg; i++){
    1800:	8c 81       	ldd	r24, Y+4	; 0x04
    1802:	9d 81       	ldd	r25, Y+5	; 0x05
    1804:	18 16       	cp	r1, r24
    1806:	19 06       	cpc	r1, r25
    1808:	34 f5       	brge	.+76     	; 0x1856 <_ZN7SharpIR8distanceEv+0x68>
    180a:	00 e0       	ldi	r16, 0x00	; 0
    180c:	10 e0       	ldi	r17, 0x00	; 0
        
        int foo=cm();
    180e:	ce 01       	movw	r24, r28
    1810:	82 df       	rcall	.-252    	; 0x1716 <_ZN7SharpIR2cmEv>
        
        if (foo>=(_tol*_previousDistance)){
    1812:	6c 85       	ldd	r22, Y+12	; 0x0c
    1814:	7d 85       	ldd	r23, Y+13	; 0x0d
    1816:	4a 85       	ldd	r20, Y+10	; 0x0a
    1818:	5b 85       	ldd	r21, Y+11	; 0x0b
    181a:	64 9f       	mul	r22, r20
    181c:	90 01       	movw	r18, r0
    181e:	65 9f       	mul	r22, r21
    1820:	30 0d       	add	r19, r0
    1822:	74 9f       	mul	r23, r20
    1824:	30 0d       	add	r19, r0
    1826:	11 24       	eor	r1, r1
    1828:	82 17       	cp	r24, r18
    182a:	93 07       	cpc	r25, r19
    182c:	6c f0       	brlt	.+26     	; 0x1848 <_ZN7SharpIR8distanceEv+0x5a>
        
            _previousDistance=foo;
    182e:	9b 87       	std	Y+11, r25	; 0x0b
    1830:	8a 87       	std	Y+10, r24	; 0x0a
            _sum=_sum+foo;
    1832:	28 85       	ldd	r18, Y+8	; 0x08
    1834:	39 85       	ldd	r19, Y+9	; 0x09
    1836:	82 0f       	add	r24, r18
    1838:	93 1f       	adc	r25, r19
    183a:	99 87       	std	Y+9, r25	; 0x09
    183c:	88 87       	std	Y+8, r24	; 0x08
            _p++;
    183e:	8e 81       	ldd	r24, Y+6	; 0x06
    1840:	9f 81       	ldd	r25, Y+7	; 0x07
    1842:	01 96       	adiw	r24, 0x01	; 1
    1844:	9f 83       	std	Y+7, r25	; 0x07
    1846:	8e 83       	std	Y+6, r24	; 0x06

    _p=0;
    _sum=0;

    
    for (int i=0; i<_avg; i++){
    1848:	0f 5f       	subi	r16, 0xFF	; 255
    184a:	1f 4f       	sbci	r17, 0xFF	; 255
    184c:	8c 81       	ldd	r24, Y+4	; 0x04
    184e:	9d 81       	ldd	r25, Y+5	; 0x05
    1850:	08 17       	cp	r16, r24
    1852:	19 07       	cpc	r17, r25
    1854:	e4 f2       	brlt	.-72     	; 0x180e <_ZN7SharpIR8distanceEv+0x20>
        
        
    }

    
    int accurateDistance=_sum/_p;
    1856:	88 85       	ldd	r24, Y+8	; 0x08
    1858:	99 85       	ldd	r25, Y+9	; 0x09
    185a:	6e 81       	ldd	r22, Y+6	; 0x06
    185c:	7f 81       	ldd	r23, Y+7	; 0x07
    185e:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <__divmodhi4>
    1862:	cb 01       	movw	r24, r22
    
    return accurateDistance;

}
    1864:	df 91       	pop	r29
    1866:	cf 91       	pop	r28
    1868:	1f 91       	pop	r17
    186a:	0f 91       	pop	r16
    186c:	08 95       	ret

0000186e <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    186e:	e0 91 ef 08 	lds	r30, 0x08EF
    1872:	f0 91 f0 08 	lds	r31, 0x08F0
    1876:	80 81       	ld	r24, Z
    1878:	81 11       	cpse	r24, r1
    187a:	07 c0       	rjmp	.+14     	; 0x188a <prvResetNextTaskUnblockTime+0x1c>
    187c:	8f ef       	ldi	r24, 0xFF	; 255
    187e:	9f ef       	ldi	r25, 0xFF	; 255
    1880:	90 93 07 02 	sts	0x0207, r25
    1884:	80 93 06 02 	sts	0x0206, r24
    1888:	08 95       	ret
    188a:	e0 91 ef 08 	lds	r30, 0x08EF
    188e:	f0 91 f0 08 	lds	r31, 0x08F0
    1892:	05 80       	ldd	r0, Z+5	; 0x05
    1894:	f6 81       	ldd	r31, Z+6	; 0x06
    1896:	e0 2d       	mov	r30, r0
    1898:	06 80       	ldd	r0, Z+6	; 0x06
    189a:	f7 81       	ldd	r31, Z+7	; 0x07
    189c:	e0 2d       	mov	r30, r0
    189e:	82 81       	ldd	r24, Z+2	; 0x02
    18a0:	93 81       	ldd	r25, Z+3	; 0x03
    18a2:	90 93 07 02 	sts	0x0207, r25
    18a6:	80 93 06 02 	sts	0x0206, r24
    18aa:	08 95       	ret

000018ac <prvAddCurrentTaskToDelayedList>:
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
    18b0:	ec 01       	movw	r28, r24
    18b2:	e0 91 27 09 	lds	r30, 0x0927
    18b6:	f0 91 28 09 	lds	r31, 0x0928
    18ba:	93 83       	std	Z+3, r25	; 0x03
    18bc:	82 83       	std	Z+2, r24	; 0x02
    18be:	80 91 d7 08 	lds	r24, 0x08D7
    18c2:	90 91 d8 08 	lds	r25, 0x08D8
    18c6:	c8 17       	cp	r28, r24
    18c8:	d9 07       	cpc	r29, r25
    18ca:	60 f4       	brcc	.+24     	; 0x18e4 <prvAddCurrentTaskToDelayedList+0x38>
    18cc:	60 91 27 09 	lds	r22, 0x0927
    18d0:	70 91 28 09 	lds	r23, 0x0928
    18d4:	80 91 ed 08 	lds	r24, 0x08ED
    18d8:	90 91 ee 08 	lds	r25, 0x08EE
    18dc:	6e 5f       	subi	r22, 0xFE	; 254
    18de:	7f 4f       	sbci	r23, 0xFF	; 255
    18e0:	08 d8       	rcall	.-4080   	; 0x8f2 <vListInsert>
    18e2:	17 c0       	rjmp	.+46     	; 0x1912 <prvAddCurrentTaskToDelayedList+0x66>
    18e4:	60 91 27 09 	lds	r22, 0x0927
    18e8:	70 91 28 09 	lds	r23, 0x0928
    18ec:	80 91 ef 08 	lds	r24, 0x08EF
    18f0:	90 91 f0 08 	lds	r25, 0x08F0
    18f4:	6e 5f       	subi	r22, 0xFE	; 254
    18f6:	7f 4f       	sbci	r23, 0xFF	; 255
    18f8:	0e 94 79 04 	call	0x8f2	; 0x8f2 <vListInsert>
    18fc:	80 91 06 02 	lds	r24, 0x0206
    1900:	90 91 07 02 	lds	r25, 0x0207
    1904:	c8 17       	cp	r28, r24
    1906:	d9 07       	cpc	r29, r25
    1908:	20 f4       	brcc	.+8      	; 0x1912 <prvAddCurrentTaskToDelayedList+0x66>
    190a:	d0 93 07 02 	sts	0x0207, r29
    190e:	c0 93 06 02 	sts	0x0206, r28
    1912:	df 91       	pop	r29
    1914:	cf 91       	pop	r28
    1916:	08 95       	ret

00001918 <xTaskGenericCreate>:
    1918:	4f 92       	push	r4
    191a:	5f 92       	push	r5
    191c:	6f 92       	push	r6
    191e:	7f 92       	push	r7
    1920:	8f 92       	push	r8
    1922:	9f 92       	push	r9
    1924:	af 92       	push	r10
    1926:	bf 92       	push	r11
    1928:	cf 92       	push	r12
    192a:	df 92       	push	r13
    192c:	ef 92       	push	r14
    192e:	ff 92       	push	r15
    1930:	0f 93       	push	r16
    1932:	1f 93       	push	r17
    1934:	cf 93       	push	r28
    1936:	df 93       	push	r29
    1938:	4c 01       	movw	r8, r24
    193a:	5b 01       	movw	r10, r22
    193c:	2a 01       	movw	r4, r20
    193e:	39 01       	movw	r6, r18
    1940:	81 e2       	ldi	r24, 0x21	; 33
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	0e 94 98 02 	call	0x530	; 0x530 <pvPortMalloc>
    1948:	ec 01       	movw	r28, r24
    194a:	00 97       	sbiw	r24, 0x00	; 0
    194c:	09 f4       	brne	.+2      	; 0x1950 <xTaskGenericCreate+0x38>
    194e:	da c0       	rjmp	.+436    	; 0x1b04 <xTaskGenericCreate+0x1ec>
    1950:	c1 14       	cp	r12, r1
    1952:	d1 04       	cpc	r13, r1
    1954:	09 f0       	breq	.+2      	; 0x1958 <xTaskGenericCreate+0x40>
    1956:	bf c0       	rjmp	.+382    	; 0x1ad6 <xTaskGenericCreate+0x1be>
    1958:	c2 01       	movw	r24, r4
    195a:	0e 94 98 02 	call	0x530	; 0x530 <pvPortMalloc>
    195e:	98 8f       	std	Y+24, r25	; 0x18
    1960:	8f 8b       	std	Y+23, r24	; 0x17
    1962:	89 2b       	or	r24, r25
    1964:	09 f0       	breq	.+2      	; 0x1968 <xTaskGenericCreate+0x50>
    1966:	b9 c0       	rjmp	.+370    	; 0x1ada <xTaskGenericCreate+0x1c2>
    1968:	ce 01       	movw	r24, r28
    196a:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortFree>
    196e:	ca c0       	rjmp	.+404    	; 0x1b04 <xTaskGenericCreate+0x1ec>
    1970:	cf 01       	movw	r24, r30
    1972:	31 91       	ld	r19, Z+
    1974:	da 01       	movw	r26, r20
    1976:	3d 93       	st	X+, r19
    1978:	ad 01       	movw	r20, r26
    197a:	dc 01       	movw	r26, r24
    197c:	8c 91       	ld	r24, X
    197e:	88 23       	and	r24, r24
    1980:	11 f0       	breq	.+4      	; 0x1986 <xTaskGenericCreate+0x6e>
    1982:	21 50       	subi	r18, 0x01	; 1
    1984:	a9 f7       	brne	.-22     	; 0x1970 <xTaskGenericCreate+0x58>
    1986:	18 a2       	std	Y+32, r1	; 0x20
    1988:	10 2f       	mov	r17, r16
    198a:	04 30       	cpi	r16, 0x04	; 4
    198c:	08 f0       	brcs	.+2      	; 0x1990 <xTaskGenericCreate+0x78>
    198e:	13 e0       	ldi	r17, 0x03	; 3
    1990:	1e 8b       	std	Y+22, r17	; 0x16
    1992:	5e 01       	movw	r10, r28
    1994:	b2 e0       	ldi	r27, 0x02	; 2
    1996:	ab 0e       	add	r10, r27
    1998:	b1 1c       	adc	r11, r1
    199a:	c5 01       	movw	r24, r10
    199c:	0e 94 54 04 	call	0x8a8	; 0x8a8 <vListInitialiseItem>
    19a0:	ce 01       	movw	r24, r28
    19a2:	0c 96       	adiw	r24, 0x0c	; 12
    19a4:	0e 94 54 04 	call	0x8a8	; 0x8a8 <vListInitialiseItem>
    19a8:	d9 87       	std	Y+9, r29	; 0x09
    19aa:	c8 87       	std	Y+8, r28	; 0x08
    19ac:	84 e0       	ldi	r24, 0x04	; 4
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	81 1b       	sub	r24, r17
    19b2:	91 09       	sbc	r25, r1
    19b4:	9d 87       	std	Y+13, r25	; 0x0d
    19b6:	8c 87       	std	Y+12, r24	; 0x0c
    19b8:	db 8b       	std	Y+19, r29	; 0x13
    19ba:	ca 8b       	std	Y+18, r28	; 0x12
    19bc:	a3 01       	movw	r20, r6
    19be:	b4 01       	movw	r22, r8
    19c0:	c6 01       	movw	r24, r12
    19c2:	d7 da       	rcall	.-2642   	; 0xf72 <pxPortInitialiseStack>
    19c4:	99 83       	std	Y+1, r25	; 0x01
    19c6:	88 83       	st	Y, r24
    19c8:	e1 14       	cp	r14, r1
    19ca:	f1 04       	cpc	r15, r1
    19cc:	19 f0       	breq	.+6      	; 0x19d4 <xTaskGenericCreate+0xbc>
    19ce:	f7 01       	movw	r30, r14
    19d0:	d1 83       	std	Z+1, r29	; 0x01
    19d2:	c0 83       	st	Z, r28
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	0f 92       	push	r0
    19da:	80 91 d9 08 	lds	r24, 0x08D9
    19de:	8f 5f       	subi	r24, 0xFF	; 255
    19e0:	80 93 d9 08 	sts	0x08D9, r24
    19e4:	80 91 27 09 	lds	r24, 0x0927
    19e8:	90 91 28 09 	lds	r25, 0x0928
    19ec:	89 2b       	or	r24, r25
    19ee:	a9 f5       	brne	.+106    	; 0x1a5a <xTaskGenericCreate+0x142>
    19f0:	d0 93 28 09 	sts	0x0928, r29
    19f4:	c0 93 27 09 	sts	0x0927, r28
    19f8:	80 91 d9 08 	lds	r24, 0x08D9
    19fc:	81 30       	cpi	r24, 0x01	; 1
    19fe:	e1 f5       	brne	.+120    	; 0x1a78 <xTaskGenericCreate+0x160>
    1a00:	83 e0       	ldi	r24, 0x03	; 3
    1a02:	99 e0       	ldi	r25, 0x09	; 9
    1a04:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a08:	8c e0       	ldi	r24, 0x0C	; 12
    1a0a:	99 e0       	ldi	r25, 0x09	; 9
    1a0c:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a10:	85 e1       	ldi	r24, 0x15	; 21
    1a12:	99 e0       	ldi	r25, 0x09	; 9
    1a14:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a18:	8e e1       	ldi	r24, 0x1E	; 30
    1a1a:	99 e0       	ldi	r25, 0x09	; 9
    1a1c:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a20:	8a ef       	ldi	r24, 0xFA	; 250
    1a22:	98 e0       	ldi	r25, 0x08	; 8
    1a24:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a28:	81 ef       	ldi	r24, 0xF1	; 241
    1a2a:	98 e0       	ldi	r25, 0x08	; 8
    1a2c:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a30:	84 ee       	ldi	r24, 0xE4	; 228
    1a32:	98 e0       	ldi	r25, 0x08	; 8
    1a34:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a38:	8b ed       	ldi	r24, 0xDB	; 219
    1a3a:	98 e0       	ldi	r25, 0x08	; 8
    1a3c:	0e 94 46 04 	call	0x88c	; 0x88c <vListInitialise>
    1a40:	8a ef       	ldi	r24, 0xFA	; 250
    1a42:	98 e0       	ldi	r25, 0x08	; 8
    1a44:	90 93 f0 08 	sts	0x08F0, r25
    1a48:	80 93 ef 08 	sts	0x08EF, r24
    1a4c:	81 ef       	ldi	r24, 0xF1	; 241
    1a4e:	98 e0       	ldi	r25, 0x08	; 8
    1a50:	90 93 ee 08 	sts	0x08EE, r25
    1a54:	80 93 ed 08 	sts	0x08ED, r24
    1a58:	0f c0       	rjmp	.+30     	; 0x1a78 <xTaskGenericCreate+0x160>
    1a5a:	80 91 d5 08 	lds	r24, 0x08D5
    1a5e:	81 11       	cpse	r24, r1
    1a60:	0b c0       	rjmp	.+22     	; 0x1a78 <xTaskGenericCreate+0x160>
    1a62:	e0 91 27 09 	lds	r30, 0x0927
    1a66:	f0 91 28 09 	lds	r31, 0x0928
    1a6a:	86 89       	ldd	r24, Z+22	; 0x16
    1a6c:	08 17       	cp	r16, r24
    1a6e:	20 f0       	brcs	.+8      	; 0x1a78 <xTaskGenericCreate+0x160>
    1a70:	d0 93 28 09 	sts	0x0928, r29
    1a74:	c0 93 27 09 	sts	0x0927, r28
    1a78:	80 91 d1 08 	lds	r24, 0x08D1
    1a7c:	8f 5f       	subi	r24, 0xFF	; 255
    1a7e:	80 93 d1 08 	sts	0x08D1, r24
    1a82:	8e 89       	ldd	r24, Y+22	; 0x16
    1a84:	90 91 d6 08 	lds	r25, 0x08D6
    1a88:	98 17       	cp	r25, r24
    1a8a:	10 f4       	brcc	.+4      	; 0x1a90 <xTaskGenericCreate+0x178>
    1a8c:	80 93 d6 08 	sts	0x08D6, r24
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	9c 01       	movw	r18, r24
    1a94:	22 0f       	add	r18, r18
    1a96:	33 1f       	adc	r19, r19
    1a98:	22 0f       	add	r18, r18
    1a9a:	33 1f       	adc	r19, r19
    1a9c:	22 0f       	add	r18, r18
    1a9e:	33 1f       	adc	r19, r19
    1aa0:	82 0f       	add	r24, r18
    1aa2:	93 1f       	adc	r25, r19
    1aa4:	b5 01       	movw	r22, r10
    1aa6:	8d 5f       	subi	r24, 0xFD	; 253
    1aa8:	96 4f       	sbci	r25, 0xF6	; 246
    1aaa:	0e 94 58 04 	call	0x8b0	; 0x8b0 <vListInsertEnd>
    1aae:	0f 90       	pop	r0
    1ab0:	0f be       	out	0x3f, r0	; 63
    1ab2:	80 91 d5 08 	lds	r24, 0x08D5
    1ab6:	88 23       	and	r24, r24
    1ab8:	51 f0       	breq	.+20     	; 0x1ace <xTaskGenericCreate+0x1b6>
    1aba:	e0 91 27 09 	lds	r30, 0x0927
    1abe:	f0 91 28 09 	lds	r31, 0x0928
    1ac2:	86 89       	ldd	r24, Z+22	; 0x16
    1ac4:	80 17       	cp	r24, r16
    1ac6:	28 f4       	brcc	.+10     	; 0x1ad2 <xTaskGenericCreate+0x1ba>
    1ac8:	07 db       	rcall	.-2546   	; 0x10d8 <vPortYield>
    1aca:	81 e0       	ldi	r24, 0x01	; 1
    1acc:	1c c0       	rjmp	.+56     	; 0x1b06 <xTaskGenericCreate+0x1ee>
    1ace:	81 e0       	ldi	r24, 0x01	; 1
    1ad0:	1a c0       	rjmp	.+52     	; 0x1b06 <xTaskGenericCreate+0x1ee>
    1ad2:	81 e0       	ldi	r24, 0x01	; 1
    1ad4:	18 c0       	rjmp	.+48     	; 0x1b06 <xTaskGenericCreate+0x1ee>
    1ad6:	d8 8e       	std	Y+24, r13	; 0x18
    1ad8:	cf 8a       	std	Y+23, r12	; 0x17
    1ada:	f1 e0       	ldi	r31, 0x01	; 1
    1adc:	4f 1a       	sub	r4, r31
    1ade:	51 08       	sbc	r5, r1
    1ae0:	cf 88       	ldd	r12, Y+23	; 0x17
    1ae2:	d8 8c       	ldd	r13, Y+24	; 0x18
    1ae4:	c4 0c       	add	r12, r4
    1ae6:	d5 1c       	adc	r13, r5
    1ae8:	d5 01       	movw	r26, r10
    1aea:	8c 91       	ld	r24, X
    1aec:	89 8f       	std	Y+25, r24	; 0x19
    1aee:	8c 91       	ld	r24, X
    1af0:	88 23       	and	r24, r24
    1af2:	09 f4       	brne	.+2      	; 0x1af6 <xTaskGenericCreate+0x1de>
    1af4:	48 cf       	rjmp	.-368    	; 0x1986 <xTaskGenericCreate+0x6e>
    1af6:	ae 01       	movw	r20, r28
    1af8:	46 5e       	subi	r20, 0xE6	; 230
    1afa:	5f 4f       	sbci	r21, 0xFF	; 255
    1afc:	f5 01       	movw	r30, r10
    1afe:	31 96       	adiw	r30, 0x01	; 1
    1b00:	27 e0       	ldi	r18, 0x07	; 7
    1b02:	36 cf       	rjmp	.-404    	; 0x1970 <xTaskGenericCreate+0x58>
    1b04:	8f ef       	ldi	r24, 0xFF	; 255
    1b06:	df 91       	pop	r29
    1b08:	cf 91       	pop	r28
    1b0a:	1f 91       	pop	r17
    1b0c:	0f 91       	pop	r16
    1b0e:	ff 90       	pop	r15
    1b10:	ef 90       	pop	r14
    1b12:	df 90       	pop	r13
    1b14:	cf 90       	pop	r12
    1b16:	bf 90       	pop	r11
    1b18:	af 90       	pop	r10
    1b1a:	9f 90       	pop	r9
    1b1c:	8f 90       	pop	r8
    1b1e:	7f 90       	pop	r7
    1b20:	6f 90       	pop	r6
    1b22:	5f 90       	pop	r5
    1b24:	4f 90       	pop	r4
    1b26:	08 95       	ret

00001b28 <vTaskStartScheduler>:
    1b28:	af 92       	push	r10
    1b2a:	bf 92       	push	r11
    1b2c:	cf 92       	push	r12
    1b2e:	df 92       	push	r13
    1b30:	ef 92       	push	r14
    1b32:	ff 92       	push	r15
    1b34:	0f 93       	push	r16
    1b36:	a1 2c       	mov	r10, r1
    1b38:	b1 2c       	mov	r11, r1
    1b3a:	c1 2c       	mov	r12, r1
    1b3c:	d1 2c       	mov	r13, r1
    1b3e:	e1 2c       	mov	r14, r1
    1b40:	f1 2c       	mov	r15, r1
    1b42:	00 e0       	ldi	r16, 0x00	; 0
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	45 e5       	ldi	r20, 0x55	; 85
    1b4a:	50 e0       	ldi	r21, 0x00	; 0
    1b4c:	68 e6       	ldi	r22, 0x68	; 104
    1b4e:	72 e0       	ldi	r23, 0x02	; 2
    1b50:	8e e1       	ldi	r24, 0x1E	; 30
    1b52:	9f e0       	ldi	r25, 0x0F	; 15
    1b54:	e1 de       	rcall	.-574    	; 0x1918 <xTaskGenericCreate>
    1b56:	81 30       	cpi	r24, 0x01	; 1
    1b58:	41 f4       	brne	.+16     	; 0x1b6a <vTaskStartScheduler+0x42>
    1b5a:	f8 94       	cli
    1b5c:	80 93 d5 08 	sts	0x08D5, r24
    1b60:	10 92 d8 08 	sts	0x08D8, r1
    1b64:	10 92 d7 08 	sts	0x08D7, r1
    1b68:	76 da       	rcall	.-2836   	; 0x1056 <xPortStartScheduler>
    1b6a:	0f 91       	pop	r16
    1b6c:	ff 90       	pop	r15
    1b6e:	ef 90       	pop	r14
    1b70:	df 90       	pop	r13
    1b72:	cf 90       	pop	r12
    1b74:	bf 90       	pop	r11
    1b76:	af 90       	pop	r10
    1b78:	08 95       	ret

00001b7a <vTaskSuspendAll>:
    1b7a:	80 91 d0 08 	lds	r24, 0x08D0
    1b7e:	8f 5f       	subi	r24, 0xFF	; 255
    1b80:	80 93 d0 08 	sts	0x08D0, r24
    1b84:	08 95       	ret

00001b86 <xTaskIncrementTick>:
    1b86:	cf 92       	push	r12
    1b88:	df 92       	push	r13
    1b8a:	ef 92       	push	r14
    1b8c:	ff 92       	push	r15
    1b8e:	0f 93       	push	r16
    1b90:	1f 93       	push	r17
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
    1b96:	80 91 d0 08 	lds	r24, 0x08D0
    1b9a:	81 11       	cpse	r24, r1
    1b9c:	99 c0       	rjmp	.+306    	; 0x1cd0 <xTaskIncrementTick+0x14a>
    1b9e:	80 91 d7 08 	lds	r24, 0x08D7
    1ba2:	90 91 d8 08 	lds	r25, 0x08D8
    1ba6:	01 96       	adiw	r24, 0x01	; 1
    1ba8:	90 93 d8 08 	sts	0x08D8, r25
    1bac:	80 93 d7 08 	sts	0x08D7, r24
    1bb0:	e0 90 d7 08 	lds	r14, 0x08D7
    1bb4:	f0 90 d8 08 	lds	r15, 0x08D8
    1bb8:	e1 14       	cp	r14, r1
    1bba:	f1 04       	cpc	r15, r1
    1bbc:	b1 f4       	brne	.+44     	; 0x1bea <xTaskIncrementTick+0x64>
    1bbe:	80 91 ef 08 	lds	r24, 0x08EF
    1bc2:	90 91 f0 08 	lds	r25, 0x08F0
    1bc6:	20 91 ed 08 	lds	r18, 0x08ED
    1bca:	30 91 ee 08 	lds	r19, 0x08EE
    1bce:	30 93 f0 08 	sts	0x08F0, r19
    1bd2:	20 93 ef 08 	sts	0x08EF, r18
    1bd6:	90 93 ee 08 	sts	0x08EE, r25
    1bda:	80 93 ed 08 	sts	0x08ED, r24
    1bde:	80 91 d2 08 	lds	r24, 0x08D2
    1be2:	8f 5f       	subi	r24, 0xFF	; 255
    1be4:	80 93 d2 08 	sts	0x08D2, r24
    1be8:	42 de       	rcall	.-892    	; 0x186e <prvResetNextTaskUnblockTime>
    1bea:	80 91 06 02 	lds	r24, 0x0206
    1bee:	90 91 07 02 	lds	r25, 0x0207
    1bf2:	e8 16       	cp	r14, r24
    1bf4:	f9 06       	cpc	r15, r25
    1bf6:	08 f4       	brcc	.+2      	; 0x1bfa <xTaskIncrementTick+0x74>
    1bf8:	54 c0       	rjmp	.+168    	; 0x1ca2 <xTaskIncrementTick+0x11c>
    1bfa:	d1 2c       	mov	r13, r1
    1bfc:	cc 24       	eor	r12, r12
    1bfe:	c3 94       	inc	r12
    1c00:	01 c0       	rjmp	.+2      	; 0x1c04 <xTaskIncrementTick+0x7e>
    1c02:	dc 2c       	mov	r13, r12
    1c04:	e0 91 ef 08 	lds	r30, 0x08EF
    1c08:	f0 91 f0 08 	lds	r31, 0x08F0
    1c0c:	80 81       	ld	r24, Z
    1c0e:	81 11       	cpse	r24, r1
    1c10:	07 c0       	rjmp	.+14     	; 0x1c20 <xTaskIncrementTick+0x9a>
    1c12:	8f ef       	ldi	r24, 0xFF	; 255
    1c14:	9f ef       	ldi	r25, 0xFF	; 255
    1c16:	90 93 07 02 	sts	0x0207, r25
    1c1a:	80 93 06 02 	sts	0x0206, r24
    1c1e:	42 c0       	rjmp	.+132    	; 0x1ca4 <xTaskIncrementTick+0x11e>
    1c20:	e0 91 ef 08 	lds	r30, 0x08EF
    1c24:	f0 91 f0 08 	lds	r31, 0x08F0
    1c28:	05 80       	ldd	r0, Z+5	; 0x05
    1c2a:	f6 81       	ldd	r31, Z+6	; 0x06
    1c2c:	e0 2d       	mov	r30, r0
    1c2e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c30:	d7 81       	ldd	r29, Z+7	; 0x07
    1c32:	2a 81       	ldd	r18, Y+2	; 0x02
    1c34:	3b 81       	ldd	r19, Y+3	; 0x03
    1c36:	e2 16       	cp	r14, r18
    1c38:	f3 06       	cpc	r15, r19
    1c3a:	28 f4       	brcc	.+10     	; 0x1c46 <xTaskIncrementTick+0xc0>
    1c3c:	30 93 07 02 	sts	0x0207, r19
    1c40:	20 93 06 02 	sts	0x0206, r18
    1c44:	2f c0       	rjmp	.+94     	; 0x1ca4 <xTaskIncrementTick+0x11e>
    1c46:	8e 01       	movw	r16, r28
    1c48:	0e 5f       	subi	r16, 0xFE	; 254
    1c4a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c4c:	c8 01       	movw	r24, r16
    1c4e:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1c52:	8c 89       	ldd	r24, Y+20	; 0x14
    1c54:	9d 89       	ldd	r25, Y+21	; 0x15
    1c56:	89 2b       	or	r24, r25
    1c58:	21 f0       	breq	.+8      	; 0x1c62 <xTaskIncrementTick+0xdc>
    1c5a:	ce 01       	movw	r24, r28
    1c5c:	0c 96       	adiw	r24, 0x0c	; 12
    1c5e:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1c62:	2e 89       	ldd	r18, Y+22	; 0x16
    1c64:	80 91 d6 08 	lds	r24, 0x08D6
    1c68:	82 17       	cp	r24, r18
    1c6a:	10 f4       	brcc	.+4      	; 0x1c70 <xTaskIncrementTick+0xea>
    1c6c:	20 93 d6 08 	sts	0x08D6, r18
    1c70:	30 e0       	ldi	r19, 0x00	; 0
    1c72:	c9 01       	movw	r24, r18
    1c74:	88 0f       	add	r24, r24
    1c76:	99 1f       	adc	r25, r25
    1c78:	88 0f       	add	r24, r24
    1c7a:	99 1f       	adc	r25, r25
    1c7c:	88 0f       	add	r24, r24
    1c7e:	99 1f       	adc	r25, r25
    1c80:	82 0f       	add	r24, r18
    1c82:	93 1f       	adc	r25, r19
    1c84:	b8 01       	movw	r22, r16
    1c86:	8d 5f       	subi	r24, 0xFD	; 253
    1c88:	96 4f       	sbci	r25, 0xF6	; 246
    1c8a:	0e 94 58 04 	call	0x8b0	; 0x8b0 <vListInsertEnd>
    1c8e:	e0 91 27 09 	lds	r30, 0x0927
    1c92:	f0 91 28 09 	lds	r31, 0x0928
    1c96:	9e 89       	ldd	r25, Y+22	; 0x16
    1c98:	86 89       	ldd	r24, Z+22	; 0x16
    1c9a:	98 17       	cp	r25, r24
    1c9c:	08 f0       	brcs	.+2      	; 0x1ca0 <xTaskIncrementTick+0x11a>
    1c9e:	b1 cf       	rjmp	.-158    	; 0x1c02 <xTaskIncrementTick+0x7c>
    1ca0:	b1 cf       	rjmp	.-158    	; 0x1c04 <xTaskIncrementTick+0x7e>
    1ca2:	d1 2c       	mov	r13, r1
    1ca4:	e0 91 27 09 	lds	r30, 0x0927
    1ca8:	f0 91 28 09 	lds	r31, 0x0928
    1cac:	86 89       	ldd	r24, Z+22	; 0x16
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	fc 01       	movw	r30, r24
    1cb2:	ee 0f       	add	r30, r30
    1cb4:	ff 1f       	adc	r31, r31
    1cb6:	ee 0f       	add	r30, r30
    1cb8:	ff 1f       	adc	r31, r31
    1cba:	ee 0f       	add	r30, r30
    1cbc:	ff 1f       	adc	r31, r31
    1cbe:	8e 0f       	add	r24, r30
    1cc0:	9f 1f       	adc	r25, r31
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	ed 5f       	subi	r30, 0xFD	; 253
    1cc6:	f6 4f       	sbci	r31, 0xF6	; 246
    1cc8:	80 81       	ld	r24, Z
    1cca:	82 30       	cpi	r24, 0x02	; 2
    1ccc:	40 f4       	brcc	.+16     	; 0x1cde <xTaskIncrementTick+0x158>
    1cce:	09 c0       	rjmp	.+18     	; 0x1ce2 <xTaskIncrementTick+0x15c>
    1cd0:	80 91 d4 08 	lds	r24, 0x08D4
    1cd4:	8f 5f       	subi	r24, 0xFF	; 255
    1cd6:	80 93 d4 08 	sts	0x08D4, r24
    1cda:	d1 2c       	mov	r13, r1
    1cdc:	02 c0       	rjmp	.+4      	; 0x1ce2 <xTaskIncrementTick+0x15c>
    1cde:	dd 24       	eor	r13, r13
    1ce0:	d3 94       	inc	r13
    1ce2:	80 91 d3 08 	lds	r24, 0x08D3
    1ce6:	88 23       	and	r24, r24
    1ce8:	11 f0       	breq	.+4      	; 0x1cee <xTaskIncrementTick+0x168>
    1cea:	dd 24       	eor	r13, r13
    1cec:	d3 94       	inc	r13
    1cee:	8d 2d       	mov	r24, r13
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	1f 91       	pop	r17
    1cf6:	0f 91       	pop	r16
    1cf8:	ff 90       	pop	r15
    1cfa:	ef 90       	pop	r14
    1cfc:	df 90       	pop	r13
    1cfe:	cf 90       	pop	r12
    1d00:	08 95       	ret

00001d02 <xTaskResumeAll>:
    1d02:	df 92       	push	r13
    1d04:	ef 92       	push	r14
    1d06:	ff 92       	push	r15
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	0f 92       	push	r0
    1d16:	80 91 d0 08 	lds	r24, 0x08D0
    1d1a:	81 50       	subi	r24, 0x01	; 1
    1d1c:	80 93 d0 08 	sts	0x08D0, r24
    1d20:	80 91 d0 08 	lds	r24, 0x08D0
    1d24:	81 11       	cpse	r24, r1
    1d26:	5f c0       	rjmp	.+190    	; 0x1de6 <xTaskResumeAll+0xe4>
    1d28:	80 91 d9 08 	lds	r24, 0x08D9
    1d2c:	88 23       	and	r24, r24
    1d2e:	09 f4       	brne	.+2      	; 0x1d32 <xTaskResumeAll+0x30>
    1d30:	5c c0       	rjmp	.+184    	; 0x1dea <xTaskResumeAll+0xe8>
    1d32:	0f 2e       	mov	r0, r31
    1d34:	f4 ee       	ldi	r31, 0xE4	; 228
    1d36:	ef 2e       	mov	r14, r31
    1d38:	f8 e0       	ldi	r31, 0x08	; 8
    1d3a:	ff 2e       	mov	r15, r31
    1d3c:	f0 2d       	mov	r31, r0
    1d3e:	dd 24       	eor	r13, r13
    1d40:	d3 94       	inc	r13
    1d42:	30 c0       	rjmp	.+96     	; 0x1da4 <xTaskResumeAll+0xa2>
    1d44:	e0 91 e9 08 	lds	r30, 0x08E9
    1d48:	f0 91 ea 08 	lds	r31, 0x08EA
    1d4c:	c6 81       	ldd	r28, Z+6	; 0x06
    1d4e:	d7 81       	ldd	r29, Z+7	; 0x07
    1d50:	ce 01       	movw	r24, r28
    1d52:	0c 96       	adiw	r24, 0x0c	; 12
    1d54:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1d58:	8e 01       	movw	r16, r28
    1d5a:	0e 5f       	subi	r16, 0xFE	; 254
    1d5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d5e:	c8 01       	movw	r24, r16
    1d60:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
    1d64:	8e 89       	ldd	r24, Y+22	; 0x16
    1d66:	90 91 d6 08 	lds	r25, 0x08D6
    1d6a:	98 17       	cp	r25, r24
    1d6c:	10 f4       	brcc	.+4      	; 0x1d72 <xTaskResumeAll+0x70>
    1d6e:	80 93 d6 08 	sts	0x08D6, r24
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	9c 01       	movw	r18, r24
    1d76:	22 0f       	add	r18, r18
    1d78:	33 1f       	adc	r19, r19
    1d7a:	22 0f       	add	r18, r18
    1d7c:	33 1f       	adc	r19, r19
    1d7e:	22 0f       	add	r18, r18
    1d80:	33 1f       	adc	r19, r19
    1d82:	82 0f       	add	r24, r18
    1d84:	93 1f       	adc	r25, r19
    1d86:	b8 01       	movw	r22, r16
    1d88:	8d 5f       	subi	r24, 0xFD	; 253
    1d8a:	96 4f       	sbci	r25, 0xF6	; 246
    1d8c:	0e 94 58 04 	call	0x8b0	; 0x8b0 <vListInsertEnd>
    1d90:	e0 91 27 09 	lds	r30, 0x0927
    1d94:	f0 91 28 09 	lds	r31, 0x0928
    1d98:	9e 89       	ldd	r25, Y+22	; 0x16
    1d9a:	86 89       	ldd	r24, Z+22	; 0x16
    1d9c:	98 17       	cp	r25, r24
    1d9e:	10 f0       	brcs	.+4      	; 0x1da4 <xTaskResumeAll+0xa2>
    1da0:	d0 92 d3 08 	sts	0x08D3, r13
    1da4:	f7 01       	movw	r30, r14
    1da6:	80 81       	ld	r24, Z
    1da8:	81 11       	cpse	r24, r1
    1daa:	cc cf       	rjmp	.-104    	; 0x1d44 <xTaskResumeAll+0x42>
    1dac:	80 91 d4 08 	lds	r24, 0x08D4
    1db0:	88 23       	and	r24, r24
    1db2:	91 f0       	breq	.+36     	; 0x1dd8 <xTaskResumeAll+0xd6>
    1db4:	80 91 d4 08 	lds	r24, 0x08D4
    1db8:	88 23       	and	r24, r24
    1dba:	71 f0       	breq	.+28     	; 0x1dd8 <xTaskResumeAll+0xd6>
    1dbc:	c1 e0       	ldi	r28, 0x01	; 1
    1dbe:	e3 de       	rcall	.-570    	; 0x1b86 <xTaskIncrementTick>
    1dc0:	81 11       	cpse	r24, r1
    1dc2:	c0 93 d3 08 	sts	0x08D3, r28
    1dc6:	80 91 d4 08 	lds	r24, 0x08D4
    1dca:	81 50       	subi	r24, 0x01	; 1
    1dcc:	80 93 d4 08 	sts	0x08D4, r24
    1dd0:	80 91 d4 08 	lds	r24, 0x08D4
    1dd4:	81 11       	cpse	r24, r1
    1dd6:	f3 cf       	rjmp	.-26     	; 0x1dbe <xTaskResumeAll+0xbc>
    1dd8:	80 91 d3 08 	lds	r24, 0x08D3
    1ddc:	81 30       	cpi	r24, 0x01	; 1
    1dde:	39 f4       	brne	.+14     	; 0x1dee <xTaskResumeAll+0xec>
    1de0:	7b d9       	rcall	.-3338   	; 0x10d8 <vPortYield>
    1de2:	81 e0       	ldi	r24, 0x01	; 1
    1de4:	05 c0       	rjmp	.+10     	; 0x1df0 <xTaskResumeAll+0xee>
    1de6:	80 e0       	ldi	r24, 0x00	; 0
    1de8:	03 c0       	rjmp	.+6      	; 0x1df0 <xTaskResumeAll+0xee>
    1dea:	80 e0       	ldi	r24, 0x00	; 0
    1dec:	01 c0       	rjmp	.+2      	; 0x1df0 <xTaskResumeAll+0xee>
    1dee:	80 e0       	ldi	r24, 0x00	; 0
    1df0:	0f 90       	pop	r0
    1df2:	0f be       	out	0x3f, r0	; 63
    1df4:	df 91       	pop	r29
    1df6:	cf 91       	pop	r28
    1df8:	1f 91       	pop	r17
    1dfa:	0f 91       	pop	r16
    1dfc:	ff 90       	pop	r15
    1dfe:	ef 90       	pop	r14
    1e00:	df 90       	pop	r13
    1e02:	08 95       	ret

00001e04 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1e04:	cf 93       	push	r28
    1e06:	df 93       	push	r29
    1e08:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1e0a:	00 97       	sbiw	r24, 0x00	; 0
    1e0c:	99 f0       	breq	.+38     	; 0x1e34 <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1e0e:	b5 de       	rcall	.-662    	; 0x1b7a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e10:	80 91 d7 08 	lds	r24, 0x08D7
    1e14:	90 91 d8 08 	lds	r25, 0x08D8
    1e18:	c8 0f       	add	r28, r24
    1e1a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1e1c:	80 91 27 09 	lds	r24, 0x0927
    1e20:	90 91 28 09 	lds	r25, 0x0928
    1e24:	02 96       	adiw	r24, 0x02	; 2
    1e26:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e2a:	ce 01       	movw	r24, r28
    1e2c:	3f dd       	rcall	.-1410   	; 0x18ac <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e2e:	69 df       	rcall	.-302    	; 0x1d02 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e30:	81 11       	cpse	r24, r1
    1e32:	01 c0       	rjmp	.+2      	; 0x1e36 <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    1e34:	51 d9       	rcall	.-3422   	; 0x10d8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1e36:	df 91       	pop	r29
    1e38:	cf 91       	pop	r28
    1e3a:	08 95       	ret

00001e3c <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1e3c:	0f 2e       	mov	r0, r31
    1e3e:	f3 e0       	ldi	r31, 0x03	; 3
    1e40:	ef 2e       	mov	r14, r31
    1e42:	f9 e0       	ldi	r31, 0x09	; 9
    1e44:	ff 2e       	mov	r15, r31
    1e46:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1e48:	cb ed       	ldi	r28, 0xDB	; 219
    1e4a:	d8 e0       	ldi	r29, 0x08	; 8
    1e4c:	26 c0       	rjmp	.+76     	; 0x1e9a <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    1e4e:	95 de       	rcall	.-726    	; 0x1b7a <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1e50:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    1e52:	57 df       	rcall	.-338    	; 0x1d02 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1e54:	11 23       	and	r17, r17
    1e56:	09 f1       	breq	.+66     	; 0x1e9a <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1e58:	0f b6       	in	r0, 0x3f	; 63
    1e5a:	f8 94       	cli
    1e5c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1e5e:	e0 91 e0 08 	lds	r30, 0x08E0
    1e62:	f0 91 e1 08 	lds	r31, 0x08E1
    1e66:	06 81       	ldd	r16, Z+6	; 0x06
    1e68:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1e6a:	c8 01       	movw	r24, r16
    1e6c:	02 96       	adiw	r24, 0x02	; 2
    1e6e:	0e 94 aa 04 	call	0x954	; 0x954 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1e72:	80 91 d9 08 	lds	r24, 0x08D9
    1e76:	81 50       	subi	r24, 0x01	; 1
    1e78:	80 93 d9 08 	sts	0x08D9, r24
					--uxTasksDeleted;
    1e7c:	80 91 da 08 	lds	r24, 0x08DA
    1e80:	81 50       	subi	r24, 0x01	; 1
    1e82:	80 93 da 08 	sts	0x08DA, r24
				}
				taskEXIT_CRITICAL();
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    1e8a:	f8 01       	movw	r30, r16
    1e8c:	87 89       	ldd	r24, Z+23	; 0x17
    1e8e:	90 8d       	ldd	r25, Z+24	; 0x18
    1e90:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortFree>
		vPortFree( pxTCB );
    1e94:	c8 01       	movw	r24, r16
    1e96:	0e 94 cd 02 	call	0x59a	; 0x59a <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1e9a:	80 91 da 08 	lds	r24, 0x08DA
    1e9e:	81 11       	cpse	r24, r1
    1ea0:	d6 cf       	rjmp	.-84     	; 0x1e4e <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1ea2:	f7 01       	movw	r30, r14
    1ea4:	80 81       	ld	r24, Z
    1ea6:	82 30       	cpi	r24, 0x02	; 2
    1ea8:	c0 f3       	brcs	.-16     	; 0x1e9a <prvIdleTask+0x5e>
			{
				taskYIELD();
    1eaa:	16 d9       	rcall	.-3540   	; 0x10d8 <vPortYield>
    1eac:	f6 cf       	rjmp	.-20     	; 0x1e9a <prvIdleTask+0x5e>

00001eae <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1eae:	80 91 d0 08 	lds	r24, 0x08D0
    1eb2:	88 23       	and	r24, r24
    1eb4:	21 f0       	breq	.+8      	; 0x1ebe <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	80 93 d3 08 	sts	0x08D3, r24
    1ebc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1ebe:	10 92 d3 08 	sts	0x08D3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1ec2:	80 91 d6 08 	lds	r24, 0x08D6
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	fc 01       	movw	r30, r24
    1eca:	ee 0f       	add	r30, r30
    1ecc:	ff 1f       	adc	r31, r31
    1ece:	ee 0f       	add	r30, r30
    1ed0:	ff 1f       	adc	r31, r31
    1ed2:	ee 0f       	add	r30, r30
    1ed4:	ff 1f       	adc	r31, r31
    1ed6:	8e 0f       	add	r24, r30
    1ed8:	9f 1f       	adc	r25, r31
    1eda:	fc 01       	movw	r30, r24
    1edc:	ed 5f       	subi	r30, 0xFD	; 253
    1ede:	f6 4f       	sbci	r31, 0xF6	; 246
    1ee0:	80 81       	ld	r24, Z
    1ee2:	81 11       	cpse	r24, r1
    1ee4:	17 c0       	rjmp	.+46     	; 0x1f14 <vTaskSwitchContext+0x66>
    1ee6:	80 91 d6 08 	lds	r24, 0x08D6
    1eea:	81 50       	subi	r24, 0x01	; 1
    1eec:	80 93 d6 08 	sts	0x08D6, r24
    1ef0:	80 91 d6 08 	lds	r24, 0x08D6
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	fc 01       	movw	r30, r24
    1ef8:	ee 0f       	add	r30, r30
    1efa:	ff 1f       	adc	r31, r31
    1efc:	ee 0f       	add	r30, r30
    1efe:	ff 1f       	adc	r31, r31
    1f00:	ee 0f       	add	r30, r30
    1f02:	ff 1f       	adc	r31, r31
    1f04:	8e 0f       	add	r24, r30
    1f06:	9f 1f       	adc	r25, r31
    1f08:	fc 01       	movw	r30, r24
    1f0a:	ed 5f       	subi	r30, 0xFD	; 253
    1f0c:	f6 4f       	sbci	r31, 0xF6	; 246
    1f0e:	80 81       	ld	r24, Z
    1f10:	88 23       	and	r24, r24
    1f12:	49 f3       	breq	.-46     	; 0x1ee6 <vTaskSwitchContext+0x38>
    1f14:	e0 91 d6 08 	lds	r30, 0x08D6
    1f18:	f0 e0       	ldi	r31, 0x00	; 0
    1f1a:	cf 01       	movw	r24, r30
    1f1c:	88 0f       	add	r24, r24
    1f1e:	99 1f       	adc	r25, r25
    1f20:	88 0f       	add	r24, r24
    1f22:	99 1f       	adc	r25, r25
    1f24:	88 0f       	add	r24, r24
    1f26:	99 1f       	adc	r25, r25
    1f28:	e8 0f       	add	r30, r24
    1f2a:	f9 1f       	adc	r31, r25
    1f2c:	ed 5f       	subi	r30, 0xFD	; 253
    1f2e:	f6 4f       	sbci	r31, 0xF6	; 246
    1f30:	a1 81       	ldd	r26, Z+1	; 0x01
    1f32:	b2 81       	ldd	r27, Z+2	; 0x02
    1f34:	12 96       	adiw	r26, 0x02	; 2
    1f36:	0d 90       	ld	r0, X+
    1f38:	bc 91       	ld	r27, X
    1f3a:	a0 2d       	mov	r26, r0
    1f3c:	b2 83       	std	Z+2, r27	; 0x02
    1f3e:	a1 83       	std	Z+1, r26	; 0x01
    1f40:	cf 01       	movw	r24, r30
    1f42:	03 96       	adiw	r24, 0x03	; 3
    1f44:	a8 17       	cp	r26, r24
    1f46:	b9 07       	cpc	r27, r25
    1f48:	31 f4       	brne	.+12     	; 0x1f56 <vTaskSwitchContext+0xa8>
    1f4a:	12 96       	adiw	r26, 0x02	; 2
    1f4c:	8d 91       	ld	r24, X+
    1f4e:	9c 91       	ld	r25, X
    1f50:	13 97       	sbiw	r26, 0x03	; 3
    1f52:	92 83       	std	Z+2, r25	; 0x02
    1f54:	81 83       	std	Z+1, r24	; 0x01
    1f56:	01 80       	ldd	r0, Z+1	; 0x01
    1f58:	f2 81       	ldd	r31, Z+2	; 0x02
    1f5a:	e0 2d       	mov	r30, r0
    1f5c:	86 81       	ldd	r24, Z+6	; 0x06
    1f5e:	97 81       	ldd	r25, Z+7	; 0x07
    1f60:	90 93 28 09 	sts	0x0928, r25
    1f64:	80 93 27 09 	sts	0x0927, r24
    1f68:	08 95       	ret

00001f6a <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1f6a:	10 92 96 09 	sts	0x0996, r1
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	80 93 94 09 	sts	0x0994, r24
    1f74:	10 92 93 09 	sts	0x0993, r1
    1f78:	61 e0       	ldi	r22, 0x01	; 1
    1f7a:	84 e1       	ldi	r24, 0x14	; 20
    1f7c:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <digitalWrite>
    1f80:	61 e0       	ldi	r22, 0x01	; 1
    1f82:	85 e1       	ldi	r24, 0x15	; 21
    1f84:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <digitalWrite>
    1f88:	e9 eb       	ldi	r30, 0xB9	; 185
    1f8a:	f0 e0       	ldi	r31, 0x00	; 0
    1f8c:	80 81       	ld	r24, Z
    1f8e:	8e 7f       	andi	r24, 0xFE	; 254
    1f90:	80 83       	st	Z, r24
    1f92:	80 81       	ld	r24, Z
    1f94:	8d 7f       	andi	r24, 0xFD	; 253
    1f96:	80 83       	st	Z, r24
    1f98:	8d ef       	ldi	r24, 0xFD	; 253
    1f9a:	80 93 b8 00 	sts	0x00B8, r24
    1f9e:	85 e4       	ldi	r24, 0x45	; 69
    1fa0:	80 93 bc 00 	sts	0x00BC, r24
    1fa4:	08 95       	ret

00001fa6 <twi_readFrom>:
    1fa6:	41 32       	cpi	r20, 0x21	; 33
    1fa8:	08 f0       	brcs	.+2      	; 0x1fac <twi_readFrom+0x6>
    1faa:	45 c0       	rjmp	.+138    	; 0x2036 <twi_readFrom+0x90>
    1fac:	90 91 96 09 	lds	r25, 0x0996
    1fb0:	91 11       	cpse	r25, r1
    1fb2:	fc cf       	rjmp	.-8      	; 0x1fac <twi_readFrom+0x6>
    1fb4:	91 e0       	ldi	r25, 0x01	; 1
    1fb6:	90 93 96 09 	sts	0x0996, r25
    1fba:	20 93 94 09 	sts	0x0994, r18
    1fbe:	2f ef       	ldi	r18, 0xFF	; 255
    1fc0:	20 93 29 09 	sts	0x0929, r18
    1fc4:	10 92 6e 09 	sts	0x096E, r1
    1fc8:	24 0f       	add	r18, r20
    1fca:	20 93 6d 09 	sts	0x096D, r18
    1fce:	90 93 95 09 	sts	0x0995, r25
    1fd2:	90 91 95 09 	lds	r25, 0x0995
    1fd6:	88 0f       	add	r24, r24
    1fd8:	89 2b       	or	r24, r25
    1fda:	80 93 95 09 	sts	0x0995, r24
    1fde:	80 91 93 09 	lds	r24, 0x0993
    1fe2:	81 30       	cpi	r24, 0x01	; 1
    1fe4:	51 f4       	brne	.+20     	; 0x1ffa <twi_readFrom+0x54>
    1fe6:	10 92 93 09 	sts	0x0993, r1
    1fea:	80 91 95 09 	lds	r24, 0x0995
    1fee:	80 93 bb 00 	sts	0x00BB, r24
    1ff2:	85 ec       	ldi	r24, 0xC5	; 197
    1ff4:	80 93 bc 00 	sts	0x00BC, r24
    1ff8:	03 c0       	rjmp	.+6      	; 0x2000 <twi_readFrom+0x5a>
    1ffa:	85 ee       	ldi	r24, 0xE5	; 229
    1ffc:	80 93 bc 00 	sts	0x00BC, r24
    2000:	80 91 96 09 	lds	r24, 0x0996
    2004:	81 30       	cpi	r24, 0x01	; 1
    2006:	e1 f3       	breq	.-8      	; 0x2000 <twi_readFrom+0x5a>
    2008:	80 91 6e 09 	lds	r24, 0x096E
    200c:	84 17       	cp	r24, r20
    200e:	10 f4       	brcc	.+4      	; 0x2014 <twi_readFrom+0x6e>
    2010:	40 91 6e 09 	lds	r20, 0x096E
    2014:	44 23       	and	r20, r20
    2016:	89 f0       	breq	.+34     	; 0x203a <twi_readFrom+0x94>
    2018:	ef e6       	ldi	r30, 0x6F	; 111
    201a:	f9 e0       	ldi	r31, 0x09	; 9
    201c:	a6 2f       	mov	r26, r22
    201e:	b7 2f       	mov	r27, r23
    2020:	2f ef       	ldi	r18, 0xFF	; 255
    2022:	24 0f       	add	r18, r20
    2024:	30 e0       	ldi	r19, 0x00	; 0
    2026:	20 59       	subi	r18, 0x90	; 144
    2028:	36 4f       	sbci	r19, 0xF6	; 246
    202a:	91 91       	ld	r25, Z+
    202c:	9d 93       	st	X+, r25
    202e:	e2 17       	cp	r30, r18
    2030:	f3 07       	cpc	r31, r19
    2032:	d9 f7       	brne	.-10     	; 0x202a <twi_readFrom+0x84>
    2034:	04 c0       	rjmp	.+8      	; 0x203e <twi_readFrom+0x98>
    2036:	80 e0       	ldi	r24, 0x00	; 0
    2038:	08 95       	ret
    203a:	84 2f       	mov	r24, r20
    203c:	08 95       	ret
    203e:	84 2f       	mov	r24, r20
    2040:	08 95       	ret

00002042 <twi_writeTo>:
    2042:	0f 93       	push	r16
    2044:	41 32       	cpi	r20, 0x21	; 33
    2046:	08 f0       	brcs	.+2      	; 0x204a <twi_writeTo+0x8>
    2048:	50 c0       	rjmp	.+160    	; 0x20ea <twi_writeTo+0xa8>
    204a:	90 91 96 09 	lds	r25, 0x0996
    204e:	91 11       	cpse	r25, r1
    2050:	fc cf       	rjmp	.-8      	; 0x204a <twi_writeTo+0x8>
    2052:	92 e0       	ldi	r25, 0x02	; 2
    2054:	90 93 96 09 	sts	0x0996, r25
    2058:	00 93 94 09 	sts	0x0994, r16
    205c:	9f ef       	ldi	r25, 0xFF	; 255
    205e:	90 93 29 09 	sts	0x0929, r25
    2062:	10 92 6e 09 	sts	0x096E, r1
    2066:	40 93 6d 09 	sts	0x096D, r20
    206a:	44 23       	and	r20, r20
    206c:	69 f0       	breq	.+26     	; 0x2088 <twi_writeTo+0x46>
    206e:	fb 01       	movw	r30, r22
    2070:	af e6       	ldi	r26, 0x6F	; 111
    2072:	b9 e0       	ldi	r27, 0x09	; 9
    2074:	6f 5f       	subi	r22, 0xFF	; 255
    2076:	7f 4f       	sbci	r23, 0xFF	; 255
    2078:	41 50       	subi	r20, 0x01	; 1
    207a:	64 0f       	add	r22, r20
    207c:	71 1d       	adc	r23, r1
    207e:	91 91       	ld	r25, Z+
    2080:	9d 93       	st	X+, r25
    2082:	e6 17       	cp	r30, r22
    2084:	f7 07       	cpc	r31, r23
    2086:	d9 f7       	brne	.-10     	; 0x207e <twi_writeTo+0x3c>
    2088:	10 92 95 09 	sts	0x0995, r1
    208c:	90 91 95 09 	lds	r25, 0x0995
    2090:	88 0f       	add	r24, r24
    2092:	89 2b       	or	r24, r25
    2094:	80 93 95 09 	sts	0x0995, r24
    2098:	80 91 93 09 	lds	r24, 0x0993
    209c:	81 30       	cpi	r24, 0x01	; 1
    209e:	51 f4       	brne	.+20     	; 0x20b4 <twi_writeTo+0x72>
    20a0:	10 92 93 09 	sts	0x0993, r1
    20a4:	80 91 95 09 	lds	r24, 0x0995
    20a8:	80 93 bb 00 	sts	0x00BB, r24
    20ac:	85 ec       	ldi	r24, 0xC5	; 197
    20ae:	80 93 bc 00 	sts	0x00BC, r24
    20b2:	03 c0       	rjmp	.+6      	; 0x20ba <twi_writeTo+0x78>
    20b4:	85 ee       	ldi	r24, 0xE5	; 229
    20b6:	80 93 bc 00 	sts	0x00BC, r24
    20ba:	22 23       	and	r18, r18
    20bc:	41 f0       	breq	.+16     	; 0x20ce <twi_writeTo+0x8c>
    20be:	80 91 96 09 	lds	r24, 0x0996
    20c2:	82 30       	cpi	r24, 0x02	; 2
    20c4:	21 f4       	brne	.+8      	; 0x20ce <twi_writeTo+0x8c>
    20c6:	80 91 96 09 	lds	r24, 0x0996
    20ca:	82 30       	cpi	r24, 0x02	; 2
    20cc:	e1 f3       	breq	.-8      	; 0x20c6 <twi_writeTo+0x84>
    20ce:	80 91 29 09 	lds	r24, 0x0929
    20d2:	8f 3f       	cpi	r24, 0xFF	; 255
    20d4:	61 f0       	breq	.+24     	; 0x20ee <twi_writeTo+0xac>
    20d6:	80 91 29 09 	lds	r24, 0x0929
    20da:	80 32       	cpi	r24, 0x20	; 32
    20dc:	51 f0       	breq	.+20     	; 0x20f2 <twi_writeTo+0xb0>
    20de:	80 91 29 09 	lds	r24, 0x0929
    20e2:	80 33       	cpi	r24, 0x30	; 48
    20e4:	41 f4       	brne	.+16     	; 0x20f6 <twi_writeTo+0xb4>
    20e6:	83 e0       	ldi	r24, 0x03	; 3
    20e8:	07 c0       	rjmp	.+14     	; 0x20f8 <twi_writeTo+0xb6>
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	05 c0       	rjmp	.+10     	; 0x20f8 <twi_writeTo+0xb6>
    20ee:	80 e0       	ldi	r24, 0x00	; 0
    20f0:	03 c0       	rjmp	.+6      	; 0x20f8 <twi_writeTo+0xb6>
    20f2:	82 e0       	ldi	r24, 0x02	; 2
    20f4:	01 c0       	rjmp	.+2      	; 0x20f8 <twi_writeTo+0xb6>
    20f6:	84 e0       	ldi	r24, 0x04	; 4
    20f8:	0f 91       	pop	r16
    20fa:	08 95       	ret

000020fc <twi_transmit>:
    20fc:	61 32       	cpi	r22, 0x21	; 33
    20fe:	a8 f4       	brcc	.+42     	; 0x212a <twi_transmit+0x2e>
    2100:	20 91 96 09 	lds	r18, 0x0996
    2104:	24 30       	cpi	r18, 0x04	; 4
    2106:	99 f4       	brne	.+38     	; 0x212e <twi_transmit+0x32>
    2108:	60 93 4b 09 	sts	0x094B, r22
    210c:	66 23       	and	r22, r22
    210e:	89 f0       	breq	.+34     	; 0x2132 <twi_transmit+0x36>
    2110:	fc 01       	movw	r30, r24
    2112:	ad e4       	ldi	r26, 0x4D	; 77
    2114:	b9 e0       	ldi	r27, 0x09	; 9
    2116:	01 96       	adiw	r24, 0x01	; 1
    2118:	61 50       	subi	r22, 0x01	; 1
    211a:	86 0f       	add	r24, r22
    211c:	91 1d       	adc	r25, r1
    211e:	21 91       	ld	r18, Z+
    2120:	2d 93       	st	X+, r18
    2122:	e8 17       	cp	r30, r24
    2124:	f9 07       	cpc	r31, r25
    2126:	d9 f7       	brne	.-10     	; 0x211e <twi_transmit+0x22>
    2128:	06 c0       	rjmp	.+12     	; 0x2136 <twi_transmit+0x3a>
    212a:	81 e0       	ldi	r24, 0x01	; 1
    212c:	08 95       	ret
    212e:	82 e0       	ldi	r24, 0x02	; 2
    2130:	08 95       	ret
    2132:	80 e0       	ldi	r24, 0x00	; 0
    2134:	08 95       	ret
    2136:	80 e0       	ldi	r24, 0x00	; 0
    2138:	08 95       	ret

0000213a <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    213a:	85 ed       	ldi	r24, 0xD5	; 213
    213c:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    2140:	ec eb       	ldi	r30, 0xBC	; 188
    2142:	f0 e0       	ldi	r31, 0x00	; 0
    2144:	80 81       	ld	r24, Z
    2146:	84 fd       	sbrc	r24, 4
    2148:	fd cf       	rjmp	.-6      	; 0x2144 <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    214a:	10 92 96 09 	sts	0x0996, r1
    214e:	08 95       	ret

00002150 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2150:	85 ec       	ldi	r24, 0xC5	; 197
    2152:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2156:	10 92 96 09 	sts	0x0996, r1
    215a:	08 95       	ret

0000215c <__vector_39>:
}

ISR(TWI_vect)
{
    215c:	1f 92       	push	r1
    215e:	0f 92       	push	r0
    2160:	0f b6       	in	r0, 0x3f	; 63
    2162:	0f 92       	push	r0
    2164:	11 24       	eor	r1, r1
    2166:	0b b6       	in	r0, 0x3b	; 59
    2168:	0f 92       	push	r0
    216a:	2f 93       	push	r18
    216c:	3f 93       	push	r19
    216e:	4f 93       	push	r20
    2170:	5f 93       	push	r21
    2172:	6f 93       	push	r22
    2174:	7f 93       	push	r23
    2176:	8f 93       	push	r24
    2178:	9f 93       	push	r25
    217a:	af 93       	push	r26
    217c:	bf 93       	push	r27
    217e:	ef 93       	push	r30
    2180:	ff 93       	push	r31
  switch(TW_STATUS){
    2182:	80 91 b9 00 	lds	r24, 0x00B9
    2186:	88 7f       	andi	r24, 0xF8	; 248
    2188:	90 e0       	ldi	r25, 0x00	; 0
    218a:	89 3c       	cpi	r24, 0xC9	; 201
    218c:	91 05       	cpc	r25, r1
    218e:	08 f0       	brcs	.+2      	; 0x2192 <__vector_39+0x36>
    2190:	ee c0       	rjmp	.+476    	; 0x236e <__stack+0x16f>
    2192:	fc 01       	movw	r30, r24
    2194:	ee 58       	subi	r30, 0x8E	; 142
    2196:	ff 4f       	sbci	r31, 0xFF	; 255
    2198:	0c 94 4e 1b 	jmp	0x369c	; 0x369c <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    219c:	80 91 95 09 	lds	r24, 0x0995
    21a0:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    21a4:	85 ec       	ldi	r24, 0xC5	; 197
    21a6:	80 93 bc 00 	sts	0x00BC, r24
    21aa:	e1 c0       	rjmp	.+450    	; 0x236e <__stack+0x16f>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    21ac:	90 91 6e 09 	lds	r25, 0x096E
    21b0:	80 91 6d 09 	lds	r24, 0x096D
    21b4:	98 17       	cp	r25, r24
    21b6:	80 f4       	brcc	.+32     	; 0x21d8 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    21b8:	e0 91 6e 09 	lds	r30, 0x096E
    21bc:	81 e0       	ldi	r24, 0x01	; 1
    21be:	8e 0f       	add	r24, r30
    21c0:	80 93 6e 09 	sts	0x096E, r24
    21c4:	f0 e0       	ldi	r31, 0x00	; 0
    21c6:	e1 59       	subi	r30, 0x91	; 145
    21c8:	f6 4f       	sbci	r31, 0xF6	; 246
    21ca:	80 81       	ld	r24, Z
    21cc:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    21d0:	85 ec       	ldi	r24, 0xC5	; 197
    21d2:	80 93 bc 00 	sts	0x00BC, r24
    21d6:	cb c0       	rjmp	.+406    	; 0x236e <__stack+0x16f>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    21d8:	80 91 94 09 	lds	r24, 0x0994
    21dc:	88 23       	and	r24, r24
    21de:	11 f0       	breq	.+4      	; 0x21e4 <__vector_39+0x88>
          twi_stop();
    21e0:	ac df       	rcall	.-168    	; 0x213a <twi_stop>
    21e2:	c5 c0       	rjmp	.+394    	; 0x236e <__stack+0x16f>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	80 93 93 09 	sts	0x0993, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    21ea:	84 ea       	ldi	r24, 0xA4	; 164
    21ec:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    21f0:	10 92 96 09 	sts	0x0996, r1
    21f4:	bc c0       	rjmp	.+376    	; 0x236e <__stack+0x16f>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    21f6:	80 e2       	ldi	r24, 0x20	; 32
    21f8:	80 93 29 09 	sts	0x0929, r24
      twi_stop();
    21fc:	9e df       	rcall	.-196    	; 0x213a <twi_stop>
      break;
    21fe:	b7 c0       	rjmp	.+366    	; 0x236e <__stack+0x16f>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    2200:	80 e3       	ldi	r24, 0x30	; 48
    2202:	80 93 29 09 	sts	0x0929, r24
      twi_stop();
    2206:	99 df       	rcall	.-206    	; 0x213a <twi_stop>
      break;
    2208:	b2 c0       	rjmp	.+356    	; 0x236e <__stack+0x16f>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    220a:	88 e3       	ldi	r24, 0x38	; 56
    220c:	80 93 29 09 	sts	0x0929, r24
      twi_releaseBus();
    2210:	9f df       	rcall	.-194    	; 0x2150 <twi_releaseBus>
      break;
    2212:	ad c0       	rjmp	.+346    	; 0x236e <__stack+0x16f>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2214:	e0 91 6e 09 	lds	r30, 0x096E
    2218:	81 e0       	ldi	r24, 0x01	; 1
    221a:	8e 0f       	add	r24, r30
    221c:	80 93 6e 09 	sts	0x096E, r24
    2220:	80 91 bb 00 	lds	r24, 0x00BB
    2224:	f0 e0       	ldi	r31, 0x00	; 0
    2226:	e1 59       	subi	r30, 0x91	; 145
    2228:	f6 4f       	sbci	r31, 0xF6	; 246
    222a:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    222c:	90 91 6e 09 	lds	r25, 0x096E
    2230:	80 91 6d 09 	lds	r24, 0x096D
    2234:	98 17       	cp	r25, r24
    2236:	20 f4       	brcc	.+8      	; 0x2240 <__stack+0x41>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2238:	85 ec       	ldi	r24, 0xC5	; 197
    223a:	80 93 bc 00 	sts	0x00BC, r24
    223e:	97 c0       	rjmp	.+302    	; 0x236e <__stack+0x16f>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2240:	85 e8       	ldi	r24, 0x85	; 133
    2242:	80 93 bc 00 	sts	0x00BC, r24
    2246:	93 c0       	rjmp	.+294    	; 0x236e <__stack+0x16f>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2248:	e0 91 6e 09 	lds	r30, 0x096E
    224c:	81 e0       	ldi	r24, 0x01	; 1
    224e:	8e 0f       	add	r24, r30
    2250:	80 93 6e 09 	sts	0x096E, r24
    2254:	80 91 bb 00 	lds	r24, 0x00BB
    2258:	f0 e0       	ldi	r31, 0x00	; 0
    225a:	e1 59       	subi	r30, 0x91	; 145
    225c:	f6 4f       	sbci	r31, 0xF6	; 246
    225e:	80 83       	st	Z, r24
	if (twi_sendStop)
    2260:	80 91 94 09 	lds	r24, 0x0994
    2264:	88 23       	and	r24, r24
    2266:	11 f0       	breq	.+4      	; 0x226c <__stack+0x6d>
          twi_stop();
    2268:	68 df       	rcall	.-304    	; 0x213a <twi_stop>
    226a:	81 c0       	rjmp	.+258    	; 0x236e <__stack+0x16f>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    226c:	81 e0       	ldi	r24, 0x01	; 1
    226e:	80 93 93 09 	sts	0x0993, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2272:	84 ea       	ldi	r24, 0xA4	; 164
    2274:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    2278:	10 92 96 09 	sts	0x0996, r1
    227c:	78 c0       	rjmp	.+240    	; 0x236e <__stack+0x16f>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    227e:	5d df       	rcall	.-326    	; 0x213a <twi_stop>
      break;
    2280:	76 c0       	rjmp	.+236    	; 0x236e <__stack+0x16f>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    2282:	83 e0       	ldi	r24, 0x03	; 3
    2284:	80 93 96 09 	sts	0x0996, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    2288:	10 92 2a 09 	sts	0x092A, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    228c:	85 ec       	ldi	r24, 0xC5	; 197
    228e:	80 93 bc 00 	sts	0x00BC, r24
    2292:	6d c0       	rjmp	.+218    	; 0x236e <__stack+0x16f>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    2294:	80 91 2a 09 	lds	r24, 0x092A
    2298:	80 32       	cpi	r24, 0x20	; 32
    229a:	80 f4       	brcc	.+32     	; 0x22bc <__stack+0xbd>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    229c:	e0 91 2a 09 	lds	r30, 0x092A
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	8e 0f       	add	r24, r30
    22a4:	80 93 2a 09 	sts	0x092A, r24
    22a8:	80 91 bb 00 	lds	r24, 0x00BB
    22ac:	f0 e0       	ldi	r31, 0x00	; 0
    22ae:	e5 5d       	subi	r30, 0xD5	; 213
    22b0:	f6 4f       	sbci	r31, 0xF6	; 246
    22b2:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    22b4:	85 ec       	ldi	r24, 0xC5	; 197
    22b6:	80 93 bc 00 	sts	0x00BC, r24
    22ba:	59 c0       	rjmp	.+178    	; 0x236e <__stack+0x16f>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    22bc:	85 e8       	ldi	r24, 0x85	; 133
    22be:	80 93 bc 00 	sts	0x00BC, r24
    22c2:	55 c0       	rjmp	.+170    	; 0x236e <__stack+0x16f>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    22c4:	80 91 2a 09 	lds	r24, 0x092A
    22c8:	80 32       	cpi	r24, 0x20	; 32
    22ca:	30 f4       	brcc	.+12     	; 0x22d8 <__stack+0xd9>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    22cc:	e0 91 2a 09 	lds	r30, 0x092A
    22d0:	f0 e0       	ldi	r31, 0x00	; 0
    22d2:	e5 5d       	subi	r30, 0xD5	; 213
    22d4:	f6 4f       	sbci	r31, 0xF6	; 246
    22d6:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    22d8:	30 df       	rcall	.-416    	; 0x213a <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    22da:	60 91 2a 09 	lds	r22, 0x092A
    22de:	70 e0       	ldi	r23, 0x00	; 0
    22e0:	e0 91 8f 09 	lds	r30, 0x098F
    22e4:	f0 91 90 09 	lds	r31, 0x0990
    22e8:	8b e2       	ldi	r24, 0x2B	; 43
    22ea:	99 e0       	ldi	r25, 0x09	; 9
    22ec:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    22ee:	10 92 2a 09 	sts	0x092A, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    22f2:	2e df       	rcall	.-420    	; 0x2150 <twi_releaseBus>
      break;
    22f4:	3c c0       	rjmp	.+120    	; 0x236e <__stack+0x16f>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    22f6:	85 e8       	ldi	r24, 0x85	; 133
    22f8:	80 93 bc 00 	sts	0x00BC, r24
    22fc:	38 c0       	rjmp	.+112    	; 0x236e <__stack+0x16f>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    22fe:	84 e0       	ldi	r24, 0x04	; 4
    2300:	80 93 96 09 	sts	0x0996, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    2304:	10 92 4c 09 	sts	0x094C, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2308:	10 92 4b 09 	sts	0x094B, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    230c:	e0 91 91 09 	lds	r30, 0x0991
    2310:	f0 91 92 09 	lds	r31, 0x0992
    2314:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2316:	80 91 4b 09 	lds	r24, 0x094B
    231a:	81 11       	cpse	r24, r1
    231c:	05 c0       	rjmp	.+10     	; 0x2328 <__stack+0x129>
        twi_txBufferLength = 1;
    231e:	81 e0       	ldi	r24, 0x01	; 1
    2320:	80 93 4b 09 	sts	0x094B, r24
        twi_txBuffer[0] = 0x00;
    2324:	10 92 4d 09 	sts	0x094D, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2328:	e0 91 4c 09 	lds	r30, 0x094C
    232c:	81 e0       	ldi	r24, 0x01	; 1
    232e:	8e 0f       	add	r24, r30
    2330:	80 93 4c 09 	sts	0x094C, r24
    2334:	f0 e0       	ldi	r31, 0x00	; 0
    2336:	e3 5b       	subi	r30, 0xB3	; 179
    2338:	f6 4f       	sbci	r31, 0xF6	; 246
    233a:	80 81       	ld	r24, Z
    233c:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    2340:	90 91 4c 09 	lds	r25, 0x094C
    2344:	80 91 4b 09 	lds	r24, 0x094B
    2348:	98 17       	cp	r25, r24
    234a:	20 f4       	brcc	.+8      	; 0x2354 <__stack+0x155>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    234c:	85 ec       	ldi	r24, 0xC5	; 197
    234e:	80 93 bc 00 	sts	0x00BC, r24
    2352:	0d c0       	rjmp	.+26     	; 0x236e <__stack+0x16f>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2354:	85 e8       	ldi	r24, 0x85	; 133
    2356:	80 93 bc 00 	sts	0x00BC, r24
    235a:	09 c0       	rjmp	.+18     	; 0x236e <__stack+0x16f>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    235c:	85 ec       	ldi	r24, 0xC5	; 197
    235e:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    2362:	10 92 96 09 	sts	0x0996, r1
      break;
    2366:	03 c0       	rjmp	.+6      	; 0x236e <__stack+0x16f>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    2368:	10 92 29 09 	sts	0x0929, r1
      twi_stop();
    236c:	e6 de       	rcall	.-564    	; 0x213a <twi_stop>
      break;
  }
}
    236e:	ff 91       	pop	r31
    2370:	ef 91       	pop	r30
    2372:	bf 91       	pop	r27
    2374:	af 91       	pop	r26
    2376:	9f 91       	pop	r25
    2378:	8f 91       	pop	r24
    237a:	7f 91       	pop	r23
    237c:	6f 91       	pop	r22
    237e:	5f 91       	pop	r21
    2380:	4f 91       	pop	r20
    2382:	3f 91       	pop	r19
    2384:	2f 91       	pop	r18
    2386:	0f 90       	pop	r0
    2388:	0b be       	out	0x3b, r0	; 59
    238a:	0f 90       	pop	r0
    238c:	0f be       	out	0x3f, r0	; 63
    238e:	0f 90       	pop	r0
    2390:	1f 90       	pop	r1
    2392:	18 95       	reti

00002394 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    2394:	80 91 c7 09 	lds	r24, 0x09C7
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	20 91 c8 09 	lds	r18, 0x09C8
    239e:	82 1b       	sub	r24, r18
    23a0:	91 09       	sbc	r25, r1
    23a2:	08 95       	ret

000023a4 <_ZN7TwoWire4readEv>:
    23a4:	20 91 c8 09 	lds	r18, 0x09C8
    23a8:	80 91 c7 09 	lds	r24, 0x09C7
    23ac:	28 17       	cp	r18, r24
    23ae:	50 f4       	brcc	.+20     	; 0x23c4 <_ZN7TwoWire4readEv+0x20>
    23b0:	e2 2f       	mov	r30, r18
    23b2:	f0 e0       	ldi	r31, 0x00	; 0
    23b4:	e7 53       	subi	r30, 0x37	; 55
    23b6:	f6 4f       	sbci	r31, 0xF6	; 246
    23b8:	80 81       	ld	r24, Z
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	2f 5f       	subi	r18, 0xFF	; 255
    23be:	20 93 c8 09 	sts	0x09C8, r18
    23c2:	08 95       	ret
    23c4:	8f ef       	ldi	r24, 0xFF	; 255
    23c6:	9f ef       	ldi	r25, 0xFF	; 255
    23c8:	08 95       	ret

000023ca <_ZN7TwoWire4peekEv>:
    23ca:	e0 91 c8 09 	lds	r30, 0x09C8
    23ce:	80 91 c7 09 	lds	r24, 0x09C7
    23d2:	e8 17       	cp	r30, r24
    23d4:	30 f4       	brcc	.+12     	; 0x23e2 <_ZN7TwoWire4peekEv+0x18>
    23d6:	f0 e0       	ldi	r31, 0x00	; 0
    23d8:	e7 53       	subi	r30, 0x37	; 55
    23da:	f6 4f       	sbci	r31, 0xF6	; 246
    23dc:	80 81       	ld	r24, Z
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	08 95       	ret
    23e2:	8f ef       	ldi	r24, 0xFF	; 255
    23e4:	9f ef       	ldi	r25, 0xFF	; 255
    23e6:	08 95       	ret

000023e8 <_ZN7TwoWire5flushEv>:
    23e8:	08 95       	ret

000023ea <_ZN7TwoWire5writeEPKhj>:
    23ea:	cf 92       	push	r12
    23ec:	df 92       	push	r13
    23ee:	ef 92       	push	r14
    23f0:	ff 92       	push	r15
    23f2:	0f 93       	push	r16
    23f4:	1f 93       	push	r17
    23f6:	cf 93       	push	r28
    23f8:	df 93       	push	r29
    23fa:	8c 01       	movw	r16, r24
    23fc:	7b 01       	movw	r14, r22
    23fe:	6a 01       	movw	r12, r20
    2400:	80 91 a3 09 	lds	r24, 0x09A3
    2404:	88 23       	and	r24, r24
    2406:	99 f0       	breq	.+38     	; 0x242e <_ZN7TwoWire5writeEPKhj+0x44>
    2408:	41 15       	cp	r20, r1
    240a:	51 05       	cpc	r21, r1
    240c:	99 f0       	breq	.+38     	; 0x2434 <_ZN7TwoWire5writeEPKhj+0x4a>
    240e:	eb 01       	movw	r28, r22
    2410:	e4 0e       	add	r14, r20
    2412:	f5 1e       	adc	r15, r21
    2414:	69 91       	ld	r22, Y+
    2416:	d8 01       	movw	r26, r16
    2418:	ed 91       	ld	r30, X+
    241a:	fc 91       	ld	r31, X
    241c:	01 90       	ld	r0, Z+
    241e:	f0 81       	ld	r31, Z
    2420:	e0 2d       	mov	r30, r0
    2422:	c8 01       	movw	r24, r16
    2424:	19 95       	eicall
    2426:	ce 15       	cp	r28, r14
    2428:	df 05       	cpc	r29, r15
    242a:	a1 f7       	brne	.-24     	; 0x2414 <_ZN7TwoWire5writeEPKhj+0x2a>
    242c:	03 c0       	rjmp	.+6      	; 0x2434 <_ZN7TwoWire5writeEPKhj+0x4a>
    242e:	64 2f       	mov	r22, r20
    2430:	c7 01       	movw	r24, r14
    2432:	64 de       	rcall	.-824    	; 0x20fc <twi_transmit>
    2434:	c6 01       	movw	r24, r12
    2436:	df 91       	pop	r29
    2438:	cf 91       	pop	r28
    243a:	1f 91       	pop	r17
    243c:	0f 91       	pop	r16
    243e:	ff 90       	pop	r15
    2440:	ef 90       	pop	r14
    2442:	df 90       	pop	r13
    2444:	cf 90       	pop	r12
    2446:	08 95       	ret

00002448 <_ZN7TwoWire5writeEh>:
    2448:	cf 93       	push	r28
    244a:	df 93       	push	r29
    244c:	1f 92       	push	r1
    244e:	cd b7       	in	r28, 0x3d	; 61
    2450:	de b7       	in	r29, 0x3e	; 62
    2452:	69 83       	std	Y+1, r22	; 0x01
    2454:	20 91 a3 09 	lds	r18, 0x09A3
    2458:	22 23       	and	r18, r18
    245a:	e1 f0       	breq	.+56     	; 0x2494 <_ZN7TwoWire5writeEh+0x4c>
    245c:	20 91 a4 09 	lds	r18, 0x09A4
    2460:	20 32       	cpi	r18, 0x20	; 32
    2462:	40 f0       	brcs	.+16     	; 0x2474 <_ZN7TwoWire5writeEh+0x2c>
    2464:	21 e0       	ldi	r18, 0x01	; 1
    2466:	30 e0       	ldi	r19, 0x00	; 0
    2468:	fc 01       	movw	r30, r24
    246a:	33 83       	std	Z+3, r19	; 0x03
    246c:	22 83       	std	Z+2, r18	; 0x02
    246e:	80 e0       	ldi	r24, 0x00	; 0
    2470:	90 e0       	ldi	r25, 0x00	; 0
    2472:	16 c0       	rjmp	.+44     	; 0x24a0 <_ZN7TwoWire5writeEh+0x58>
    2474:	80 91 a5 09 	lds	r24, 0x09A5
    2478:	e8 2f       	mov	r30, r24
    247a:	f0 e0       	ldi	r31, 0x00	; 0
    247c:	ea 55       	subi	r30, 0x5A	; 90
    247e:	f6 4f       	sbci	r31, 0xF6	; 246
    2480:	99 81       	ldd	r25, Y+1	; 0x01
    2482:	90 83       	st	Z, r25
    2484:	8f 5f       	subi	r24, 0xFF	; 255
    2486:	80 93 a5 09 	sts	0x09A5, r24
    248a:	80 93 a4 09 	sts	0x09A4, r24
    248e:	81 e0       	ldi	r24, 0x01	; 1
    2490:	90 e0       	ldi	r25, 0x00	; 0
    2492:	06 c0       	rjmp	.+12     	; 0x24a0 <_ZN7TwoWire5writeEh+0x58>
    2494:	61 e0       	ldi	r22, 0x01	; 1
    2496:	ce 01       	movw	r24, r28
    2498:	01 96       	adiw	r24, 0x01	; 1
    249a:	30 de       	rcall	.-928    	; 0x20fc <twi_transmit>
    249c:	81 e0       	ldi	r24, 0x01	; 1
    249e:	90 e0       	ldi	r25, 0x00	; 0
    24a0:	0f 90       	pop	r0
    24a2:	df 91       	pop	r29
    24a4:	cf 91       	pop	r28
    24a6:	08 95       	ret

000024a8 <_ZN7TwoWireC1Ev>:
    24a8:	fc 01       	movw	r30, r24
    24aa:	13 82       	std	Z+3, r1	; 0x03
    24ac:	12 82       	std	Z+2, r1	; 0x02
    24ae:	48 ee       	ldi	r20, 0xE8	; 232
    24b0:	53 e0       	ldi	r21, 0x03	; 3
    24b2:	60 e0       	ldi	r22, 0x00	; 0
    24b4:	70 e0       	ldi	r23, 0x00	; 0
    24b6:	44 83       	std	Z+4, r20	; 0x04
    24b8:	55 83       	std	Z+5, r21	; 0x05
    24ba:	66 83       	std	Z+6, r22	; 0x06
    24bc:	77 83       	std	Z+7, r23	; 0x07
    24be:	81 e7       	ldi	r24, 0x71	; 113
    24c0:	92 e0       	ldi	r25, 0x02	; 2
    24c2:	91 83       	std	Z+1, r25	; 0x01
    24c4:	80 83       	st	Z, r24
    24c6:	08 95       	ret

000024c8 <_ZN7TwoWire5beginEv>:
    24c8:	10 92 c8 09 	sts	0x09C8, r1
    24cc:	10 92 c7 09 	sts	0x09C7, r1
    24d0:	10 92 a5 09 	sts	0x09A5, r1
    24d4:	10 92 a4 09 	sts	0x09A4, r1
    24d8:	48 cd       	rjmp	.-1392   	; 0x1f6a <twi_init>
    24da:	08 95       	ret

000024dc <_ZN7TwoWire11requestFromEhhh>:
    24dc:	86 2f       	mov	r24, r22
    24de:	41 32       	cpi	r20, 0x21	; 33
    24e0:	08 f0       	brcs	.+2      	; 0x24e4 <_ZN7TwoWire11requestFromEhhh+0x8>
    24e2:	40 e2       	ldi	r20, 0x20	; 32
    24e4:	69 ec       	ldi	r22, 0xC9	; 201
    24e6:	79 e0       	ldi	r23, 0x09	; 9
    24e8:	5e dd       	rcall	.-1348   	; 0x1fa6 <twi_readFrom>
    24ea:	10 92 c8 09 	sts	0x09C8, r1
    24ee:	80 93 c7 09 	sts	0x09C7, r24
    24f2:	08 95       	ret

000024f4 <_ZN7TwoWire11requestFromEhh>:
    24f4:	21 e0       	ldi	r18, 0x01	; 1
    24f6:	f2 cf       	rjmp	.-28     	; 0x24dc <_ZN7TwoWire11requestFromEhhh>
    24f8:	08 95       	ret

000024fa <_ZN7TwoWire17beginTransmissionEh>:
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	80 93 a3 09 	sts	0x09A3, r24
    2500:	60 93 c6 09 	sts	0x09C6, r22
    2504:	10 92 a5 09 	sts	0x09A5, r1
    2508:	10 92 a4 09 	sts	0x09A4, r1
    250c:	08 95       	ret

0000250e <_ZN7TwoWire15endTransmissionEh>:
    250e:	0f 93       	push	r16
    2510:	06 2f       	mov	r16, r22
    2512:	21 e0       	ldi	r18, 0x01	; 1
    2514:	40 91 a4 09 	lds	r20, 0x09A4
    2518:	66 ea       	ldi	r22, 0xA6	; 166
    251a:	79 e0       	ldi	r23, 0x09	; 9
    251c:	80 91 c6 09 	lds	r24, 0x09C6
    2520:	90 dd       	rcall	.-1248   	; 0x2042 <twi_writeTo>
    2522:	10 92 a5 09 	sts	0x09A5, r1
    2526:	10 92 a4 09 	sts	0x09A4, r1
    252a:	10 92 a3 09 	sts	0x09A3, r1
    252e:	0f 91       	pop	r16
    2530:	08 95       	ret

00002532 <_ZN7TwoWire15endTransmissionEv>:
    2532:	61 e0       	ldi	r22, 0x01	; 1
    2534:	ec cf       	rjmp	.-40     	; 0x250e <_ZN7TwoWire15endTransmissionEh>
    2536:	08 95       	ret

00002538 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2538:	87 e9       	ldi	r24, 0x97	; 151
    253a:	99 e0       	ldi	r25, 0x09	; 9
    253c:	b5 cf       	rjmp	.-150    	; 0x24a8 <_ZN7TwoWireC1Ev>
    253e:	08 95       	ret

00002540 <__subsf3>:
    2540:	50 58       	subi	r21, 0x80	; 128

00002542 <__addsf3>:
    2542:	bb 27       	eor	r27, r27
    2544:	aa 27       	eor	r26, r26
    2546:	0e d0       	rcall	.+28     	; 0x2564 <__addsf3x>
    2548:	72 c1       	rjmp	.+740    	; 0x282e <__fp_round>
    254a:	63 d1       	rcall	.+710    	; 0x2812 <__fp_pscA>
    254c:	30 f0       	brcs	.+12     	; 0x255a <__addsf3+0x18>
    254e:	68 d1       	rcall	.+720    	; 0x2820 <__fp_pscB>
    2550:	20 f0       	brcs	.+8      	; 0x255a <__addsf3+0x18>
    2552:	31 f4       	brne	.+12     	; 0x2560 <__addsf3+0x1e>
    2554:	9f 3f       	cpi	r25, 0xFF	; 255
    2556:	11 f4       	brne	.+4      	; 0x255c <__addsf3+0x1a>
    2558:	1e f4       	brtc	.+6      	; 0x2560 <__addsf3+0x1e>
    255a:	33 c1       	rjmp	.+614    	; 0x27c2 <__fp_nan>
    255c:	0e f4       	brtc	.+2      	; 0x2560 <__addsf3+0x1e>
    255e:	e0 95       	com	r30
    2560:	e7 fb       	bst	r30, 7
    2562:	29 c1       	rjmp	.+594    	; 0x27b6 <__fp_inf>

00002564 <__addsf3x>:
    2564:	e9 2f       	mov	r30, r25
    2566:	74 d1       	rcall	.+744    	; 0x2850 <__fp_split3>
    2568:	80 f3       	brcs	.-32     	; 0x254a <__addsf3+0x8>
    256a:	ba 17       	cp	r27, r26
    256c:	62 07       	cpc	r22, r18
    256e:	73 07       	cpc	r23, r19
    2570:	84 07       	cpc	r24, r20
    2572:	95 07       	cpc	r25, r21
    2574:	18 f0       	brcs	.+6      	; 0x257c <__addsf3x+0x18>
    2576:	71 f4       	brne	.+28     	; 0x2594 <__addsf3x+0x30>
    2578:	9e f5       	brtc	.+102    	; 0x25e0 <__addsf3x+0x7c>
    257a:	8c c1       	rjmp	.+792    	; 0x2894 <__fp_zero>
    257c:	0e f4       	brtc	.+2      	; 0x2580 <__addsf3x+0x1c>
    257e:	e0 95       	com	r30
    2580:	0b 2e       	mov	r0, r27
    2582:	ba 2f       	mov	r27, r26
    2584:	a0 2d       	mov	r26, r0
    2586:	0b 01       	movw	r0, r22
    2588:	b9 01       	movw	r22, r18
    258a:	90 01       	movw	r18, r0
    258c:	0c 01       	movw	r0, r24
    258e:	ca 01       	movw	r24, r20
    2590:	a0 01       	movw	r20, r0
    2592:	11 24       	eor	r1, r1
    2594:	ff 27       	eor	r31, r31
    2596:	59 1b       	sub	r21, r25
    2598:	99 f0       	breq	.+38     	; 0x25c0 <__addsf3x+0x5c>
    259a:	59 3f       	cpi	r21, 0xF9	; 249
    259c:	50 f4       	brcc	.+20     	; 0x25b2 <__addsf3x+0x4e>
    259e:	50 3e       	cpi	r21, 0xE0	; 224
    25a0:	68 f1       	brcs	.+90     	; 0x25fc <__addsf3x+0x98>
    25a2:	1a 16       	cp	r1, r26
    25a4:	f0 40       	sbci	r31, 0x00	; 0
    25a6:	a2 2f       	mov	r26, r18
    25a8:	23 2f       	mov	r18, r19
    25aa:	34 2f       	mov	r19, r20
    25ac:	44 27       	eor	r20, r20
    25ae:	58 5f       	subi	r21, 0xF8	; 248
    25b0:	f3 cf       	rjmp	.-26     	; 0x2598 <__addsf3x+0x34>
    25b2:	46 95       	lsr	r20
    25b4:	37 95       	ror	r19
    25b6:	27 95       	ror	r18
    25b8:	a7 95       	ror	r26
    25ba:	f0 40       	sbci	r31, 0x00	; 0
    25bc:	53 95       	inc	r21
    25be:	c9 f7       	brne	.-14     	; 0x25b2 <__addsf3x+0x4e>
    25c0:	7e f4       	brtc	.+30     	; 0x25e0 <__addsf3x+0x7c>
    25c2:	1f 16       	cp	r1, r31
    25c4:	ba 0b       	sbc	r27, r26
    25c6:	62 0b       	sbc	r22, r18
    25c8:	73 0b       	sbc	r23, r19
    25ca:	84 0b       	sbc	r24, r20
    25cc:	ba f0       	brmi	.+46     	; 0x25fc <__addsf3x+0x98>
    25ce:	91 50       	subi	r25, 0x01	; 1
    25d0:	a1 f0       	breq	.+40     	; 0x25fa <__addsf3x+0x96>
    25d2:	ff 0f       	add	r31, r31
    25d4:	bb 1f       	adc	r27, r27
    25d6:	66 1f       	adc	r22, r22
    25d8:	77 1f       	adc	r23, r23
    25da:	88 1f       	adc	r24, r24
    25dc:	c2 f7       	brpl	.-16     	; 0x25ce <__addsf3x+0x6a>
    25de:	0e c0       	rjmp	.+28     	; 0x25fc <__addsf3x+0x98>
    25e0:	ba 0f       	add	r27, r26
    25e2:	62 1f       	adc	r22, r18
    25e4:	73 1f       	adc	r23, r19
    25e6:	84 1f       	adc	r24, r20
    25e8:	48 f4       	brcc	.+18     	; 0x25fc <__addsf3x+0x98>
    25ea:	87 95       	ror	r24
    25ec:	77 95       	ror	r23
    25ee:	67 95       	ror	r22
    25f0:	b7 95       	ror	r27
    25f2:	f7 95       	ror	r31
    25f4:	9e 3f       	cpi	r25, 0xFE	; 254
    25f6:	08 f0       	brcs	.+2      	; 0x25fa <__addsf3x+0x96>
    25f8:	b3 cf       	rjmp	.-154    	; 0x2560 <__addsf3+0x1e>
    25fa:	93 95       	inc	r25
    25fc:	88 0f       	add	r24, r24
    25fe:	08 f0       	brcs	.+2      	; 0x2602 <__addsf3x+0x9e>
    2600:	99 27       	eor	r25, r25
    2602:	ee 0f       	add	r30, r30
    2604:	97 95       	ror	r25
    2606:	87 95       	ror	r24
    2608:	08 95       	ret

0000260a <__divsf3>:
    260a:	0c d0       	rcall	.+24     	; 0x2624 <__divsf3x>
    260c:	10 c1       	rjmp	.+544    	; 0x282e <__fp_round>
    260e:	08 d1       	rcall	.+528    	; 0x2820 <__fp_pscB>
    2610:	40 f0       	brcs	.+16     	; 0x2622 <__divsf3+0x18>
    2612:	ff d0       	rcall	.+510    	; 0x2812 <__fp_pscA>
    2614:	30 f0       	brcs	.+12     	; 0x2622 <__divsf3+0x18>
    2616:	21 f4       	brne	.+8      	; 0x2620 <__divsf3+0x16>
    2618:	5f 3f       	cpi	r21, 0xFF	; 255
    261a:	19 f0       	breq	.+6      	; 0x2622 <__divsf3+0x18>
    261c:	cc c0       	rjmp	.+408    	; 0x27b6 <__fp_inf>
    261e:	51 11       	cpse	r21, r1
    2620:	3a c1       	rjmp	.+628    	; 0x2896 <__fp_szero>
    2622:	cf c0       	rjmp	.+414    	; 0x27c2 <__fp_nan>

00002624 <__divsf3x>:
    2624:	15 d1       	rcall	.+554    	; 0x2850 <__fp_split3>
    2626:	98 f3       	brcs	.-26     	; 0x260e <__divsf3+0x4>

00002628 <__divsf3_pse>:
    2628:	99 23       	and	r25, r25
    262a:	c9 f3       	breq	.-14     	; 0x261e <__divsf3+0x14>
    262c:	55 23       	and	r21, r21
    262e:	b1 f3       	breq	.-20     	; 0x261c <__divsf3+0x12>
    2630:	95 1b       	sub	r25, r21
    2632:	55 0b       	sbc	r21, r21
    2634:	bb 27       	eor	r27, r27
    2636:	aa 27       	eor	r26, r26
    2638:	62 17       	cp	r22, r18
    263a:	73 07       	cpc	r23, r19
    263c:	84 07       	cpc	r24, r20
    263e:	38 f0       	brcs	.+14     	; 0x264e <__divsf3_pse+0x26>
    2640:	9f 5f       	subi	r25, 0xFF	; 255
    2642:	5f 4f       	sbci	r21, 0xFF	; 255
    2644:	22 0f       	add	r18, r18
    2646:	33 1f       	adc	r19, r19
    2648:	44 1f       	adc	r20, r20
    264a:	aa 1f       	adc	r26, r26
    264c:	a9 f3       	breq	.-22     	; 0x2638 <__divsf3_pse+0x10>
    264e:	33 d0       	rcall	.+102    	; 0x26b6 <__divsf3_pse+0x8e>
    2650:	0e 2e       	mov	r0, r30
    2652:	3a f0       	brmi	.+14     	; 0x2662 <__divsf3_pse+0x3a>
    2654:	e0 e8       	ldi	r30, 0x80	; 128
    2656:	30 d0       	rcall	.+96     	; 0x26b8 <__divsf3_pse+0x90>
    2658:	91 50       	subi	r25, 0x01	; 1
    265a:	50 40       	sbci	r21, 0x00	; 0
    265c:	e6 95       	lsr	r30
    265e:	00 1c       	adc	r0, r0
    2660:	ca f7       	brpl	.-14     	; 0x2654 <__divsf3_pse+0x2c>
    2662:	29 d0       	rcall	.+82     	; 0x26b6 <__divsf3_pse+0x8e>
    2664:	fe 2f       	mov	r31, r30
    2666:	27 d0       	rcall	.+78     	; 0x26b6 <__divsf3_pse+0x8e>
    2668:	66 0f       	add	r22, r22
    266a:	77 1f       	adc	r23, r23
    266c:	88 1f       	adc	r24, r24
    266e:	bb 1f       	adc	r27, r27
    2670:	26 17       	cp	r18, r22
    2672:	37 07       	cpc	r19, r23
    2674:	48 07       	cpc	r20, r24
    2676:	ab 07       	cpc	r26, r27
    2678:	b0 e8       	ldi	r27, 0x80	; 128
    267a:	09 f0       	breq	.+2      	; 0x267e <__divsf3_pse+0x56>
    267c:	bb 0b       	sbc	r27, r27
    267e:	80 2d       	mov	r24, r0
    2680:	bf 01       	movw	r22, r30
    2682:	ff 27       	eor	r31, r31
    2684:	93 58       	subi	r25, 0x83	; 131
    2686:	5f 4f       	sbci	r21, 0xFF	; 255
    2688:	2a f0       	brmi	.+10     	; 0x2694 <__divsf3_pse+0x6c>
    268a:	9e 3f       	cpi	r25, 0xFE	; 254
    268c:	51 05       	cpc	r21, r1
    268e:	68 f0       	brcs	.+26     	; 0x26aa <__divsf3_pse+0x82>
    2690:	92 c0       	rjmp	.+292    	; 0x27b6 <__fp_inf>
    2692:	01 c1       	rjmp	.+514    	; 0x2896 <__fp_szero>
    2694:	5f 3f       	cpi	r21, 0xFF	; 255
    2696:	ec f3       	brlt	.-6      	; 0x2692 <__divsf3_pse+0x6a>
    2698:	98 3e       	cpi	r25, 0xE8	; 232
    269a:	dc f3       	brlt	.-10     	; 0x2692 <__divsf3_pse+0x6a>
    269c:	86 95       	lsr	r24
    269e:	77 95       	ror	r23
    26a0:	67 95       	ror	r22
    26a2:	b7 95       	ror	r27
    26a4:	f7 95       	ror	r31
    26a6:	9f 5f       	subi	r25, 0xFF	; 255
    26a8:	c9 f7       	brne	.-14     	; 0x269c <__divsf3_pse+0x74>
    26aa:	88 0f       	add	r24, r24
    26ac:	91 1d       	adc	r25, r1
    26ae:	96 95       	lsr	r25
    26b0:	87 95       	ror	r24
    26b2:	97 f9       	bld	r25, 7
    26b4:	08 95       	ret
    26b6:	e1 e0       	ldi	r30, 0x01	; 1
    26b8:	66 0f       	add	r22, r22
    26ba:	77 1f       	adc	r23, r23
    26bc:	88 1f       	adc	r24, r24
    26be:	bb 1f       	adc	r27, r27
    26c0:	62 17       	cp	r22, r18
    26c2:	73 07       	cpc	r23, r19
    26c4:	84 07       	cpc	r24, r20
    26c6:	ba 07       	cpc	r27, r26
    26c8:	20 f0       	brcs	.+8      	; 0x26d2 <__divsf3_pse+0xaa>
    26ca:	62 1b       	sub	r22, r18
    26cc:	73 0b       	sbc	r23, r19
    26ce:	84 0b       	sbc	r24, r20
    26d0:	ba 0b       	sbc	r27, r26
    26d2:	ee 1f       	adc	r30, r30
    26d4:	88 f7       	brcc	.-30     	; 0x26b8 <__divsf3_pse+0x90>
    26d6:	e0 95       	com	r30
    26d8:	08 95       	ret

000026da <__fixsfsi>:
    26da:	04 d0       	rcall	.+8      	; 0x26e4 <__fixunssfsi>
    26dc:	68 94       	set
    26de:	b1 11       	cpse	r27, r1
    26e0:	da c0       	rjmp	.+436    	; 0x2896 <__fp_szero>
    26e2:	08 95       	ret

000026e4 <__fixunssfsi>:
    26e4:	bd d0       	rcall	.+378    	; 0x2860 <__fp_splitA>
    26e6:	88 f0       	brcs	.+34     	; 0x270a <__fixunssfsi+0x26>
    26e8:	9f 57       	subi	r25, 0x7F	; 127
    26ea:	90 f0       	brcs	.+36     	; 0x2710 <__fixunssfsi+0x2c>
    26ec:	b9 2f       	mov	r27, r25
    26ee:	99 27       	eor	r25, r25
    26f0:	b7 51       	subi	r27, 0x17	; 23
    26f2:	a0 f0       	brcs	.+40     	; 0x271c <__fixunssfsi+0x38>
    26f4:	d1 f0       	breq	.+52     	; 0x272a <__fixunssfsi+0x46>
    26f6:	66 0f       	add	r22, r22
    26f8:	77 1f       	adc	r23, r23
    26fa:	88 1f       	adc	r24, r24
    26fc:	99 1f       	adc	r25, r25
    26fe:	1a f0       	brmi	.+6      	; 0x2706 <__fixunssfsi+0x22>
    2700:	ba 95       	dec	r27
    2702:	c9 f7       	brne	.-14     	; 0x26f6 <__fixunssfsi+0x12>
    2704:	12 c0       	rjmp	.+36     	; 0x272a <__fixunssfsi+0x46>
    2706:	b1 30       	cpi	r27, 0x01	; 1
    2708:	81 f0       	breq	.+32     	; 0x272a <__fixunssfsi+0x46>
    270a:	c4 d0       	rcall	.+392    	; 0x2894 <__fp_zero>
    270c:	b1 e0       	ldi	r27, 0x01	; 1
    270e:	08 95       	ret
    2710:	c1 c0       	rjmp	.+386    	; 0x2894 <__fp_zero>
    2712:	67 2f       	mov	r22, r23
    2714:	78 2f       	mov	r23, r24
    2716:	88 27       	eor	r24, r24
    2718:	b8 5f       	subi	r27, 0xF8	; 248
    271a:	39 f0       	breq	.+14     	; 0x272a <__fixunssfsi+0x46>
    271c:	b9 3f       	cpi	r27, 0xF9	; 249
    271e:	cc f3       	brlt	.-14     	; 0x2712 <__fixunssfsi+0x2e>
    2720:	86 95       	lsr	r24
    2722:	77 95       	ror	r23
    2724:	67 95       	ror	r22
    2726:	b3 95       	inc	r27
    2728:	d9 f7       	brne	.-10     	; 0x2720 <__fixunssfsi+0x3c>
    272a:	3e f4       	brtc	.+14     	; 0x273a <__fixunssfsi+0x56>
    272c:	90 95       	com	r25
    272e:	80 95       	com	r24
    2730:	70 95       	com	r23
    2732:	61 95       	neg	r22
    2734:	7f 4f       	sbci	r23, 0xFF	; 255
    2736:	8f 4f       	sbci	r24, 0xFF	; 255
    2738:	9f 4f       	sbci	r25, 0xFF	; 255
    273a:	08 95       	ret

0000273c <__floatunsisf>:
    273c:	e8 94       	clt
    273e:	09 c0       	rjmp	.+18     	; 0x2752 <__floatsisf+0x12>

00002740 <__floatsisf>:
    2740:	97 fb       	bst	r25, 7
    2742:	3e f4       	brtc	.+14     	; 0x2752 <__floatsisf+0x12>
    2744:	90 95       	com	r25
    2746:	80 95       	com	r24
    2748:	70 95       	com	r23
    274a:	61 95       	neg	r22
    274c:	7f 4f       	sbci	r23, 0xFF	; 255
    274e:	8f 4f       	sbci	r24, 0xFF	; 255
    2750:	9f 4f       	sbci	r25, 0xFF	; 255
    2752:	99 23       	and	r25, r25
    2754:	a9 f0       	breq	.+42     	; 0x2780 <__floatsisf+0x40>
    2756:	f9 2f       	mov	r31, r25
    2758:	96 e9       	ldi	r25, 0x96	; 150
    275a:	bb 27       	eor	r27, r27
    275c:	93 95       	inc	r25
    275e:	f6 95       	lsr	r31
    2760:	87 95       	ror	r24
    2762:	77 95       	ror	r23
    2764:	67 95       	ror	r22
    2766:	b7 95       	ror	r27
    2768:	f1 11       	cpse	r31, r1
    276a:	f8 cf       	rjmp	.-16     	; 0x275c <__floatsisf+0x1c>
    276c:	fa f4       	brpl	.+62     	; 0x27ac <__floatsisf+0x6c>
    276e:	bb 0f       	add	r27, r27
    2770:	11 f4       	brne	.+4      	; 0x2776 <__floatsisf+0x36>
    2772:	60 ff       	sbrs	r22, 0
    2774:	1b c0       	rjmp	.+54     	; 0x27ac <__floatsisf+0x6c>
    2776:	6f 5f       	subi	r22, 0xFF	; 255
    2778:	7f 4f       	sbci	r23, 0xFF	; 255
    277a:	8f 4f       	sbci	r24, 0xFF	; 255
    277c:	9f 4f       	sbci	r25, 0xFF	; 255
    277e:	16 c0       	rjmp	.+44     	; 0x27ac <__floatsisf+0x6c>
    2780:	88 23       	and	r24, r24
    2782:	11 f0       	breq	.+4      	; 0x2788 <__floatsisf+0x48>
    2784:	96 e9       	ldi	r25, 0x96	; 150
    2786:	11 c0       	rjmp	.+34     	; 0x27aa <__floatsisf+0x6a>
    2788:	77 23       	and	r23, r23
    278a:	21 f0       	breq	.+8      	; 0x2794 <__floatsisf+0x54>
    278c:	9e e8       	ldi	r25, 0x8E	; 142
    278e:	87 2f       	mov	r24, r23
    2790:	76 2f       	mov	r23, r22
    2792:	05 c0       	rjmp	.+10     	; 0x279e <__floatsisf+0x5e>
    2794:	66 23       	and	r22, r22
    2796:	71 f0       	breq	.+28     	; 0x27b4 <__floatsisf+0x74>
    2798:	96 e8       	ldi	r25, 0x86	; 134
    279a:	86 2f       	mov	r24, r22
    279c:	70 e0       	ldi	r23, 0x00	; 0
    279e:	60 e0       	ldi	r22, 0x00	; 0
    27a0:	2a f0       	brmi	.+10     	; 0x27ac <__floatsisf+0x6c>
    27a2:	9a 95       	dec	r25
    27a4:	66 0f       	add	r22, r22
    27a6:	77 1f       	adc	r23, r23
    27a8:	88 1f       	adc	r24, r24
    27aa:	da f7       	brpl	.-10     	; 0x27a2 <__floatsisf+0x62>
    27ac:	88 0f       	add	r24, r24
    27ae:	96 95       	lsr	r25
    27b0:	87 95       	ror	r24
    27b2:	97 f9       	bld	r25, 7
    27b4:	08 95       	ret

000027b6 <__fp_inf>:
    27b6:	97 f9       	bld	r25, 7
    27b8:	9f 67       	ori	r25, 0x7F	; 127
    27ba:	80 e8       	ldi	r24, 0x80	; 128
    27bc:	70 e0       	ldi	r23, 0x00	; 0
    27be:	60 e0       	ldi	r22, 0x00	; 0
    27c0:	08 95       	ret

000027c2 <__fp_nan>:
    27c2:	9f ef       	ldi	r25, 0xFF	; 255
    27c4:	80 ec       	ldi	r24, 0xC0	; 192
    27c6:	08 95       	ret

000027c8 <__fp_powser>:
    27c8:	df 93       	push	r29
    27ca:	cf 93       	push	r28
    27cc:	1f 93       	push	r17
    27ce:	0f 93       	push	r16
    27d0:	ff 92       	push	r15
    27d2:	ef 92       	push	r14
    27d4:	df 92       	push	r13
    27d6:	7b 01       	movw	r14, r22
    27d8:	8c 01       	movw	r16, r24
    27da:	68 94       	set
    27dc:	05 c0       	rjmp	.+10     	; 0x27e8 <__fp_powser+0x20>
    27de:	da 2e       	mov	r13, r26
    27e0:	ef 01       	movw	r28, r30
    27e2:	72 d0       	rcall	.+228    	; 0x28c8 <__mulsf3x>
    27e4:	fe 01       	movw	r30, r28
    27e6:	e8 94       	clt
    27e8:	a5 91       	lpm	r26, Z+
    27ea:	25 91       	lpm	r18, Z+
    27ec:	35 91       	lpm	r19, Z+
    27ee:	45 91       	lpm	r20, Z+
    27f0:	55 91       	lpm	r21, Z+
    27f2:	ae f3       	brts	.-22     	; 0x27de <__fp_powser+0x16>
    27f4:	ef 01       	movw	r28, r30
    27f6:	b6 de       	rcall	.-660    	; 0x2564 <__addsf3x>
    27f8:	fe 01       	movw	r30, r28
    27fa:	97 01       	movw	r18, r14
    27fc:	a8 01       	movw	r20, r16
    27fe:	da 94       	dec	r13
    2800:	79 f7       	brne	.-34     	; 0x27e0 <__fp_powser+0x18>
    2802:	df 90       	pop	r13
    2804:	ef 90       	pop	r14
    2806:	ff 90       	pop	r15
    2808:	0f 91       	pop	r16
    280a:	1f 91       	pop	r17
    280c:	cf 91       	pop	r28
    280e:	df 91       	pop	r29
    2810:	08 95       	ret

00002812 <__fp_pscA>:
    2812:	00 24       	eor	r0, r0
    2814:	0a 94       	dec	r0
    2816:	16 16       	cp	r1, r22
    2818:	17 06       	cpc	r1, r23
    281a:	18 06       	cpc	r1, r24
    281c:	09 06       	cpc	r0, r25
    281e:	08 95       	ret

00002820 <__fp_pscB>:
    2820:	00 24       	eor	r0, r0
    2822:	0a 94       	dec	r0
    2824:	12 16       	cp	r1, r18
    2826:	13 06       	cpc	r1, r19
    2828:	14 06       	cpc	r1, r20
    282a:	05 06       	cpc	r0, r21
    282c:	08 95       	ret

0000282e <__fp_round>:
    282e:	09 2e       	mov	r0, r25
    2830:	03 94       	inc	r0
    2832:	00 0c       	add	r0, r0
    2834:	11 f4       	brne	.+4      	; 0x283a <__fp_round+0xc>
    2836:	88 23       	and	r24, r24
    2838:	52 f0       	brmi	.+20     	; 0x284e <__fp_round+0x20>
    283a:	bb 0f       	add	r27, r27
    283c:	40 f4       	brcc	.+16     	; 0x284e <__fp_round+0x20>
    283e:	bf 2b       	or	r27, r31
    2840:	11 f4       	brne	.+4      	; 0x2846 <__fp_round+0x18>
    2842:	60 ff       	sbrs	r22, 0
    2844:	04 c0       	rjmp	.+8      	; 0x284e <__fp_round+0x20>
    2846:	6f 5f       	subi	r22, 0xFF	; 255
    2848:	7f 4f       	sbci	r23, 0xFF	; 255
    284a:	8f 4f       	sbci	r24, 0xFF	; 255
    284c:	9f 4f       	sbci	r25, 0xFF	; 255
    284e:	08 95       	ret

00002850 <__fp_split3>:
    2850:	57 fd       	sbrc	r21, 7
    2852:	90 58       	subi	r25, 0x80	; 128
    2854:	44 0f       	add	r20, r20
    2856:	55 1f       	adc	r21, r21
    2858:	59 f0       	breq	.+22     	; 0x2870 <__fp_splitA+0x10>
    285a:	5f 3f       	cpi	r21, 0xFF	; 255
    285c:	71 f0       	breq	.+28     	; 0x287a <__fp_splitA+0x1a>
    285e:	47 95       	ror	r20

00002860 <__fp_splitA>:
    2860:	88 0f       	add	r24, r24
    2862:	97 fb       	bst	r25, 7
    2864:	99 1f       	adc	r25, r25
    2866:	61 f0       	breq	.+24     	; 0x2880 <__fp_splitA+0x20>
    2868:	9f 3f       	cpi	r25, 0xFF	; 255
    286a:	79 f0       	breq	.+30     	; 0x288a <__fp_splitA+0x2a>
    286c:	87 95       	ror	r24
    286e:	08 95       	ret
    2870:	12 16       	cp	r1, r18
    2872:	13 06       	cpc	r1, r19
    2874:	14 06       	cpc	r1, r20
    2876:	55 1f       	adc	r21, r21
    2878:	f2 cf       	rjmp	.-28     	; 0x285e <__fp_split3+0xe>
    287a:	46 95       	lsr	r20
    287c:	f1 df       	rcall	.-30     	; 0x2860 <__fp_splitA>
    287e:	08 c0       	rjmp	.+16     	; 0x2890 <__fp_splitA+0x30>
    2880:	16 16       	cp	r1, r22
    2882:	17 06       	cpc	r1, r23
    2884:	18 06       	cpc	r1, r24
    2886:	99 1f       	adc	r25, r25
    2888:	f1 cf       	rjmp	.-30     	; 0x286c <__fp_splitA+0xc>
    288a:	86 95       	lsr	r24
    288c:	71 05       	cpc	r23, r1
    288e:	61 05       	cpc	r22, r1
    2890:	08 94       	sec
    2892:	08 95       	ret

00002894 <__fp_zero>:
    2894:	e8 94       	clt

00002896 <__fp_szero>:
    2896:	bb 27       	eor	r27, r27
    2898:	66 27       	eor	r22, r22
    289a:	77 27       	eor	r23, r23
    289c:	cb 01       	movw	r24, r22
    289e:	97 f9       	bld	r25, 7
    28a0:	08 95       	ret

000028a2 <inverse>:
    28a2:	9b 01       	movw	r18, r22
    28a4:	ac 01       	movw	r20, r24
    28a6:	60 e0       	ldi	r22, 0x00	; 0
    28a8:	70 e0       	ldi	r23, 0x00	; 0
    28aa:	80 e8       	ldi	r24, 0x80	; 128
    28ac:	9f e3       	ldi	r25, 0x3F	; 63
    28ae:	ad ce       	rjmp	.-678    	; 0x260a <__divsf3>

000028b0 <__mulsf3>:
    28b0:	0b d0       	rcall	.+22     	; 0x28c8 <__mulsf3x>
    28b2:	bd cf       	rjmp	.-134    	; 0x282e <__fp_round>
    28b4:	ae df       	rcall	.-164    	; 0x2812 <__fp_pscA>
    28b6:	28 f0       	brcs	.+10     	; 0x28c2 <__mulsf3+0x12>
    28b8:	b3 df       	rcall	.-154    	; 0x2820 <__fp_pscB>
    28ba:	18 f0       	brcs	.+6      	; 0x28c2 <__mulsf3+0x12>
    28bc:	95 23       	and	r25, r21
    28be:	09 f0       	breq	.+2      	; 0x28c2 <__mulsf3+0x12>
    28c0:	7a cf       	rjmp	.-268    	; 0x27b6 <__fp_inf>
    28c2:	7f cf       	rjmp	.-258    	; 0x27c2 <__fp_nan>
    28c4:	11 24       	eor	r1, r1
    28c6:	e7 cf       	rjmp	.-50     	; 0x2896 <__fp_szero>

000028c8 <__mulsf3x>:
    28c8:	c3 df       	rcall	.-122    	; 0x2850 <__fp_split3>
    28ca:	a0 f3       	brcs	.-24     	; 0x28b4 <__mulsf3+0x4>

000028cc <__mulsf3_pse>:
    28cc:	95 9f       	mul	r25, r21
    28ce:	d1 f3       	breq	.-12     	; 0x28c4 <__mulsf3+0x14>
    28d0:	95 0f       	add	r25, r21
    28d2:	50 e0       	ldi	r21, 0x00	; 0
    28d4:	55 1f       	adc	r21, r21
    28d6:	62 9f       	mul	r22, r18
    28d8:	f0 01       	movw	r30, r0
    28da:	72 9f       	mul	r23, r18
    28dc:	bb 27       	eor	r27, r27
    28de:	f0 0d       	add	r31, r0
    28e0:	b1 1d       	adc	r27, r1
    28e2:	63 9f       	mul	r22, r19
    28e4:	aa 27       	eor	r26, r26
    28e6:	f0 0d       	add	r31, r0
    28e8:	b1 1d       	adc	r27, r1
    28ea:	aa 1f       	adc	r26, r26
    28ec:	64 9f       	mul	r22, r20
    28ee:	66 27       	eor	r22, r22
    28f0:	b0 0d       	add	r27, r0
    28f2:	a1 1d       	adc	r26, r1
    28f4:	66 1f       	adc	r22, r22
    28f6:	82 9f       	mul	r24, r18
    28f8:	22 27       	eor	r18, r18
    28fa:	b0 0d       	add	r27, r0
    28fc:	a1 1d       	adc	r26, r1
    28fe:	62 1f       	adc	r22, r18
    2900:	73 9f       	mul	r23, r19
    2902:	b0 0d       	add	r27, r0
    2904:	a1 1d       	adc	r26, r1
    2906:	62 1f       	adc	r22, r18
    2908:	83 9f       	mul	r24, r19
    290a:	a0 0d       	add	r26, r0
    290c:	61 1d       	adc	r22, r1
    290e:	22 1f       	adc	r18, r18
    2910:	74 9f       	mul	r23, r20
    2912:	33 27       	eor	r19, r19
    2914:	a0 0d       	add	r26, r0
    2916:	61 1d       	adc	r22, r1
    2918:	23 1f       	adc	r18, r19
    291a:	84 9f       	mul	r24, r20
    291c:	60 0d       	add	r22, r0
    291e:	21 1d       	adc	r18, r1
    2920:	82 2f       	mov	r24, r18
    2922:	76 2f       	mov	r23, r22
    2924:	6a 2f       	mov	r22, r26
    2926:	11 24       	eor	r1, r1
    2928:	9f 57       	subi	r25, 0x7F	; 127
    292a:	50 40       	sbci	r21, 0x00	; 0
    292c:	8a f0       	brmi	.+34     	; 0x2950 <__mulsf3_pse+0x84>
    292e:	e1 f0       	breq	.+56     	; 0x2968 <__mulsf3_pse+0x9c>
    2930:	88 23       	and	r24, r24
    2932:	4a f0       	brmi	.+18     	; 0x2946 <__mulsf3_pse+0x7a>
    2934:	ee 0f       	add	r30, r30
    2936:	ff 1f       	adc	r31, r31
    2938:	bb 1f       	adc	r27, r27
    293a:	66 1f       	adc	r22, r22
    293c:	77 1f       	adc	r23, r23
    293e:	88 1f       	adc	r24, r24
    2940:	91 50       	subi	r25, 0x01	; 1
    2942:	50 40       	sbci	r21, 0x00	; 0
    2944:	a9 f7       	brne	.-22     	; 0x2930 <__mulsf3_pse+0x64>
    2946:	9e 3f       	cpi	r25, 0xFE	; 254
    2948:	51 05       	cpc	r21, r1
    294a:	70 f0       	brcs	.+28     	; 0x2968 <__mulsf3_pse+0x9c>
    294c:	34 cf       	rjmp	.-408    	; 0x27b6 <__fp_inf>
    294e:	a3 cf       	rjmp	.-186    	; 0x2896 <__fp_szero>
    2950:	5f 3f       	cpi	r21, 0xFF	; 255
    2952:	ec f3       	brlt	.-6      	; 0x294e <__mulsf3_pse+0x82>
    2954:	98 3e       	cpi	r25, 0xE8	; 232
    2956:	dc f3       	brlt	.-10     	; 0x294e <__mulsf3_pse+0x82>
    2958:	86 95       	lsr	r24
    295a:	77 95       	ror	r23
    295c:	67 95       	ror	r22
    295e:	b7 95       	ror	r27
    2960:	f7 95       	ror	r31
    2962:	e7 95       	ror	r30
    2964:	9f 5f       	subi	r25, 0xFF	; 255
    2966:	c1 f7       	brne	.-16     	; 0x2958 <__mulsf3_pse+0x8c>
    2968:	fe 2b       	or	r31, r30
    296a:	88 0f       	add	r24, r24
    296c:	91 1d       	adc	r25, r1
    296e:	96 95       	lsr	r25
    2970:	87 95       	ror	r24
    2972:	97 f9       	bld	r25, 7
    2974:	08 95       	ret

00002976 <pow>:
    2976:	fa 01       	movw	r30, r20
    2978:	ee 0f       	add	r30, r30
    297a:	ff 1f       	adc	r31, r31
    297c:	30 96       	adiw	r30, 0x00	; 0
    297e:	21 05       	cpc	r18, r1
    2980:	31 05       	cpc	r19, r1
    2982:	99 f1       	breq	.+102    	; 0x29ea <pow+0x74>
    2984:	61 15       	cp	r22, r1
    2986:	71 05       	cpc	r23, r1
    2988:	61 f4       	brne	.+24     	; 0x29a2 <pow+0x2c>
    298a:	80 38       	cpi	r24, 0x80	; 128
    298c:	bf e3       	ldi	r27, 0x3F	; 63
    298e:	9b 07       	cpc	r25, r27
    2990:	49 f1       	breq	.+82     	; 0x29e4 <pow+0x6e>
    2992:	68 94       	set
    2994:	90 38       	cpi	r25, 0x80	; 128
    2996:	81 05       	cpc	r24, r1
    2998:	61 f0       	breq	.+24     	; 0x29b2 <pow+0x3c>
    299a:	80 38       	cpi	r24, 0x80	; 128
    299c:	bf ef       	ldi	r27, 0xFF	; 255
    299e:	9b 07       	cpc	r25, r27
    29a0:	41 f0       	breq	.+16     	; 0x29b2 <pow+0x3c>
    29a2:	99 23       	and	r25, r25
    29a4:	42 f5       	brpl	.+80     	; 0x29f6 <pow+0x80>
    29a6:	ff 3f       	cpi	r31, 0xFF	; 255
    29a8:	e1 05       	cpc	r30, r1
    29aa:	31 05       	cpc	r19, r1
    29ac:	21 05       	cpc	r18, r1
    29ae:	11 f1       	breq	.+68     	; 0x29f4 <pow+0x7e>
    29b0:	e8 94       	clt
    29b2:	08 94       	sec
    29b4:	e7 95       	ror	r30
    29b6:	d9 01       	movw	r26, r18
    29b8:	aa 23       	and	r26, r26
    29ba:	29 f4       	brne	.+10     	; 0x29c6 <pow+0x50>
    29bc:	ab 2f       	mov	r26, r27
    29be:	be 2f       	mov	r27, r30
    29c0:	f8 5f       	subi	r31, 0xF8	; 248
    29c2:	d0 f3       	brcs	.-12     	; 0x29b8 <pow+0x42>
    29c4:	10 c0       	rjmp	.+32     	; 0x29e6 <pow+0x70>
    29c6:	ff 5f       	subi	r31, 0xFF	; 255
    29c8:	70 f4       	brcc	.+28     	; 0x29e6 <pow+0x70>
    29ca:	a6 95       	lsr	r26
    29cc:	e0 f7       	brcc	.-8      	; 0x29c6 <pow+0x50>
    29ce:	f7 39       	cpi	r31, 0x97	; 151
    29d0:	50 f0       	brcs	.+20     	; 0x29e6 <pow+0x70>
    29d2:	19 f0       	breq	.+6      	; 0x29da <pow+0x64>
    29d4:	ff 3a       	cpi	r31, 0xAF	; 175
    29d6:	38 f4       	brcc	.+14     	; 0x29e6 <pow+0x70>
    29d8:	9f 77       	andi	r25, 0x7F	; 127
    29da:	9f 93       	push	r25
    29dc:	0c d0       	rcall	.+24     	; 0x29f6 <pow+0x80>
    29de:	0f 90       	pop	r0
    29e0:	07 fc       	sbrc	r0, 7
    29e2:	90 58       	subi	r25, 0x80	; 128
    29e4:	08 95       	ret
    29e6:	3e f0       	brts	.+14     	; 0x29f6 <pow+0x80>
    29e8:	ec ce       	rjmp	.-552    	; 0x27c2 <__fp_nan>
    29ea:	60 e0       	ldi	r22, 0x00	; 0
    29ec:	70 e0       	ldi	r23, 0x00	; 0
    29ee:	80 e8       	ldi	r24, 0x80	; 128
    29f0:	9f e3       	ldi	r25, 0x3F	; 63
    29f2:	08 95       	ret
    29f4:	4f e7       	ldi	r20, 0x7F	; 127
    29f6:	9f 77       	andi	r25, 0x7F	; 127
    29f8:	5f 93       	push	r21
    29fa:	4f 93       	push	r20
    29fc:	3f 93       	push	r19
    29fe:	2f 93       	push	r18
    2a00:	80 d0       	rcall	.+256    	; 0x2b02 <log>
    2a02:	2f 91       	pop	r18
    2a04:	3f 91       	pop	r19
    2a06:	4f 91       	pop	r20
    2a08:	5f 91       	pop	r21
    2a0a:	52 df       	rcall	.-348    	; 0x28b0 <__mulsf3>
    2a0c:	05 c0       	rjmp	.+10     	; 0x2a18 <exp>
    2a0e:	19 f4       	brne	.+6      	; 0x2a16 <pow+0xa0>
    2a10:	0e f0       	brts	.+2      	; 0x2a14 <pow+0x9e>
    2a12:	d1 ce       	rjmp	.-606    	; 0x27b6 <__fp_inf>
    2a14:	3f cf       	rjmp	.-386    	; 0x2894 <__fp_zero>
    2a16:	d5 ce       	rjmp	.-598    	; 0x27c2 <__fp_nan>

00002a18 <exp>:
    2a18:	23 df       	rcall	.-442    	; 0x2860 <__fp_splitA>
    2a1a:	c8 f3       	brcs	.-14     	; 0x2a0e <pow+0x98>
    2a1c:	96 38       	cpi	r25, 0x86	; 134
    2a1e:	c0 f7       	brcc	.-16     	; 0x2a10 <pow+0x9a>
    2a20:	07 f8       	bld	r0, 7
    2a22:	0f 92       	push	r0
    2a24:	e8 94       	clt
    2a26:	2b e3       	ldi	r18, 0x3B	; 59
    2a28:	3a ea       	ldi	r19, 0xAA	; 170
    2a2a:	48 eb       	ldi	r20, 0xB8	; 184
    2a2c:	5f e7       	ldi	r21, 0x7F	; 127
    2a2e:	4e df       	rcall	.-356    	; 0x28cc <__mulsf3_pse>
    2a30:	0f 92       	push	r0
    2a32:	0f 92       	push	r0
    2a34:	0f 92       	push	r0
    2a36:	4d b7       	in	r20, 0x3d	; 61
    2a38:	5e b7       	in	r21, 0x3e	; 62
    2a3a:	0f 92       	push	r0
    2a3c:	a2 d0       	rcall	.+324    	; 0x2b82 <modf>
    2a3e:	e6 e7       	ldi	r30, 0x76	; 118
    2a40:	f2 e0       	ldi	r31, 0x02	; 2
    2a42:	c2 de       	rcall	.-636    	; 0x27c8 <__fp_powser>
    2a44:	4f 91       	pop	r20
    2a46:	5f 91       	pop	r21
    2a48:	ef 91       	pop	r30
    2a4a:	ff 91       	pop	r31
    2a4c:	e5 95       	asr	r30
    2a4e:	ee 1f       	adc	r30, r30
    2a50:	ff 1f       	adc	r31, r31
    2a52:	49 f0       	breq	.+18     	; 0x2a66 <exp+0x4e>
    2a54:	fe 57       	subi	r31, 0x7E	; 126
    2a56:	e0 68       	ori	r30, 0x80	; 128
    2a58:	44 27       	eor	r20, r20
    2a5a:	ee 0f       	add	r30, r30
    2a5c:	44 1f       	adc	r20, r20
    2a5e:	fa 95       	dec	r31
    2a60:	e1 f7       	brne	.-8      	; 0x2a5a <exp+0x42>
    2a62:	41 95       	neg	r20
    2a64:	55 0b       	sbc	r21, r21
    2a66:	14 d0       	rcall	.+40     	; 0x2a90 <ldexp>
    2a68:	0f 90       	pop	r0
    2a6a:	07 fe       	sbrs	r0, 7
    2a6c:	1a cf       	rjmp	.-460    	; 0x28a2 <inverse>
    2a6e:	08 95       	ret

00002a70 <__fp_mpack>:
    2a70:	9f 3f       	cpi	r25, 0xFF	; 255
    2a72:	31 f0       	breq	.+12     	; 0x2a80 <__fp_mpack_finite+0xc>

00002a74 <__fp_mpack_finite>:
    2a74:	91 50       	subi	r25, 0x01	; 1
    2a76:	20 f4       	brcc	.+8      	; 0x2a80 <__fp_mpack_finite+0xc>
    2a78:	87 95       	ror	r24
    2a7a:	77 95       	ror	r23
    2a7c:	67 95       	ror	r22
    2a7e:	b7 95       	ror	r27
    2a80:	88 0f       	add	r24, r24
    2a82:	91 1d       	adc	r25, r1
    2a84:	96 95       	lsr	r25
    2a86:	87 95       	ror	r24
    2a88:	97 f9       	bld	r25, 7
    2a8a:	08 95       	ret
    2a8c:	94 ce       	rjmp	.-728    	; 0x27b6 <__fp_inf>
    2a8e:	f0 cf       	rjmp	.-32     	; 0x2a70 <__fp_mpack>

00002a90 <ldexp>:
    2a90:	e7 de       	rcall	.-562    	; 0x2860 <__fp_splitA>
    2a92:	e8 f3       	brcs	.-6      	; 0x2a8e <__fp_mpack_finite+0x1a>
    2a94:	99 23       	and	r25, r25
    2a96:	d9 f3       	breq	.-10     	; 0x2a8e <__fp_mpack_finite+0x1a>
    2a98:	94 0f       	add	r25, r20
    2a9a:	51 1d       	adc	r21, r1
    2a9c:	bb f3       	brvs	.-18     	; 0x2a8c <__fp_mpack_finite+0x18>
    2a9e:	91 50       	subi	r25, 0x01	; 1
    2aa0:	50 40       	sbci	r21, 0x00	; 0
    2aa2:	94 f0       	brlt	.+36     	; 0x2ac8 <ldexp+0x38>
    2aa4:	59 f0       	breq	.+22     	; 0x2abc <ldexp+0x2c>
    2aa6:	88 23       	and	r24, r24
    2aa8:	32 f0       	brmi	.+12     	; 0x2ab6 <ldexp+0x26>
    2aaa:	66 0f       	add	r22, r22
    2aac:	77 1f       	adc	r23, r23
    2aae:	88 1f       	adc	r24, r24
    2ab0:	91 50       	subi	r25, 0x01	; 1
    2ab2:	50 40       	sbci	r21, 0x00	; 0
    2ab4:	c1 f7       	brne	.-16     	; 0x2aa6 <ldexp+0x16>
    2ab6:	9e 3f       	cpi	r25, 0xFE	; 254
    2ab8:	51 05       	cpc	r21, r1
    2aba:	44 f7       	brge	.-48     	; 0x2a8c <__fp_mpack_finite+0x18>
    2abc:	88 0f       	add	r24, r24
    2abe:	91 1d       	adc	r25, r1
    2ac0:	96 95       	lsr	r25
    2ac2:	87 95       	ror	r24
    2ac4:	97 f9       	bld	r25, 7
    2ac6:	08 95       	ret
    2ac8:	5f 3f       	cpi	r21, 0xFF	; 255
    2aca:	ac f0       	brlt	.+42     	; 0x2af6 <ldexp+0x66>
    2acc:	98 3e       	cpi	r25, 0xE8	; 232
    2ace:	9c f0       	brlt	.+38     	; 0x2af6 <ldexp+0x66>
    2ad0:	bb 27       	eor	r27, r27
    2ad2:	86 95       	lsr	r24
    2ad4:	77 95       	ror	r23
    2ad6:	67 95       	ror	r22
    2ad8:	b7 95       	ror	r27
    2ada:	08 f4       	brcc	.+2      	; 0x2ade <ldexp+0x4e>
    2adc:	b1 60       	ori	r27, 0x01	; 1
    2ade:	93 95       	inc	r25
    2ae0:	c1 f7       	brne	.-16     	; 0x2ad2 <ldexp+0x42>
    2ae2:	bb 0f       	add	r27, r27
    2ae4:	58 f7       	brcc	.-42     	; 0x2abc <ldexp+0x2c>
    2ae6:	11 f4       	brne	.+4      	; 0x2aec <ldexp+0x5c>
    2ae8:	60 ff       	sbrs	r22, 0
    2aea:	e8 cf       	rjmp	.-48     	; 0x2abc <ldexp+0x2c>
    2aec:	6f 5f       	subi	r22, 0xFF	; 255
    2aee:	7f 4f       	sbci	r23, 0xFF	; 255
    2af0:	8f 4f       	sbci	r24, 0xFF	; 255
    2af2:	9f 4f       	sbci	r25, 0xFF	; 255
    2af4:	e3 cf       	rjmp	.-58     	; 0x2abc <ldexp+0x2c>
    2af6:	cf ce       	rjmp	.-610    	; 0x2896 <__fp_szero>
    2af8:	0e f0       	brts	.+2      	; 0x2afc <ldexp+0x6c>
    2afa:	ba cf       	rjmp	.-140    	; 0x2a70 <__fp_mpack>
    2afc:	62 ce       	rjmp	.-828    	; 0x27c2 <__fp_nan>
    2afe:	68 94       	set
    2b00:	5a ce       	rjmp	.-844    	; 0x27b6 <__fp_inf>

00002b02 <log>:
    2b02:	ae de       	rcall	.-676    	; 0x2860 <__fp_splitA>
    2b04:	c8 f3       	brcs	.-14     	; 0x2af8 <ldexp+0x68>
    2b06:	99 23       	and	r25, r25
    2b08:	d1 f3       	breq	.-12     	; 0x2afe <ldexp+0x6e>
    2b0a:	c6 f3       	brts	.-16     	; 0x2afc <ldexp+0x6c>
    2b0c:	df 93       	push	r29
    2b0e:	cf 93       	push	r28
    2b10:	1f 93       	push	r17
    2b12:	0f 93       	push	r16
    2b14:	ff 92       	push	r15
    2b16:	c9 2f       	mov	r28, r25
    2b18:	dd 27       	eor	r29, r29
    2b1a:	88 23       	and	r24, r24
    2b1c:	2a f0       	brmi	.+10     	; 0x2b28 <log+0x26>
    2b1e:	21 97       	sbiw	r28, 0x01	; 1
    2b20:	66 0f       	add	r22, r22
    2b22:	77 1f       	adc	r23, r23
    2b24:	88 1f       	adc	r24, r24
    2b26:	da f7       	brpl	.-10     	; 0x2b1e <log+0x1c>
    2b28:	20 e0       	ldi	r18, 0x00	; 0
    2b2a:	30 e0       	ldi	r19, 0x00	; 0
    2b2c:	40 e8       	ldi	r20, 0x80	; 128
    2b2e:	5f eb       	ldi	r21, 0xBF	; 191
    2b30:	9f e3       	ldi	r25, 0x3F	; 63
    2b32:	88 39       	cpi	r24, 0x98	; 152
    2b34:	20 f0       	brcs	.+8      	; 0x2b3e <log+0x3c>
    2b36:	80 3e       	cpi	r24, 0xE0	; 224
    2b38:	30 f0       	brcs	.+12     	; 0x2b46 <log+0x44>
    2b3a:	21 96       	adiw	r28, 0x01	; 1
    2b3c:	8f 77       	andi	r24, 0x7F	; 127
    2b3e:	01 dd       	rcall	.-1534   	; 0x2542 <__addsf3>
    2b40:	ee e9       	ldi	r30, 0x9E	; 158
    2b42:	f2 e0       	ldi	r31, 0x02	; 2
    2b44:	03 c0       	rjmp	.+6      	; 0x2b4c <log+0x4a>
    2b46:	fd dc       	rcall	.-1542   	; 0x2542 <__addsf3>
    2b48:	eb ec       	ldi	r30, 0xCB	; 203
    2b4a:	f2 e0       	ldi	r31, 0x02	; 2
    2b4c:	3d de       	rcall	.-902    	; 0x27c8 <__fp_powser>
    2b4e:	8b 01       	movw	r16, r22
    2b50:	be 01       	movw	r22, r28
    2b52:	ec 01       	movw	r28, r24
    2b54:	fb 2e       	mov	r15, r27
    2b56:	6f 57       	subi	r22, 0x7F	; 127
    2b58:	71 09       	sbc	r23, r1
    2b5a:	75 95       	asr	r23
    2b5c:	77 1f       	adc	r23, r23
    2b5e:	88 0b       	sbc	r24, r24
    2b60:	99 0b       	sbc	r25, r25
    2b62:	ee dd       	rcall	.-1060   	; 0x2740 <__floatsisf>
    2b64:	28 e1       	ldi	r18, 0x18	; 24
    2b66:	32 e7       	ldi	r19, 0x72	; 114
    2b68:	41 e3       	ldi	r20, 0x31	; 49
    2b6a:	5f e3       	ldi	r21, 0x3F	; 63
    2b6c:	ad de       	rcall	.-678    	; 0x28c8 <__mulsf3x>
    2b6e:	af 2d       	mov	r26, r15
    2b70:	98 01       	movw	r18, r16
    2b72:	ae 01       	movw	r20, r28
    2b74:	ff 90       	pop	r15
    2b76:	0f 91       	pop	r16
    2b78:	1f 91       	pop	r17
    2b7a:	cf 91       	pop	r28
    2b7c:	df 91       	pop	r29
    2b7e:	f2 dc       	rcall	.-1564   	; 0x2564 <__addsf3x>
    2b80:	56 ce       	rjmp	.-852    	; 0x282e <__fp_round>

00002b82 <modf>:
    2b82:	fa 01       	movw	r30, r20
    2b84:	dc 01       	movw	r26, r24
    2b86:	aa 0f       	add	r26, r26
    2b88:	bb 1f       	adc	r27, r27
    2b8a:	9b 01       	movw	r18, r22
    2b8c:	ac 01       	movw	r20, r24
    2b8e:	bf 57       	subi	r27, 0x7F	; 127
    2b90:	28 f4       	brcc	.+10     	; 0x2b9c <modf+0x1a>
    2b92:	22 27       	eor	r18, r18
    2b94:	33 27       	eor	r19, r19
    2b96:	44 27       	eor	r20, r20
    2b98:	50 78       	andi	r21, 0x80	; 128
    2b9a:	1f c0       	rjmp	.+62     	; 0x2bda <modf+0x58>
    2b9c:	b7 51       	subi	r27, 0x17	; 23
    2b9e:	88 f4       	brcc	.+34     	; 0x2bc2 <modf+0x40>
    2ba0:	ab 2f       	mov	r26, r27
    2ba2:	00 24       	eor	r0, r0
    2ba4:	46 95       	lsr	r20
    2ba6:	37 95       	ror	r19
    2ba8:	27 95       	ror	r18
    2baa:	01 1c       	adc	r0, r1
    2bac:	a3 95       	inc	r26
    2bae:	d2 f3       	brmi	.-12     	; 0x2ba4 <modf+0x22>
    2bb0:	00 20       	and	r0, r0
    2bb2:	69 f0       	breq	.+26     	; 0x2bce <modf+0x4c>
    2bb4:	22 0f       	add	r18, r18
    2bb6:	33 1f       	adc	r19, r19
    2bb8:	44 1f       	adc	r20, r20
    2bba:	b3 95       	inc	r27
    2bbc:	da f3       	brmi	.-10     	; 0x2bb4 <modf+0x32>
    2bbe:	0d d0       	rcall	.+26     	; 0x2bda <modf+0x58>
    2bc0:	bf cc       	rjmp	.-1666   	; 0x2540 <__subsf3>
    2bc2:	61 30       	cpi	r22, 0x01	; 1
    2bc4:	71 05       	cpc	r23, r1
    2bc6:	a0 e8       	ldi	r26, 0x80	; 128
    2bc8:	8a 07       	cpc	r24, r26
    2bca:	b9 46       	sbci	r27, 0x69	; 105
    2bcc:	30 f4       	brcc	.+12     	; 0x2bda <modf+0x58>
    2bce:	9b 01       	movw	r18, r22
    2bd0:	ac 01       	movw	r20, r24
    2bd2:	66 27       	eor	r22, r22
    2bd4:	77 27       	eor	r23, r23
    2bd6:	88 27       	eor	r24, r24
    2bd8:	90 78       	andi	r25, 0x80	; 128
    2bda:	30 96       	adiw	r30, 0x00	; 0
    2bdc:	21 f0       	breq	.+8      	; 0x2be6 <modf+0x64>
    2bde:	20 83       	st	Z, r18
    2be0:	31 83       	std	Z+1, r19	; 0x01
    2be2:	42 83       	std	Z+2, r20	; 0x02
    2be4:	53 83       	std	Z+3, r21	; 0x03
    2be6:	08 95       	ret

00002be8 <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    2be8:	fc 01       	movw	r30, r24
    2bea:	81 8d       	ldd	r24, Z+25	; 0x19
    2bec:	22 8d       	ldd	r18, Z+26	; 0x1a
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	80 5c       	subi	r24, 0xC0	; 192
    2bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    2bf4:	82 1b       	sub	r24, r18
    2bf6:	91 09       	sbc	r25, r1
    2bf8:	8f 73       	andi	r24, 0x3F	; 63
    2bfa:	99 27       	eor	r25, r25
    2bfc:	08 95       	ret

00002bfe <_ZN14HardwareSerial4peekEv>:
    2bfe:	fc 01       	movw	r30, r24
    2c00:	91 8d       	ldd	r25, Z+25	; 0x19
    2c02:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c04:	98 17       	cp	r25, r24
    2c06:	31 f0       	breq	.+12     	; 0x2c14 <_ZN14HardwareSerial4peekEv+0x16>
    2c08:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c0a:	e8 0f       	add	r30, r24
    2c0c:	f1 1d       	adc	r31, r1
    2c0e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c10:	90 e0       	ldi	r25, 0x00	; 0
    2c12:	08 95       	ret
    2c14:	8f ef       	ldi	r24, 0xFF	; 255
    2c16:	9f ef       	ldi	r25, 0xFF	; 255
    2c18:	08 95       	ret

00002c1a <_ZN14HardwareSerial4readEv>:
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	91 8d       	ldd	r25, Z+25	; 0x19
    2c1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c20:	98 17       	cp	r25, r24
    2c22:	61 f0       	breq	.+24     	; 0x2c3c <_ZN14HardwareSerial4readEv+0x22>
    2c24:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c26:	df 01       	movw	r26, r30
    2c28:	a8 0f       	add	r26, r24
    2c2a:	b1 1d       	adc	r27, r1
    2c2c:	5d 96       	adiw	r26, 0x1d	; 29
    2c2e:	8c 91       	ld	r24, X
    2c30:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c32:	9f 5f       	subi	r25, 0xFF	; 255
    2c34:	9f 73       	andi	r25, 0x3F	; 63
    2c36:	92 8f       	std	Z+26, r25	; 0x1a
    2c38:	90 e0       	ldi	r25, 0x00	; 0
    2c3a:	08 95       	ret
    2c3c:	8f ef       	ldi	r24, 0xFF	; 255
    2c3e:	9f ef       	ldi	r25, 0xFF	; 255
    2c40:	08 95       	ret

00002c42 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    2c42:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    2c44:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c46:	df 01       	movw	r26, r30
    2c48:	a8 0f       	add	r26, r24
    2c4a:	b1 1d       	adc	r27, r1
    2c4c:	a3 5a       	subi	r26, 0xA3	; 163
    2c4e:	bf 4f       	sbci	r27, 0xFF	; 255
    2c50:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    2c52:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	01 96       	adiw	r24, 0x01	; 1
    2c58:	8f 73       	andi	r24, 0x3F	; 63
    2c5a:	90 78       	andi	r25, 0x80	; 128
    2c5c:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    2c5e:	a6 89       	ldd	r26, Z+22	; 0x16
    2c60:	b7 89       	ldd	r27, Z+23	; 0x17
    2c62:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    2c64:	a0 89       	ldd	r26, Z+16	; 0x10
    2c66:	b1 89       	ldd	r27, Z+17	; 0x11
    2c68:	8c 91       	ld	r24, X
    2c6a:	80 64       	ori	r24, 0x40	; 64
    2c6c:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    2c6e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c70:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c72:	98 13       	cpse	r25, r24
    2c74:	06 c0       	rjmp	.+12     	; 0x2c82 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    2c76:	02 88       	ldd	r0, Z+18	; 0x12
    2c78:	f3 89       	ldd	r31, Z+19	; 0x13
    2c7a:	e0 2d       	mov	r30, r0
    2c7c:	80 81       	ld	r24, Z
    2c7e:	8f 7d       	andi	r24, 0xDF	; 223
    2c80:	80 83       	st	Z, r24
    2c82:	08 95       	ret

00002c84 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    2c84:	cf 93       	push	r28
    2c86:	df 93       	push	r29
    2c88:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    2c8a:	88 8d       	ldd	r24, Y+24	; 0x18
    2c8c:	81 11       	cpse	r24, r1
    2c8e:	0a c0       	rjmp	.+20     	; 0x2ca4 <_ZN14HardwareSerial5flushEv+0x20>
    2c90:	1a c0       	rjmp	.+52     	; 0x2cc6 <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    2c92:	0f b6       	in	r0, 0x3f	; 63
    2c94:	07 fc       	sbrc	r0, 7
    2c96:	08 c0       	rjmp	.+16     	; 0x2ca8 <_ZN14HardwareSerial5flushEv+0x24>
    2c98:	80 81       	ld	r24, Z
    2c9a:	85 ff       	sbrs	r24, 5
    2c9c:	05 c0       	rjmp	.+10     	; 0x2ca8 <_ZN14HardwareSerial5flushEv+0x24>
    2c9e:	0d c0       	rjmp	.+26     	; 0x2cba <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    2ca0:	ce 01       	movw	r24, r28
    2ca2:	cf df       	rcall	.-98     	; 0x2c42 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    2ca4:	ea 89       	ldd	r30, Y+18	; 0x12
    2ca6:	fb 89       	ldd	r31, Y+19	; 0x13
    2ca8:	80 81       	ld	r24, Z
    2caa:	85 fd       	sbrc	r24, 5
    2cac:	f2 cf       	rjmp	.-28     	; 0x2c92 <_ZN14HardwareSerial5flushEv+0xe>
    2cae:	a8 89       	ldd	r26, Y+16	; 0x10
    2cb0:	b9 89       	ldd	r27, Y+17	; 0x11
    2cb2:	8c 91       	ld	r24, X
    2cb4:	86 ff       	sbrs	r24, 6
    2cb6:	ed cf       	rjmp	.-38     	; 0x2c92 <_ZN14HardwareSerial5flushEv+0xe>
    2cb8:	06 c0       	rjmp	.+12     	; 0x2cc6 <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    2cba:	a8 89       	ldd	r26, Y+16	; 0x10
    2cbc:	b9 89       	ldd	r27, Y+17	; 0x11
    2cbe:	8c 91       	ld	r24, X
    2cc0:	85 ff       	sbrs	r24, 5
    2cc2:	f2 cf       	rjmp	.-28     	; 0x2ca8 <_ZN14HardwareSerial5flushEv+0x24>
    2cc4:	ed cf       	rjmp	.-38     	; 0x2ca0 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    2cc6:	df 91       	pop	r29
    2cc8:	cf 91       	pop	r28
    2cca:	08 95       	ret

00002ccc <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    2ccc:	0f 93       	push	r16
    2cce:	1f 93       	push	r17
    2cd0:	cf 93       	push	r28
    2cd2:	df 93       	push	r29
    2cd4:	ec 01       	movw	r28, r24
    2cd6:	16 2f       	mov	r17, r22
  _written = true;
    2cd8:	81 e0       	ldi	r24, 0x01	; 1
    2cda:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    2cdc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2cde:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2ce0:	98 13       	cpse	r25, r24
    2ce2:	21 c0       	rjmp	.+66     	; 0x2d26 <_ZN14HardwareSerial5writeEh+0x5a>
    2ce4:	e8 89       	ldd	r30, Y+16	; 0x10
    2ce6:	f9 89       	ldd	r31, Y+17	; 0x11
    2ce8:	80 81       	ld	r24, Z
    2cea:	85 fd       	sbrc	r24, 5
    2cec:	23 c0       	rjmp	.+70     	; 0x2d34 <_ZN14HardwareSerial5writeEh+0x68>
    2cee:	1b c0       	rjmp	.+54     	; 0x2d26 <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    2cf0:	0f b6       	in	r0, 0x3f	; 63
    2cf2:	07 fc       	sbrc	r0, 7
    2cf4:	07 c0       	rjmp	.+14     	; 0x2d04 <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    2cf6:	e8 89       	ldd	r30, Y+16	; 0x10
    2cf8:	f9 89       	ldd	r31, Y+17	; 0x11
    2cfa:	80 81       	ld	r24, Z
    2cfc:	85 ff       	sbrs	r24, 5
    2cfe:	02 c0       	rjmp	.+4      	; 0x2d04 <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    2d00:	ce 01       	movw	r24, r28
    2d02:	9f df       	rcall	.-194    	; 0x2c42 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2d04:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2d06:	09 17       	cp	r16, r25
    2d08:	99 f3       	breq	.-26     	; 0x2cf0 <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    2d0a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d0c:	fe 01       	movw	r30, r28
    2d0e:	e8 0f       	add	r30, r24
    2d10:	f1 1d       	adc	r31, r1
    2d12:	e3 5a       	subi	r30, 0xA3	; 163
    2d14:	ff 4f       	sbci	r31, 0xFF	; 255
    2d16:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    2d18:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    2d1a:	ea 89       	ldd	r30, Y+18	; 0x12
    2d1c:	fb 89       	ldd	r31, Y+19	; 0x13
    2d1e:	80 81       	ld	r24, Z
    2d20:	80 62       	ori	r24, 0x20	; 32
    2d22:	80 83       	st	Z, r24
  
  return 1;
    2d24:	0f c0       	rjmp	.+30     	; 0x2d44 <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    2d26:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d28:	90 e0       	ldi	r25, 0x00	; 0
    2d2a:	01 96       	adiw	r24, 0x01	; 1
    2d2c:	8f 73       	andi	r24, 0x3F	; 63
    2d2e:	90 78       	andi	r25, 0x80	; 128
    2d30:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2d32:	e8 cf       	rjmp	.-48     	; 0x2d04 <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    2d34:	ee 89       	ldd	r30, Y+22	; 0x16
    2d36:	ff 89       	ldd	r31, Y+23	; 0x17
    2d38:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    2d3a:	e8 89       	ldd	r30, Y+16	; 0x10
    2d3c:	f9 89       	ldd	r31, Y+17	; 0x11
    2d3e:	80 81       	ld	r24, Z
    2d40:	80 64       	ori	r24, 0x40	; 64
    2d42:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    2d44:	81 e0       	ldi	r24, 0x01	; 1
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	df 91       	pop	r29
    2d4a:	cf 91       	pop	r28
    2d4c:	1f 91       	pop	r17
    2d4e:	0f 91       	pop	r16
    2d50:	08 95       	ret

00002d52 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    2d52:	cf 92       	push	r12
    2d54:	df 92       	push	r13
    2d56:	ef 92       	push	r14
    2d58:	ff 92       	push	r15
    2d5a:	1f 93       	push	r17
    2d5c:	cf 93       	push	r28
    2d5e:	df 93       	push	r29
    2d60:	ec 01       	movw	r28, r24
    2d62:	6a 01       	movw	r12, r20
    2d64:	7b 01       	movw	r14, r22
    2d66:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    2d68:	e8 89       	ldd	r30, Y+16	; 0x10
    2d6a:	f9 89       	ldd	r31, Y+17	; 0x11
    2d6c:	82 e0       	ldi	r24, 0x02	; 2
    2d6e:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2d70:	41 15       	cp	r20, r1
    2d72:	81 ee       	ldi	r24, 0xE1	; 225
    2d74:	58 07       	cpc	r21, r24
    2d76:	61 05       	cpc	r22, r1
    2d78:	71 05       	cpc	r23, r1
    2d7a:	a9 f0       	breq	.+42     	; 0x2da6 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    2d7c:	60 e0       	ldi	r22, 0x00	; 0
    2d7e:	79 e0       	ldi	r23, 0x09	; 9
    2d80:	8d e3       	ldi	r24, 0x3D	; 61
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	a7 01       	movw	r20, r14
    2d86:	96 01       	movw	r18, r12
    2d88:	4b d4       	rcall	.+2198   	; 0x3620 <__udivmodsi4>
    2d8a:	ba 01       	movw	r22, r20
    2d8c:	a9 01       	movw	r20, r18
    2d8e:	41 50       	subi	r20, 0x01	; 1
    2d90:	51 09       	sbc	r21, r1
    2d92:	61 09       	sbc	r22, r1
    2d94:	71 09       	sbc	r23, r1
    2d96:	76 95       	lsr	r23
    2d98:	67 95       	ror	r22
    2d9a:	57 95       	ror	r21
    2d9c:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2d9e:	41 15       	cp	r20, r1
    2da0:	80 e1       	ldi	r24, 0x10	; 16
    2da2:	58 07       	cpc	r21, r24
    2da4:	a0 f0       	brcs	.+40     	; 0x2dce <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    2da6:	e8 89       	ldd	r30, Y+16	; 0x10
    2da8:	f9 89       	ldd	r31, Y+17	; 0x11
    2daa:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    2dac:	60 e8       	ldi	r22, 0x80	; 128
    2dae:	74 e8       	ldi	r23, 0x84	; 132
    2db0:	8e e1       	ldi	r24, 0x1E	; 30
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	a7 01       	movw	r20, r14
    2db6:	96 01       	movw	r18, r12
    2db8:	33 d4       	rcall	.+2150   	; 0x3620 <__udivmodsi4>
    2dba:	ba 01       	movw	r22, r20
    2dbc:	a9 01       	movw	r20, r18
    2dbe:	41 50       	subi	r20, 0x01	; 1
    2dc0:	51 09       	sbc	r21, r1
    2dc2:	61 09       	sbc	r22, r1
    2dc4:	71 09       	sbc	r23, r1
    2dc6:	76 95       	lsr	r23
    2dc8:	67 95       	ror	r22
    2dca:	57 95       	ror	r21
    2dcc:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    2dce:	ec 85       	ldd	r30, Y+12	; 0x0c
    2dd0:	fd 85       	ldd	r31, Y+13	; 0x0d
    2dd2:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    2dd4:	ee 85       	ldd	r30, Y+14	; 0x0e
    2dd6:	ff 85       	ldd	r31, Y+15	; 0x0f
    2dd8:	40 83       	st	Z, r20

  _written = false;
    2dda:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    2ddc:	ec 89       	ldd	r30, Y+20	; 0x14
    2dde:	fd 89       	ldd	r31, Y+21	; 0x15
    2de0:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    2de2:	ea 89       	ldd	r30, Y+18	; 0x12
    2de4:	fb 89       	ldd	r31, Y+19	; 0x13
    2de6:	80 81       	ld	r24, Z
    2de8:	80 61       	ori	r24, 0x10	; 16
    2dea:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    2dec:	ea 89       	ldd	r30, Y+18	; 0x12
    2dee:	fb 89       	ldd	r31, Y+19	; 0x13
    2df0:	80 81       	ld	r24, Z
    2df2:	88 60       	ori	r24, 0x08	; 8
    2df4:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    2df6:	ea 89       	ldd	r30, Y+18	; 0x12
    2df8:	fb 89       	ldd	r31, Y+19	; 0x13
    2dfa:	80 81       	ld	r24, Z
    2dfc:	80 68       	ori	r24, 0x80	; 128
    2dfe:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    2e00:	ea 89       	ldd	r30, Y+18	; 0x12
    2e02:	fb 89       	ldd	r31, Y+19	; 0x13
    2e04:	80 81       	ld	r24, Z
    2e06:	8f 7d       	andi	r24, 0xDF	; 223
    2e08:	80 83       	st	Z, r24
}
    2e0a:	df 91       	pop	r29
    2e0c:	cf 91       	pop	r28
    2e0e:	1f 91       	pop	r17
    2e10:	ff 90       	pop	r15
    2e12:	ef 90       	pop	r14
    2e14:	df 90       	pop	r13
    2e16:	cf 90       	pop	r12
    2e18:	08 95       	ret

00002e1a <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    2e1a:	1f 92       	push	r1
    2e1c:	0f 92       	push	r0
    2e1e:	0f b6       	in	r0, 0x3f	; 63
    2e20:	0f 92       	push	r0
    2e22:	11 24       	eor	r1, r1
    2e24:	0b b6       	in	r0, 0x3b	; 59
    2e26:	0f 92       	push	r0
    2e28:	2f 93       	push	r18
    2e2a:	8f 93       	push	r24
    2e2c:	9f 93       	push	r25
    2e2e:	af 93       	push	r26
    2e30:	bf 93       	push	r27
    2e32:	ef 93       	push	r30
    2e34:	ff 93       	push	r31
    2e36:	e0 91 f9 09 	lds	r30, 0x09F9
    2e3a:	f0 91 fa 09 	lds	r31, 0x09FA
    2e3e:	80 81       	ld	r24, Z
    2e40:	82 fd       	sbrc	r24, 2
    2e42:	17 c0       	rjmp	.+46     	; 0x2e72 <__vector_25+0x58>
    2e44:	e0 91 ff 09 	lds	r30, 0x09FF
    2e48:	f0 91 00 0a 	lds	r31, 0x0A00
    2e4c:	20 81       	ld	r18, Z
    2e4e:	80 91 02 0a 	lds	r24, 0x0A02
    2e52:	8f 5f       	subi	r24, 0xFF	; 255
    2e54:	8f 73       	andi	r24, 0x3F	; 63
    2e56:	90 91 03 0a 	lds	r25, 0x0A03
    2e5a:	89 17       	cp	r24, r25
    2e5c:	79 f0       	breq	.+30     	; 0x2e7c <__vector_25+0x62>
    2e5e:	e2 e0       	ldi	r30, 0x02	; 2
    2e60:	fa e0       	ldi	r31, 0x0A	; 10
    2e62:	a0 81       	ld	r26, Z
    2e64:	b0 e0       	ldi	r27, 0x00	; 0
    2e66:	a7 51       	subi	r26, 0x17	; 23
    2e68:	b6 4f       	sbci	r27, 0xF6	; 246
    2e6a:	5d 96       	adiw	r26, 0x1d	; 29
    2e6c:	2c 93       	st	X, r18
    2e6e:	80 83       	st	Z, r24
    2e70:	05 c0       	rjmp	.+10     	; 0x2e7c <__vector_25+0x62>
    2e72:	e0 91 ff 09 	lds	r30, 0x09FF
    2e76:	f0 91 00 0a 	lds	r31, 0x0A00
    2e7a:	80 81       	ld	r24, Z
    2e7c:	ff 91       	pop	r31
    2e7e:	ef 91       	pop	r30
    2e80:	bf 91       	pop	r27
    2e82:	af 91       	pop	r26
    2e84:	9f 91       	pop	r25
    2e86:	8f 91       	pop	r24
    2e88:	2f 91       	pop	r18
    2e8a:	0f 90       	pop	r0
    2e8c:	0b be       	out	0x3b, r0	; 59
    2e8e:	0f 90       	pop	r0
    2e90:	0f be       	out	0x3f, r0	; 63
    2e92:	0f 90       	pop	r0
    2e94:	1f 90       	pop	r1
    2e96:	18 95       	reti

00002e98 <__vector_26>:
    2e98:	1f 92       	push	r1
    2e9a:	0f 92       	push	r0
    2e9c:	0f b6       	in	r0, 0x3f	; 63
    2e9e:	0f 92       	push	r0
    2ea0:	11 24       	eor	r1, r1
    2ea2:	0b b6       	in	r0, 0x3b	; 59
    2ea4:	0f 92       	push	r0
    2ea6:	2f 93       	push	r18
    2ea8:	3f 93       	push	r19
    2eaa:	4f 93       	push	r20
    2eac:	5f 93       	push	r21
    2eae:	6f 93       	push	r22
    2eb0:	7f 93       	push	r23
    2eb2:	8f 93       	push	r24
    2eb4:	9f 93       	push	r25
    2eb6:	af 93       	push	r26
    2eb8:	bf 93       	push	r27
    2eba:	ef 93       	push	r30
    2ebc:	ff 93       	push	r31
    2ebe:	89 ee       	ldi	r24, 0xE9	; 233
    2ec0:	99 e0       	ldi	r25, 0x09	; 9
    2ec2:	bf de       	rcall	.-642    	; 0x2c42 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    2ec4:	ff 91       	pop	r31
    2ec6:	ef 91       	pop	r30
    2ec8:	bf 91       	pop	r27
    2eca:	af 91       	pop	r26
    2ecc:	9f 91       	pop	r25
    2ece:	8f 91       	pop	r24
    2ed0:	7f 91       	pop	r23
    2ed2:	6f 91       	pop	r22
    2ed4:	5f 91       	pop	r21
    2ed6:	4f 91       	pop	r20
    2ed8:	3f 91       	pop	r19
    2eda:	2f 91       	pop	r18
    2edc:	0f 90       	pop	r0
    2ede:	0b be       	out	0x3b, r0	; 59
    2ee0:	0f 90       	pop	r0
    2ee2:	0f be       	out	0x3f, r0	; 63
    2ee4:	0f 90       	pop	r0
    2ee6:	1f 90       	pop	r1
    2ee8:	18 95       	reti

00002eea <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2eea:	10 92 ec 09 	sts	0x09EC, r1
    2eee:	10 92 eb 09 	sts	0x09EB, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    2ef2:	88 ee       	ldi	r24, 0xE8	; 232
    2ef4:	93 e0       	ldi	r25, 0x03	; 3
    2ef6:	a0 e0       	ldi	r26, 0x00	; 0
    2ef8:	b0 e0       	ldi	r27, 0x00	; 0
    2efa:	80 93 ed 09 	sts	0x09ED, r24
    2efe:	90 93 ee 09 	sts	0x09EE, r25
    2f02:	a0 93 ef 09 	sts	0x09EF, r26
    2f06:	b0 93 f0 09 	sts	0x09F0, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    2f0a:	81 e8       	ldi	r24, 0x81	; 129
    2f0c:	92 e0       	ldi	r25, 0x02	; 2
    2f0e:	90 93 ea 09 	sts	0x09EA, r25
    2f12:	80 93 e9 09 	sts	0x09E9, r24
    2f16:	85 ec       	ldi	r24, 0xC5	; 197
    2f18:	90 e0       	ldi	r25, 0x00	; 0
    2f1a:	90 93 f6 09 	sts	0x09F6, r25
    2f1e:	80 93 f5 09 	sts	0x09F5, r24
    2f22:	84 ec       	ldi	r24, 0xC4	; 196
    2f24:	90 e0       	ldi	r25, 0x00	; 0
    2f26:	90 93 f8 09 	sts	0x09F8, r25
    2f2a:	80 93 f7 09 	sts	0x09F7, r24
    2f2e:	80 ec       	ldi	r24, 0xC0	; 192
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	90 93 fa 09 	sts	0x09FA, r25
    2f36:	80 93 f9 09 	sts	0x09F9, r24
    2f3a:	81 ec       	ldi	r24, 0xC1	; 193
    2f3c:	90 e0       	ldi	r25, 0x00	; 0
    2f3e:	90 93 fc 09 	sts	0x09FC, r25
    2f42:	80 93 fb 09 	sts	0x09FB, r24
    2f46:	82 ec       	ldi	r24, 0xC2	; 194
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	90 93 fe 09 	sts	0x09FE, r25
    2f4e:	80 93 fd 09 	sts	0x09FD, r24
    2f52:	86 ec       	ldi	r24, 0xC6	; 198
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	90 93 00 0a 	sts	0x0A00, r25
    2f5a:	80 93 ff 09 	sts	0x09FF, r24
    2f5e:	10 92 02 0a 	sts	0x0A02, r1
    2f62:	10 92 03 0a 	sts	0x0A03, r1
    2f66:	10 92 04 0a 	sts	0x0A04, r1
    2f6a:	10 92 05 0a 	sts	0x0A05, r1
    2f6e:	08 95       	ret

00002f70 <_ZN5Print5writeEPKhj>:
size_t Print::println(long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    2f70:	cf 92       	push	r12
    2f72:	df 92       	push	r13
    2f74:	ef 92       	push	r14
    2f76:	ff 92       	push	r15
    2f78:	0f 93       	push	r16
    2f7a:	1f 93       	push	r17
    2f7c:	cf 93       	push	r28
    2f7e:	df 93       	push	r29
    2f80:	6c 01       	movw	r12, r24
    2f82:	41 15       	cp	r20, r1
    2f84:	51 05       	cpc	r21, r1
    2f86:	b1 f0       	breq	.+44     	; 0x2fb4 <_ZN5Print5writeEPKhj+0x44>
    2f88:	06 2f       	mov	r16, r22
    2f8a:	17 2f       	mov	r17, r23
    2f8c:	ea 01       	movw	r28, r20
    2f8e:	e1 2c       	mov	r14, r1
    2f90:	f1 2c       	mov	r15, r1
    2f92:	d8 01       	movw	r26, r16
    2f94:	6d 91       	ld	r22, X+
    2f96:	8d 01       	movw	r16, r26
    2f98:	d6 01       	movw	r26, r12
    2f9a:	ed 91       	ld	r30, X+
    2f9c:	fc 91       	ld	r31, X
    2f9e:	01 90       	ld	r0, Z+
    2fa0:	f0 81       	ld	r31, Z
    2fa2:	e0 2d       	mov	r30, r0
    2fa4:	c6 01       	movw	r24, r12
    2fa6:	19 95       	eicall
    2fa8:	e8 0e       	add	r14, r24
    2faa:	f9 1e       	adc	r15, r25
    2fac:	21 97       	sbiw	r28, 0x01	; 1
    2fae:	20 97       	sbiw	r28, 0x00	; 0
    2fb0:	81 f7       	brne	.-32     	; 0x2f92 <_ZN5Print5writeEPKhj+0x22>
    2fb2:	02 c0       	rjmp	.+4      	; 0x2fb8 <_ZN5Print5writeEPKhj+0x48>
    2fb4:	e1 2c       	mov	r14, r1
    2fb6:	f1 2c       	mov	r15, r1
    2fb8:	c7 01       	movw	r24, r14
    2fba:	df 91       	pop	r29
    2fbc:	cf 91       	pop	r28
    2fbe:	1f 91       	pop	r17
    2fc0:	0f 91       	pop	r16
    2fc2:	ff 90       	pop	r15
    2fc4:	ef 90       	pop	r14
    2fc6:	df 90       	pop	r13
    2fc8:	cf 90       	pop	r12
    2fca:	08 95       	ret

00002fcc <_ZN5Print5printEc>:
    2fcc:	dc 01       	movw	r26, r24
    2fce:	ed 91       	ld	r30, X+
    2fd0:	fc 91       	ld	r31, X
    2fd2:	01 90       	ld	r0, Z+
    2fd4:	f0 81       	ld	r31, Z
    2fd6:	e0 2d       	mov	r30, r0
    2fd8:	19 95       	eicall
    2fda:	08 95       	ret

00002fdc <_ZN5Print7printlnEv>:
    2fdc:	dc 01       	movw	r26, r24
    2fde:	ed 91       	ld	r30, X+
    2fe0:	fc 91       	ld	r31, X
    2fe2:	02 80       	ldd	r0, Z+2	; 0x02
    2fe4:	f3 81       	ldd	r31, Z+3	; 0x03
    2fe6:	e0 2d       	mov	r30, r0
    2fe8:	42 e0       	ldi	r20, 0x02	; 2
    2fea:	50 e0       	ldi	r21, 0x00	; 0
    2fec:	6d e8       	ldi	r22, 0x8D	; 141
    2fee:	72 e0       	ldi	r23, 0x02	; 2
    2ff0:	19 95       	eicall
    2ff2:	08 95       	ret

00002ff4 <_ZN5Print11printNumberEmh>:
    2ff4:	6f 92       	push	r6
    2ff6:	7f 92       	push	r7
    2ff8:	8f 92       	push	r8
    2ffa:	9f 92       	push	r9
    2ffc:	af 92       	push	r10
    2ffe:	bf 92       	push	r11
    3000:	cf 92       	push	r12
    3002:	df 92       	push	r13
    3004:	ef 92       	push	r14
    3006:	ff 92       	push	r15
    3008:	0f 93       	push	r16
    300a:	1f 93       	push	r17
    300c:	cf 93       	push	r28
    300e:	df 93       	push	r29
    3010:	cd b7       	in	r28, 0x3d	; 61
    3012:	de b7       	in	r29, 0x3e	; 62
    3014:	a1 97       	sbiw	r28, 0x21	; 33
    3016:	0f b6       	in	r0, 0x3f	; 63
    3018:	f8 94       	cli
    301a:	de bf       	out	0x3e, r29	; 62
    301c:	0f be       	out	0x3f, r0	; 63
    301e:	cd bf       	out	0x3d, r28	; 61
    3020:	6c 01       	movw	r12, r24
    3022:	74 2e       	mov	r7, r20
    3024:	35 2f       	mov	r19, r21
    3026:	86 2f       	mov	r24, r22
    3028:	97 2f       	mov	r25, r23
    302a:	62 2e       	mov	r6, r18
    302c:	19 a2       	std	Y+33, r1	; 0x21
    302e:	21 e0       	ldi	r18, 0x01	; 1
    3030:	26 15       	cp	r18, r6
    3032:	20 f0       	brcs	.+8      	; 0x303c <_ZN5Print11printNumberEmh+0x48>
    3034:	0f 2e       	mov	r0, r31
    3036:	fa e0       	ldi	r31, 0x0A	; 10
    3038:	6f 2e       	mov	r6, r31
    303a:	f0 2d       	mov	r31, r0
    303c:	7e 01       	movw	r14, r28
    303e:	a1 e2       	ldi	r26, 0x21	; 33
    3040:	ea 0e       	add	r14, r26
    3042:	f1 1c       	adc	r15, r1
    3044:	86 2c       	mov	r8, r6
    3046:	91 2c       	mov	r9, r1
    3048:	a1 2c       	mov	r10, r1
    304a:	b1 2c       	mov	r11, r1
    304c:	67 2d       	mov	r22, r7
    304e:	73 2f       	mov	r23, r19
    3050:	a5 01       	movw	r20, r10
    3052:	94 01       	movw	r18, r8
    3054:	e5 d2       	rcall	.+1482   	; 0x3620 <__udivmodsi4>
    3056:	e2 2f       	mov	r30, r18
    3058:	73 2f       	mov	r23, r19
    305a:	02 2f       	mov	r16, r18
    305c:	13 2f       	mov	r17, r19
    305e:	24 2f       	mov	r18, r20
    3060:	35 2f       	mov	r19, r21
    3062:	f7 2d       	mov	r31, r7
    3064:	6e 9e       	mul	r6, r30
    3066:	f0 19       	sub	r31, r0
    3068:	11 24       	eor	r1, r1
    306a:	b1 e0       	ldi	r27, 0x01	; 1
    306c:	eb 1a       	sub	r14, r27
    306e:	f1 08       	sbc	r15, r1
    3070:	fa 30       	cpi	r31, 0x0A	; 10
    3072:	10 f4       	brcc	.+4      	; 0x3078 <_ZN5Print11printNumberEmh+0x84>
    3074:	f0 5d       	subi	r31, 0xD0	; 208
    3076:	01 c0       	rjmp	.+2      	; 0x307a <_ZN5Print11printNumberEmh+0x86>
    3078:	f9 5c       	subi	r31, 0xC9	; 201
    307a:	d7 01       	movw	r26, r14
    307c:	fc 93       	st	X, r31
    307e:	01 2b       	or	r16, r17
    3080:	02 2b       	or	r16, r18
    3082:	03 2b       	or	r16, r19
    3084:	29 f0       	breq	.+10     	; 0x3090 <_ZN5Print11printNumberEmh+0x9c>
    3086:	7e 2e       	mov	r7, r30
    3088:	37 2f       	mov	r19, r23
    308a:	84 2f       	mov	r24, r20
    308c:	95 2f       	mov	r25, r21
    308e:	de cf       	rjmp	.-68     	; 0x304c <_ZN5Print11printNumberEmh+0x58>
    3090:	e1 14       	cp	r14, r1
    3092:	f1 04       	cpc	r15, r1
    3094:	91 f0       	breq	.+36     	; 0x30ba <_ZN5Print11printNumberEmh+0xc6>
    3096:	f7 01       	movw	r30, r14
    3098:	01 90       	ld	r0, Z+
    309a:	00 20       	and	r0, r0
    309c:	e9 f7       	brne	.-6      	; 0x3098 <_ZN5Print11printNumberEmh+0xa4>
    309e:	31 97       	sbiw	r30, 0x01	; 1
    30a0:	af 01       	movw	r20, r30
    30a2:	4e 19       	sub	r20, r14
    30a4:	5f 09       	sbc	r21, r15
    30a6:	d6 01       	movw	r26, r12
    30a8:	ed 91       	ld	r30, X+
    30aa:	fc 91       	ld	r31, X
    30ac:	02 80       	ldd	r0, Z+2	; 0x02
    30ae:	f3 81       	ldd	r31, Z+3	; 0x03
    30b0:	e0 2d       	mov	r30, r0
    30b2:	b7 01       	movw	r22, r14
    30b4:	c6 01       	movw	r24, r12
    30b6:	19 95       	eicall
    30b8:	02 c0       	rjmp	.+4      	; 0x30be <_ZN5Print11printNumberEmh+0xca>
    30ba:	80 e0       	ldi	r24, 0x00	; 0
    30bc:	90 e0       	ldi	r25, 0x00	; 0
    30be:	a1 96       	adiw	r28, 0x21	; 33
    30c0:	0f b6       	in	r0, 0x3f	; 63
    30c2:	f8 94       	cli
    30c4:	de bf       	out	0x3e, r29	; 62
    30c6:	0f be       	out	0x3f, r0	; 63
    30c8:	cd bf       	out	0x3d, r28	; 61
    30ca:	df 91       	pop	r29
    30cc:	cf 91       	pop	r28
    30ce:	1f 91       	pop	r17
    30d0:	0f 91       	pop	r16
    30d2:	ff 90       	pop	r15
    30d4:	ef 90       	pop	r14
    30d6:	df 90       	pop	r13
    30d8:	cf 90       	pop	r12
    30da:	bf 90       	pop	r11
    30dc:	af 90       	pop	r10
    30de:	9f 90       	pop	r9
    30e0:	8f 90       	pop	r8
    30e2:	7f 90       	pop	r7
    30e4:	6f 90       	pop	r6
    30e6:	08 95       	ret

000030e8 <_ZN5Print5printEli>:
    30e8:	cf 92       	push	r12
    30ea:	df 92       	push	r13
    30ec:	ef 92       	push	r14
    30ee:	ff 92       	push	r15
    30f0:	0f 93       	push	r16
    30f2:	1f 93       	push	r17
    30f4:	cf 93       	push	r28
    30f6:	df 93       	push	r29
    30f8:	ec 01       	movw	r28, r24
    30fa:	6a 01       	movw	r12, r20
    30fc:	7b 01       	movw	r14, r22
    30fe:	21 15       	cp	r18, r1
    3100:	31 05       	cpc	r19, r1
    3102:	41 f4       	brne	.+16     	; 0x3114 <_ZN5Print5printEli+0x2c>
    3104:	e8 81       	ld	r30, Y
    3106:	f9 81       	ldd	r31, Y+1	; 0x01
    3108:	01 90       	ld	r0, Z+
    310a:	f0 81       	ld	r31, Z
    310c:	e0 2d       	mov	r30, r0
    310e:	64 2f       	mov	r22, r20
    3110:	19 95       	eicall
    3112:	19 c0       	rjmp	.+50     	; 0x3146 <_ZN5Print5printEli+0x5e>
    3114:	2a 30       	cpi	r18, 0x0A	; 10
    3116:	31 05       	cpc	r19, r1
    3118:	a9 f4       	brne	.+42     	; 0x3144 <_ZN5Print5printEli+0x5c>
    311a:	77 23       	and	r23, r23
    311c:	84 f4       	brge	.+32     	; 0x313e <_ZN5Print5printEli+0x56>
    311e:	6d e2       	ldi	r22, 0x2D	; 45
    3120:	55 df       	rcall	.-342    	; 0x2fcc <_ZN5Print5printEc>
    3122:	8c 01       	movw	r16, r24
    3124:	44 27       	eor	r20, r20
    3126:	55 27       	eor	r21, r21
    3128:	ba 01       	movw	r22, r20
    312a:	4c 19       	sub	r20, r12
    312c:	5d 09       	sbc	r21, r13
    312e:	6e 09       	sbc	r22, r14
    3130:	7f 09       	sbc	r23, r15
    3132:	2a e0       	ldi	r18, 0x0A	; 10
    3134:	ce 01       	movw	r24, r28
    3136:	5e df       	rcall	.-324    	; 0x2ff4 <_ZN5Print11printNumberEmh>
    3138:	80 0f       	add	r24, r16
    313a:	91 1f       	adc	r25, r17
    313c:	04 c0       	rjmp	.+8      	; 0x3146 <_ZN5Print5printEli+0x5e>
    313e:	2a e0       	ldi	r18, 0x0A	; 10
    3140:	59 df       	rcall	.-334    	; 0x2ff4 <_ZN5Print11printNumberEmh>
    3142:	01 c0       	rjmp	.+2      	; 0x3146 <_ZN5Print5printEli+0x5e>
    3144:	57 df       	rcall	.-338    	; 0x2ff4 <_ZN5Print11printNumberEmh>
    3146:	df 91       	pop	r29
    3148:	cf 91       	pop	r28
    314a:	1f 91       	pop	r17
    314c:	0f 91       	pop	r16
    314e:	ff 90       	pop	r15
    3150:	ef 90       	pop	r14
    3152:	df 90       	pop	r13
    3154:	cf 90       	pop	r12
    3156:	08 95       	ret

00003158 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    3158:	0f 93       	push	r16
    315a:	1f 93       	push	r17
    315c:	cf 93       	push	r28
    315e:	df 93       	push	r29
    3160:	ec 01       	movw	r28, r24
    3162:	9a 01       	movw	r18, r20
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
    3164:	ab 01       	movw	r20, r22
    3166:	66 27       	eor	r22, r22
    3168:	57 fd       	sbrc	r21, 7
    316a:	60 95       	com	r22
    316c:	76 2f       	mov	r23, r22
    316e:	bc df       	rcall	.-136    	; 0x30e8 <_ZN5Print5printEli>
    3170:	8c 01       	movw	r16, r24
}

size_t Print::println(int num, int base)
{
  size_t n = print(num, base);
  n += println();
    3172:	ce 01       	movw	r24, r28
    3174:	33 df       	rcall	.-410    	; 0x2fdc <_ZN5Print7printlnEv>
  return n;
}
    3176:	80 0f       	add	r24, r16
    3178:	91 1f       	adc	r25, r17
    317a:	df 91       	pop	r29
    317c:	cf 91       	pop	r28
    317e:	1f 91       	pop	r17
    3180:	0f 91       	pop	r16
    3182:	08 95       	ret

00003184 <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    3184:	1f 92       	push	r1
    3186:	0f 92       	push	r0
    3188:	0f b6       	in	r0, 0x3f	; 63
    318a:	0f 92       	push	r0
    318c:	11 24       	eor	r1, r1
    318e:	2f 93       	push	r18
    3190:	3f 93       	push	r19
    3192:	8f 93       	push	r24
    3194:	9f 93       	push	r25
    3196:	af 93       	push	r26
    3198:	bf 93       	push	r27
    319a:	80 91 87 0a 	lds	r24, 0x0A87
    319e:	90 91 88 0a 	lds	r25, 0x0A88
    31a2:	a0 91 89 0a 	lds	r26, 0x0A89
    31a6:	b0 91 8a 0a 	lds	r27, 0x0A8A
    31aa:	30 91 86 0a 	lds	r19, 0x0A86
    31ae:	23 e0       	ldi	r18, 0x03	; 3
    31b0:	23 0f       	add	r18, r19
    31b2:	2d 37       	cpi	r18, 0x7D	; 125
    31b4:	20 f4       	brcc	.+8      	; 0x31be <__vector_23+0x3a>
    31b6:	01 96       	adiw	r24, 0x01	; 1
    31b8:	a1 1d       	adc	r26, r1
    31ba:	b1 1d       	adc	r27, r1
    31bc:	05 c0       	rjmp	.+10     	; 0x31c8 <__vector_23+0x44>
    31be:	26 e8       	ldi	r18, 0x86	; 134
    31c0:	23 0f       	add	r18, r19
    31c2:	02 96       	adiw	r24, 0x02	; 2
    31c4:	a1 1d       	adc	r26, r1
    31c6:	b1 1d       	adc	r27, r1
    31c8:	20 93 86 0a 	sts	0x0A86, r18
    31cc:	80 93 87 0a 	sts	0x0A87, r24
    31d0:	90 93 88 0a 	sts	0x0A88, r25
    31d4:	a0 93 89 0a 	sts	0x0A89, r26
    31d8:	b0 93 8a 0a 	sts	0x0A8A, r27
    31dc:	80 91 8b 0a 	lds	r24, 0x0A8B
    31e0:	90 91 8c 0a 	lds	r25, 0x0A8C
    31e4:	a0 91 8d 0a 	lds	r26, 0x0A8D
    31e8:	b0 91 8e 0a 	lds	r27, 0x0A8E
    31ec:	01 96       	adiw	r24, 0x01	; 1
    31ee:	a1 1d       	adc	r26, r1
    31f0:	b1 1d       	adc	r27, r1
    31f2:	80 93 8b 0a 	sts	0x0A8B, r24
    31f6:	90 93 8c 0a 	sts	0x0A8C, r25
    31fa:	a0 93 8d 0a 	sts	0x0A8D, r26
    31fe:	b0 93 8e 0a 	sts	0x0A8E, r27
    3202:	bf 91       	pop	r27
    3204:	af 91       	pop	r26
    3206:	9f 91       	pop	r25
    3208:	8f 91       	pop	r24
    320a:	3f 91       	pop	r19
    320c:	2f 91       	pop	r18
    320e:	0f 90       	pop	r0
    3210:	0f be       	out	0x3f, r0	; 63
    3212:	0f 90       	pop	r0
    3214:	1f 90       	pop	r1
    3216:	18 95       	reti

00003218 <millis>:
    3218:	2f b7       	in	r18, 0x3f	; 63
    321a:	f8 94       	cli
    321c:	60 91 87 0a 	lds	r22, 0x0A87
    3220:	70 91 88 0a 	lds	r23, 0x0A88
    3224:	80 91 89 0a 	lds	r24, 0x0A89
    3228:	90 91 8a 0a 	lds	r25, 0x0A8A
    322c:	2f bf       	out	0x3f, r18	; 63
    322e:	08 95       	ret

00003230 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    3230:	82 30       	cpi	r24, 0x02	; 2
    3232:	91 05       	cpc	r25, r1
    3234:	38 f0       	brcs	.+14     	; 0x3244 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    3236:	88 0f       	add	r24, r24
    3238:	99 1f       	adc	r25, r25
    323a:	88 0f       	add	r24, r24
    323c:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    323e:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    3240:	01 97       	sbiw	r24, 0x01	; 1
    3242:	f1 f7       	brne	.-4      	; 0x3240 <delayMicroseconds+0x10>
    3244:	08 95       	ret

00003246 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    3246:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    3248:	84 b5       	in	r24, 0x24	; 36
    324a:	82 60       	ori	r24, 0x02	; 2
    324c:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    324e:	84 b5       	in	r24, 0x24	; 36
    3250:	81 60       	ori	r24, 0x01	; 1
    3252:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    3254:	85 b5       	in	r24, 0x25	; 37
    3256:	82 60       	ori	r24, 0x02	; 2
    3258:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    325a:	85 b5       	in	r24, 0x25	; 37
    325c:	81 60       	ori	r24, 0x01	; 1
    325e:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    3260:	ee e6       	ldi	r30, 0x6E	; 110
    3262:	f0 e0       	ldi	r31, 0x00	; 0
    3264:	80 81       	ld	r24, Z
    3266:	81 60       	ori	r24, 0x01	; 1
    3268:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    326a:	e1 e8       	ldi	r30, 0x81	; 129
    326c:	f0 e0       	ldi	r31, 0x00	; 0
    326e:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    3270:	80 81       	ld	r24, Z
    3272:	82 60       	ori	r24, 0x02	; 2
    3274:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    3276:	80 81       	ld	r24, Z
    3278:	81 60       	ori	r24, 0x01	; 1
    327a:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    327c:	e0 e8       	ldi	r30, 0x80	; 128
    327e:	f0 e0       	ldi	r31, 0x00	; 0
    3280:	80 81       	ld	r24, Z
    3282:	81 60       	ori	r24, 0x01	; 1
    3284:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    3286:	e1 eb       	ldi	r30, 0xB1	; 177
    3288:	f0 e0       	ldi	r31, 0x00	; 0
    328a:	80 81       	ld	r24, Z
    328c:	84 60       	ori	r24, 0x04	; 4
    328e:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    3290:	e0 eb       	ldi	r30, 0xB0	; 176
    3292:	f0 e0       	ldi	r31, 0x00	; 0
    3294:	80 81       	ld	r24, Z
    3296:	81 60       	ori	r24, 0x01	; 1
    3298:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    329a:	e1 e9       	ldi	r30, 0x91	; 145
    329c:	f0 e0       	ldi	r31, 0x00	; 0
    329e:	80 81       	ld	r24, Z
    32a0:	82 60       	ori	r24, 0x02	; 2
    32a2:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    32a4:	80 81       	ld	r24, Z
    32a6:	81 60       	ori	r24, 0x01	; 1
    32a8:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    32aa:	e0 e9       	ldi	r30, 0x90	; 144
    32ac:	f0 e0       	ldi	r31, 0x00	; 0
    32ae:	80 81       	ld	r24, Z
    32b0:	81 60       	ori	r24, 0x01	; 1
    32b2:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    32b4:	e1 ea       	ldi	r30, 0xA1	; 161
    32b6:	f0 e0       	ldi	r31, 0x00	; 0
    32b8:	80 81       	ld	r24, Z
    32ba:	82 60       	ori	r24, 0x02	; 2
    32bc:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    32be:	80 81       	ld	r24, Z
    32c0:	81 60       	ori	r24, 0x01	; 1
    32c2:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    32c4:	e0 ea       	ldi	r30, 0xA0	; 160
    32c6:	f0 e0       	ldi	r31, 0x00	; 0
    32c8:	80 81       	ld	r24, Z
    32ca:	81 60       	ori	r24, 0x01	; 1
    32cc:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    32ce:	e1 e2       	ldi	r30, 0x21	; 33
    32d0:	f1 e0       	ldi	r31, 0x01	; 1
    32d2:	80 81       	ld	r24, Z
    32d4:	82 60       	ori	r24, 0x02	; 2
    32d6:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    32d8:	80 81       	ld	r24, Z
    32da:	81 60       	ori	r24, 0x01	; 1
    32dc:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    32de:	e0 e2       	ldi	r30, 0x20	; 32
    32e0:	f1 e0       	ldi	r31, 0x01	; 1
    32e2:	80 81       	ld	r24, Z
    32e4:	81 60       	ori	r24, 0x01	; 1
    32e6:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    32e8:	ea e7       	ldi	r30, 0x7A	; 122
    32ea:	f0 e0       	ldi	r31, 0x00	; 0
    32ec:	80 81       	ld	r24, Z
    32ee:	84 60       	ori	r24, 0x04	; 4
    32f0:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    32f2:	80 81       	ld	r24, Z
    32f4:	82 60       	ori	r24, 0x02	; 2
    32f6:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    32f8:	80 81       	ld	r24, Z
    32fa:	81 60       	ori	r24, 0x01	; 1
    32fc:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    32fe:	80 81       	ld	r24, Z
    3300:	80 68       	ori	r24, 0x80	; 128
    3302:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    3304:	10 92 c1 00 	sts	0x00C1, r1
    3308:	08 95       	ret

0000330a <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
    330a:	80 93 08 02 	sts	0x0208, r24
    330e:	08 95       	ret

00003310 <analogRead>:
#if defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#endif
	pin = analogPinToChannel(pin);
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
    3310:	86 33       	cpi	r24, 0x36	; 54
    3312:	08 f0       	brcs	.+2      	; 0x3316 <analogRead+0x6>
    3314:	86 53       	subi	r24, 0x36	; 54
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
    3316:	eb e7       	ldi	r30, 0x7B	; 123
    3318:	f0 e0       	ldi	r31, 0x00	; 0
    331a:	90 81       	ld	r25, Z
    331c:	28 2f       	mov	r18, r24
    331e:	28 70       	andi	r18, 0x08	; 8
    3320:	97 7f       	andi	r25, 0xF7	; 247
    3322:	92 2b       	or	r25, r18
    3324:	90 83       	st	Z, r25
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    3326:	87 70       	andi	r24, 0x07	; 7
    3328:	20 91 08 02 	lds	r18, 0x0208
    332c:	90 e4       	ldi	r25, 0x40	; 64
    332e:	29 9f       	mul	r18, r25
    3330:	90 01       	movw	r18, r0
    3332:	11 24       	eor	r1, r1
    3334:	28 2b       	or	r18, r24
    3336:	20 93 7c 00 	sts	0x007C, r18
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    333a:	ea e7       	ldi	r30, 0x7A	; 122
    333c:	f0 e0       	ldi	r31, 0x00	; 0
    333e:	80 81       	ld	r24, Z
    3340:	80 64       	ori	r24, 0x40	; 64
    3342:	80 83       	st	Z, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    3344:	80 81       	ld	r24, Z
    3346:	86 fd       	sbrc	r24, 6
    3348:	fd cf       	rjmp	.-6      	; 0x3344 <analogRead+0x34>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    334a:	80 91 78 00 	lds	r24, 0x0078
	high = ADCH;
    334e:	20 91 79 00 	lds	r18, 0x0079
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    3352:	90 e0       	ldi	r25, 0x00	; 0
}
    3354:	92 2b       	or	r25, r18
    3356:	08 95       	ret

00003358 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    3358:	90 e0       	ldi	r25, 0x00	; 0
    335a:	fc 01       	movw	r30, r24
    335c:	31 97       	sbiw	r30, 0x01	; 1
    335e:	e2 31       	cpi	r30, 0x12	; 18
    3360:	f1 05       	cpc	r31, r1
    3362:	08 f0       	brcs	.+2      	; 0x3366 <turnOffPWM+0xe>
    3364:	5e c0       	rjmp	.+188    	; 0x3422 <turnOffPWM+0xca>
    3366:	e4 58       	subi	r30, 0x84	; 132
    3368:	fe 4f       	sbci	r31, 0xFE	; 254
    336a:	98 c1       	rjmp	.+816    	; 0x369c <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    336c:	e0 e8       	ldi	r30, 0x80	; 128
    336e:	f0 e0       	ldi	r31, 0x00	; 0
    3370:	80 81       	ld	r24, Z
    3372:	8f 77       	andi	r24, 0x7F	; 127
    3374:	80 83       	st	Z, r24
    3376:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    3378:	e0 e8       	ldi	r30, 0x80	; 128
    337a:	f0 e0       	ldi	r31, 0x00	; 0
    337c:	80 81       	ld	r24, Z
    337e:	8f 7d       	andi	r24, 0xDF	; 223
    3380:	80 83       	st	Z, r24
    3382:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    3384:	e0 e8       	ldi	r30, 0x80	; 128
    3386:	f0 e0       	ldi	r31, 0x00	; 0
    3388:	80 81       	ld	r24, Z
    338a:	87 7f       	andi	r24, 0xF7	; 247
    338c:	80 83       	st	Z, r24
    338e:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    3390:	84 b5       	in	r24, 0x24	; 36
    3392:	8f 77       	andi	r24, 0x7F	; 127
    3394:	84 bd       	out	0x24, r24	; 36
    3396:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    3398:	84 b5       	in	r24, 0x24	; 36
    339a:	8f 7d       	andi	r24, 0xDF	; 223
    339c:	84 bd       	out	0x24, r24	; 36
    339e:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    33a0:	e0 eb       	ldi	r30, 0xB0	; 176
    33a2:	f0 e0       	ldi	r31, 0x00	; 0
    33a4:	80 81       	ld	r24, Z
    33a6:	8f 77       	andi	r24, 0x7F	; 127
    33a8:	80 83       	st	Z, r24
    33aa:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    33ac:	e0 eb       	ldi	r30, 0xB0	; 176
    33ae:	f0 e0       	ldi	r31, 0x00	; 0
    33b0:	80 81       	ld	r24, Z
    33b2:	8f 7d       	andi	r24, 0xDF	; 223
    33b4:	80 83       	st	Z, r24
    33b6:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    33b8:	e0 e9       	ldi	r30, 0x90	; 144
    33ba:	f0 e0       	ldi	r31, 0x00	; 0
    33bc:	80 81       	ld	r24, Z
    33be:	8f 77       	andi	r24, 0x7F	; 127
    33c0:	80 83       	st	Z, r24
    33c2:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    33c4:	e0 e9       	ldi	r30, 0x90	; 144
    33c6:	f0 e0       	ldi	r31, 0x00	; 0
    33c8:	80 81       	ld	r24, Z
    33ca:	8f 7d       	andi	r24, 0xDF	; 223
    33cc:	80 83       	st	Z, r24
    33ce:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    33d0:	e0 e9       	ldi	r30, 0x90	; 144
    33d2:	f0 e0       	ldi	r31, 0x00	; 0
    33d4:	80 81       	ld	r24, Z
    33d6:	87 7f       	andi	r24, 0xF7	; 247
    33d8:	80 83       	st	Z, r24
    33da:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    33dc:	e0 ea       	ldi	r30, 0xA0	; 160
    33de:	f0 e0       	ldi	r31, 0x00	; 0
    33e0:	80 81       	ld	r24, Z
    33e2:	8f 77       	andi	r24, 0x7F	; 127
    33e4:	80 83       	st	Z, r24
    33e6:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    33e8:	e0 ea       	ldi	r30, 0xA0	; 160
    33ea:	f0 e0       	ldi	r31, 0x00	; 0
    33ec:	80 81       	ld	r24, Z
    33ee:	8f 7d       	andi	r24, 0xDF	; 223
    33f0:	80 83       	st	Z, r24
    33f2:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    33f4:	e0 ea       	ldi	r30, 0xA0	; 160
    33f6:	f0 e0       	ldi	r31, 0x00	; 0
    33f8:	80 81       	ld	r24, Z
    33fa:	87 7f       	andi	r24, 0xF7	; 247
    33fc:	80 83       	st	Z, r24
    33fe:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3400:	e0 e2       	ldi	r30, 0x20	; 32
    3402:	f1 e0       	ldi	r31, 0x01	; 1
    3404:	80 81       	ld	r24, Z
    3406:	8f 77       	andi	r24, 0x7F	; 127
    3408:	80 83       	st	Z, r24
    340a:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    340c:	e0 e2       	ldi	r30, 0x20	; 32
    340e:	f1 e0       	ldi	r31, 0x01	; 1
    3410:	80 81       	ld	r24, Z
    3412:	8f 7d       	andi	r24, 0xDF	; 223
    3414:	80 83       	st	Z, r24
    3416:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    3418:	e0 e2       	ldi	r30, 0x20	; 32
    341a:	f1 e0       	ldi	r31, 0x01	; 1
    341c:	80 81       	ld	r24, Z
    341e:	87 7f       	andi	r24, 0xF7	; 247
    3420:	80 83       	st	Z, r24
    3422:	08 95       	ret

00003424 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    3424:	cf 93       	push	r28
    3426:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    3428:	90 e0       	ldi	r25, 0x00	; 0
    342a:	fc 01       	movw	r30, r24
    342c:	ee 59       	subi	r30, 0x9E	; 158
    342e:	fc 4f       	sbci	r31, 0xFC	; 252
    3430:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    3432:	fc 01       	movw	r30, r24
    3434:	e8 55       	subi	r30, 0x58	; 88
    3436:	fc 4f       	sbci	r31, 0xFC	; 252
    3438:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    343a:	88 23       	and	r24, r24
    343c:	71 f1       	breq	.+92     	; 0x349a <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	88 0f       	add	r24, r24
    3442:	99 1f       	adc	r25, r25
    3444:	fc 01       	movw	r30, r24
    3446:	ee 5d       	subi	r30, 0xDE	; 222
    3448:	fb 4f       	sbci	r31, 0xFB	; 251
    344a:	a5 91       	lpm	r26, Z+
    344c:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    344e:	88 5f       	subi	r24, 0xF8	; 248
    3450:	9b 4f       	sbci	r25, 0xFB	; 251
    3452:	fc 01       	movw	r30, r24
    3454:	c5 91       	lpm	r28, Z+
    3456:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    3458:	61 11       	cpse	r22, r1
    345a:	0b c0       	rjmp	.+22     	; 0x3472 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    345c:	8f b7       	in	r24, 0x3f	; 63
                cli();
    345e:	f8 94       	cli
		*reg &= ~bit;
    3460:	9c 91       	ld	r25, X
    3462:	20 95       	com	r18
    3464:	92 23       	and	r25, r18
    3466:	9c 93       	st	X, r25
		*out &= ~bit;
    3468:	e8 81       	ld	r30, Y
    346a:	2e 23       	and	r18, r30
    346c:	28 83       	st	Y, r18
		SREG = oldSREG;
    346e:	8f bf       	out	0x3f, r24	; 63
    3470:	14 c0       	rjmp	.+40     	; 0x349a <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    3472:	62 30       	cpi	r22, 0x02	; 2
    3474:	61 f4       	brne	.+24     	; 0x348e <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    3476:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3478:	f8 94       	cli
		*reg &= ~bit;
    347a:	3c 91       	ld	r19, X
    347c:	92 2f       	mov	r25, r18
    347e:	90 95       	com	r25
    3480:	93 23       	and	r25, r19
    3482:	9c 93       	st	X, r25
		*out |= bit;
    3484:	e8 81       	ld	r30, Y
    3486:	2e 2b       	or	r18, r30
    3488:	28 83       	st	Y, r18
		SREG = oldSREG;
    348a:	8f bf       	out	0x3f, r24	; 63
    348c:	06 c0       	rjmp	.+12     	; 0x349a <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    348e:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3490:	f8 94       	cli
		*reg |= bit;
    3492:	ec 91       	ld	r30, X
    3494:	2e 2b       	or	r18, r30
    3496:	2c 93       	st	X, r18
		SREG = oldSREG;
    3498:	8f bf       	out	0x3f, r24	; 63
	}
}
    349a:	df 91       	pop	r29
    349c:	cf 91       	pop	r28
    349e:	08 95       	ret

000034a0 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    34a0:	1f 93       	push	r17
    34a2:	cf 93       	push	r28
    34a4:	df 93       	push	r29
    34a6:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    34a8:	28 2f       	mov	r18, r24
    34aa:	30 e0       	ldi	r19, 0x00	; 0
    34ac:	f9 01       	movw	r30, r18
    34ae:	e4 5e       	subi	r30, 0xE4	; 228
    34b0:	fc 4f       	sbci	r31, 0xFC	; 252
    34b2:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    34b4:	f9 01       	movw	r30, r18
    34b6:	ee 59       	subi	r30, 0x9E	; 158
    34b8:	fc 4f       	sbci	r31, 0xFC	; 252
    34ba:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    34bc:	f9 01       	movw	r30, r18
    34be:	e8 55       	subi	r30, 0x58	; 88
    34c0:	fc 4f       	sbci	r31, 0xFC	; 252
    34c2:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    34c4:	dd 23       	and	r29, r29
    34c6:	c1 f0       	breq	.+48     	; 0x34f8 <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    34c8:	81 11       	cpse	r24, r1
    34ca:	46 df       	rcall	.-372    	; 0x3358 <turnOffPWM>

	out = portOutputRegister(port);
    34cc:	2d 2f       	mov	r18, r29
    34ce:	30 e0       	ldi	r19, 0x00	; 0
    34d0:	f9 01       	movw	r30, r18
    34d2:	ee 0f       	add	r30, r30
    34d4:	ff 1f       	adc	r31, r31
    34d6:	e8 5f       	subi	r30, 0xF8	; 248
    34d8:	fb 4f       	sbci	r31, 0xFB	; 251
    34da:	a5 91       	lpm	r26, Z+
    34dc:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    34de:	8f b7       	in	r24, 0x3f	; 63
	cli();
    34e0:	f8 94       	cli

	if (val == LOW) {
    34e2:	c1 11       	cpse	r28, r1
    34e4:	05 c0       	rjmp	.+10     	; 0x34f0 <digitalWrite+0x50>
		*out &= ~bit;
    34e6:	ec 91       	ld	r30, X
    34e8:	10 95       	com	r17
    34ea:	1e 23       	and	r17, r30
    34ec:	1c 93       	st	X, r17
    34ee:	03 c0       	rjmp	.+6      	; 0x34f6 <digitalWrite+0x56>
	} else {
		*out |= bit;
    34f0:	ec 91       	ld	r30, X
    34f2:	1e 2b       	or	r17, r30
    34f4:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    34f6:	8f bf       	out	0x3f, r24	; 63
}
    34f8:	df 91       	pop	r29
    34fa:	cf 91       	pop	r28
    34fc:	1f 91       	pop	r17
    34fe:	08 95       	ret

00003500 <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3500:	0f 93       	push	r16
    3502:	1f 93       	push	r17
    3504:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    3506:	90 e0       	ldi	r25, 0x00	; 0
    3508:	fc 01       	movw	r30, r24
    350a:	ee 59       	subi	r30, 0x9E	; 158
    350c:	fc 4f       	sbci	r31, 0xFC	; 252
    350e:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    3510:	fc 01       	movw	r30, r24
    3512:	e8 55       	subi	r30, 0x58	; 88
    3514:	fc 4f       	sbci	r31, 0xFC	; 252
    3516:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    3518:	71 11       	cpse	r23, r1
    351a:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    351c:	f0 e0       	ldi	r31, 0x00	; 0
    351e:	ee 0f       	add	r30, r30
    3520:	ff 1f       	adc	r31, r31
    3522:	e2 51       	subi	r30, 0x12	; 18
    3524:	fc 4f       	sbci	r31, 0xFC	; 252
    3526:	85 91       	lpm	r24, Z+
    3528:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    352a:	89 01       	movw	r16, r18
    352c:	9a 01       	movw	r18, r20
    352e:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3530:	47 2f       	mov	r20, r23
    3532:	0e 94 53 02 	call	0x4a6	; 0x4a6 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    3536:	61 15       	cp	r22, r1
    3538:	71 05       	cpc	r23, r1
    353a:	81 05       	cpc	r24, r1
    353c:	91 05       	cpc	r25, r1
    353e:	49 f0       	breq	.+18     	; 0x3552 <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    3540:	dc 01       	movw	r26, r24
    3542:	cb 01       	movw	r24, r22
    3544:	01 96       	adiw	r24, 0x01	; 1
    3546:	a1 1d       	adc	r26, r1
    3548:	b1 1d       	adc	r27, r1
    354a:	bc 01       	movw	r22, r24
    354c:	cd 01       	movw	r24, r26
    354e:	9f 70       	andi	r25, 0x0F	; 15
    3550:	03 c0       	rjmp	.+6      	; 0x3558 <pulseIn+0x58>
	else
		return 0;
    3552:	60 e0       	ldi	r22, 0x00	; 0
    3554:	70 e0       	ldi	r23, 0x00	; 0
    3556:	cb 01       	movw	r24, r22
}
    3558:	1f 91       	pop	r17
    355a:	0f 91       	pop	r16
    355c:	08 95       	ret

0000355e <_Z3maplllll>:
  long diff = howbig - howsmall;
  return random(diff) + howsmall;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
    355e:	4f 92       	push	r4
    3560:	5f 92       	push	r5
    3562:	6f 92       	push	r6
    3564:	7f 92       	push	r7
    3566:	af 92       	push	r10
    3568:	bf 92       	push	r11
    356a:	cf 92       	push	r12
    356c:	df 92       	push	r13
    356e:	ef 92       	push	r14
    3570:	ff 92       	push	r15
    3572:	0f 93       	push	r16
    3574:	1f 93       	push	r17
    3576:	cf 93       	push	r28
    3578:	df 93       	push	r29
    357a:	cd b7       	in	r28, 0x3d	; 61
    357c:	de b7       	in	r29, 0x3e	; 62
    357e:	29 01       	movw	r4, r18
    3580:	3a 01       	movw	r6, r20
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    3582:	9b 01       	movw	r18, r22
    3584:	ac 01       	movw	r20, r24
    3586:	24 19       	sub	r18, r4
    3588:	35 09       	sbc	r19, r5
    358a:	46 09       	sbc	r20, r6
    358c:	57 09       	sbc	r21, r7
    358e:	8a 89       	ldd	r24, Y+18	; 0x12
    3590:	9b 89       	ldd	r25, Y+19	; 0x13
    3592:	ac 89       	ldd	r26, Y+20	; 0x14
    3594:	bd 89       	ldd	r27, Y+21	; 0x15
    3596:	bc 01       	movw	r22, r24
    3598:	cd 01       	movw	r24, r26
    359a:	6a 19       	sub	r22, r10
    359c:	7b 09       	sbc	r23, r11
    359e:	8c 09       	sbc	r24, r12
    35a0:	9d 09       	sbc	r25, r13
    35a2:	1c d0       	rcall	.+56     	; 0x35dc <__mulsi3>
    35a4:	a8 01       	movw	r20, r16
    35a6:	97 01       	movw	r18, r14
    35a8:	24 19       	sub	r18, r4
    35aa:	35 09       	sbc	r19, r5
    35ac:	46 09       	sbc	r20, r6
    35ae:	57 09       	sbc	r21, r7
    35b0:	59 d0       	rcall	.+178    	; 0x3664 <__divmodsi4>
    35b2:	ca 01       	movw	r24, r20
    35b4:	b9 01       	movw	r22, r18
    35b6:	6a 0d       	add	r22, r10
    35b8:	7b 1d       	adc	r23, r11
    35ba:	8c 1d       	adc	r24, r12
    35bc:	9d 1d       	adc	r25, r13
}
    35be:	df 91       	pop	r29
    35c0:	cf 91       	pop	r28
    35c2:	1f 91       	pop	r17
    35c4:	0f 91       	pop	r16
    35c6:	ff 90       	pop	r15
    35c8:	ef 90       	pop	r14
    35ca:	df 90       	pop	r13
    35cc:	cf 90       	pop	r12
    35ce:	bf 90       	pop	r11
    35d0:	af 90       	pop	r10
    35d2:	7f 90       	pop	r7
    35d4:	6f 90       	pop	r6
    35d6:	5f 90       	pop	r5
    35d8:	4f 90       	pop	r4
    35da:	08 95       	ret

000035dc <__mulsi3>:
    35dc:	db 01       	movw	r26, r22
    35de:	8f 93       	push	r24
    35e0:	9f 93       	push	r25
    35e2:	62 d0       	rcall	.+196    	; 0x36a8 <__muluhisi3>
    35e4:	bf 91       	pop	r27
    35e6:	af 91       	pop	r26
    35e8:	a2 9f       	mul	r26, r18
    35ea:	80 0d       	add	r24, r0
    35ec:	91 1d       	adc	r25, r1
    35ee:	a3 9f       	mul	r26, r19
    35f0:	90 0d       	add	r25, r0
    35f2:	b2 9f       	mul	r27, r18
    35f4:	90 0d       	add	r25, r0
    35f6:	11 24       	eor	r1, r1
    35f8:	08 95       	ret

000035fa <__divmodhi4>:
    35fa:	97 fb       	bst	r25, 7
    35fc:	07 2e       	mov	r0, r23
    35fe:	16 f4       	brtc	.+4      	; 0x3604 <__divmodhi4+0xa>
    3600:	00 94       	com	r0
    3602:	06 d0       	rcall	.+12     	; 0x3610 <__divmodhi4_neg1>
    3604:	77 fd       	sbrc	r23, 7
    3606:	08 d0       	rcall	.+16     	; 0x3618 <__divmodhi4_neg2>
    3608:	5d d0       	rcall	.+186    	; 0x36c4 <__udivmodhi4>
    360a:	07 fc       	sbrc	r0, 7
    360c:	05 d0       	rcall	.+10     	; 0x3618 <__divmodhi4_neg2>
    360e:	3e f4       	brtc	.+14     	; 0x361e <__divmodhi4_exit>

00003610 <__divmodhi4_neg1>:
    3610:	90 95       	com	r25
    3612:	81 95       	neg	r24
    3614:	9f 4f       	sbci	r25, 0xFF	; 255
    3616:	08 95       	ret

00003618 <__divmodhi4_neg2>:
    3618:	70 95       	com	r23
    361a:	61 95       	neg	r22
    361c:	7f 4f       	sbci	r23, 0xFF	; 255

0000361e <__divmodhi4_exit>:
    361e:	08 95       	ret

00003620 <__udivmodsi4>:
    3620:	a1 e2       	ldi	r26, 0x21	; 33
    3622:	1a 2e       	mov	r1, r26
    3624:	aa 1b       	sub	r26, r26
    3626:	bb 1b       	sub	r27, r27
    3628:	fd 01       	movw	r30, r26
    362a:	0d c0       	rjmp	.+26     	; 0x3646 <__udivmodsi4_ep>

0000362c <__udivmodsi4_loop>:
    362c:	aa 1f       	adc	r26, r26
    362e:	bb 1f       	adc	r27, r27
    3630:	ee 1f       	adc	r30, r30
    3632:	ff 1f       	adc	r31, r31
    3634:	a2 17       	cp	r26, r18
    3636:	b3 07       	cpc	r27, r19
    3638:	e4 07       	cpc	r30, r20
    363a:	f5 07       	cpc	r31, r21
    363c:	20 f0       	brcs	.+8      	; 0x3646 <__udivmodsi4_ep>
    363e:	a2 1b       	sub	r26, r18
    3640:	b3 0b       	sbc	r27, r19
    3642:	e4 0b       	sbc	r30, r20
    3644:	f5 0b       	sbc	r31, r21

00003646 <__udivmodsi4_ep>:
    3646:	66 1f       	adc	r22, r22
    3648:	77 1f       	adc	r23, r23
    364a:	88 1f       	adc	r24, r24
    364c:	99 1f       	adc	r25, r25
    364e:	1a 94       	dec	r1
    3650:	69 f7       	brne	.-38     	; 0x362c <__udivmodsi4_loop>
    3652:	60 95       	com	r22
    3654:	70 95       	com	r23
    3656:	80 95       	com	r24
    3658:	90 95       	com	r25
    365a:	9b 01       	movw	r18, r22
    365c:	ac 01       	movw	r20, r24
    365e:	bd 01       	movw	r22, r26
    3660:	cf 01       	movw	r24, r30
    3662:	08 95       	ret

00003664 <__divmodsi4>:
    3664:	05 2e       	mov	r0, r21
    3666:	97 fb       	bst	r25, 7
    3668:	16 f4       	brtc	.+4      	; 0x366e <__divmodsi4+0xa>
    366a:	00 94       	com	r0
    366c:	0f d0       	rcall	.+30     	; 0x368c <__negsi2>
    366e:	57 fd       	sbrc	r21, 7
    3670:	05 d0       	rcall	.+10     	; 0x367c <__divmodsi4_neg2>
    3672:	d6 df       	rcall	.-84     	; 0x3620 <__udivmodsi4>
    3674:	07 fc       	sbrc	r0, 7
    3676:	02 d0       	rcall	.+4      	; 0x367c <__divmodsi4_neg2>
    3678:	46 f4       	brtc	.+16     	; 0x368a <__divmodsi4_exit>
    367a:	08 c0       	rjmp	.+16     	; 0x368c <__negsi2>

0000367c <__divmodsi4_neg2>:
    367c:	50 95       	com	r21
    367e:	40 95       	com	r20
    3680:	30 95       	com	r19
    3682:	21 95       	neg	r18
    3684:	3f 4f       	sbci	r19, 0xFF	; 255
    3686:	4f 4f       	sbci	r20, 0xFF	; 255
    3688:	5f 4f       	sbci	r21, 0xFF	; 255

0000368a <__divmodsi4_exit>:
    368a:	08 95       	ret

0000368c <__negsi2>:
    368c:	90 95       	com	r25
    368e:	80 95       	com	r24
    3690:	70 95       	com	r23
    3692:	61 95       	neg	r22
    3694:	7f 4f       	sbci	r23, 0xFF	; 255
    3696:	8f 4f       	sbci	r24, 0xFF	; 255
    3698:	9f 4f       	sbci	r25, 0xFF	; 255
    369a:	08 95       	ret

0000369c <__tablejump2__>:
    369c:	ee 0f       	add	r30, r30
    369e:	ff 1f       	adc	r31, r31

000036a0 <__tablejump__>:
    36a0:	05 90       	lpm	r0, Z+
    36a2:	f4 91       	lpm	r31, Z
    36a4:	e0 2d       	mov	r30, r0
    36a6:	19 94       	eijmp

000036a8 <__muluhisi3>:
    36a8:	21 d0       	rcall	.+66     	; 0x36ec <__umulhisi3>
    36aa:	a5 9f       	mul	r26, r21
    36ac:	90 0d       	add	r25, r0
    36ae:	b4 9f       	mul	r27, r20
    36b0:	90 0d       	add	r25, r0
    36b2:	a4 9f       	mul	r26, r20
    36b4:	80 0d       	add	r24, r0
    36b6:	91 1d       	adc	r25, r1
    36b8:	11 24       	eor	r1, r1
    36ba:	08 95       	ret

000036bc <__tablejump_elpm__>:
    36bc:	07 90       	elpm	r0, Z+
    36be:	f6 91       	elpm	r31, Z
    36c0:	e0 2d       	mov	r30, r0
    36c2:	19 94       	eijmp

000036c4 <__udivmodhi4>:
    36c4:	aa 1b       	sub	r26, r26
    36c6:	bb 1b       	sub	r27, r27
    36c8:	51 e1       	ldi	r21, 0x11	; 17
    36ca:	07 c0       	rjmp	.+14     	; 0x36da <__udivmodhi4_ep>

000036cc <__udivmodhi4_loop>:
    36cc:	aa 1f       	adc	r26, r26
    36ce:	bb 1f       	adc	r27, r27
    36d0:	a6 17       	cp	r26, r22
    36d2:	b7 07       	cpc	r27, r23
    36d4:	10 f0       	brcs	.+4      	; 0x36da <__udivmodhi4_ep>
    36d6:	a6 1b       	sub	r26, r22
    36d8:	b7 0b       	sbc	r27, r23

000036da <__udivmodhi4_ep>:
    36da:	88 1f       	adc	r24, r24
    36dc:	99 1f       	adc	r25, r25
    36de:	5a 95       	dec	r21
    36e0:	a9 f7       	brne	.-22     	; 0x36cc <__udivmodhi4_loop>
    36e2:	80 95       	com	r24
    36e4:	90 95       	com	r25
    36e6:	bc 01       	movw	r22, r24
    36e8:	cd 01       	movw	r24, r26
    36ea:	08 95       	ret

000036ec <__umulhisi3>:
    36ec:	a2 9f       	mul	r26, r18
    36ee:	b0 01       	movw	r22, r0
    36f0:	b3 9f       	mul	r27, r19
    36f2:	c0 01       	movw	r24, r0
    36f4:	a3 9f       	mul	r26, r19
    36f6:	70 0d       	add	r23, r0
    36f8:	81 1d       	adc	r24, r1
    36fa:	11 24       	eor	r1, r1
    36fc:	91 1d       	adc	r25, r1
    36fe:	b2 9f       	mul	r27, r18
    3700:	70 0d       	add	r23, r0
    3702:	81 1d       	adc	r24, r1
    3704:	11 24       	eor	r1, r1
    3706:	91 1d       	adc	r25, r1
    3708:	08 95       	ret

0000370a <_exit>:
    370a:	f8 94       	cli

0000370c <__stop_program>:
    370c:	ff cf       	rjmp	.-2      	; 0x370c <__stop_program>
