
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007c  00800200  000035f4  00003688  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035f4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007e9  0080027c  0080027c  00003704  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003704  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000758  00000000  00000000  00003738  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000fb2f  00000000  00000000  00003e90  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002b28  00000000  00000000  000139bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000053d3  00000000  00000000  000164e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001610  00000000  00000000  0001b8bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000387f  00000000  00000000  0001cecc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000080fa  00000000  00000000  0002074b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000738  00000000  00000000  00028845  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	df c1       	rjmp	.+958    	; 0x3c0 <__ctors_end>
       2:	00 00       	nop
       4:	0e c2       	rjmp	.+1052   	; 0x422 <__bad_interrupt>
       6:	00 00       	nop
       8:	0c c2       	rjmp	.+1048   	; 0x422 <__bad_interrupt>
       a:	00 00       	nop
       c:	0a c2       	rjmp	.+1044   	; 0x422 <__bad_interrupt>
       e:	00 00       	nop
      10:	08 c2       	rjmp	.+1040   	; 0x422 <__bad_interrupt>
      12:	00 00       	nop
      14:	06 c2       	rjmp	.+1036   	; 0x422 <__bad_interrupt>
      16:	00 00       	nop
      18:	04 c2       	rjmp	.+1032   	; 0x422 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	02 c2       	rjmp	.+1028   	; 0x422 <__bad_interrupt>
      1e:	00 00       	nop
      20:	00 c2       	rjmp	.+1024   	; 0x422 <__bad_interrupt>
      22:	00 00       	nop
      24:	fe c1       	rjmp	.+1020   	; 0x422 <__bad_interrupt>
      26:	00 00       	nop
      28:	fc c1       	rjmp	.+1016   	; 0x422 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	fa c1       	rjmp	.+1012   	; 0x422 <__bad_interrupt>
      2e:	00 00       	nop
      30:	f8 c1       	rjmp	.+1008   	; 0x422 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 ef 08 	jmp	0x11de	; 0x11de <__vector_13>
      38:	f4 c1       	rjmp	.+1000   	; 0x422 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f2 c1       	rjmp	.+996    	; 0x422 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f0 c1       	rjmp	.+992    	; 0x422 <__bad_interrupt>
      42:	00 00       	nop
      44:	ee c1       	rjmp	.+988    	; 0x422 <__bad_interrupt>
      46:	00 00       	nop
      48:	ec c1       	rjmp	.+984    	; 0x422 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ea c1       	rjmp	.+980    	; 0x422 <__bad_interrupt>
      4e:	00 00       	nop
      50:	e8 c1       	rjmp	.+976    	; 0x422 <__bad_interrupt>
      52:	00 00       	nop
      54:	e6 c1       	rjmp	.+972    	; 0x422 <__bad_interrupt>
      56:	00 00       	nop
      58:	e4 c1       	rjmp	.+968    	; 0x422 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 fd 18 	jmp	0x31fa	; 0x31fa <__vector_23>
      60:	e0 c1       	rjmp	.+960    	; 0x422 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 62 17 	jmp	0x2ec4	; 0x2ec4 <__vector_25>
      68:	0c 94 a1 17 	jmp	0x2f42	; 0x2f42 <__vector_26>
      6c:	da c1       	rjmp	.+948    	; 0x422 <__bad_interrupt>
      6e:	00 00       	nop
      70:	d8 c1       	rjmp	.+944    	; 0x422 <__bad_interrupt>
      72:	00 00       	nop
      74:	d6 c1       	rjmp	.+940    	; 0x422 <__bad_interrupt>
      76:	00 00       	nop
      78:	d4 c1       	rjmp	.+936    	; 0x422 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d2 c1       	rjmp	.+932    	; 0x422 <__bad_interrupt>
      7e:	00 00       	nop
      80:	d0 c1       	rjmp	.+928    	; 0x422 <__bad_interrupt>
      82:	00 00       	nop
      84:	ce c1       	rjmp	.+924    	; 0x422 <__bad_interrupt>
      86:	00 00       	nop
      88:	cc c1       	rjmp	.+920    	; 0x422 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	ca c1       	rjmp	.+916    	; 0x422 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 80 0c 	jmp	0x1900	; 0x1900 <__vector_36>
      94:	c6 c1       	rjmp	.+908    	; 0x422 <__bad_interrupt>
      96:	00 00       	nop
      98:	c4 c1       	rjmp	.+904    	; 0x422 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 ce 12 	jmp	0x259c	; 0x259c <__vector_39>
      a0:	c0 c1       	rjmp	.+896    	; 0x422 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	be c1       	rjmp	.+892    	; 0x422 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bc c1       	rjmp	.+888    	; 0x422 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	ba c1       	rjmp	.+884    	; 0x422 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	b8 c1       	rjmp	.+880    	; 0x422 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b6 c1       	rjmp	.+876    	; 0x422 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b4 c1       	rjmp	.+872    	; 0x422 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b2 c1       	rjmp	.+868    	; 0x422 <__bad_interrupt>
      be:	00 00       	nop
      c0:	b0 c1       	rjmp	.+864    	; 0x422 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	ae c1       	rjmp	.+860    	; 0x422 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	ac c1       	rjmp	.+856    	; 0x422 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	aa c1       	rjmp	.+852    	; 0x422 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	a8 c1       	rjmp	.+848    	; 0x422 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	a6 c1       	rjmp	.+844    	; 0x422 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	a4 c1       	rjmp	.+840    	; 0x422 <__bad_interrupt>
      da:	00 00       	nop
      dc:	a2 c1       	rjmp	.+836    	; 0x422 <__bad_interrupt>
      de:	00 00       	nop
      e0:	a0 c1       	rjmp	.+832    	; 0x422 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	d3 13       	cpse	r29, r19
      e6:	d6 13       	cpse	r29, r22
      e8:	d6 13       	cpse	r29, r22
      ea:	d6 13       	cpse	r29, r22
      ec:	d6 13       	cpse	r29, r22
      ee:	d6 13       	cpse	r29, r22
      f0:	d6 13       	cpse	r29, r22
      f2:	d6 13       	cpse	r29, r22
      f4:	ed 12       	cpse	r14, r29
      f6:	d6 13       	cpse	r29, r22
      f8:	d6 13       	cpse	r29, r22
      fa:	d6 13       	cpse	r29, r22
      fc:	d6 13       	cpse	r29, r22
      fe:	d6 13       	cpse	r29, r22
     100:	d6 13       	cpse	r29, r22
     102:	d6 13       	cpse	r29, r22
     104:	ed 12       	cpse	r14, r29
     106:	d6 13       	cpse	r29, r22
     108:	d6 13       	cpse	r29, r22
     10a:	d6 13       	cpse	r29, r22
     10c:	d6 13       	cpse	r29, r22
     10e:	d6 13       	cpse	r29, r22
     110:	d6 13       	cpse	r29, r22
     112:	d6 13       	cpse	r29, r22
     114:	f5 12       	cpse	r15, r21
     116:	d6 13       	cpse	r29, r22
     118:	d6 13       	cpse	r29, r22
     11a:	d6 13       	cpse	r29, r22
     11c:	d6 13       	cpse	r29, r22
     11e:	d6 13       	cpse	r29, r22
     120:	d6 13       	cpse	r29, r22
     122:	d6 13       	cpse	r29, r22
     124:	1a 13       	cpse	r17, r26
     126:	d6 13       	cpse	r29, r22
     128:	d6 13       	cpse	r29, r22
     12a:	d6 13       	cpse	r29, r22
     12c:	d6 13       	cpse	r29, r22
     12e:	d6 13       	cpse	r29, r22
     130:	d6 13       	cpse	r29, r22
     132:	d6 13       	cpse	r29, r22
     134:	f5 12       	cpse	r15, r21
     136:	d6 13       	cpse	r29, r22
     138:	d6 13       	cpse	r29, r22
     13a:	d6 13       	cpse	r29, r22
     13c:	d6 13       	cpse	r29, r22
     13e:	d6 13       	cpse	r29, r22
     140:	d6 13       	cpse	r29, r22
     142:	d6 13       	cpse	r29, r22
     144:	1f 13       	cpse	r17, r31
     146:	d6 13       	cpse	r29, r22
     148:	d6 13       	cpse	r29, r22
     14a:	d6 13       	cpse	r29, r22
     14c:	d6 13       	cpse	r29, r22
     14e:	d6 13       	cpse	r29, r22
     150:	d6 13       	cpse	r29, r22
     152:	d6 13       	cpse	r29, r22
     154:	24 13       	cpse	r18, r20
     156:	d6 13       	cpse	r29, r22
     158:	d6 13       	cpse	r29, r22
     15a:	d6 13       	cpse	r29, r22
     15c:	d6 13       	cpse	r29, r22
     15e:	d6 13       	cpse	r29, r22
     160:	d6 13       	cpse	r29, r22
     162:	d6 13       	cpse	r29, r22
     164:	35 13       	cpse	r19, r21
     166:	d6 13       	cpse	r29, r22
     168:	d6 13       	cpse	r29, r22
     16a:	d6 13       	cpse	r29, r22
     16c:	d6 13       	cpse	r29, r22
     16e:	d6 13       	cpse	r29, r22
     170:	d6 13       	cpse	r29, r22
     172:	d6 13       	cpse	r29, r22
     174:	5e 13       	cpse	r21, r30
     176:	d6 13       	cpse	r29, r22
     178:	d6 13       	cpse	r29, r22
     17a:	d6 13       	cpse	r29, r22
     17c:	d6 13       	cpse	r29, r22
     17e:	d6 13       	cpse	r29, r22
     180:	d6 13       	cpse	r29, r22
     182:	d6 13       	cpse	r29, r22
     184:	29 13       	cpse	r18, r25
     186:	d6 13       	cpse	r29, r22
     188:	d6 13       	cpse	r29, r22
     18a:	d6 13       	cpse	r29, r22
     18c:	d6 13       	cpse	r29, r22
     18e:	d6 13       	cpse	r29, r22
     190:	d6 13       	cpse	r29, r22
     192:	d6 13       	cpse	r29, r22
     194:	43 13       	cpse	r20, r19
     196:	d6 13       	cpse	r29, r22
     198:	d6 13       	cpse	r29, r22
     19a:	d6 13       	cpse	r29, r22
     19c:	d6 13       	cpse	r29, r22
     19e:	d6 13       	cpse	r29, r22
     1a0:	d6 13       	cpse	r29, r22
     1a2:	d6 13       	cpse	r29, r22
     1a4:	60 13       	cpse	r22, r16
     1a6:	d6 13       	cpse	r29, r22
     1a8:	d6 13       	cpse	r29, r22
     1aa:	d6 13       	cpse	r29, r22
     1ac:	d6 13       	cpse	r29, r22
     1ae:	d6 13       	cpse	r29, r22
     1b0:	d6 13       	cpse	r29, r22
     1b2:	d6 13       	cpse	r29, r22
     1b4:	60 13       	cpse	r22, r16
     1b6:	d6 13       	cpse	r29, r22
     1b8:	d6 13       	cpse	r29, r22
     1ba:	d6 13       	cpse	r29, r22
     1bc:	d6 13       	cpse	r29, r22
     1be:	d6 13       	cpse	r29, r22
     1c0:	d6 13       	cpse	r29, r22
     1c2:	d6 13       	cpse	r29, r22
     1c4:	60 13       	cpse	r22, r16
     1c6:	d6 13       	cpse	r29, r22
     1c8:	d6 13       	cpse	r29, r22
     1ca:	d6 13       	cpse	r29, r22
     1cc:	d6 13       	cpse	r29, r22
     1ce:	d6 13       	cpse	r29, r22
     1d0:	d6 13       	cpse	r29, r22
     1d2:	d6 13       	cpse	r29, r22
     1d4:	60 13       	cpse	r22, r16
     1d6:	d6 13       	cpse	r29, r22
     1d8:	d6 13       	cpse	r29, r22
     1da:	d6 13       	cpse	r29, r22
     1dc:	d6 13       	cpse	r29, r22
     1de:	d6 13       	cpse	r29, r22
     1e0:	d6 13       	cpse	r29, r22
     1e2:	d6 13       	cpse	r29, r22
     1e4:	69 13       	cpse	r22, r25
     1e6:	d6 13       	cpse	r29, r22
     1e8:	d6 13       	cpse	r29, r22
     1ea:	d6 13       	cpse	r29, r22
     1ec:	d6 13       	cpse	r29, r22
     1ee:	d6 13       	cpse	r29, r22
     1f0:	d6 13       	cpse	r29, r22
     1f2:	d6 13       	cpse	r29, r22
     1f4:	9a 13       	cpse	r25, r26
     1f6:	d6 13       	cpse	r29, r22
     1f8:	d6 13       	cpse	r29, r22
     1fa:	d6 13       	cpse	r29, r22
     1fc:	d6 13       	cpse	r29, r22
     1fe:	d6 13       	cpse	r29, r22
     200:	d6 13       	cpse	r29, r22
     202:	d6 13       	cpse	r29, r22
     204:	69 13       	cpse	r22, r25
     206:	d6 13       	cpse	r29, r22
     208:	d6 13       	cpse	r29, r22
     20a:	d6 13       	cpse	r29, r22
     20c:	d6 13       	cpse	r29, r22
     20e:	d6 13       	cpse	r29, r22
     210:	d6 13       	cpse	r29, r22
     212:	d6 13       	cpse	r29, r22
     214:	9a 13       	cpse	r25, r26
     216:	d6 13       	cpse	r29, r22
     218:	d6 13       	cpse	r29, r22
     21a:	d6 13       	cpse	r29, r22
     21c:	d6 13       	cpse	r29, r22
     21e:	d6 13       	cpse	r29, r22
     220:	d6 13       	cpse	r29, r22
     222:	d6 13       	cpse	r29, r22
     224:	81 13       	cpse	r24, r17
     226:	d6 13       	cpse	r29, r22
     228:	d6 13       	cpse	r29, r22
     22a:	d6 13       	cpse	r29, r22
     22c:	d6 13       	cpse	r29, r22
     22e:	d6 13       	cpse	r29, r22
     230:	d6 13       	cpse	r29, r22
     232:	d6 13       	cpse	r29, r22
     234:	9e 13       	cpse	r25, r30
     236:	d6 13       	cpse	r29, r22
     238:	d6 13       	cpse	r29, r22
     23a:	d6 13       	cpse	r29, r22
     23c:	d6 13       	cpse	r29, r22
     23e:	d6 13       	cpse	r29, r22
     240:	d6 13       	cpse	r29, r22
     242:	d6 13       	cpse	r29, r22
     244:	9e 13       	cpse	r25, r30
     246:	d6 13       	cpse	r29, r22
     248:	d6 13       	cpse	r29, r22
     24a:	d6 13       	cpse	r29, r22
     24c:	d6 13       	cpse	r29, r22
     24e:	d6 13       	cpse	r29, r22
     250:	d6 13       	cpse	r29, r22
     252:	d6 13       	cpse	r29, r22
     254:	b3 13       	cpse	r27, r19
     256:	d6 13       	cpse	r29, r22
     258:	d6 13       	cpse	r29, r22
     25a:	d6 13       	cpse	r29, r22
     25c:	d6 13       	cpse	r29, r22
     25e:	d6 13       	cpse	r29, r22
     260:	d6 13       	cpse	r29, r22
     262:	d6 13       	cpse	r29, r22
     264:	cd 13       	cpse	r28, r29
     266:	d6 13       	cpse	r29, r22
     268:	d6 13       	cpse	r29, r22
     26a:	d6 13       	cpse	r29, r22
     26c:	d6 13       	cpse	r29, r22
     26e:	d6 13       	cpse	r29, r22
     270:	d6 13       	cpse	r29, r22
     272:	d6 13       	cpse	r29, r22
     274:	cd 13       	cpse	r28, r29
     276:	dc 19       	sub	r29, r12
     278:	e0 19       	sub	r30, r0
     27a:	ca 19       	sub	r28, r10
     27c:	d0 19       	sub	r29, r0
     27e:	d6 19       	sub	r29, r6
     280:	25 1a       	sub	r2, r21
     282:	e4 19       	sub	r30, r4
     284:	ea 19       	sub	r30, r10
     286:	f0 19       	sub	r31, r0
     288:	f6 19       	sub	r31, r6
     28a:	fc 19       	sub	r31, r12
     28c:	02 1a       	sub	r0, r18
     28e:	08 1a       	sub	r0, r24
     290:	0e 1a       	sub	r0, r30
     292:	25 1a       	sub	r2, r21
     294:	14 1a       	sub	r1, r20
     296:	1a 1a       	sub	r1, r26
     298:	20 1a       	sub	r2, r16

0000029a <__trampolines_end>:
     29a:	00 00       	nop
     29c:	0a 0b       	sbc	r16, r26
     29e:	02 09       	sbc	r16, r2
     2a0:	0c 0d       	add	r16, r12
     2a2:	0e 08       	sbc	r0, r14
     2a4:	07 03       	mulsu	r16, r23
     2a6:	04 01       	movw	r0, r8
	...
     2c4:	00 00       	nop
     2c6:	12 11       	cpse	r17, r2
     2c8:	10 00       	.word	0x0010	; ????
	...

000002e0 <digital_pin_to_bit_mask_PGM>:
     2e0:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     2f0:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     300:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     310:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     320:	04 08 10 20 40 80                                   ... @.

00000326 <digital_pin_to_port_PGM>:
     326:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     336:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     346:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     356:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     366:	0b 0b 0b 0b 0b 0b                                   ......

0000036c <port_to_input_PGM>:
     36c:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     37c:	00 01 00 00 03 01 06 01 09 01                       ..........

00000386 <port_to_output_PGM>:
     386:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     396:	02 01 00 00 05 01 08 01 0b 01                       ..........

000003a0 <port_to_mode_PGM>:
     3a0:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     3b0:	01 01 00 00 04 01 07 01 0a 01                       ..........

000003ba <__ctors_start>:
     3ba:	6c 0d       	add	r22, r12
     3bc:	bb 14       	cp	r11, r11
     3be:	ca 17       	cp	r28, r26

000003c0 <__ctors_end>:
     3c0:	11 24       	eor	r1, r1
     3c2:	1f be       	out	0x3f, r1	; 63
     3c4:	cf ef       	ldi	r28, 0xFF	; 255
     3c6:	d1 e2       	ldi	r29, 0x21	; 33
     3c8:	de bf       	out	0x3e, r29	; 62
     3ca:	cd bf       	out	0x3d, r28	; 61
     3cc:	00 e0       	ldi	r16, 0x00	; 0
     3ce:	0c bf       	out	0x3c, r16	; 60

000003d0 <__do_copy_data>:
     3d0:	12 e0       	ldi	r17, 0x02	; 2
     3d2:	a0 e0       	ldi	r26, 0x00	; 0
     3d4:	b2 e0       	ldi	r27, 0x02	; 2
     3d6:	e4 ef       	ldi	r30, 0xF4	; 244
     3d8:	f5 e3       	ldi	r31, 0x35	; 53
     3da:	00 e0       	ldi	r16, 0x00	; 0
     3dc:	0b bf       	out	0x3b, r16	; 59
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <__do_copy_data+0x14>
     3e0:	07 90       	elpm	r0, Z+
     3e2:	0d 92       	st	X+, r0
     3e4:	ac 37       	cpi	r26, 0x7C	; 124
     3e6:	b1 07       	cpc	r27, r17
     3e8:	d9 f7       	brne	.-10     	; 0x3e0 <__do_copy_data+0x10>

000003ea <__do_clear_bss>:
     3ea:	2a e0       	ldi	r18, 0x0A	; 10
     3ec:	ac e7       	ldi	r26, 0x7C	; 124
     3ee:	b2 e0       	ldi	r27, 0x02	; 2
     3f0:	01 c0       	rjmp	.+2      	; 0x3f4 <.do_clear_bss_start>

000003f2 <.do_clear_bss_loop>:
     3f2:	1d 92       	st	X+, r1

000003f4 <.do_clear_bss_start>:
     3f4:	a5 36       	cpi	r26, 0x65	; 101
     3f6:	b2 07       	cpc	r27, r18
     3f8:	e1 f7       	brne	.-8      	; 0x3f2 <.do_clear_bss_loop>

000003fa <__do_global_ctors>:
     3fa:	13 e0       	ldi	r17, 0x03	; 3
     3fc:	c0 ec       	ldi	r28, 0xC0	; 192
     3fe:	d3 e0       	ldi	r29, 0x03	; 3
     400:	00 e0       	ldi	r16, 0x00	; 0
     402:	06 c0       	rjmp	.+12     	; 0x410 <__do_global_ctors+0x16>
     404:	22 97       	sbiw	r28, 0x02	; 2
     406:	01 09       	sbc	r16, r1
     408:	fe 01       	movw	r30, r28
     40a:	0b bf       	out	0x3b, r16	; 59
     40c:	0e 94 eb 1a 	call	0x35d6	; 0x35d6 <__tablejump_elpm__>
     410:	ca 3b       	cpi	r28, 0xBA	; 186
     412:	d1 07       	cpc	r29, r17
     414:	80 e0       	ldi	r24, 0x00	; 0
     416:	08 07       	cpc	r16, r24
     418:	a9 f7       	brne	.-22     	; 0x404 <__do_global_ctors+0xa>
     41a:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <main>
     41e:	0c 94 f8 1a 	jmp	0x35f0	; 0x35f0 <_exit>

00000422 <__bad_interrupt>:
     422:	ee cd       	rjmp	.-1060   	; 0x0 <__vectors>

00000424 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     424:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     426:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     428:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     42a:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     42c:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     42e:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     430:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     432:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     434:	05 c0       	rjmp	.+10     	; 0x440 <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     436:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     438:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     43a:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     43c:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     43e:	61 f1       	breq	.+88     	; 0x498 <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     440:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     442:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     444:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     446:	b9 f3       	breq	.-18     	; 0x436 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     448:	05 c0       	rjmp	.+10     	; 0x454 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     44a:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     44c:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     44e:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     450:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     452:	11 f1       	breq	.+68     	; 0x498 <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     454:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     456:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     458:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     45a:	f7 cf       	rjmp	.-18     	; 0x44a <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     45c:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     45e:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     460:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     462:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     464:	0a c0       	rjmp	.+20     	; 0x47a <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     466:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     468:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     46a:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     46c:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     46e:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     470:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     472:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     474:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     476:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     478:	79 f0       	breq	.+30     	; 0x498 <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     47a:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     47c:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     47e:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     480:	91 f3       	breq	.-28     	; 0x466 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     482:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     484:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     486:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     488:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     48a:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     48c:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     48e:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     490:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     492:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     494:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     496:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     498:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     49a:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     49c:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     49e:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     4a0:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     4a2:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     4a4:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     4a6:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     4a8:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     4aa:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     4ac:	08 95       	ret

000004ae <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4ae:	cf 93       	push	r28
     4b0:	df 93       	push	r29
     4b2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4b4:	0e 94 35 0f 	call	0x1e6a	; 0x1e6a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     4b8:	80 91 7c 02 	lds	r24, 0x027C
     4bc:	90 91 7d 02 	lds	r25, 0x027D
     4c0:	89 2b       	or	r24, r25
     4c2:	31 f4       	brne	.+12     	; 0x4d0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     4c4:	81 e8       	ldi	r24, 0x81	; 129
     4c6:	92 e0       	ldi	r25, 0x02	; 2
     4c8:	90 93 7d 02 	sts	0x027D, r25
     4cc:	80 93 7c 02 	sts	0x027C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     4d0:	40 91 7e 02 	lds	r20, 0x027E
     4d4:	50 91 7f 02 	lds	r21, 0x027F
     4d8:	9e 01       	movw	r18, r28
     4da:	24 0f       	add	r18, r20
     4dc:	35 1f       	adc	r19, r21
     4de:	2b 3d       	cpi	r18, 0xDB	; 219
     4e0:	85 e0       	ldi	r24, 0x05	; 5
     4e2:	38 07       	cpc	r19, r24
     4e4:	70 f4       	brcc	.+28     	; 0x502 <pvPortMalloc+0x54>
     4e6:	42 17       	cp	r20, r18
     4e8:	53 07       	cpc	r21, r19
     4ea:	70 f4       	brcc	.+28     	; 0x508 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     4ec:	c0 91 7c 02 	lds	r28, 0x027C
     4f0:	d0 91 7d 02 	lds	r29, 0x027D
     4f4:	c4 0f       	add	r28, r20
     4f6:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     4f8:	30 93 7f 02 	sts	0x027F, r19
     4fc:	20 93 7e 02 	sts	0x027E, r18
     500:	05 c0       	rjmp	.+10     	; 0x50c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     502:	c0 e0       	ldi	r28, 0x00	; 0
     504:	d0 e0       	ldi	r29, 0x00	; 0
     506:	02 c0       	rjmp	.+4      	; 0x50c <pvPortMalloc+0x5e>
     508:	c0 e0       	ldi	r28, 0x00	; 0
     50a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     50c:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     510:	ce 01       	movw	r24, r28
     512:	df 91       	pop	r29
     514:	cf 91       	pop	r28
     516:	08 95       	ret

00000518 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     518:	08 95       	ret

0000051a <_ZN3L3GC1Ev>:
  Wire.requestFrom(address, (byte)1);
  value = Wire.read();
  Wire.endTransmission();

  return value;
}
     51a:	fc 01       	movw	r30, r24
     51c:	83 e0       	ldi	r24, 0x03	; 3
     51e:	87 83       	std	Z+7, r24	; 0x07
     520:	12 86       	std	Z+10, r1	; 0x0a
     522:	11 86       	std	Z+9, r1	; 0x09
     524:	13 86       	std	Z+11, r1	; 0x0b
     526:	08 95       	ret

00000528 <_ZN3L3G8writeRegEhh>:
     528:	0f 93       	push	r16
     52a:	1f 93       	push	r17
     52c:	cf 93       	push	r28
     52e:	df 93       	push	r29
     530:	ec 01       	movw	r28, r24
     532:	06 2f       	mov	r16, r22
     534:	14 2f       	mov	r17, r20
     536:	68 85       	ldd	r22, Y+8	; 0x08
     538:	8d e6       	ldi	r24, 0x6D	; 109
     53a:	99 e0       	ldi	r25, 0x09	; 9
     53c:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
     540:	60 2f       	mov	r22, r16
     542:	8d e6       	ldi	r24, 0x6D	; 109
     544:	99 e0       	ldi	r25, 0x09	; 9
     546:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
     54a:	61 2f       	mov	r22, r17
     54c:	8d e6       	ldi	r24, 0x6D	; 109
     54e:	99 e0       	ldi	r25, 0x09	; 9
     550:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
     554:	8d e6       	ldi	r24, 0x6D	; 109
     556:	99 e0       	ldi	r25, 0x09	; 9
     558:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     55c:	8e 83       	std	Y+6, r24	; 0x06
     55e:	df 91       	pop	r29
     560:	cf 91       	pop	r28
     562:	1f 91       	pop	r17
     564:	0f 91       	pop	r16
     566:	08 95       	ret

00000568 <_ZN3L3G13enableDefaultEv>:
     568:	cf 93       	push	r28
     56a:	df 93       	push	r29
     56c:	ec 01       	movw	r28, r24
     56e:	8f 81       	ldd	r24, Y+7	; 0x07
     570:	82 30       	cpi	r24, 0x02	; 2
     572:	21 f4       	brne	.+8      	; 0x57c <_ZN3L3G13enableDefaultEv+0x14>
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	69 e3       	ldi	r22, 0x39	; 57
     578:	ce 01       	movw	r24, r28
     57a:	d6 df       	rcall	.-84     	; 0x528 <_ZN3L3G8writeRegEhh>
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	63 e2       	ldi	r22, 0x23	; 35
     580:	ce 01       	movw	r24, r28
     582:	d2 df       	rcall	.-92     	; 0x528 <_ZN3L3G8writeRegEhh>
     584:	4f e6       	ldi	r20, 0x6F	; 111
     586:	60 e2       	ldi	r22, 0x20	; 32
     588:	ce 01       	movw	r24, r28
     58a:	ce df       	rcall	.-100    	; 0x528 <_ZN3L3G8writeRegEhh>
     58c:	df 91       	pop	r29
     58e:	cf 91       	pop	r28
     590:	08 95       	ret

00000592 <_ZN3L3G4readEv>:

// Reads the 3 gyro channels and stores them in vector g
void L3G::read()
{
     592:	9f 92       	push	r9
     594:	af 92       	push	r10
     596:	bf 92       	push	r11
     598:	cf 92       	push	r12
     59a:	df 92       	push	r13
     59c:	ef 92       	push	r14
     59e:	ff 92       	push	r15
     5a0:	0f 93       	push	r16
     5a2:	1f 93       	push	r17
     5a4:	cf 93       	push	r28
     5a6:	df 93       	push	r29
     5a8:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     5aa:	68 85       	ldd	r22, Y+8	; 0x08
     5ac:	8d e6       	ldi	r24, 0x6D	; 109
     5ae:	99 e0       	ldi	r25, 0x09	; 9
     5b0:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     5b4:	e0 91 6d 09 	lds	r30, 0x096D
     5b8:	f0 91 6e 09 	lds	r31, 0x096E
     5bc:	01 90       	ld	r0, Z+
     5be:	f0 81       	ld	r31, Z
     5c0:	e0 2d       	mov	r30, r0
     5c2:	68 ea       	ldi	r22, 0xA8	; 168
     5c4:	8d e6       	ldi	r24, 0x6D	; 109
     5c6:	99 e0       	ldi	r25, 0x09	; 9
     5c8:	19 95       	eicall
  // assert the MSB of the address to get the gyro
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
     5ca:	8d e6       	ldi	r24, 0x6D	; 109
     5cc:	99 e0       	ldi	r25, 0x09	; 9
     5ce:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)6);
     5d2:	46 e0       	ldi	r20, 0x06	; 6
     5d4:	68 85       	ldd	r22, Y+8	; 0x08
     5d6:	8d e6       	ldi	r24, 0x6D	; 109
     5d8:	99 e0       	ldi	r25, 0x09	; 9
     5da:	0e 94 99 14 	call	0x2932	; 0x2932 <_ZN7TwoWire11requestFromEhh>
  
  unsigned int millis_start = millis();
     5de:	0e 94 47 19 	call	0x328e	; 0x328e <millis>
     5e2:	8b 01       	movw	r16, r22
  while (Wire.available() < 6)
     5e4:	10 c0       	rjmp	.+32     	; 0x606 <_ZN3L3G4readEv+0x74>
  {
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     5e6:	89 85       	ldd	r24, Y+9	; 0x09
     5e8:	9a 85       	ldd	r25, Y+10	; 0x0a
     5ea:	89 2b       	or	r24, r25
     5ec:	61 f0       	breq	.+24     	; 0x606 <_ZN3L3G4readEv+0x74>
     5ee:	0e 94 47 19 	call	0x328e	; 0x328e <millis>
     5f2:	60 1b       	sub	r22, r16
     5f4:	71 0b       	sbc	r23, r17
     5f6:	89 85       	ldd	r24, Y+9	; 0x09
     5f8:	9a 85       	ldd	r25, Y+10	; 0x0a
     5fa:	86 17       	cp	r24, r22
     5fc:	97 07       	cpc	r25, r23
     5fe:	18 f4       	brcc	.+6      	; 0x606 <_ZN3L3G4readEv+0x74>
    {
      did_timeout = true;
     600:	81 e0       	ldi	r24, 0x01	; 1
     602:	8b 87       	std	Y+11, r24	; 0x0b
      return;
     604:	32 c0       	rjmp	.+100    	; 0x66a <_ZN3L3G4readEv+0xd8>
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
  Wire.requestFrom(address, (byte)6);
  
  unsigned int millis_start = millis();
  while (Wire.available() < 6)
     606:	8d e6       	ldi	r24, 0x6D	; 109
     608:	99 e0       	ldi	r25, 0x09	; 9
     60a:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <_ZN7TwoWire9availableEv>
     60e:	06 97       	sbiw	r24, 0x06	; 6
     610:	54 f3       	brlt	.-44     	; 0x5e6 <_ZN3L3G4readEv+0x54>
      did_timeout = true;
      return;
    }
  }

  uint8_t xlg = Wire.read();
     612:	8d e6       	ldi	r24, 0x6D	; 109
     614:	99 e0       	ldi	r25, 0x09	; 9
     616:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     61a:	a8 2e       	mov	r10, r24
  uint8_t xhg = Wire.read();
     61c:	8d e6       	ldi	r24, 0x6D	; 109
     61e:	99 e0       	ldi	r25, 0x09	; 9
     620:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     624:	98 2e       	mov	r9, r24
  uint8_t ylg = Wire.read();
     626:	8d e6       	ldi	r24, 0x6D	; 109
     628:	99 e0       	ldi	r25, 0x09	; 9
     62a:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     62e:	08 2f       	mov	r16, r24
  uint8_t yhg = Wire.read();
     630:	8d e6       	ldi	r24, 0x6D	; 109
     632:	99 e0       	ldi	r25, 0x09	; 9
     634:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     638:	b8 2e       	mov	r11, r24
  uint8_t zlg = Wire.read();
     63a:	8d e6       	ldi	r24, 0x6D	; 109
     63c:	99 e0       	ldi	r25, 0x09	; 9
     63e:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     642:	18 2f       	mov	r17, r24
  uint8_t zhg = Wire.read();
     644:	8d e6       	ldi	r24, 0x6D	; 109
     646:	99 e0       	ldi	r25, 0x09	; 9
     648:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
     64c:	d9 2c       	mov	r13, r9
     64e:	c1 2c       	mov	r12, r1
     650:	ca 28       	or	r12, r10
     652:	d9 82       	std	Y+1, r13	; 0x01
     654:	c8 82       	st	Y, r12
  g.y = (int16_t)(yhg << 8 | ylg);
     656:	fb 2c       	mov	r15, r11
     658:	e1 2c       	mov	r14, r1
     65a:	e0 2a       	or	r14, r16
     65c:	fb 82       	std	Y+3, r15	; 0x03
     65e:	ea 82       	std	Y+2, r14	; 0x02
  g.z = (int16_t)(zhg << 8 | zlg);
     660:	98 2f       	mov	r25, r24
     662:	88 27       	eor	r24, r24
     664:	81 2b       	or	r24, r17
     666:	9d 83       	std	Y+5, r25	; 0x05
     668:	8c 83       	std	Y+4, r24	; 0x04
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	1f 91       	pop	r17
     670:	0f 91       	pop	r16
     672:	ff 90       	pop	r15
     674:	ef 90       	pop	r14
     676:	df 90       	pop	r13
     678:	cf 90       	pop	r12
     67a:	bf 90       	pop	r11
     67c:	af 90       	pop	r10
     67e:	9f 90       	pop	r9
     680:	08 95       	ret

00000682 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     682:	cf 93       	push	r28
     684:	df 93       	push	r29
     686:	c6 2f       	mov	r28, r22
     688:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     68a:	8d e6       	ldi	r24, 0x6D	; 109
     68c:	99 e0       	ldi	r25, 0x09	; 9
     68e:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     692:	6d 2f       	mov	r22, r29
     694:	8d e6       	ldi	r24, 0x6D	; 109
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     69c:	8d e6       	ldi	r24, 0x6D	; 109
     69e:	99 e0       	ldi	r25, 0x09	; 9
     6a0:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     6a4:	81 11       	cpse	r24, r1
     6a6:	11 c0       	rjmp	.+34     	; 0x6ca <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     6a8:	41 e0       	ldi	r20, 0x01	; 1
     6aa:	6c 2f       	mov	r22, r28
     6ac:	8d e6       	ldi	r24, 0x6D	; 109
     6ae:	99 e0       	ldi	r25, 0x09	; 9
     6b0:	0e 94 99 14 	call	0x2932	; 0x2932 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     6b4:	8d e6       	ldi	r24, 0x6D	; 109
     6b6:	99 e0       	ldi	r25, 0x09	; 9
     6b8:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <_ZN7TwoWire9availableEv>
     6bc:	89 2b       	or	r24, r25
     6be:	41 f0       	breq	.+16     	; 0x6d0 <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     6c0:	8d e6       	ldi	r24, 0x6D	; 109
     6c2:	99 e0       	ldi	r25, 0x09	; 9
     6c4:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     6c8:	05 c0       	rjmp	.+10     	; 0x6d4 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     6ca:	8f ef       	ldi	r24, 0xFF	; 255
     6cc:	9f ef       	ldi	r25, 0xFF	; 255
     6ce:	02 c0       	rjmp	.+4      	; 0x6d4 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	08 95       	ret

000006da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     6da:	0f 93       	push	r16
     6dc:	1f 93       	push	r17
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	ec 01       	movw	r28, r24
     6e4:	16 2f       	mov	r17, r22
     6e6:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     6e8:	63 30       	cpi	r22, 0x03	; 3
     6ea:	09 f4       	brne	.+2      	; 0x6ee <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     6ec:	56 c0       	rjmp	.+172    	; 0x79a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     6ee:	42 30       	cpi	r20, 0x02	; 2
     6f0:	c9 f5       	brne	.+114    	; 0x764 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     6f2:	56 c0       	rjmp	.+172    	; 0x7a0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     6f4:	13 30       	cpi	r17, 0x03	; 3
     6f6:	09 f0       	breq	.+2      	; 0x6fa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     6f8:	58 c0       	rjmp	.+176    	; 0x7aa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     6fa:	87 3d       	cpi	r24, 0xD7	; 215
     6fc:	91 05       	cpc	r25, r1
     6fe:	09 f4       	brne	.+2      	; 0x702 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     700:	58 c0       	rjmp	.+176    	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     702:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     704:	11 e0       	ldi	r17, 0x01	; 1
     706:	2c c0       	rjmp	.+88     	; 0x760 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     708:	01 30       	cpi	r16, 0x01	; 1
     70a:	91 f0       	breq	.+36     	; 0x730 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     70c:	4f e0       	ldi	r20, 0x0F	; 15
     70e:	6a e6       	ldi	r22, 0x6A	; 106
     710:	ce 01       	movw	r24, r28
     712:	b7 df       	rcall	.-146    	; 0x682 <_ZN3L3G7testRegEhNS_7regAddrE>
     714:	8f 3f       	cpi	r24, 0xFF	; 255
     716:	2f ef       	ldi	r18, 0xFF	; 255
     718:	92 07       	cpc	r25, r18
     71a:	51 f0       	breq	.+20     	; 0x730 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     71c:	13 30       	cpi	r17, 0x03	; 3
     71e:	09 f0       	breq	.+2      	; 0x722 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     720:	46 c0       	rjmp	.+140    	; 0x7ae <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     722:	87 3d       	cpi	r24, 0xD7	; 215
     724:	91 05       	cpc	r25, r1
     726:	09 f0       	breq	.+2      	; 0x72a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     728:	47 c0       	rjmp	.+142    	; 0x7b8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     72a:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     72c:	12 e0       	ldi	r17, 0x02	; 2
     72e:	18 c0       	rjmp	.+48     	; 0x760 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     730:	13 30       	cpi	r17, 0x03	; 3
     732:	11 f0       	breq	.+4      	; 0x738 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     734:	11 11       	cpse	r17, r1
     736:	14 c0       	rjmp	.+40     	; 0x760 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     738:	00 23       	and	r16, r16
     73a:	49 f0       	breq	.+18     	; 0x74e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     73c:	4f e0       	ldi	r20, 0x0F	; 15
     73e:	69 e6       	ldi	r22, 0x69	; 105
     740:	ce 01       	movw	r24, r28
     742:	9f df       	rcall	.-194    	; 0x682 <_ZN3L3G7testRegEhNS_7regAddrE>
     744:	83 3d       	cpi	r24, 0xD3	; 211
     746:	91 05       	cpc	r25, r1
     748:	d1 f1       	breq	.+116    	; 0x7be <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     74a:	01 30       	cpi	r16, 0x01	; 1
     74c:	39 f0       	breq	.+14     	; 0x75c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     74e:	4f e0       	ldi	r20, 0x0F	; 15
     750:	68 e6       	ldi	r22, 0x68	; 104
     752:	ce 01       	movw	r24, r28
     754:	96 df       	rcall	.-212    	; 0x682 <_ZN3L3G7testRegEhNS_7regAddrE>
     756:	83 3d       	cpi	r24, 0xD3	; 211
     758:	91 05       	cpc	r25, r1
     75a:	99 f1       	breq	.+102    	; 0x7c2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     75c:	13 30       	cpi	r17, 0x03	; 3
     75e:	b9 f0       	breq	.+46     	; 0x78e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     760:	02 30       	cpi	r16, 0x02	; 2
     762:	b9 f0       	breq	.+46     	; 0x792 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     764:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     766:	11 23       	and	r17, r17
     768:	51 f0       	breq	.+20     	; 0x77e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     76a:	13 30       	cpi	r17, 0x03	; 3
     76c:	a0 f4       	brcc	.+40     	; 0x796 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     76e:	01 30       	cpi	r16, 0x01	; 1
     770:	11 f4       	brne	.+4      	; 0x776 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     772:	8b e6       	ldi	r24, 0x6B	; 107
     774:	01 c0       	rjmp	.+2      	; 0x778 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     776:	8a e6       	ldi	r24, 0x6A	; 106
     778:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     77a:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     77c:	41 c0       	rjmp	.+130    	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     77e:	01 30       	cpi	r16, 0x01	; 1
     780:	11 f4       	brne	.+4      	; 0x786 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     782:	89 e6       	ldi	r24, 0x69	; 105
     784:	01 c0       	rjmp	.+2      	; 0x788 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     786:	88 e6       	ldi	r24, 0x68	; 104
     788:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     78a:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     78c:	39 c0       	rjmp	.+114    	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     78e:	80 e0       	ldi	r24, 0x00	; 0
     790:	37 c0       	rjmp	.+110    	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     792:	80 e0       	ldi	r24, 0x00	; 0
     794:	35 c0       	rjmp	.+106    	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	33 c0       	rjmp	.+102    	; 0x800 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     79a:	44 23       	and	r20, r20
     79c:	41 f1       	breq	.+80     	; 0x7ee <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     79e:	1e c0       	rjmp	.+60     	; 0x7dc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     7a0:	8f ef       	ldi	r24, 0xFF	; 255
     7a2:	86 0f       	add	r24, r22
     7a4:	83 30       	cpi	r24, 0x03	; 3
     7a6:	30 f6       	brcc	.-116    	; 0x734 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     7a8:	0f c0       	rjmp	.+30     	; 0x7c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7aa:	01 e0       	ldi	r16, 0x01	; 1
     7ac:	c3 cf       	rjmp	.-122    	; 0x734 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7ae:	00 e0       	ldi	r16, 0x00	; 0
     7b0:	c1 cf       	rjmp	.-126    	; 0x734 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7b2:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7b4:	12 e0       	ldi	r17, 0x02	; 2
     7b6:	d4 cf       	rjmp	.-88     	; 0x760 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7b8:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7ba:	11 e0       	ldi	r17, 0x01	; 1
     7bc:	d1 cf       	rjmp	.-94     	; 0x760 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     7be:	01 e0       	ldi	r16, 0x01	; 1
     7c0:	01 c0       	rjmp	.+2      	; 0x7c4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     7c2:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     7c4:	1f 82       	std	Y+7, r1	; 0x07
     7c6:	db cf       	rjmp	.-74     	; 0x77e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7c8:	4f e0       	ldi	r20, 0x0F	; 15
     7ca:	6b e6       	ldi	r22, 0x6B	; 107
     7cc:	ce 01       	movw	r24, r28
     7ce:	59 df       	rcall	.-334    	; 0x682 <_ZN3L3G7testRegEhNS_7regAddrE>
     7d0:	8f 3f       	cpi	r24, 0xFF	; 255
     7d2:	2f ef       	ldi	r18, 0xFF	; 255
     7d4:	92 07       	cpc	r25, r18
     7d6:	09 f0       	breq	.+2      	; 0x7da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     7d8:	8d cf       	rjmp	.-230    	; 0x6f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     7da:	98 cf       	rjmp	.-208    	; 0x70c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     7dc:	4f e0       	ldi	r20, 0x0F	; 15
     7de:	6b e6       	ldi	r22, 0x6B	; 107
     7e0:	50 df       	rcall	.-352    	; 0x682 <_ZN3L3G7testRegEhNS_7regAddrE>
     7e2:	8f 3f       	cpi	r24, 0xFF	; 255
     7e4:	2f ef       	ldi	r18, 0xFF	; 255
     7e6:	92 07       	cpc	r25, r18
     7e8:	09 f0       	breq	.+2      	; 0x7ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     7ea:	87 cf       	rjmp	.-242    	; 0x6fa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     7ec:	8d cf       	rjmp	.-230    	; 0x708 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7ee:	4f e0       	ldi	r20, 0x0F	; 15
     7f0:	6a e6       	ldi	r22, 0x6A	; 106
     7f2:	47 df       	rcall	.-370    	; 0x682 <_ZN3L3G7testRegEhNS_7regAddrE>
     7f4:	8f 3f       	cpi	r24, 0xFF	; 255
     7f6:	2f ef       	ldi	r18, 0xFF	; 255
     7f8:	92 07       	cpc	r25, r18
     7fa:	09 f0       	breq	.+2      	; 0x7fe <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     7fc:	92 cf       	rjmp	.-220    	; 0x722 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     7fe:	98 cf       	rjmp	.-208    	; 0x730 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     800:	df 91       	pop	r29
     802:	cf 91       	pop	r28
     804:	1f 91       	pop	r17
     806:	0f 91       	pop	r16
     808:	08 95       	ret

0000080a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     80a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     80c:	03 96       	adiw	r24, 0x03	; 3
     80e:	92 83       	std	Z+2, r25	; 0x02
     810:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     812:	2f ef       	ldi	r18, 0xFF	; 255
     814:	3f ef       	ldi	r19, 0xFF	; 255
     816:	34 83       	std	Z+4, r19	; 0x04
     818:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     81a:	96 83       	std	Z+6, r25	; 0x06
     81c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     81e:	90 87       	std	Z+8, r25	; 0x08
     820:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     822:	10 82       	st	Z, r1
     824:	08 95       	ret

00000826 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     826:	fc 01       	movw	r30, r24
     828:	11 86       	std	Z+9, r1	; 0x09
     82a:	10 86       	std	Z+8, r1	; 0x08
     82c:	08 95       	ret

0000082e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	9c 01       	movw	r18, r24
     834:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     836:	dc 01       	movw	r26, r24
     838:	11 96       	adiw	r26, 0x01	; 1
     83a:	cd 91       	ld	r28, X+
     83c:	dc 91       	ld	r29, X
     83e:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     840:	d3 83       	std	Z+3, r29	; 0x03
     842:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     844:	8c 81       	ldd	r24, Y+4	; 0x04
     846:	9d 81       	ldd	r25, Y+5	; 0x05
     848:	95 83       	std	Z+5, r25	; 0x05
     84a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     84c:	8c 81       	ldd	r24, Y+4	; 0x04
     84e:	9d 81       	ldd	r25, Y+5	; 0x05
     850:	dc 01       	movw	r26, r24
     852:	13 96       	adiw	r26, 0x03	; 3
     854:	7c 93       	st	X, r23
     856:	6e 93       	st	-X, r22
     858:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     85a:	7d 83       	std	Y+5, r23	; 0x05
     85c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     85e:	31 87       	std	Z+9, r19	; 0x09
     860:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     862:	f9 01       	movw	r30, r18
     864:	80 81       	ld	r24, Z
     866:	8f 5f       	subi	r24, 0xFF	; 255
     868:	80 83       	st	Z, r24
}
     86a:	df 91       	pop	r29
     86c:	cf 91       	pop	r28
     86e:	08 95       	ret

00000870 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     870:	cf 93       	push	r28
     872:	df 93       	push	r29
     874:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     876:	48 81       	ld	r20, Y
     878:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     87a:	4f 3f       	cpi	r20, 0xFF	; 255
     87c:	2f ef       	ldi	r18, 0xFF	; 255
     87e:	52 07       	cpc	r21, r18
     880:	21 f4       	brne	.+8      	; 0x88a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     882:	fc 01       	movw	r30, r24
     884:	a7 81       	ldd	r26, Z+7	; 0x07
     886:	b0 85       	ldd	r27, Z+8	; 0x08
     888:	0d c0       	rjmp	.+26     	; 0x8a4 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     88a:	dc 01       	movw	r26, r24
     88c:	13 96       	adiw	r26, 0x03	; 3
     88e:	12 96       	adiw	r26, 0x02	; 2
     890:	ed 91       	ld	r30, X+
     892:	fc 91       	ld	r31, X
     894:	13 97       	sbiw	r26, 0x03	; 3
     896:	20 81       	ld	r18, Z
     898:	31 81       	ldd	r19, Z+1	; 0x01
     89a:	42 17       	cp	r20, r18
     89c:	53 07       	cpc	r21, r19
     89e:	10 f0       	brcs	.+4      	; 0x8a4 <vListInsert+0x34>
     8a0:	df 01       	movw	r26, r30
     8a2:	f5 cf       	rjmp	.-22     	; 0x88e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8a4:	12 96       	adiw	r26, 0x02	; 2
     8a6:	ed 91       	ld	r30, X+
     8a8:	fc 91       	ld	r31, X
     8aa:	13 97       	sbiw	r26, 0x03	; 3
     8ac:	fb 83       	std	Y+3, r31	; 0x03
     8ae:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8b0:	d5 83       	std	Z+5, r29	; 0x05
     8b2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8b4:	bd 83       	std	Y+5, r27	; 0x05
     8b6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8b8:	13 96       	adiw	r26, 0x03	; 3
     8ba:	dc 93       	st	X, r29
     8bc:	ce 93       	st	-X, r28
     8be:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8c0:	99 87       	std	Y+9, r25	; 0x09
     8c2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8c4:	fc 01       	movw	r30, r24
     8c6:	20 81       	ld	r18, Z
     8c8:	2f 5f       	subi	r18, 0xFF	; 255
     8ca:	20 83       	st	Z, r18
}
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
     8d0:	08 95       	ret

000008d2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8d8:	a0 85       	ldd	r26, Z+8	; 0x08
     8da:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8dc:	c2 81       	ldd	r28, Z+2	; 0x02
     8de:	d3 81       	ldd	r29, Z+3	; 0x03
     8e0:	84 81       	ldd	r24, Z+4	; 0x04
     8e2:	95 81       	ldd	r25, Z+5	; 0x05
     8e4:	9d 83       	std	Y+5, r25	; 0x05
     8e6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8e8:	c4 81       	ldd	r28, Z+4	; 0x04
     8ea:	d5 81       	ldd	r29, Z+5	; 0x05
     8ec:	82 81       	ldd	r24, Z+2	; 0x02
     8ee:	93 81       	ldd	r25, Z+3	; 0x03
     8f0:	9b 83       	std	Y+3, r25	; 0x03
     8f2:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8f4:	11 96       	adiw	r26, 0x01	; 1
     8f6:	cd 91       	ld	r28, X+
     8f8:	dc 91       	ld	r29, X
     8fa:	12 97       	sbiw	r26, 0x02	; 2
     8fc:	ce 17       	cp	r28, r30
     8fe:	df 07       	cpc	r29, r31
     900:	31 f4       	brne	.+12     	; 0x90e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     902:	8c 81       	ldd	r24, Y+4	; 0x04
     904:	9d 81       	ldd	r25, Y+5	; 0x05
     906:	12 96       	adiw	r26, 0x02	; 2
     908:	9c 93       	st	X, r25
     90a:	8e 93       	st	-X, r24
     90c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     90e:	11 86       	std	Z+9, r1	; 0x09
     910:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     912:	8c 91       	ld	r24, X
     914:	81 50       	subi	r24, 0x01	; 1
     916:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     918:	df 91       	pop	r29
     91a:	cf 91       	pop	r28
     91c:	08 95       	ret

0000091e <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29
     922:	ec 01       	movw	r28, r24
     924:	86 e0       	ldi	r24, 0x06	; 6
     926:	e6 e0       	ldi	r30, 0x06	; 6
     928:	f2 e0       	ldi	r31, 0x02	; 2
     92a:	de 01       	movw	r26, r28
     92c:	52 96       	adiw	r26, 0x12	; 18
     92e:	01 90       	ld	r0, Z+
     930:	0d 92       	st	X+, r0
     932:	8a 95       	dec	r24
     934:	e1 f7       	brne	.-8      	; 0x92e <_ZN6LSM303C1Ev+0x10>
     936:	86 e0       	ldi	r24, 0x06	; 6
     938:	ec e0       	ldi	r30, 0x0C	; 12
     93a:	f2 e0       	ldi	r31, 0x02	; 2
     93c:	de 01       	movw	r26, r28
     93e:	1c 96       	adiw	r26, 0x0c	; 12
     940:	01 90       	ld	r0, Z+
     942:	0d 92       	st	X+, r0
     944:	8a 95       	dec	r24
     946:	e1 f7       	brne	.-8      	; 0x940 <_ZN6LSM303C1Ev+0x22>
     948:	84 e0       	ldi	r24, 0x04	; 4
     94a:	89 8f       	std	Y+25, r24	; 0x19
     94c:	1c a2       	std	Y+36, r1	; 0x24
     94e:	1b a2       	std	Y+35, r1	; 0x23
     950:	1d a2       	std	Y+37, r1	; 0x25
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	08 95       	ret

00000958 <_ZN6LSM30311writeAccRegEhh>:
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	cf 93       	push	r28
     95e:	df 93       	push	r29
     960:	ec 01       	movw	r28, r24
     962:	06 2f       	mov	r16, r22
     964:	14 2f       	mov	r17, r20
     966:	6a 8d       	ldd	r22, Y+26	; 0x1a
     968:	8d e6       	ldi	r24, 0x6D	; 109
     96a:	99 e0       	ldi	r25, 0x09	; 9
     96c:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
     970:	60 2f       	mov	r22, r16
     972:	8d e6       	ldi	r24, 0x6D	; 109
     974:	99 e0       	ldi	r25, 0x09	; 9
     976:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
     97a:	61 2f       	mov	r22, r17
     97c:	8d e6       	ldi	r24, 0x6D	; 109
     97e:	99 e0       	ldi	r25, 0x09	; 9
     980:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
     984:	8d e6       	ldi	r24, 0x6D	; 109
     986:	99 e0       	ldi	r25, 0x09	; 9
     988:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     98c:	88 8f       	std	Y+24, r24	; 0x18
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	08 95       	ret

00000998 <_ZN6LSM30311writeMagRegEhh>:
     998:	0f 93       	push	r16
     99a:	1f 93       	push	r17
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
     9a0:	ec 01       	movw	r28, r24
     9a2:	06 2f       	mov	r16, r22
     9a4:	14 2f       	mov	r17, r20
     9a6:	6b 8d       	ldd	r22, Y+27	; 0x1b
     9a8:	8d e6       	ldi	r24, 0x6D	; 109
     9aa:	99 e0       	ldi	r25, 0x09	; 9
     9ac:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
     9b0:	60 2f       	mov	r22, r16
     9b2:	8d e6       	ldi	r24, 0x6D	; 109
     9b4:	99 e0       	ldi	r25, 0x09	; 9
     9b6:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
     9ba:	61 2f       	mov	r22, r17
     9bc:	8d e6       	ldi	r24, 0x6D	; 109
     9be:	99 e0       	ldi	r25, 0x09	; 9
     9c0:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
     9c4:	8d e6       	ldi	r24, 0x6D	; 109
     9c6:	99 e0       	ldi	r25, 0x09	; 9
     9c8:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     9cc:	88 8f       	std	Y+24, r24	; 0x18
     9ce:	df 91       	pop	r29
     9d0:	cf 91       	pop	r28
     9d2:	1f 91       	pop	r17
     9d4:	0f 91       	pop	r16
     9d6:	08 95       	ret

000009d8 <_ZN6LSM3038writeRegEhh>:
     9d8:	fc 01       	movw	r30, r24
     9da:	21 8d       	ldd	r18, Z+25	; 0x19
     9dc:	23 30       	cpi	r18, 0x03	; 3
     9de:	11 f0       	breq	.+4      	; 0x9e4 <_ZN6LSM3038writeRegEhh+0xc>
     9e0:	60 32       	cpi	r22, 0x20	; 32
     9e2:	10 f4       	brcc	.+4      	; 0x9e8 <_ZN6LSM3038writeRegEhh+0x10>
     9e4:	d9 cf       	rjmp	.-78     	; 0x998 <_ZN6LSM30311writeMagRegEhh>
     9e6:	08 95       	ret
     9e8:	b7 cf       	rjmp	.-146    	; 0x958 <_ZN6LSM30311writeAccRegEhh>
     9ea:	08 95       	ret

000009ec <_ZN6LSM30313enableDefaultEv>:
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	ec 01       	movw	r28, r24
     9f2:	89 8d       	ldd	r24, Y+25	; 0x19
     9f4:	83 30       	cpi	r24, 0x03	; 3
     9f6:	a9 f4       	brne	.+42     	; 0xa22 <_ZN6LSM30313enableDefaultEv+0x36>
     9f8:	40 e0       	ldi	r20, 0x00	; 0
     9fa:	61 e2       	ldi	r22, 0x21	; 33
     9fc:	ce 01       	movw	r24, r28
     9fe:	ec df       	rcall	.-40     	; 0x9d8 <_ZN6LSM3038writeRegEhh>
     a00:	47 e5       	ldi	r20, 0x57	; 87
     a02:	60 e2       	ldi	r22, 0x20	; 32
     a04:	ce 01       	movw	r24, r28
     a06:	e8 df       	rcall	.-48     	; 0x9d8 <_ZN6LSM3038writeRegEhh>
     a08:	44 e6       	ldi	r20, 0x64	; 100
     a0a:	64 e2       	ldi	r22, 0x24	; 36
     a0c:	ce 01       	movw	r24, r28
     a0e:	e4 df       	rcall	.-56     	; 0x9d8 <_ZN6LSM3038writeRegEhh>
     a10:	40 e2       	ldi	r20, 0x20	; 32
     a12:	65 e2       	ldi	r22, 0x25	; 37
     a14:	ce 01       	movw	r24, r28
     a16:	e0 df       	rcall	.-64     	; 0x9d8 <_ZN6LSM3038writeRegEhh>
     a18:	40 e0       	ldi	r20, 0x00	; 0
     a1a:	66 e2       	ldi	r22, 0x26	; 38
     a1c:	ce 01       	movw	r24, r28
     a1e:	dc df       	rcall	.-72     	; 0x9d8 <_ZN6LSM3038writeRegEhh>
     a20:	1f c0       	rjmp	.+62     	; 0xa60 <_ZN6LSM30313enableDefaultEv+0x74>
     a22:	82 30       	cpi	r24, 0x02	; 2
     a24:	49 f4       	brne	.+18     	; 0xa38 <_ZN6LSM30313enableDefaultEv+0x4c>
     a26:	48 e0       	ldi	r20, 0x08	; 8
     a28:	63 e2       	ldi	r22, 0x23	; 35
     a2a:	ce 01       	movw	r24, r28
     a2c:	95 df       	rcall	.-214    	; 0x958 <_ZN6LSM30311writeAccRegEhh>
     a2e:	47 e4       	ldi	r20, 0x47	; 71
     a30:	60 e2       	ldi	r22, 0x20	; 32
     a32:	ce 01       	movw	r24, r28
     a34:	91 df       	rcall	.-222    	; 0x958 <_ZN6LSM30311writeAccRegEhh>
     a36:	08 c0       	rjmp	.+16     	; 0xa48 <_ZN6LSM30313enableDefaultEv+0x5c>
     a38:	40 e0       	ldi	r20, 0x00	; 0
     a3a:	63 e2       	ldi	r22, 0x23	; 35
     a3c:	ce 01       	movw	r24, r28
     a3e:	8c df       	rcall	.-232    	; 0x958 <_ZN6LSM30311writeAccRegEhh>
     a40:	47 e2       	ldi	r20, 0x27	; 39
     a42:	60 e2       	ldi	r22, 0x20	; 32
     a44:	ce 01       	movw	r24, r28
     a46:	88 df       	rcall	.-240    	; 0x958 <_ZN6LSM30311writeAccRegEhh>
     a48:	4c e0       	ldi	r20, 0x0C	; 12
     a4a:	60 e0       	ldi	r22, 0x00	; 0
     a4c:	ce 01       	movw	r24, r28
     a4e:	a4 df       	rcall	.-184    	; 0x998 <_ZN6LSM30311writeMagRegEhh>
     a50:	40 e2       	ldi	r20, 0x20	; 32
     a52:	61 e0       	ldi	r22, 0x01	; 1
     a54:	ce 01       	movw	r24, r28
     a56:	a0 df       	rcall	.-192    	; 0x998 <_ZN6LSM30311writeMagRegEhh>
     a58:	40 e0       	ldi	r20, 0x00	; 0
     a5a:	62 e0       	ldi	r22, 0x02	; 2
     a5c:	ce 01       	movw	r24, r28
     a5e:	9c df       	rcall	.-200    	; 0x998 <_ZN6LSM30311writeMagRegEhh>
     a60:	df 91       	pop	r29
     a62:	cf 91       	pop	r28
     a64:	08 95       	ret

00000a66 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
     a66:	9f 92       	push	r9
     a68:	af 92       	push	r10
     a6a:	bf 92       	push	r11
     a6c:	cf 92       	push	r12
     a6e:	df 92       	push	r13
     a70:	ef 92       	push	r14
     a72:	ff 92       	push	r15
     a74:	0f 93       	push	r16
     a76:	1f 93       	push	r17
     a78:	cf 93       	push	r28
     a7a:	df 93       	push	r29
     a7c:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
     a7e:	6a 8d       	ldd	r22, Y+26	; 0x1a
     a80:	8d e6       	ldi	r24, 0x6D	; 109
     a82:	99 e0       	ldi	r25, 0x09	; 9
     a84:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
     a88:	e0 91 6d 09 	lds	r30, 0x096D
     a8c:	f0 91 6e 09 	lds	r31, 0x096E
     a90:	01 90       	ld	r0, Z+
     a92:	f0 81       	ld	r31, Z
     a94:	e0 2d       	mov	r30, r0
     a96:	68 ea       	ldi	r22, 0xA8	; 168
     a98:	8d e6       	ldi	r24, 0x6D	; 109
     a9a:	99 e0       	ldi	r25, 0x09	; 9
     a9c:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
     a9e:	8d e6       	ldi	r24, 0x6D	; 109
     aa0:	99 e0       	ldi	r25, 0x09	; 9
     aa2:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     aa6:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
     aa8:	46 e0       	ldi	r20, 0x06	; 6
     aaa:	6a 8d       	ldd	r22, Y+26	; 0x1a
     aac:	8d e6       	ldi	r24, 0x6D	; 109
     aae:	99 e0       	ldi	r25, 0x09	; 9
     ab0:	0e 94 99 14 	call	0x2932	; 0x2932 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     ab4:	0e 94 47 19 	call	0x328e	; 0x328e <millis>
     ab8:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     aba:	10 c0       	rjmp	.+32     	; 0xadc <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     abc:	8b a1       	ldd	r24, Y+35	; 0x23
     abe:	9c a1       	ldd	r25, Y+36	; 0x24
     ac0:	89 2b       	or	r24, r25
     ac2:	61 f0       	breq	.+24     	; 0xadc <_ZN6LSM3037readAccEv+0x76>
     ac4:	0e 94 47 19 	call	0x328e	; 0x328e <millis>
     ac8:	60 1b       	sub	r22, r16
     aca:	71 0b       	sbc	r23, r17
     acc:	8b a1       	ldd	r24, Y+35	; 0x23
     ace:	9c a1       	ldd	r25, Y+36	; 0x24
     ad0:	86 17       	cp	r24, r22
     ad2:	97 07       	cpc	r25, r23
     ad4:	18 f4       	brcc	.+6      	; 0xadc <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	8d a3       	std	Y+37, r24	; 0x25
      return;
     ada:	32 c0       	rjmp	.+100    	; 0xb40 <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     adc:	8d e6       	ldi	r24, 0x6D	; 109
     ade:	99 e0       	ldi	r25, 0x09	; 9
     ae0:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <_ZN7TwoWire9availableEv>
     ae4:	06 97       	sbiw	r24, 0x06	; 6
     ae6:	54 f3       	brlt	.-44     	; 0xabc <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
     ae8:	8d e6       	ldi	r24, 0x6D	; 109
     aea:	99 e0       	ldi	r25, 0x09	; 9
     aec:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     af0:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
     af2:	8d e6       	ldi	r24, 0x6D	; 109
     af4:	99 e0       	ldi	r25, 0x09	; 9
     af6:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     afa:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
     afc:	8d e6       	ldi	r24, 0x6D	; 109
     afe:	99 e0       	ldi	r25, 0x09	; 9
     b00:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     b04:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
     b06:	8d e6       	ldi	r24, 0x6D	; 109
     b08:	99 e0       	ldi	r25, 0x09	; 9
     b0a:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     b0e:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
     b10:	8d e6       	ldi	r24, 0x6D	; 109
     b12:	99 e0       	ldi	r25, 0x09	; 9
     b14:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     b18:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
     b1a:	8d e6       	ldi	r24, 0x6D	; 109
     b1c:	99 e0       	ldi	r25, 0x09	; 9
     b1e:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
     b22:	d9 2c       	mov	r13, r9
     b24:	c1 2c       	mov	r12, r1
     b26:	ca 28       	or	r12, r10
     b28:	d9 82       	std	Y+1, r13	; 0x01
     b2a:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
     b2c:	fb 2c       	mov	r15, r11
     b2e:	e1 2c       	mov	r14, r1
     b30:	e0 2a       	or	r14, r16
     b32:	fb 82       	std	Y+3, r15	; 0x03
     b34:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
     b36:	98 2f       	mov	r25, r24
     b38:	88 27       	eor	r24, r24
     b3a:	81 2b       	or	r24, r17
     b3c:	9d 83       	std	Y+5, r25	; 0x05
     b3e:	8c 83       	std	Y+4, r24	; 0x04
}
     b40:	df 91       	pop	r29
     b42:	cf 91       	pop	r28
     b44:	1f 91       	pop	r17
     b46:	0f 91       	pop	r16
     b48:	ff 90       	pop	r15
     b4a:	ef 90       	pop	r14
     b4c:	df 90       	pop	r13
     b4e:	cf 90       	pop	r12
     b50:	bf 90       	pop	r11
     b52:	af 90       	pop	r10
     b54:	9f 90       	pop	r9
     b56:	08 95       	ret

00000b58 <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
     b58:	cf 92       	push	r12
     b5a:	df 92       	push	r13
     b5c:	ef 92       	push	r14
     b5e:	ff 92       	push	r15
     b60:	0f 93       	push	r16
     b62:	1f 93       	push	r17
     b64:	cf 93       	push	r28
     b66:	df 93       	push	r29
     b68:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
     b6a:	6b 8d       	ldd	r22, Y+27	; 0x1b
     b6c:	8d e6       	ldi	r24, 0x6D	; 109
     b6e:	99 e0       	ldi	r25, 0x09	; 9
     b70:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
     b74:	89 8d       	ldd	r24, Y+25	; 0x19
     b76:	83 30       	cpi	r24, 0x03	; 3
     b78:	31 f4       	brne	.+12     	; 0xb86 <_ZN6LSM3037readMagEv+0x2e>
     b7a:	6e 8d       	ldd	r22, Y+30	; 0x1e
     b7c:	77 27       	eor	r23, r23
     b7e:	67 fd       	sbrc	r22, 7
     b80:	70 95       	com	r23
     b82:	60 68       	ori	r22, 0x80	; 128
     b84:	04 c0       	rjmp	.+8      	; 0xb8e <_ZN6LSM3037readMagEv+0x36>
     b86:	6d 8d       	ldd	r22, Y+29	; 0x1d
     b88:	77 27       	eor	r23, r23
     b8a:	67 fd       	sbrc	r22, 7
     b8c:	70 95       	com	r23
     b8e:	e0 91 6d 09 	lds	r30, 0x096D
     b92:	f0 91 6e 09 	lds	r31, 0x096E
     b96:	01 90       	ld	r0, Z+
     b98:	f0 81       	ld	r31, Z
     b9a:	e0 2d       	mov	r30, r0
     b9c:	8d e6       	ldi	r24, 0x6D	; 109
     b9e:	99 e0       	ldi	r25, 0x09	; 9
     ba0:	19 95       	eicall
  last_status = Wire.endTransmission();
     ba2:	8d e6       	ldi	r24, 0x6D	; 109
     ba4:	99 e0       	ldi	r25, 0x09	; 9
     ba6:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     baa:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
     bac:	46 e0       	ldi	r20, 0x06	; 6
     bae:	6b 8d       	ldd	r22, Y+27	; 0x1b
     bb0:	8d e6       	ldi	r24, 0x6D	; 109
     bb2:	99 e0       	ldi	r25, 0x09	; 9
     bb4:	0e 94 99 14 	call	0x2932	; 0x2932 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
     bb8:	0e 94 47 19 	call	0x328e	; 0x328e <millis>
     bbc:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
     bbe:	10 c0       	rjmp	.+32     	; 0xbe0 <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     bc0:	8b a1       	ldd	r24, Y+35	; 0x23
     bc2:	9c a1       	ldd	r25, Y+36	; 0x24
     bc4:	89 2b       	or	r24, r25
     bc6:	61 f0       	breq	.+24     	; 0xbe0 <_ZN6LSM3037readMagEv+0x88>
     bc8:	0e 94 47 19 	call	0x328e	; 0x328e <millis>
     bcc:	60 1b       	sub	r22, r16
     bce:	71 0b       	sbc	r23, r17
     bd0:	8b a1       	ldd	r24, Y+35	; 0x23
     bd2:	9c a1       	ldd	r25, Y+36	; 0x24
     bd4:	86 17       	cp	r24, r22
     bd6:	97 07       	cpc	r25, r23
     bd8:	18 f4       	brcc	.+6      	; 0xbe0 <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
     bda:	81 e0       	ldi	r24, 0x01	; 1
     bdc:	8d a3       	std	Y+37, r24	; 0x25
      return;
     bde:	6e c0       	rjmp	.+220    	; 0xcbc <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
     be0:	8d e6       	ldi	r24, 0x6D	; 109
     be2:	99 e0       	ldi	r25, 0x09	; 9
     be4:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <_ZN7TwoWire9availableEv>
     be8:	06 97       	sbiw	r24, 0x06	; 6
     bea:	54 f3       	brlt	.-44     	; 0xbc0 <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
     bec:	89 8d       	ldd	r24, Y+25	; 0x19
     bee:	83 30       	cpi	r24, 0x03	; 3
     bf0:	f9 f4       	brne	.+62     	; 0xc30 <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
     bf2:	8d e6       	ldi	r24, 0x6D	; 109
     bf4:	99 e0       	ldi	r25, 0x09	; 9
     bf6:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     bfa:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
     bfc:	8d e6       	ldi	r24, 0x6D	; 109
     bfe:	99 e0       	ldi	r25, 0x09	; 9
     c00:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c04:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
     c06:	8d e6       	ldi	r24, 0x6D	; 109
     c08:	99 e0       	ldi	r25, 0x09	; 9
     c0a:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c0e:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
     c10:	8d e6       	ldi	r24, 0x6D	; 109
     c12:	99 e0       	ldi	r25, 0x09	; 9
     c14:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c18:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
     c1a:	8d e6       	ldi	r24, 0x6D	; 109
     c1c:	99 e0       	ldi	r25, 0x09	; 9
     c1e:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c22:	08 2f       	mov	r16, r24
    zhm = Wire.read();
     c24:	8d e6       	ldi	r24, 0x6D	; 109
     c26:	99 e0       	ldi	r25, 0x09	; 9
     c28:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c2c:	18 2f       	mov	r17, r24
     c2e:	36 c0       	rjmp	.+108    	; 0xc9c <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
     c30:	8d e6       	ldi	r24, 0x6D	; 109
     c32:	99 e0       	ldi	r25, 0x09	; 9
     c34:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c38:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
     c3a:	8d e6       	ldi	r24, 0x6D	; 109
     c3c:	99 e0       	ldi	r25, 0x09	; 9
     c3e:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c42:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
     c44:	89 8d       	ldd	r24, Y+25	; 0x19
     c46:	81 11       	cpse	r24, r1
     c48:	15 c0       	rjmp	.+42     	; 0xc74 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
     c4a:	8d e6       	ldi	r24, 0x6D	; 109
     c4c:	99 e0       	ldi	r25, 0x09	; 9
     c4e:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c52:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
     c54:	8d e6       	ldi	r24, 0x6D	; 109
     c56:	99 e0       	ldi	r25, 0x09	; 9
     c58:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c5c:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
     c5e:	8d e6       	ldi	r24, 0x6D	; 109
     c60:	99 e0       	ldi	r25, 0x09	; 9
     c62:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c66:	18 2f       	mov	r17, r24
      zlm = Wire.read();
     c68:	8d e6       	ldi	r24, 0x6D	; 109
     c6a:	99 e0       	ldi	r25, 0x09	; 9
     c6c:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c70:	08 2f       	mov	r16, r24
     c72:	14 c0       	rjmp	.+40     	; 0xc9c <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
     c74:	8d e6       	ldi	r24, 0x6D	; 109
     c76:	99 e0       	ldi	r25, 0x09	; 9
     c78:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c7c:	18 2f       	mov	r17, r24
      zlm = Wire.read();
     c7e:	8d e6       	ldi	r24, 0x6D	; 109
     c80:	99 e0       	ldi	r25, 0x09	; 9
     c82:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c86:	08 2f       	mov	r16, r24
      yhm = Wire.read();
     c88:	8d e6       	ldi	r24, 0x6D	; 109
     c8a:	99 e0       	ldi	r25, 0x09	; 9
     c8c:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c90:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
     c92:	8d e6       	ldi	r24, 0x6D	; 109
     c94:	99 e0       	ldi	r25, 0x09	; 9
     c96:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     c9a:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
     c9c:	6c 2d       	mov	r22, r12
     c9e:	70 e0       	ldi	r23, 0x00	; 0
     ca0:	7d 29       	or	r23, r13
     ca2:	7f 83       	std	Y+7, r23	; 0x07
     ca4:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
     ca6:	4e 2d       	mov	r20, r14
     ca8:	50 e0       	ldi	r21, 0x00	; 0
     caa:	5f 29       	or	r21, r15
     cac:	59 87       	std	Y+9, r21	; 0x09
     cae:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
     cb0:	20 2f       	mov	r18, r16
     cb2:	30 e0       	ldi	r19, 0x00	; 0
     cb4:	c9 01       	movw	r24, r18
     cb6:	91 2b       	or	r25, r17
     cb8:	9b 87       	std	Y+11, r25	; 0x0b
     cba:	8a 87       	std	Y+10, r24	; 0x0a
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	ff 90       	pop	r15
     cc6:	ef 90       	pop	r14
     cc8:	df 90       	pop	r13
     cca:	cf 90       	pop	r12
     ccc:	08 95       	ret

00000cce <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	ec 01       	movw	r28, r24
  readAcc();
     cd4:	c8 de       	rcall	.-624    	; 0xa66 <_ZN6LSM3037readAccEv>
  readMag();
     cd6:	ce 01       	movw	r24, r28
     cd8:	3f df       	rcall	.-386    	; 0xb58 <_ZN6LSM3037readMagEv>
}
     cda:	df 91       	pop	r29
     cdc:	cf 91       	pop	r28
     cde:	08 95       	ret

00000ce0 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
     ce4:	c6 2f       	mov	r28, r22
     ce6:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     ce8:	8d e6       	ldi	r24, 0x6D	; 109
     cea:	99 e0       	ldi	r25, 0x09	; 9
     cec:	0e 94 9c 14 	call	0x2938	; 0x2938 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     cf0:	6d 2f       	mov	r22, r29
     cf2:	8d e6       	ldi	r24, 0x6D	; 109
     cf4:	99 e0       	ldi	r25, 0x09	; 9
     cf6:	0e 94 43 14 	call	0x2886	; 0x2886 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     cfa:	8d e6       	ldi	r24, 0x6D	; 109
     cfc:	99 e0       	ldi	r25, 0x09	; 9
     cfe:	0e 94 b8 14 	call	0x2970	; 0x2970 <_ZN7TwoWire15endTransmissionEv>
     d02:	81 11       	cpse	r24, r1
     d04:	11 c0       	rjmp	.+34     	; 0xd28 <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     d06:	41 e0       	ldi	r20, 0x01	; 1
     d08:	6c 2f       	mov	r22, r28
     d0a:	8d e6       	ldi	r24, 0x6D	; 109
     d0c:	99 e0       	ldi	r25, 0x09	; 9
     d0e:	0e 94 99 14 	call	0x2932	; 0x2932 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     d12:	8d e6       	ldi	r24, 0x6D	; 109
     d14:	99 e0       	ldi	r25, 0x09	; 9
     d16:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <_ZN7TwoWire9availableEv>
     d1a:	89 2b       	or	r24, r25
     d1c:	41 f0       	breq	.+16     	; 0xd2e <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     d1e:	8d e6       	ldi	r24, 0x6D	; 109
     d20:	99 e0       	ldi	r25, 0x09	; 9
     d22:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <_ZN7TwoWire4readEv>
     d26:	05 c0       	rjmp	.+10     	; 0xd32 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     d28:	8f ef       	ldi	r24, 0xFF	; 255
     d2a:	9f ef       	ldi	r25, 0xFF	; 255
     d2c:	02 c0       	rjmp	.+4      	; 0xd32 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     d2e:	8f ef       	ldi	r24, 0xFF	; 255
     d30:	9f ef       	ldi	r25, 0xFF	; 255
  }
     d32:	df 91       	pop	r29
     d34:	cf 91       	pop	r28
     d36:	08 95       	ret

00000d38 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
     d38:	0f 93       	push	r16
     d3a:	1f 93       	push	r17
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
     d40:	ec 01       	movw	r28, r24
     d42:	16 2f       	mov	r17, r22
     d44:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     d46:	64 30       	cpi	r22, 0x04	; 4
     d48:	09 f4       	brne	.+2      	; 0xd4c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
     d4a:	ad c0       	rjmp	.+346    	; 0xea6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
     d4c:	42 30       	cpi	r20, 0x02	; 2
     d4e:	09 f0       	breq	.+2      	; 0xd52 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
     d50:	47 c0       	rjmp	.+142    	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     d52:	ad c0       	rjmp	.+346    	; 0xeae <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     d54:	4f e0       	ldi	r20, 0x0F	; 15
     d56:	6d e1       	ldi	r22, 0x1D	; 29
     d58:	ce 01       	movw	r24, r28
     d5a:	c2 df       	rcall	.-124    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     d5c:	89 34       	cpi	r24, 0x49	; 73
     d5e:	91 05       	cpc	r25, r1
     d60:	09 f4       	brne	.+2      	; 0xd64 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
     d62:	ab c0       	rjmp	.+342    	; 0xeba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
     d64:	01 30       	cpi	r16, 0x01	; 1
     d66:	41 f0       	breq	.+16     	; 0xd78 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     d68:	4f e0       	ldi	r20, 0x0F	; 15
     d6a:	6e e1       	ldi	r22, 0x1E	; 30
     d6c:	ce 01       	movw	r24, r28
     d6e:	b8 df       	rcall	.-144    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     d70:	89 34       	cpi	r24, 0x49	; 73
     d72:	91 05       	cpc	r25, r1
     d74:	09 f4       	brne	.+2      	; 0xd78 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     d76:	a3 c0       	rjmp	.+326    	; 0xebe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
     d78:	14 30       	cpi	r17, 0x04	; 4
     d7a:	11 f0       	breq	.+4      	; 0xd80 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
     d7c:	13 30       	cpi	r17, 0x03	; 3
     d7e:	68 f5       	brcc	.+90     	; 0xdda <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     d80:	00 23       	and	r16, r16
     d82:	a9 f0       	breq	.+42     	; 0xdae <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
     d84:	40 e2       	ldi	r20, 0x20	; 32
     d86:	69 e1       	ldi	r22, 0x19	; 25
     d88:	ce 01       	movw	r24, r28
     d8a:	aa df       	rcall	.-172    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     d8c:	01 96       	adiw	r24, 0x01	; 1
     d8e:	69 f0       	breq	.+26     	; 0xdaa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
     d90:	14 30       	cpi	r17, 0x04	; 4
     d92:	09 f0       	breq	.+2      	; 0xd96 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
     d94:	99 c0       	rjmp	.+306    	; 0xec8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     d96:	4f e0       	ldi	r20, 0x0F	; 15
     d98:	6e e1       	ldi	r22, 0x1E	; 30
     d9a:	ce 01       	movw	r24, r28
     d9c:	a1 df       	rcall	.-190    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     d9e:	cc 97       	sbiw	r24, 0x3c	; 60
     da0:	09 f0       	breq	.+2      	; 0xda4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
     da2:	94 c0       	rjmp	.+296    	; 0xecc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     da4:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     da6:	12 e0       	ldi	r17, 0x02	; 2
     da8:	1b c0       	rjmp	.+54     	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     daa:	01 30       	cpi	r16, 0x01	; 1
     dac:	99 f0       	breq	.+38     	; 0xdd4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
     dae:	40 e2       	ldi	r20, 0x20	; 32
     db0:	68 e1       	ldi	r22, 0x18	; 24
     db2:	ce 01       	movw	r24, r28
     db4:	95 df       	rcall	.-214    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     db6:	01 96       	adiw	r24, 0x01	; 1
     db8:	69 f0       	breq	.+26     	; 0xdd4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
     dba:	14 30       	cpi	r17, 0x04	; 4
     dbc:	09 f0       	breq	.+2      	; 0xdc0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
     dbe:	89 c0       	rjmp	.+274    	; 0xed2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
     dc0:	4f e0       	ldi	r20, 0x0F	; 15
     dc2:	6e e1       	ldi	r22, 0x1E	; 30
     dc4:	ce 01       	movw	r24, r28
     dc6:	8c df       	rcall	.-232    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     dc8:	11 e0       	ldi	r17, 0x01	; 1
     dca:	cc 97       	sbiw	r24, 0x3c	; 60
     dcc:	09 f0       	breq	.+2      	; 0xdd0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
     dce:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     dd0:	00 e0       	ldi	r16, 0x00	; 0
     dd2:	06 c0       	rjmp	.+12     	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     dd4:	14 30       	cpi	r17, 0x04	; 4
     dd6:	09 f4       	brne	.+2      	; 0xdda <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
     dd8:	60 c0       	rjmp	.+192    	; 0xe9a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
     dda:	02 30       	cpi	r16, 0x02	; 2
     ddc:	09 f4       	brne	.+2      	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     dde:	5f c0       	rjmp	.+190    	; 0xe9e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
     de0:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
     de2:	11 30       	cpi	r17, 0x01	; 1
     de4:	71 f1       	breq	.+92     	; 0xe42 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
     de6:	08 f4       	brcc	.+2      	; 0xdea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
     de8:	42 c0       	rjmp	.+132    	; 0xe6e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
     dea:	12 30       	cpi	r17, 0x02	; 2
     dec:	c1 f0       	breq	.+48     	; 0xe1e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
     dee:	13 30       	cpi	r17, 0x03	; 3
     df0:	09 f0       	breq	.+2      	; 0xdf4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
     df2:	57 c0       	rjmp	.+174    	; 0xea2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
     df4:	01 30       	cpi	r16, 0x01	; 1
     df6:	11 f4       	brne	.+4      	; 0xdfc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
     df8:	8d e1       	ldi	r24, 0x1D	; 29
     dfa:	01 c0       	rjmp	.+2      	; 0xdfe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
     dfc:	8e e1       	ldi	r24, 0x1E	; 30
     dfe:	8b 8f       	std	Y+27, r24	; 0x1b
     e00:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
     e02:	88 e0       	ldi	r24, 0x08	; 8
     e04:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
     e06:	89 e0       	ldi	r24, 0x09	; 9
     e08:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
     e0a:	8a e0       	ldi	r24, 0x0A	; 10
     e0c:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
     e0e:	8b e0       	ldi	r24, 0x0B	; 11
     e10:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
     e12:	8c e0       	ldi	r24, 0x0C	; 12
     e14:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
     e16:	8d e0       	ldi	r24, 0x0D	; 13
     e18:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     e1a:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
     e1c:	64 c0       	rjmp	.+200    	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
     e1e:	89 e1       	ldi	r24, 0x19	; 25
     e20:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     e22:	8e e1       	ldi	r24, 0x1E	; 30
     e24:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
     e26:	83 e0       	ldi	r24, 0x03	; 3
     e28:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
     e2a:	84 e0       	ldi	r24, 0x04	; 4
     e2c:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
     e2e:	87 e0       	ldi	r24, 0x07	; 7
     e30:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
     e32:	88 e0       	ldi	r24, 0x08	; 8
     e34:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
     e36:	85 e0       	ldi	r24, 0x05	; 5
     e38:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
     e3a:	86 e0       	ldi	r24, 0x06	; 6
     e3c:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     e3e:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
     e40:	52 c0       	rjmp	.+164    	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     e42:	01 30       	cpi	r16, 0x01	; 1
     e44:	11 f4       	brne	.+4      	; 0xe4a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
     e46:	89 e1       	ldi	r24, 0x19	; 25
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
     e4a:	88 e1       	ldi	r24, 0x18	; 24
     e4c:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     e4e:	8e e1       	ldi	r24, 0x1E	; 30
     e50:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
     e52:	83 e0       	ldi	r24, 0x03	; 3
     e54:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
     e56:	84 e0       	ldi	r24, 0x04	; 4
     e58:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
     e5a:	87 e0       	ldi	r24, 0x07	; 7
     e5c:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
     e5e:	88 e0       	ldi	r24, 0x08	; 8
     e60:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
     e62:	85 e0       	ldi	r24, 0x05	; 5
     e64:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
     e66:	86 e0       	ldi	r24, 0x06	; 6
     e68:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     e6a:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
     e6c:	3c c0       	rjmp	.+120    	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     e6e:	01 30       	cpi	r16, 0x01	; 1
     e70:	11 f4       	brne	.+4      	; 0xe76 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
     e72:	89 e1       	ldi	r24, 0x19	; 25
     e74:	01 c0       	rjmp	.+2      	; 0xe78 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
     e76:	88 e1       	ldi	r24, 0x18	; 24
     e78:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     e7a:	8e e1       	ldi	r24, 0x1E	; 30
     e7c:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
     e7e:	83 e0       	ldi	r24, 0x03	; 3
     e80:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
     e82:	84 e0       	ldi	r24, 0x04	; 4
     e84:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
     e86:	85 e0       	ldi	r24, 0x05	; 5
     e88:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
     e8a:	86 e0       	ldi	r24, 0x06	; 6
     e8c:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
     e8e:	87 e0       	ldi	r24, 0x07	; 7
     e90:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
     e92:	88 e0       	ldi	r24, 0x08	; 8
     e94:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
     e96:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
     e98:	26 c0       	rjmp	.+76     	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     e9a:	80 e0       	ldi	r24, 0x00	; 0
     e9c:	24 c0       	rjmp	.+72     	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	22 c0       	rjmp	.+68     	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	20 c0       	rjmp	.+64     	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     ea6:	44 23       	and	r20, r20
     ea8:	09 f4       	brne	.+2      	; 0xeac <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
     eaa:	5e cf       	rjmp	.-324    	; 0xd68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
     eac:	53 cf       	rjmp	.-346    	; 0xd54 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
     eae:	8d ef       	ldi	r24, 0xFD	; 253
     eb0:	86 0f       	add	r24, r22
     eb2:	82 30       	cpi	r24, 0x02	; 2
     eb4:	08 f0       	brcs	.+2      	; 0xeb8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
     eb6:	62 cf       	rjmp	.-316    	; 0xd7c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
     eb8:	0e c0       	rjmp	.+28     	; 0xed6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     eba:	01 e0       	ldi	r16, 0x01	; 1
     ebc:	03 c0       	rjmp	.+6      	; 0xec4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
     ebe:	00 e0       	ldi	r16, 0x00	; 0
     ec0:	01 c0       	rjmp	.+2      	; 0xec4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     ec2:	01 e0       	ldi	r16, 0x01	; 1
     ec4:	13 e0       	ldi	r17, 0x03	; 3
     ec6:	89 cf       	rjmp	.-238    	; 0xdda <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     ec8:	01 e0       	ldi	r16, 0x01	; 1
     eca:	8a cf       	rjmp	.-236    	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     ecc:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     ece:	10 e0       	ldi	r17, 0x00	; 0
     ed0:	87 cf       	rjmp	.-242    	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     ed2:	00 e0       	ldi	r16, 0x00	; 0
     ed4:	85 cf       	rjmp	.-246    	; 0xde0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     ed6:	4f e0       	ldi	r20, 0x0F	; 15
     ed8:	6d e1       	ldi	r22, 0x1D	; 29
     eda:	ce 01       	movw	r24, r28
     edc:	01 df       	rcall	.-510    	; 0xce0 <_ZN6LSM3037testRegEhNS_7regAddrE>
     ede:	89 34       	cpi	r24, 0x49	; 73
     ee0:	91 05       	cpc	r25, r1
     ee2:	79 f3       	breq	.-34     	; 0xec2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
     ee4:	41 cf       	rjmp	.-382    	; 0xd68 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	08 95       	ret

00000ef0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ef0:	31 e1       	ldi	r19, 0x11	; 17
     ef2:	fc 01       	movw	r30, r24
     ef4:	30 83       	st	Z, r19
     ef6:	31 97       	sbiw	r30, 0x01	; 1
     ef8:	22 e2       	ldi	r18, 0x22	; 34
     efa:	20 83       	st	Z, r18
     efc:	31 97       	sbiw	r30, 0x01	; 1
     efe:	a3 e3       	ldi	r26, 0x33	; 51
     f00:	a0 83       	st	Z, r26
     f02:	31 97       	sbiw	r30, 0x01	; 1
     f04:	60 83       	st	Z, r22
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	70 83       	st	Z, r23
     f0a:	31 97       	sbiw	r30, 0x01	; 1
     f0c:	10 82       	st	Z, r1
     f0e:	31 97       	sbiw	r30, 0x01	; 1
     f10:	10 82       	st	Z, r1
     f12:	31 97       	sbiw	r30, 0x01	; 1
     f14:	60 e8       	ldi	r22, 0x80	; 128
     f16:	60 83       	st	Z, r22
     f18:	31 97       	sbiw	r30, 0x01	; 1
     f1a:	10 82       	st	Z, r1
     f1c:	31 97       	sbiw	r30, 0x01	; 1
     f1e:	10 82       	st	Z, r1
     f20:	31 97       	sbiw	r30, 0x01	; 1
     f22:	10 82       	st	Z, r1
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	62 e0       	ldi	r22, 0x02	; 2
     f28:	60 83       	st	Z, r22
     f2a:	31 97       	sbiw	r30, 0x01	; 1
     f2c:	63 e0       	ldi	r22, 0x03	; 3
     f2e:	60 83       	st	Z, r22
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	64 e0       	ldi	r22, 0x04	; 4
     f34:	60 83       	st	Z, r22
     f36:	31 97       	sbiw	r30, 0x01	; 1
     f38:	65 e0       	ldi	r22, 0x05	; 5
     f3a:	60 83       	st	Z, r22
     f3c:	31 97       	sbiw	r30, 0x01	; 1
     f3e:	66 e0       	ldi	r22, 0x06	; 6
     f40:	60 83       	st	Z, r22
     f42:	31 97       	sbiw	r30, 0x01	; 1
     f44:	67 e0       	ldi	r22, 0x07	; 7
     f46:	60 83       	st	Z, r22
     f48:	31 97       	sbiw	r30, 0x01	; 1
     f4a:	68 e0       	ldi	r22, 0x08	; 8
     f4c:	60 83       	st	Z, r22
     f4e:	31 97       	sbiw	r30, 0x01	; 1
     f50:	69 e0       	ldi	r22, 0x09	; 9
     f52:	60 83       	st	Z, r22
     f54:	31 97       	sbiw	r30, 0x01	; 1
     f56:	60 e1       	ldi	r22, 0x10	; 16
     f58:	60 83       	st	Z, r22
     f5a:	31 97       	sbiw	r30, 0x01	; 1
     f5c:	30 83       	st	Z, r19
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	32 e1       	ldi	r19, 0x12	; 18
     f62:	30 83       	st	Z, r19
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	33 e1       	ldi	r19, 0x13	; 19
     f68:	30 83       	st	Z, r19
     f6a:	31 97       	sbiw	r30, 0x01	; 1
     f6c:	34 e1       	ldi	r19, 0x14	; 20
     f6e:	30 83       	st	Z, r19
     f70:	31 97       	sbiw	r30, 0x01	; 1
     f72:	35 e1       	ldi	r19, 0x15	; 21
     f74:	30 83       	st	Z, r19
     f76:	31 97       	sbiw	r30, 0x01	; 1
     f78:	36 e1       	ldi	r19, 0x16	; 22
     f7a:	30 83       	st	Z, r19
     f7c:	31 97       	sbiw	r30, 0x01	; 1
     f7e:	37 e1       	ldi	r19, 0x17	; 23
     f80:	30 83       	st	Z, r19
     f82:	31 97       	sbiw	r30, 0x01	; 1
     f84:	38 e1       	ldi	r19, 0x18	; 24
     f86:	30 83       	st	Z, r19
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	39 e1       	ldi	r19, 0x19	; 25
     f8c:	30 83       	st	Z, r19
     f8e:	31 97       	sbiw	r30, 0x01	; 1
     f90:	30 e2       	ldi	r19, 0x20	; 32
     f92:	30 83       	st	Z, r19
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	31 e2       	ldi	r19, 0x21	; 33
     f98:	30 83       	st	Z, r19
     f9a:	31 97       	sbiw	r30, 0x01	; 1
     f9c:	20 83       	st	Z, r18
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	23 e2       	ldi	r18, 0x23	; 35
     fa2:	20 83       	st	Z, r18
     fa4:	31 97       	sbiw	r30, 0x01	; 1
     fa6:	40 83       	st	Z, r20
     fa8:	31 97       	sbiw	r30, 0x01	; 1
     faa:	50 83       	st	Z, r21
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	26 e2       	ldi	r18, 0x26	; 38
     fb0:	20 83       	st	Z, r18
     fb2:	31 97       	sbiw	r30, 0x01	; 1
     fb4:	27 e2       	ldi	r18, 0x27	; 39
     fb6:	20 83       	st	Z, r18
     fb8:	31 97       	sbiw	r30, 0x01	; 1
     fba:	28 e2       	ldi	r18, 0x28	; 40
     fbc:	20 83       	st	Z, r18
     fbe:	31 97       	sbiw	r30, 0x01	; 1
     fc0:	29 e2       	ldi	r18, 0x29	; 41
     fc2:	20 83       	st	Z, r18
     fc4:	31 97       	sbiw	r30, 0x01	; 1
     fc6:	20 e3       	ldi	r18, 0x30	; 48
     fc8:	20 83       	st	Z, r18
     fca:	31 97       	sbiw	r30, 0x01	; 1
     fcc:	21 e3       	ldi	r18, 0x31	; 49
     fce:	20 83       	st	Z, r18
     fd0:	89 97       	sbiw	r24, 0x29	; 41
     fd2:	08 95       	ret

00000fd4 <xPortStartScheduler>:
     fd4:	82 e0       	ldi	r24, 0x02	; 2
     fd6:	80 93 b0 00 	sts	0x00B0, r24
     fda:	10 92 b2 00 	sts	0x00B2, r1
     fde:	80 e3       	ldi	r24, 0x30	; 48
     fe0:	80 93 b3 00 	sts	0x00B3, r24
     fe4:	e0 e7       	ldi	r30, 0x70	; 112
     fe6:	f0 e0       	ldi	r31, 0x00	; 0
     fe8:	80 81       	ld	r24, Z
     fea:	82 60       	ori	r24, 0x02	; 2
     fec:	80 83       	st	Z, r24
     fee:	84 e0       	ldi	r24, 0x04	; 4
     ff0:	80 93 b1 00 	sts	0x00B1, r24
     ff4:	a0 91 fd 08 	lds	r26, 0x08FD
     ff8:	b0 91 fe 08 	lds	r27, 0x08FE
     ffc:	cd 91       	ld	r28, X+
     ffe:	cd bf       	out	0x3d, r28	; 61
    1000:	dd 91       	ld	r29, X+
    1002:	de bf       	out	0x3e, r29	; 62
    1004:	ff 91       	pop	r31
    1006:	ef 91       	pop	r30
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	bf 91       	pop	r27
    100e:	af 91       	pop	r26
    1010:	9f 91       	pop	r25
    1012:	8f 91       	pop	r24
    1014:	7f 91       	pop	r23
    1016:	6f 91       	pop	r22
    1018:	5f 91       	pop	r21
    101a:	4f 91       	pop	r20
    101c:	3f 91       	pop	r19
    101e:	2f 91       	pop	r18
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	ff 90       	pop	r15
    1026:	ef 90       	pop	r14
    1028:	df 90       	pop	r13
    102a:	cf 90       	pop	r12
    102c:	bf 90       	pop	r11
    102e:	af 90       	pop	r10
    1030:	9f 90       	pop	r9
    1032:	8f 90       	pop	r8
    1034:	7f 90       	pop	r7
    1036:	6f 90       	pop	r6
    1038:	5f 90       	pop	r5
    103a:	4f 90       	pop	r4
    103c:	3f 90       	pop	r3
    103e:	2f 90       	pop	r2
    1040:	1f 90       	pop	r1
    1042:	0f 90       	pop	r0
    1044:	0c be       	out	0x3c, r0	; 60
    1046:	0f 90       	pop	r0
    1048:	0b be       	out	0x3b, r0	; 59
    104a:	0f 90       	pop	r0
    104c:	0f be       	out	0x3f, r0	; 63
    104e:	0f 90       	pop	r0
    1050:	08 95       	ret
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	08 95       	ret

00001056 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1056:	0f 92       	push	r0
    1058:	0f b6       	in	r0, 0x3f	; 63
    105a:	f8 94       	cli
    105c:	0f 92       	push	r0
    105e:	0c b6       	in	r0, 0x3c	; 60
    1060:	0f 92       	push	r0
    1062:	0b b6       	in	r0, 0x3b	; 59
    1064:	0f 92       	push	r0
    1066:	1f 92       	push	r1
    1068:	11 24       	eor	r1, r1
    106a:	2f 92       	push	r2
    106c:	3f 92       	push	r3
    106e:	4f 92       	push	r4
    1070:	5f 92       	push	r5
    1072:	6f 92       	push	r6
    1074:	7f 92       	push	r7
    1076:	8f 92       	push	r8
    1078:	9f 92       	push	r9
    107a:	af 92       	push	r10
    107c:	bf 92       	push	r11
    107e:	cf 92       	push	r12
    1080:	df 92       	push	r13
    1082:	ef 92       	push	r14
    1084:	ff 92       	push	r15
    1086:	0f 93       	push	r16
    1088:	1f 93       	push	r17
    108a:	2f 93       	push	r18
    108c:	3f 93       	push	r19
    108e:	4f 93       	push	r20
    1090:	5f 93       	push	r21
    1092:	6f 93       	push	r22
    1094:	7f 93       	push	r23
    1096:	8f 93       	push	r24
    1098:	9f 93       	push	r25
    109a:	af 93       	push	r26
    109c:	bf 93       	push	r27
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	ef 93       	push	r30
    10a4:	ff 93       	push	r31
    10a6:	a0 91 fd 08 	lds	r26, 0x08FD
    10aa:	b0 91 fe 08 	lds	r27, 0x08FE
    10ae:	0d b6       	in	r0, 0x3d	; 61
    10b0:	0d 92       	st	X+, r0
    10b2:	0e b6       	in	r0, 0x3e	; 62
    10b4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    10b6:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10ba:	a0 91 fd 08 	lds	r26, 0x08FD
    10be:	b0 91 fe 08 	lds	r27, 0x08FE
    10c2:	cd 91       	ld	r28, X+
    10c4:	cd bf       	out	0x3d, r28	; 61
    10c6:	dd 91       	ld	r29, X+
    10c8:	de bf       	out	0x3e, r29	; 62
    10ca:	ff 91       	pop	r31
    10cc:	ef 91       	pop	r30
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	bf 91       	pop	r27
    10d4:	af 91       	pop	r26
    10d6:	9f 91       	pop	r25
    10d8:	8f 91       	pop	r24
    10da:	7f 91       	pop	r23
    10dc:	6f 91       	pop	r22
    10de:	5f 91       	pop	r21
    10e0:	4f 91       	pop	r20
    10e2:	3f 91       	pop	r19
    10e4:	2f 91       	pop	r18
    10e6:	1f 91       	pop	r17
    10e8:	0f 91       	pop	r16
    10ea:	ff 90       	pop	r15
    10ec:	ef 90       	pop	r14
    10ee:	df 90       	pop	r13
    10f0:	cf 90       	pop	r12
    10f2:	bf 90       	pop	r11
    10f4:	af 90       	pop	r10
    10f6:	9f 90       	pop	r9
    10f8:	8f 90       	pop	r8
    10fa:	7f 90       	pop	r7
    10fc:	6f 90       	pop	r6
    10fe:	5f 90       	pop	r5
    1100:	4f 90       	pop	r4
    1102:	3f 90       	pop	r3
    1104:	2f 90       	pop	r2
    1106:	1f 90       	pop	r1
    1108:	0f 90       	pop	r0
    110a:	0c be       	out	0x3c, r0	; 60
    110c:	0f 90       	pop	r0
    110e:	0b be       	out	0x3b, r0	; 59
    1110:	0f 90       	pop	r0
    1112:	0f be       	out	0x3f, r0	; 63
    1114:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1116:	08 95       	ret

00001118 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1118:	0f 92       	push	r0
    111a:	0f b6       	in	r0, 0x3f	; 63
    111c:	f8 94       	cli
    111e:	0f 92       	push	r0
    1120:	0c b6       	in	r0, 0x3c	; 60
    1122:	0f 92       	push	r0
    1124:	0b b6       	in	r0, 0x3b	; 59
    1126:	0f 92       	push	r0
    1128:	1f 92       	push	r1
    112a:	11 24       	eor	r1, r1
    112c:	2f 92       	push	r2
    112e:	3f 92       	push	r3
    1130:	4f 92       	push	r4
    1132:	5f 92       	push	r5
    1134:	6f 92       	push	r6
    1136:	7f 92       	push	r7
    1138:	8f 92       	push	r8
    113a:	9f 92       	push	r9
    113c:	af 92       	push	r10
    113e:	bf 92       	push	r11
    1140:	cf 92       	push	r12
    1142:	df 92       	push	r13
    1144:	ef 92       	push	r14
    1146:	ff 92       	push	r15
    1148:	0f 93       	push	r16
    114a:	1f 93       	push	r17
    114c:	2f 93       	push	r18
    114e:	3f 93       	push	r19
    1150:	4f 93       	push	r20
    1152:	5f 93       	push	r21
    1154:	6f 93       	push	r22
    1156:	7f 93       	push	r23
    1158:	8f 93       	push	r24
    115a:	9f 93       	push	r25
    115c:	af 93       	push	r26
    115e:	bf 93       	push	r27
    1160:	cf 93       	push	r28
    1162:	df 93       	push	r29
    1164:	ef 93       	push	r30
    1166:	ff 93       	push	r31
    1168:	a0 91 fd 08 	lds	r26, 0x08FD
    116c:	b0 91 fe 08 	lds	r27, 0x08FE
    1170:	0d b6       	in	r0, 0x3d	; 61
    1172:	0d 92       	st	X+, r0
    1174:	0e b6       	in	r0, 0x3e	; 62
    1176:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1178:	7e d6       	rcall	.+3324   	; 0x1e76 <xTaskIncrementTick>
    117a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    117c:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1180:	a0 91 fd 08 	lds	r26, 0x08FD
    1184:	b0 91 fe 08 	lds	r27, 0x08FE
    1188:	cd 91       	ld	r28, X+
    118a:	cd bf       	out	0x3d, r28	; 61
    118c:	dd 91       	ld	r29, X+
    118e:	de bf       	out	0x3e, r29	; 62
    1190:	ff 91       	pop	r31
    1192:	ef 91       	pop	r30
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	bf 91       	pop	r27
    119a:	af 91       	pop	r26
    119c:	9f 91       	pop	r25
    119e:	8f 91       	pop	r24
    11a0:	7f 91       	pop	r23
    11a2:	6f 91       	pop	r22
    11a4:	5f 91       	pop	r21
    11a6:	4f 91       	pop	r20
    11a8:	3f 91       	pop	r19
    11aa:	2f 91       	pop	r18
    11ac:	1f 91       	pop	r17
    11ae:	0f 91       	pop	r16
    11b0:	ff 90       	pop	r15
    11b2:	ef 90       	pop	r14
    11b4:	df 90       	pop	r13
    11b6:	cf 90       	pop	r12
    11b8:	bf 90       	pop	r11
    11ba:	af 90       	pop	r10
    11bc:	9f 90       	pop	r9
    11be:	8f 90       	pop	r8
    11c0:	7f 90       	pop	r7
    11c2:	6f 90       	pop	r6
    11c4:	5f 90       	pop	r5
    11c6:	4f 90       	pop	r4
    11c8:	3f 90       	pop	r3
    11ca:	2f 90       	pop	r2
    11cc:	1f 90       	pop	r1
    11ce:	0f 90       	pop	r0
    11d0:	0c be       	out	0x3c, r0	; 60
    11d2:	0f 90       	pop	r0
    11d4:	0b be       	out	0x3b, r0	; 59
    11d6:	0f 90       	pop	r0
    11d8:	0f be       	out	0x3f, r0	; 63
    11da:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11dc:	08 95       	ret

000011de <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    11de:	9c df       	rcall	.-200    	; 0x1118 <vPortYieldFromTick>
	asm volatile ( "reti" );
    11e0:	18 95       	reti

000011e2 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
    11ea:	14 2f       	mov	r17, r20
    11ec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ee:	88 23       	and	r24, r24
    11f0:	e9 f1       	breq	.+122    	; 0x126c <prvCopyDataToQueue+0x8a>
    11f2:	41 11       	cpse	r20, r1
    11f4:	17 c0       	rjmp	.+46     	; 0x1224 <prvCopyDataToQueue+0x42>
    11f6:	48 2f       	mov	r20, r24
    11f8:	50 e0       	ldi	r21, 0x00	; 0
    11fa:	8c 81       	ldd	r24, Y+4	; 0x04
    11fc:	9d 81       	ldd	r25, Y+5	; 0x05
    11fe:	0e 94 ef 1a 	call	0x35de	; 0x35de <memcpy>
    1202:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1204:	8c 81       	ldd	r24, Y+4	; 0x04
    1206:	9d 81       	ldd	r25, Y+5	; 0x05
    1208:	82 0f       	add	r24, r18
    120a:	91 1d       	adc	r25, r1
    120c:	9d 83       	std	Y+5, r25	; 0x05
    120e:	8c 83       	std	Y+4, r24	; 0x04
    1210:	2a 81       	ldd	r18, Y+2	; 0x02
    1212:	3b 81       	ldd	r19, Y+3	; 0x03
    1214:	82 17       	cp	r24, r18
    1216:	93 07       	cpc	r25, r19
    1218:	48 f1       	brcs	.+82     	; 0x126c <prvCopyDataToQueue+0x8a>
    121a:	88 81       	ld	r24, Y
    121c:	99 81       	ldd	r25, Y+1	; 0x01
    121e:	9d 83       	std	Y+5, r25	; 0x05
    1220:	8c 83       	std	Y+4, r24	; 0x04
    1222:	24 c0       	rjmp	.+72     	; 0x126c <prvCopyDataToQueue+0x8a>
    1224:	48 2f       	mov	r20, r24
    1226:	50 e0       	ldi	r21, 0x00	; 0
    1228:	8e 81       	ldd	r24, Y+6	; 0x06
    122a:	9f 81       	ldd	r25, Y+7	; 0x07
    122c:	0e 94 ef 1a 	call	0x35de	; 0x35de <memcpy>
    1230:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1232:	30 e0       	ldi	r19, 0x00	; 0
    1234:	31 95       	neg	r19
    1236:	21 95       	neg	r18
    1238:	31 09       	sbc	r19, r1
    123a:	8e 81       	ldd	r24, Y+6	; 0x06
    123c:	9f 81       	ldd	r25, Y+7	; 0x07
    123e:	82 0f       	add	r24, r18
    1240:	93 1f       	adc	r25, r19
    1242:	9f 83       	std	Y+7, r25	; 0x07
    1244:	8e 83       	std	Y+6, r24	; 0x06
    1246:	68 81       	ld	r22, Y
    1248:	79 81       	ldd	r23, Y+1	; 0x01
    124a:	86 17       	cp	r24, r22
    124c:	97 07       	cpc	r25, r23
    124e:	30 f4       	brcc	.+12     	; 0x125c <prvCopyDataToQueue+0x7a>
    1250:	8a 81       	ldd	r24, Y+2	; 0x02
    1252:	9b 81       	ldd	r25, Y+3	; 0x03
    1254:	28 0f       	add	r18, r24
    1256:	39 1f       	adc	r19, r25
    1258:	3f 83       	std	Y+7, r19	; 0x07
    125a:	2e 83       	std	Y+6, r18	; 0x06
    125c:	12 30       	cpi	r17, 0x02	; 2
    125e:	31 f4       	brne	.+12     	; 0x126c <prvCopyDataToQueue+0x8a>
    1260:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1262:	88 23       	and	r24, r24
    1264:	19 f0       	breq	.+6      	; 0x126c <prvCopyDataToQueue+0x8a>
    1266:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1268:	81 50       	subi	r24, 0x01	; 1
    126a:	8a 8f       	std	Y+26, r24	; 0x1a
    126c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    126e:	8f 5f       	subi	r24, 0xFF	; 255
    1270:	8a 8f       	std	Y+26, r24	; 0x1a
    1272:	80 e0       	ldi	r24, 0x00	; 0
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	1f 91       	pop	r17
    127a:	08 95       	ret

0000127c <prvCopyDataFromQueue>:
    127c:	fc 01       	movw	r30, r24
    127e:	cb 01       	movw	r24, r22
    1280:	44 8d       	ldd	r20, Z+28	; 0x1c
    1282:	44 23       	and	r20, r20
    1284:	a1 f0       	breq	.+40     	; 0x12ae <prvCopyDataFromQueue+0x32>
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	26 81       	ldd	r18, Z+6	; 0x06
    128a:	37 81       	ldd	r19, Z+7	; 0x07
    128c:	24 0f       	add	r18, r20
    128e:	35 1f       	adc	r19, r21
    1290:	37 83       	std	Z+7, r19	; 0x07
    1292:	26 83       	std	Z+6, r18	; 0x06
    1294:	62 81       	ldd	r22, Z+2	; 0x02
    1296:	73 81       	ldd	r23, Z+3	; 0x03
    1298:	26 17       	cp	r18, r22
    129a:	37 07       	cpc	r19, r23
    129c:	20 f0       	brcs	.+8      	; 0x12a6 <prvCopyDataFromQueue+0x2a>
    129e:	20 81       	ld	r18, Z
    12a0:	31 81       	ldd	r19, Z+1	; 0x01
    12a2:	37 83       	std	Z+7, r19	; 0x07
    12a4:	26 83       	std	Z+6, r18	; 0x06
    12a6:	66 81       	ldd	r22, Z+6	; 0x06
    12a8:	77 81       	ldd	r23, Z+7	; 0x07
    12aa:	0c 94 ef 1a 	jmp	0x35de	; 0x35de <memcpy>
    12ae:	08 95       	ret

000012b0 <prvUnlockQueue>:
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	f8 94       	cli
    12be:	0f 92       	push	r0
    12c0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12c2:	18 16       	cp	r1, r24
    12c4:	ac f4       	brge	.+42     	; 0x12f0 <prvUnlockQueue+0x40>
    12c6:	89 89       	ldd	r24, Y+17	; 0x11
    12c8:	88 23       	and	r24, r24
    12ca:	91 f0       	breq	.+36     	; 0x12f0 <prvUnlockQueue+0x40>
    12cc:	8e 01       	movw	r16, r28
    12ce:	0f 5e       	subi	r16, 0xEF	; 239
    12d0:	1f 4f       	sbci	r17, 0xFF	; 255
    12d2:	03 c0       	rjmp	.+6      	; 0x12da <prvUnlockQueue+0x2a>
    12d4:	89 89       	ldd	r24, Y+17	; 0x11
    12d6:	88 23       	and	r24, r24
    12d8:	59 f0       	breq	.+22     	; 0x12f0 <prvUnlockQueue+0x40>
    12da:	c8 01       	movw	r24, r16
    12dc:	dd d7       	rcall	.+4026   	; 0x2298 <xTaskRemoveFromEventList>
    12de:	81 11       	cpse	r24, r1
    12e0:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <vTaskMissedYield>
    12e4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12e6:	81 50       	subi	r24, 0x01	; 1
    12e8:	8e 8f       	std	Y+30, r24	; 0x1e
    12ea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12ec:	18 16       	cp	r1, r24
    12ee:	94 f3       	brlt	.-28     	; 0x12d4 <prvUnlockQueue+0x24>
    12f0:	8f ef       	ldi	r24, 0xFF	; 255
    12f2:	8e 8f       	std	Y+30, r24	; 0x1e
    12f4:	0f 90       	pop	r0
    12f6:	0f be       	out	0x3f, r0	; 63
    12f8:	0f b6       	in	r0, 0x3f	; 63
    12fa:	f8 94       	cli
    12fc:	0f 92       	push	r0
    12fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1300:	18 16       	cp	r1, r24
    1302:	ac f4       	brge	.+42     	; 0x132e <prvUnlockQueue+0x7e>
    1304:	88 85       	ldd	r24, Y+8	; 0x08
    1306:	88 23       	and	r24, r24
    1308:	91 f0       	breq	.+36     	; 0x132e <prvUnlockQueue+0x7e>
    130a:	8e 01       	movw	r16, r28
    130c:	08 5f       	subi	r16, 0xF8	; 248
    130e:	1f 4f       	sbci	r17, 0xFF	; 255
    1310:	03 c0       	rjmp	.+6      	; 0x1318 <prvUnlockQueue+0x68>
    1312:	88 85       	ldd	r24, Y+8	; 0x08
    1314:	88 23       	and	r24, r24
    1316:	59 f0       	breq	.+22     	; 0x132e <prvUnlockQueue+0x7e>
    1318:	c8 01       	movw	r24, r16
    131a:	be d7       	rcall	.+3964   	; 0x2298 <xTaskRemoveFromEventList>
    131c:	81 11       	cpse	r24, r1
    131e:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <vTaskMissedYield>
    1322:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1324:	81 50       	subi	r24, 0x01	; 1
    1326:	8d 8f       	std	Y+29, r24	; 0x1d
    1328:	8d 8d       	ldd	r24, Y+29	; 0x1d
    132a:	18 16       	cp	r1, r24
    132c:	94 f3       	brlt	.-28     	; 0x1312 <prvUnlockQueue+0x62>
    132e:	8f ef       	ldi	r24, 0xFF	; 255
    1330:	8d 8f       	std	Y+29, r24	; 0x1d
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	08 95       	ret

00001340 <xQueueGenericReset>:
    1340:	cf 93       	push	r28
    1342:	df 93       	push	r29
    1344:	ec 01       	movw	r28, r24
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	f8 94       	cli
    134a:	0f 92       	push	r0
    134c:	88 81       	ld	r24, Y
    134e:	99 81       	ldd	r25, Y+1	; 0x01
    1350:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1352:	30 e0       	ldi	r19, 0x00	; 0
    1354:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1356:	72 9f       	mul	r23, r18
    1358:	a0 01       	movw	r20, r0
    135a:	73 9f       	mul	r23, r19
    135c:	50 0d       	add	r21, r0
    135e:	11 24       	eor	r1, r1
    1360:	fc 01       	movw	r30, r24
    1362:	e4 0f       	add	r30, r20
    1364:	f5 1f       	adc	r31, r21
    1366:	fb 83       	std	Y+3, r31	; 0x03
    1368:	ea 83       	std	Y+2, r30	; 0x02
    136a:	1a 8e       	std	Y+26, r1	; 0x1a
    136c:	9d 83       	std	Y+5, r25	; 0x05
    136e:	8c 83       	std	Y+4, r24	; 0x04
    1370:	42 1b       	sub	r20, r18
    1372:	53 0b       	sbc	r21, r19
    1374:	84 0f       	add	r24, r20
    1376:	95 1f       	adc	r25, r21
    1378:	9f 83       	std	Y+7, r25	; 0x07
    137a:	8e 83       	std	Y+6, r24	; 0x06
    137c:	8f ef       	ldi	r24, 0xFF	; 255
    137e:	8d 8f       	std	Y+29, r24	; 0x1d
    1380:	8e 8f       	std	Y+30, r24	; 0x1e
    1382:	61 11       	cpse	r22, r1
    1384:	0a c0       	rjmp	.+20     	; 0x139a <xQueueGenericReset+0x5a>
    1386:	88 85       	ldd	r24, Y+8	; 0x08
    1388:	88 23       	and	r24, r24
    138a:	69 f0       	breq	.+26     	; 0x13a6 <xQueueGenericReset+0x66>
    138c:	ce 01       	movw	r24, r28
    138e:	08 96       	adiw	r24, 0x08	; 8
    1390:	83 d7       	rcall	.+3846   	; 0x2298 <xTaskRemoveFromEventList>
    1392:	81 30       	cpi	r24, 0x01	; 1
    1394:	41 f4       	brne	.+16     	; 0x13a6 <xQueueGenericReset+0x66>
    1396:	5f de       	rcall	.-834    	; 0x1056 <vPortYield>
    1398:	06 c0       	rjmp	.+12     	; 0x13a6 <xQueueGenericReset+0x66>
    139a:	ce 01       	movw	r24, r28
    139c:	08 96       	adiw	r24, 0x08	; 8
    139e:	35 da       	rcall	.-2966   	; 0x80a <vListInitialise>
    13a0:	ce 01       	movw	r24, r28
    13a2:	41 96       	adiw	r24, 0x11	; 17
    13a4:	32 da       	rcall	.-2972   	; 0x80a <vListInitialise>
    13a6:	0f 90       	pop	r0
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	df 91       	pop	r29
    13ae:	cf 91       	pop	r28
    13b0:	08 95       	ret

000013b2 <xQueueGenericCreate>:
    13b2:	0f 93       	push	r16
    13b4:	1f 93       	push	r17
    13b6:	cf 93       	push	r28
    13b8:	df 93       	push	r29
    13ba:	18 2f       	mov	r17, r24
    13bc:	06 2f       	mov	r16, r22
    13be:	88 23       	and	r24, r24
    13c0:	d1 f0       	breq	.+52     	; 0x13f6 <xQueueGenericCreate+0x44>
    13c2:	8f e1       	ldi	r24, 0x1F	; 31
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	73 d8       	rcall	.-3866   	; 0x4ae <pvPortMalloc>
    13c8:	ec 01       	movw	r28, r24
    13ca:	00 97       	sbiw	r24, 0x00	; 0
    13cc:	b1 f0       	breq	.+44     	; 0x13fa <xQueueGenericCreate+0x48>
    13ce:	10 9f       	mul	r17, r16
    13d0:	c0 01       	movw	r24, r0
    13d2:	11 24       	eor	r1, r1
    13d4:	01 96       	adiw	r24, 0x01	; 1
    13d6:	6b d8       	rcall	.-3882   	; 0x4ae <pvPortMalloc>
    13d8:	99 83       	std	Y+1, r25	; 0x01
    13da:	88 83       	st	Y, r24
    13dc:	89 2b       	or	r24, r25
    13de:	31 f0       	breq	.+12     	; 0x13ec <xQueueGenericCreate+0x3a>
    13e0:	1b 8f       	std	Y+27, r17	; 0x1b
    13e2:	0c 8f       	std	Y+28, r16	; 0x1c
    13e4:	61 e0       	ldi	r22, 0x01	; 1
    13e6:	ce 01       	movw	r24, r28
    13e8:	ab df       	rcall	.-170    	; 0x1340 <xQueueGenericReset>
    13ea:	07 c0       	rjmp	.+14     	; 0x13fa <xQueueGenericCreate+0x48>
    13ec:	ce 01       	movw	r24, r28
    13ee:	94 d8       	rcall	.-3800   	; 0x518 <vPortFree>
    13f0:	c0 e0       	ldi	r28, 0x00	; 0
    13f2:	d0 e0       	ldi	r29, 0x00	; 0
    13f4:	02 c0       	rjmp	.+4      	; 0x13fa <xQueueGenericCreate+0x48>
    13f6:	c0 e0       	ldi	r28, 0x00	; 0
    13f8:	d0 e0       	ldi	r29, 0x00	; 0
    13fa:	ce 01       	movw	r24, r28
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	1f 91       	pop	r17
    1402:	0f 91       	pop	r16
    1404:	08 95       	ret

00001406 <xQueueGenericSend>:
    1406:	9f 92       	push	r9
    1408:	af 92       	push	r10
    140a:	bf 92       	push	r11
    140c:	cf 92       	push	r12
    140e:	df 92       	push	r13
    1410:	ef 92       	push	r14
    1412:	ff 92       	push	r15
    1414:	0f 93       	push	r16
    1416:	1f 93       	push	r17
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
    141c:	00 d0       	rcall	.+0      	; 0x141e <xQueueGenericSend+0x18>
    141e:	1f 92       	push	r1
    1420:	1f 92       	push	r1
    1422:	cd b7       	in	r28, 0x3d	; 61
    1424:	de b7       	in	r29, 0x3e	; 62
    1426:	8c 01       	movw	r16, r24
    1428:	6b 01       	movw	r12, r22
    142a:	5d 83       	std	Y+5, r21	; 0x05
    142c:	4c 83       	std	Y+4, r20	; 0x04
    142e:	a2 2e       	mov	r10, r18
    1430:	b1 2c       	mov	r11, r1
    1432:	99 24       	eor	r9, r9
    1434:	93 94       	inc	r9
    1436:	7c 01       	movw	r14, r24
    1438:	88 e0       	ldi	r24, 0x08	; 8
    143a:	e8 0e       	add	r14, r24
    143c:	f1 1c       	adc	r15, r1
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	0f 92       	push	r0
    1444:	f8 01       	movw	r30, r16
    1446:	92 8d       	ldd	r25, Z+26	; 0x1a
    1448:	83 8d       	ldd	r24, Z+27	; 0x1b
    144a:	98 17       	cp	r25, r24
    144c:	18 f0       	brcs	.+6      	; 0x1454 <xQueueGenericSend+0x4e>
    144e:	f2 e0       	ldi	r31, 0x02	; 2
    1450:	af 12       	cpse	r10, r31
    1452:	15 c0       	rjmp	.+42     	; 0x147e <xQueueGenericSend+0x78>
    1454:	4a 2d       	mov	r20, r10
    1456:	b6 01       	movw	r22, r12
    1458:	c8 01       	movw	r24, r16
    145a:	c3 de       	rcall	.-634    	; 0x11e2 <prvCopyDataToQueue>
    145c:	f8 01       	movw	r30, r16
    145e:	91 89       	ldd	r25, Z+17	; 0x11
    1460:	99 23       	and	r25, r25
    1462:	39 f0       	breq	.+14     	; 0x1472 <xQueueGenericSend+0x6c>
    1464:	c8 01       	movw	r24, r16
    1466:	41 96       	adiw	r24, 0x11	; 17
    1468:	17 d7       	rcall	.+3630   	; 0x2298 <xTaskRemoveFromEventList>
    146a:	81 30       	cpi	r24, 0x01	; 1
    146c:	21 f4       	brne	.+8      	; 0x1476 <xQueueGenericSend+0x70>
    146e:	f3 dd       	rcall	.-1050   	; 0x1056 <vPortYield>
    1470:	02 c0       	rjmp	.+4      	; 0x1476 <xQueueGenericSend+0x70>
    1472:	81 11       	cpse	r24, r1
    1474:	f0 dd       	rcall	.-1056   	; 0x1056 <vPortYield>
    1476:	0f 90       	pop	r0
    1478:	0f be       	out	0x3f, r0	; 63
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	46 c0       	rjmp	.+140    	; 0x150a <xQueueGenericSend+0x104>
    147e:	ec 81       	ldd	r30, Y+4	; 0x04
    1480:	fd 81       	ldd	r31, Y+5	; 0x05
    1482:	ef 2b       	or	r30, r31
    1484:	21 f4       	brne	.+8      	; 0x148e <xQueueGenericSend+0x88>
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	3e c0       	rjmp	.+124    	; 0x150a <xQueueGenericSend+0x104>
    148e:	b1 10       	cpse	r11, r1
    1490:	04 c0       	rjmp	.+8      	; 0x149a <xQueueGenericSend+0x94>
    1492:	ce 01       	movw	r24, r28
    1494:	01 96       	adiw	r24, 0x01	; 1
    1496:	48 d7       	rcall	.+3728   	; 0x2328 <vTaskSetTimeOutState>
    1498:	b9 2c       	mov	r11, r9
    149a:	0f 90       	pop	r0
    149c:	0f be       	out	0x3f, r0	; 63
    149e:	e5 d4       	rcall	.+2506   	; 0x1e6a <vTaskSuspendAll>
    14a0:	0f b6       	in	r0, 0x3f	; 63
    14a2:	f8 94       	cli
    14a4:	0f 92       	push	r0
    14a6:	f8 01       	movw	r30, r16
    14a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    14aa:	8f 3f       	cpi	r24, 0xFF	; 255
    14ac:	09 f4       	brne	.+2      	; 0x14b0 <xQueueGenericSend+0xaa>
    14ae:	15 8e       	std	Z+29, r1	; 0x1d
    14b0:	f8 01       	movw	r30, r16
    14b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    14b4:	8f 3f       	cpi	r24, 0xFF	; 255
    14b6:	09 f4       	brne	.+2      	; 0x14ba <xQueueGenericSend+0xb4>
    14b8:	16 8e       	std	Z+30, r1	; 0x1e
    14ba:	0f 90       	pop	r0
    14bc:	0f be       	out	0x3f, r0	; 63
    14be:	be 01       	movw	r22, r28
    14c0:	6c 5f       	subi	r22, 0xFC	; 252
    14c2:	7f 4f       	sbci	r23, 0xFF	; 255
    14c4:	ce 01       	movw	r24, r28
    14c6:	01 96       	adiw	r24, 0x01	; 1
    14c8:	3a d7       	rcall	.+3700   	; 0x233e <xTaskCheckForTimeOut>
    14ca:	81 11       	cpse	r24, r1
    14cc:	1a c0       	rjmp	.+52     	; 0x1502 <xQueueGenericSend+0xfc>
    14ce:	0f b6       	in	r0, 0x3f	; 63
    14d0:	f8 94       	cli
    14d2:	0f 92       	push	r0
    14d4:	f8 01       	movw	r30, r16
    14d6:	92 8d       	ldd	r25, Z+26	; 0x1a
    14d8:	0f 90       	pop	r0
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	f8 01       	movw	r30, r16
    14de:	83 8d       	ldd	r24, Z+27	; 0x1b
    14e0:	98 13       	cpse	r25, r24
    14e2:	0b c0       	rjmp	.+22     	; 0x14fa <xQueueGenericSend+0xf4>
    14e4:	6c 81       	ldd	r22, Y+4	; 0x04
    14e6:	7d 81       	ldd	r23, Y+5	; 0x05
    14e8:	c7 01       	movw	r24, r14
    14ea:	ba d6       	rcall	.+3444   	; 0x2260 <vTaskPlaceOnEventList>
    14ec:	c8 01       	movw	r24, r16
    14ee:	e0 de       	rcall	.-576    	; 0x12b0 <prvUnlockQueue>
    14f0:	80 d5       	rcall	.+2816   	; 0x1ff2 <xTaskResumeAll>
    14f2:	81 11       	cpse	r24, r1
    14f4:	a4 cf       	rjmp	.-184    	; 0x143e <xQueueGenericSend+0x38>
    14f6:	af dd       	rcall	.-1186   	; 0x1056 <vPortYield>
    14f8:	a2 cf       	rjmp	.-188    	; 0x143e <xQueueGenericSend+0x38>
    14fa:	c8 01       	movw	r24, r16
    14fc:	d9 de       	rcall	.-590    	; 0x12b0 <prvUnlockQueue>
    14fe:	79 d5       	rcall	.+2802   	; 0x1ff2 <xTaskResumeAll>
    1500:	9e cf       	rjmp	.-196    	; 0x143e <xQueueGenericSend+0x38>
    1502:	c8 01       	movw	r24, r16
    1504:	d5 de       	rcall	.-598    	; 0x12b0 <prvUnlockQueue>
    1506:	75 d5       	rcall	.+2794   	; 0x1ff2 <xTaskResumeAll>
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	0f 90       	pop	r0
    150c:	0f 90       	pop	r0
    150e:	0f 90       	pop	r0
    1510:	0f 90       	pop	r0
    1512:	0f 90       	pop	r0
    1514:	df 91       	pop	r29
    1516:	cf 91       	pop	r28
    1518:	1f 91       	pop	r17
    151a:	0f 91       	pop	r16
    151c:	ff 90       	pop	r15
    151e:	ef 90       	pop	r14
    1520:	df 90       	pop	r13
    1522:	cf 90       	pop	r12
    1524:	bf 90       	pop	r11
    1526:	af 90       	pop	r10
    1528:	9f 90       	pop	r9
    152a:	08 95       	ret

0000152c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    152c:	9f 92       	push	r9
    152e:	af 92       	push	r10
    1530:	bf 92       	push	r11
    1532:	cf 92       	push	r12
    1534:	df 92       	push	r13
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	cf 93       	push	r28
    1540:	df 93       	push	r29
    1542:	00 d0       	rcall	.+0      	; 0x1544 <xQueueGenericReceive+0x18>
    1544:	1f 92       	push	r1
    1546:	1f 92       	push	r1
    1548:	cd b7       	in	r28, 0x3d	; 61
    154a:	de b7       	in	r29, 0x3e	; 62
    154c:	8c 01       	movw	r16, r24
    154e:	6b 01       	movw	r12, r22
    1550:	5d 83       	std	Y+5, r21	; 0x05
    1552:	4c 83       	std	Y+4, r20	; 0x04
    1554:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1556:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1558:	99 24       	eor	r9, r9
    155a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    155c:	7c 01       	movw	r14, r24
    155e:	81 e1       	ldi	r24, 0x11	; 17
    1560:	e8 0e       	add	r14, r24
    1562:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1564:	0f b6       	in	r0, 0x3f	; 63
    1566:	f8 94       	cli
    1568:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    156a:	f8 01       	movw	r30, r16
    156c:	82 8d       	ldd	r24, Z+26	; 0x1a
    156e:	88 23       	and	r24, r24
    1570:	21 f1       	breq	.+72     	; 0x15ba <xQueueGenericReceive+0x8e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1572:	e6 80       	ldd	r14, Z+6	; 0x06
    1574:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1576:	b6 01       	movw	r22, r12
    1578:	c8 01       	movw	r24, r16
    157a:	80 de       	rcall	.-768    	; 0x127c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    157c:	b1 10       	cpse	r11, r1
    157e:	0e c0       	rjmp	.+28     	; 0x159c <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1580:	f8 01       	movw	r30, r16
    1582:	82 8d       	ldd	r24, Z+26	; 0x1a
    1584:	81 50       	subi	r24, 0x01	; 1
    1586:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1588:	80 85       	ldd	r24, Z+8	; 0x08
    158a:	88 23       	and	r24, r24
    158c:	91 f0       	breq	.+36     	; 0x15b2 <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    158e:	c8 01       	movw	r24, r16
    1590:	08 96       	adiw	r24, 0x08	; 8
    1592:	82 d6       	rcall	.+3332   	; 0x2298 <xTaskRemoveFromEventList>
    1594:	81 30       	cpi	r24, 0x01	; 1
    1596:	69 f4       	brne	.+26     	; 0x15b2 <xQueueGenericReceive+0x86>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1598:	5e dd       	rcall	.-1348   	; 0x1056 <vPortYield>
    159a:	0b c0       	rjmp	.+22     	; 0x15b2 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    159c:	f8 01       	movw	r30, r16
    159e:	f7 82       	std	Z+7, r15	; 0x07
    15a0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15a2:	81 89       	ldd	r24, Z+17	; 0x11
    15a4:	88 23       	and	r24, r24
    15a6:	29 f0       	breq	.+10     	; 0x15b2 <xQueueGenericReceive+0x86>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15a8:	c8 01       	movw	r24, r16
    15aa:	41 96       	adiw	r24, 0x11	; 17
    15ac:	75 d6       	rcall	.+3306   	; 0x2298 <xTaskRemoveFromEventList>
    15ae:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    15b0:	52 dd       	rcall	.-1372   	; 0x1056 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    15b2:	0f 90       	pop	r0
    15b4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	44 c0       	rjmp	.+136    	; 0x1642 <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15ba:	4c 81       	ldd	r20, Y+4	; 0x04
    15bc:	5d 81       	ldd	r21, Y+5	; 0x05
    15be:	45 2b       	or	r20, r21
    15c0:	21 f4       	brne	.+8      	; 0x15ca <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15c2:	0f 90       	pop	r0
    15c4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	3c c0       	rjmp	.+120    	; 0x1642 <xQueueGenericReceive+0x116>
				}
				else if( xEntryTimeSet == pdFALSE )
    15ca:	a1 10       	cpse	r10, r1
    15cc:	04 c0       	rjmp	.+8      	; 0x15d6 <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15ce:	ce 01       	movw	r24, r28
    15d0:	01 96       	adiw	r24, 0x01	; 1
    15d2:	aa d6       	rcall	.+3412   	; 0x2328 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15d4:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15d6:	0f 90       	pop	r0
    15d8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15da:	47 d4       	rcall	.+2190   	; 0x1e6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15dc:	0f b6       	in	r0, 0x3f	; 63
    15de:	f8 94       	cli
    15e0:	0f 92       	push	r0
    15e2:	f8 01       	movw	r30, r16
    15e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    15e6:	8f 3f       	cpi	r24, 0xFF	; 255
    15e8:	09 f4       	brne	.+2      	; 0x15ec <xQueueGenericReceive+0xc0>
    15ea:	15 8e       	std	Z+29, r1	; 0x1d
    15ec:	f8 01       	movw	r30, r16
    15ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    15f0:	8f 3f       	cpi	r24, 0xFF	; 255
    15f2:	09 f4       	brne	.+2      	; 0x15f6 <xQueueGenericReceive+0xca>
    15f4:	16 8e       	std	Z+30, r1	; 0x1e
    15f6:	0f 90       	pop	r0
    15f8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15fa:	be 01       	movw	r22, r28
    15fc:	6c 5f       	subi	r22, 0xFC	; 252
    15fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1600:	ce 01       	movw	r24, r28
    1602:	01 96       	adiw	r24, 0x01	; 1
    1604:	9c d6       	rcall	.+3384   	; 0x233e <xTaskCheckForTimeOut>
    1606:	81 11       	cpse	r24, r1
    1608:	18 c0       	rjmp	.+48     	; 0x163a <xQueueGenericReceive+0x10e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1610:	f8 01       	movw	r30, r16
    1612:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1614:	0f 90       	pop	r0
    1616:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1618:	81 11       	cpse	r24, r1
    161a:	0b c0       	rjmp	.+22     	; 0x1632 <xQueueGenericReceive+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    161c:	6c 81       	ldd	r22, Y+4	; 0x04
    161e:	7d 81       	ldd	r23, Y+5	; 0x05
    1620:	c7 01       	movw	r24, r14
    1622:	1e d6       	rcall	.+3132   	; 0x2260 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1624:	c8 01       	movw	r24, r16
    1626:	44 de       	rcall	.-888    	; 0x12b0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1628:	e4 d4       	rcall	.+2504   	; 0x1ff2 <xTaskResumeAll>
    162a:	81 11       	cpse	r24, r1
    162c:	9b cf       	rjmp	.-202    	; 0x1564 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    162e:	13 dd       	rcall	.-1498   	; 0x1056 <vPortYield>
    1630:	99 cf       	rjmp	.-206    	; 0x1564 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1632:	c8 01       	movw	r24, r16
    1634:	3d de       	rcall	.-902    	; 0x12b0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1636:	dd d4       	rcall	.+2490   	; 0x1ff2 <xTaskResumeAll>
    1638:	95 cf       	rjmp	.-214    	; 0x1564 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    163a:	c8 01       	movw	r24, r16
    163c:	39 de       	rcall	.-910    	; 0x12b0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    163e:	d9 d4       	rcall	.+2482   	; 0x1ff2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1640:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1642:	0f 90       	pop	r0
    1644:	0f 90       	pop	r0
    1646:	0f 90       	pop	r0
    1648:	0f 90       	pop	r0
    164a:	0f 90       	pop	r0
    164c:	df 91       	pop	r29
    164e:	cf 91       	pop	r28
    1650:	1f 91       	pop	r17
    1652:	0f 91       	pop	r16
    1654:	ff 90       	pop	r15
    1656:	ef 90       	pop	r14
    1658:	df 90       	pop	r13
    165a:	cf 90       	pop	r12
    165c:	bf 90       	pop	r11
    165e:	af 90       	pop	r10
    1660:	9f 90       	pop	r9
    1662:	08 95       	ret

00001664 <_Z13taskReadSonarPv>:
		}
	}
}

void vApplicationIdleHook()
{
    1664:	c0 e0       	ldi	r28, 0x00	; 0
    1666:	d2 e0       	ldi	r29, 0x02	; 2
    1668:	02 e0       	ldi	r16, 0x02	; 2
    166a:	12 e0       	ldi	r17, 0x02	; 2
    166c:	0f 2e       	mov	r0, r31
    166e:	fe e5       	ldi	r31, 0x5E	; 94
    1670:	ef 2e       	mov	r14, r31
    1672:	f8 e0       	ldi	r31, 0x08	; 8
    1674:	ff 2e       	mov	r15, r31
    1676:	f0 2d       	mov	r31, r0
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	4f ef       	ldi	r20, 0xFF	; 255
    167c:	5f ef       	ldi	r21, 0xFF	; 255
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	70 e0       	ldi	r23, 0x00	; 0
    1682:	80 91 a4 08 	lds	r24, 0x08A4
    1686:	90 91 a5 08 	lds	r25, 0x08A5
    168a:	50 df       	rcall	.-352    	; 0x152c <xQueueGenericReceive>
    168c:	88 23       	and	r24, r24
    168e:	a1 f3       	breq	.-24     	; 0x1678 <_Z13taskReadSonarPv+0x14>
    1690:	60 e0       	ldi	r22, 0x00	; 0
    1692:	88 81       	ld	r24, Y
    1694:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <digitalWrite>
    1698:	85 e0       	ldi	r24, 0x05	; 5
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	0e 94 53 19 	call	0x32a6	; 0x32a6 <delayMicroseconds>
    16a0:	61 e0       	ldi	r22, 0x01	; 1
    16a2:	88 81       	ld	r24, Y
    16a4:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <digitalWrite>
    16a8:	8a e0       	ldi	r24, 0x0A	; 10
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	0e 94 53 19 	call	0x32a6	; 0x32a6 <delayMicroseconds>
    16b0:	60 e0       	ldi	r22, 0x00	; 0
    16b2:	88 81       	ld	r24, Y
    16b4:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <digitalWrite>
    16b8:	60 e0       	ldi	r22, 0x00	; 0
    16ba:	f8 01       	movw	r30, r16
    16bc:	80 81       	ld	r24, Z
    16be:	0e 94 26 1a 	call	0x344c	; 0x344c <pinMode>
    16c2:	20 e4       	ldi	r18, 0x40	; 64
    16c4:	32 e4       	ldi	r19, 0x42	; 66
    16c6:	4f e0       	ldi	r20, 0x0F	; 15
    16c8:	50 e0       	ldi	r21, 0x00	; 0
    16ca:	61 e0       	ldi	r22, 0x01	; 1
    16cc:	f8 01       	movw	r30, r16
    16ce:	80 81       	ld	r24, Z
    16d0:	0e 94 94 1a 	call	0x3528	; 0x3528 <pulseIn>
    16d4:	9b 01       	movw	r18, r22
    16d6:	77 23       	and	r23, r23
    16d8:	14 f4       	brge	.+4      	; 0x16de <_Z13taskReadSonarPv+0x7a>
    16da:	2f 5f       	subi	r18, 0xFF	; 255
    16dc:	3f 4f       	sbci	r19, 0xFF	; 255
    16de:	b9 01       	movw	r22, r18
    16e0:	75 95       	asr	r23
    16e2:	67 95       	ror	r22
    16e4:	88 27       	eor	r24, r24
    16e6:	77 fd       	sbrc	r23, 7
    16e8:	80 95       	com	r24
    16ea:	98 2f       	mov	r25, r24
    16ec:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <__floatsisf>
    16f0:	2d ec       	ldi	r18, 0xCD	; 205
    16f2:	3c ec       	ldi	r19, 0xCC	; 204
    16f4:	48 ee       	ldi	r20, 0xE8	; 232
    16f6:	51 e4       	ldi	r21, 0x41	; 65
    16f8:	0e 94 bf 14 	call	0x297e	; 0x297e <__divsf3>
    16fc:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <__fixsfsi>
    1700:	f7 01       	movw	r30, r14
    1702:	71 83       	std	Z+1, r23	; 0x01
    1704:	60 83       	st	Z, r22
    1706:	20 e0       	ldi	r18, 0x00	; 0
    1708:	40 e0       	ldi	r20, 0x00	; 0
    170a:	50 e0       	ldi	r21, 0x00	; 0
    170c:	60 e0       	ldi	r22, 0x00	; 0
    170e:	70 e0       	ldi	r23, 0x00	; 0
    1710:	80 91 a0 08 	lds	r24, 0x08A0
    1714:	90 91 a1 08 	lds	r25, 0x08A1
    1718:	76 de       	rcall	.-788    	; 0x1406 <xQueueGenericSend>
    171a:	88 e8       	ldi	r24, 0x88	; 136
    171c:	93 e1       	ldi	r25, 0x13	; 19
    171e:	eb d4       	rcall	.+2518   	; 0x20f6 <vTaskDelay>
    1720:	ab cf       	rjmp	.-170    	; 0x1678 <_Z13taskReadSonarPv+0x14>

00001722 <_Z11taskReadAccPv>:
    1722:	0f 2e       	mov	r0, r31
    1724:	fa e7       	ldi	r31, 0x7A	; 122
    1726:	af 2e       	mov	r10, r31
    1728:	f8 e0       	ldi	r31, 0x08	; 8
    172a:	bf 2e       	mov	r11, r31
    172c:	f0 2d       	mov	r31, r0
    172e:	0c e7       	ldi	r16, 0x7C	; 124
    1730:	18 e0       	ldi	r17, 0x08	; 8
    1732:	c0 e6       	ldi	r28, 0x60	; 96
    1734:	d8 e0       	ldi	r29, 0x08	; 8
    1736:	0f 2e       	mov	r0, r31
    1738:	f2 e6       	ldi	r31, 0x62	; 98
    173a:	8f 2e       	mov	r8, r31
    173c:	f8 e0       	ldi	r31, 0x08	; 8
    173e:	9f 2e       	mov	r9, r31
    1740:	f0 2d       	mov	r31, r0
    1742:	0f 2e       	mov	r0, r31
    1744:	f4 e6       	ldi	r31, 0x64	; 100
    1746:	2f 2e       	mov	r2, r31
    1748:	f8 e0       	ldi	r31, 0x08	; 8
    174a:	3f 2e       	mov	r3, r31
    174c:	f0 2d       	mov	r31, r0
    174e:	20 e0       	ldi	r18, 0x00	; 0
    1750:	4f ef       	ldi	r20, 0xFF	; 255
    1752:	5f ef       	ldi	r21, 0xFF	; 255
    1754:	60 e0       	ldi	r22, 0x00	; 0
    1756:	70 e0       	ldi	r23, 0x00	; 0
    1758:	80 91 9e 08 	lds	r24, 0x089E
    175c:	90 91 9f 08 	lds	r25, 0x089F
    1760:	e5 de       	rcall	.-566    	; 0x152c <xQueueGenericReceive>
    1762:	88 23       	and	r24, r24
    1764:	a1 f3       	breq	.-24     	; 0x174e <_Z11taskReadAccPv+0x2c>
    1766:	88 e7       	ldi	r24, 0x78	; 120
    1768:	98 e0       	ldi	r25, 0x08	; 8
    176a:	b1 da       	rcall	.-2718   	; 0xcce <_ZN6LSM3034readEv>
    176c:	f5 01       	movw	r30, r10
    176e:	60 81       	ld	r22, Z
    1770:	71 81       	ldd	r23, Z+1	; 0x01
    1772:	88 27       	eor	r24, r24
    1774:	77 fd       	sbrc	r23, 7
    1776:	80 95       	com	r24
    1778:	98 2f       	mov	r25, r24
    177a:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <__floatsisf>
    177e:	20 e0       	ldi	r18, 0x00	; 0
    1780:	30 e0       	ldi	r19, 0x00	; 0
    1782:	4a e7       	ldi	r20, 0x7A	; 122
    1784:	54 e4       	ldi	r21, 0x44	; 68
    1786:	0e 94 bf 14 	call	0x297e	; 0x297e <__divsf3>
    178a:	20 e0       	ldi	r18, 0x00	; 0
    178c:	30 e0       	ldi	r19, 0x00	; 0
    178e:	44 e7       	ldi	r20, 0x74	; 116
    1790:	52 e4       	ldi	r21, 0x42	; 66
    1792:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    1796:	2f e6       	ldi	r18, 0x6F	; 111
    1798:	32 e1       	ldi	r19, 0x12	; 18
    179a:	43 e8       	ldi	r20, 0x83	; 131
    179c:	5a e3       	ldi	r21, 0x3A	; 58
    179e:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    17a2:	2d ec       	ldi	r18, 0xCD	; 205
    17a4:	3c ec       	ldi	r19, 0xCC	; 204
    17a6:	4c e1       	ldi	r20, 0x1C	; 28
    17a8:	51 e4       	ldi	r21, 0x41	; 65
    17aa:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    17ae:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <__fixsfsi>
    17b2:	2b 01       	movw	r4, r22
    17b4:	3c 01       	movw	r6, r24
    17b6:	f8 01       	movw	r30, r16
    17b8:	60 81       	ld	r22, Z
    17ba:	71 81       	ldd	r23, Z+1	; 0x01
    17bc:	88 27       	eor	r24, r24
    17be:	77 fd       	sbrc	r23, 7
    17c0:	80 95       	com	r24
    17c2:	98 2f       	mov	r25, r24
    17c4:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <__floatsisf>
    17c8:	20 e0       	ldi	r18, 0x00	; 0
    17ca:	30 e0       	ldi	r19, 0x00	; 0
    17cc:	4a e7       	ldi	r20, 0x7A	; 122
    17ce:	54 e4       	ldi	r21, 0x44	; 68
    17d0:	0e 94 bf 14 	call	0x297e	; 0x297e <__divsf3>
    17d4:	20 e0       	ldi	r18, 0x00	; 0
    17d6:	30 e0       	ldi	r19, 0x00	; 0
    17d8:	44 e7       	ldi	r20, 0x74	; 116
    17da:	52 e4       	ldi	r21, 0x42	; 66
    17dc:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    17e0:	2f e6       	ldi	r18, 0x6F	; 111
    17e2:	32 e1       	ldi	r19, 0x12	; 18
    17e4:	43 e8       	ldi	r20, 0x83	; 131
    17e6:	5a e3       	ldi	r21, 0x3A	; 58
    17e8:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    17ec:	2d ec       	ldi	r18, 0xCD	; 205
    17ee:	3c ec       	ldi	r19, 0xCC	; 204
    17f0:	4c e1       	ldi	r20, 0x1C	; 28
    17f2:	51 e4       	ldi	r21, 0x41	; 65
    17f4:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    17f8:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <__fixsfsi>
    17fc:	6b 01       	movw	r12, r22
    17fe:	7c 01       	movw	r14, r24
    1800:	60 91 78 08 	lds	r22, 0x0878
    1804:	70 91 79 08 	lds	r23, 0x0879
    1808:	88 27       	eor	r24, r24
    180a:	77 fd       	sbrc	r23, 7
    180c:	80 95       	com	r24
    180e:	98 2f       	mov	r25, r24
    1810:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <__floatsisf>
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	30 e0       	ldi	r19, 0x00	; 0
    1818:	4a e7       	ldi	r20, 0x7A	; 122
    181a:	54 e4       	ldi	r21, 0x44	; 68
    181c:	0e 94 bf 14 	call	0x297e	; 0x297e <__divsf3>
    1820:	20 e0       	ldi	r18, 0x00	; 0
    1822:	30 e0       	ldi	r19, 0x00	; 0
    1824:	44 e7       	ldi	r20, 0x74	; 116
    1826:	52 e4       	ldi	r21, 0x42	; 66
    1828:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    182c:	2f e6       	ldi	r18, 0x6F	; 111
    182e:	32 e1       	ldi	r19, 0x12	; 18
    1830:	43 e8       	ldi	r20, 0x83	; 131
    1832:	5a e3       	ldi	r21, 0x3A	; 58
    1834:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    1838:	2d ec       	ldi	r18, 0xCD	; 205
    183a:	3c ec       	ldi	r19, 0xCC	; 204
    183c:	4c e1       	ldi	r20, 0x1C	; 28
    183e:	51 e4       	ldi	r21, 0x41	; 65
    1840:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <__mulsf3>
    1844:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <__fixsfsi>
    1848:	79 83       	std	Y+1, r23	; 0x01
    184a:	68 83       	st	Y, r22
    184c:	f4 01       	movw	r30, r8
    184e:	51 82       	std	Z+1, r5	; 0x01
    1850:	40 82       	st	Z, r4
    1852:	f1 01       	movw	r30, r2
    1854:	d1 82       	std	Z+1, r13	; 0x01
    1856:	c0 82       	st	Z, r12
    1858:	20 e0       	ldi	r18, 0x00	; 0
    185a:	40 e0       	ldi	r20, 0x00	; 0
    185c:	50 e0       	ldi	r21, 0x00	; 0
    185e:	60 e0       	ldi	r22, 0x00	; 0
    1860:	70 e0       	ldi	r23, 0x00	; 0
    1862:	80 91 a4 08 	lds	r24, 0x08A4
    1866:	90 91 a5 08 	lds	r25, 0x08A5
    186a:	cd dd       	rcall	.-1126   	; 0x1406 <xQueueGenericSend>
    186c:	88 ee       	ldi	r24, 0xE8	; 232
    186e:	93 e0       	ldi	r25, 0x03	; 3
    1870:	42 d4       	rcall	.+2180   	; 0x20f6 <vTaskDelay>
    1872:	6d cf       	rjmp	.-294    	; 0x174e <_Z11taskReadAccPv+0x2c>

00001874 <_Z12taskReadGyroPv>:
    1874:	0f 2e       	mov	r0, r31
    1876:	fe e6       	ldi	r31, 0x6E	; 110
    1878:	af 2e       	mov	r10, r31
    187a:	f8 e0       	ldi	r31, 0x08	; 8
    187c:	bf 2e       	mov	r11, r31
    187e:	f0 2d       	mov	r31, r0
    1880:	0f 2e       	mov	r0, r31
    1882:	f0 e7       	ldi	r31, 0x70	; 112
    1884:	cf 2e       	mov	r12, r31
    1886:	f8 e0       	ldi	r31, 0x08	; 8
    1888:	df 2e       	mov	r13, r31
    188a:	f0 2d       	mov	r31, r0
    188c:	0f 2e       	mov	r0, r31
    188e:	f6 e6       	ldi	r31, 0x66	; 102
    1890:	ef 2e       	mov	r14, r31
    1892:	f8 e0       	ldi	r31, 0x08	; 8
    1894:	ff 2e       	mov	r15, r31
    1896:	f0 2d       	mov	r31, r0
    1898:	08 e6       	ldi	r16, 0x68	; 104
    189a:	18 e0       	ldi	r17, 0x08	; 8
    189c:	ca e6       	ldi	r28, 0x6A	; 106
    189e:	d8 e0       	ldi	r29, 0x08	; 8
    18a0:	20 e0       	ldi	r18, 0x00	; 0
    18a2:	4f ef       	ldi	r20, 0xFF	; 255
    18a4:	5f ef       	ldi	r21, 0xFF	; 255
    18a6:	60 e0       	ldi	r22, 0x00	; 0
    18a8:	70 e0       	ldi	r23, 0x00	; 0
    18aa:	80 91 a0 08 	lds	r24, 0x08A0
    18ae:	90 91 a1 08 	lds	r25, 0x08A1
    18b2:	3c de       	rcall	.-904    	; 0x152c <xQueueGenericReceive>
    18b4:	88 23       	and	r24, r24
    18b6:	a1 f3       	breq	.-24     	; 0x18a0 <_Z12taskReadGyroPv+0x2c>
    18b8:	8c e6       	ldi	r24, 0x6C	; 108
    18ba:	98 e0       	ldi	r25, 0x08	; 8
    18bc:	0e 94 c9 02 	call	0x592	; 0x592 <_ZN3L3G4readEv>
    18c0:	f5 01       	movw	r30, r10
    18c2:	20 81       	ld	r18, Z
    18c4:	31 81       	ldd	r19, Z+1	; 0x01
    18c6:	f6 01       	movw	r30, r12
    18c8:	80 81       	ld	r24, Z
    18ca:	91 81       	ldd	r25, Z+1	; 0x01
    18cc:	40 91 6c 08 	lds	r20, 0x086C
    18d0:	50 91 6d 08 	lds	r21, 0x086D
    18d4:	f7 01       	movw	r30, r14
    18d6:	51 83       	std	Z+1, r21	; 0x01
    18d8:	40 83       	st	Z, r20
    18da:	f8 01       	movw	r30, r16
    18dc:	31 83       	std	Z+1, r19	; 0x01
    18de:	20 83       	st	Z, r18
    18e0:	99 83       	std	Y+1, r25	; 0x01
    18e2:	88 83       	st	Y, r24
    18e4:	20 e0       	ldi	r18, 0x00	; 0
    18e6:	40 e0       	ldi	r20, 0x00	; 0
    18e8:	50 e0       	ldi	r21, 0x00	; 0
    18ea:	60 e0       	ldi	r22, 0x00	; 0
    18ec:	70 e0       	ldi	r23, 0x00	; 0
    18ee:	80 91 9e 08 	lds	r24, 0x089E
    18f2:	90 91 9f 08 	lds	r25, 0x089F
    18f6:	87 dd       	rcall	.-1266   	; 0x1406 <xQueueGenericSend>
    18f8:	88 ee       	ldi	r24, 0xE8	; 232
    18fa:	93 e0       	ldi	r25, 0x03	; 3
    18fc:	fc d3       	rcall	.+2040   	; 0x20f6 <vTaskDelay>
    18fe:	d0 cf       	rjmp	.-96     	; 0x18a0 <_Z12taskReadGyroPv+0x2c>

00001900 <__vector_36>:
    1900:	1f 92       	push	r1
    1902:	0f 92       	push	r0
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	0f 92       	push	r0
    1908:	11 24       	eor	r1, r1
    190a:	0f 90       	pop	r0
    190c:	0f be       	out	0x3f, r0	; 63
    190e:	0f 90       	pop	r0
    1910:	1f 90       	pop	r1
    1912:	18 95       	reti

00001914 <setup>:
	// Do nothing.
}

void setup(void) 
{
	vSemaphoreCreateBinary(sonarSema);
    1914:	43 e0       	ldi	r20, 0x03	; 3
    1916:	60 e0       	ldi	r22, 0x00	; 0
    1918:	81 e0       	ldi	r24, 0x01	; 1
    191a:	4b dd       	rcall	.-1386   	; 0x13b2 <xQueueGenericCreate>
    191c:	90 93 a5 08 	sts	0x08A5, r25
    1920:	80 93 a4 08 	sts	0x08A4, r24
    1924:	00 97       	sbiw	r24, 0x00	; 0
    1926:	31 f0       	breq	.+12     	; 0x1934 <setup+0x20>
    1928:	20 e0       	ldi	r18, 0x00	; 0
    192a:	40 e0       	ldi	r20, 0x00	; 0
    192c:	50 e0       	ldi	r21, 0x00	; 0
    192e:	60 e0       	ldi	r22, 0x00	; 0
    1930:	70 e0       	ldi	r23, 0x00	; 0
    1932:	69 dd       	rcall	.-1326   	; 0x1406 <xQueueGenericSend>
	vSemaphoreCreateBinary(acceSema);
    1934:	43 e0       	ldi	r20, 0x03	; 3
    1936:	60 e0       	ldi	r22, 0x00	; 0
    1938:	81 e0       	ldi	r24, 0x01	; 1
    193a:	3b dd       	rcall	.-1418   	; 0x13b2 <xQueueGenericCreate>
    193c:	90 93 9f 08 	sts	0x089F, r25
    1940:	80 93 9e 08 	sts	0x089E, r24
    1944:	00 97       	sbiw	r24, 0x00	; 0
    1946:	31 f0       	breq	.+12     	; 0x1954 <setup+0x40>
    1948:	20 e0       	ldi	r18, 0x00	; 0
    194a:	40 e0       	ldi	r20, 0x00	; 0
    194c:	50 e0       	ldi	r21, 0x00	; 0
    194e:	60 e0       	ldi	r22, 0x00	; 0
    1950:	70 e0       	ldi	r23, 0x00	; 0
    1952:	59 dd       	rcall	.-1358   	; 0x1406 <xQueueGenericSend>
	vSemaphoreCreateBinary(magnetoSema);
    1954:	43 e0       	ldi	r20, 0x03	; 3
    1956:	60 e0       	ldi	r22, 0x00	; 0
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	2b dd       	rcall	.-1450   	; 0x13b2 <xQueueGenericCreate>
    195c:	90 93 a3 08 	sts	0x08A3, r25
    1960:	80 93 a2 08 	sts	0x08A2, r24
    1964:	00 97       	sbiw	r24, 0x00	; 0
    1966:	31 f0       	breq	.+12     	; 0x1974 <setup+0x60>
    1968:	20 e0       	ldi	r18, 0x00	; 0
    196a:	40 e0       	ldi	r20, 0x00	; 0
    196c:	50 e0       	ldi	r21, 0x00	; 0
    196e:	60 e0       	ldi	r22, 0x00	; 0
    1970:	70 e0       	ldi	r23, 0x00	; 0
    1972:	49 dd       	rcall	.-1390   	; 0x1406 <xQueueGenericSend>
	vSemaphoreCreateBinary(gyroSema);
    1974:	43 e0       	ldi	r20, 0x03	; 3
    1976:	60 e0       	ldi	r22, 0x00	; 0
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	1b dd       	rcall	.-1482   	; 0x13b2 <xQueueGenericCreate>
    197c:	90 93 a1 08 	sts	0x08A1, r25
    1980:	80 93 a0 08 	sts	0x08A0, r24
    1984:	00 97       	sbiw	r24, 0x00	; 0
    1986:	31 f0       	breq	.+12     	; 0x1994 <setup+0x80>
    1988:	20 e0       	ldi	r18, 0x00	; 0
    198a:	40 e0       	ldi	r20, 0x00	; 0
    198c:	50 e0       	ldi	r21, 0x00	; 0
    198e:	60 e0       	ldi	r22, 0x00	; 0
    1990:	70 e0       	ldi	r23, 0x00	; 0
    1992:	39 dd       	rcall	.-1422   	; 0x1406 <xQueueGenericSend>
	xSemaphoreGive(gyroSema);
    1994:	20 e0       	ldi	r18, 0x00	; 0
    1996:	40 e0       	ldi	r20, 0x00	; 0
    1998:	50 e0       	ldi	r21, 0x00	; 0
    199a:	60 e0       	ldi	r22, 0x00	; 0
    199c:	70 e0       	ldi	r23, 0x00	; 0
    199e:	80 91 a0 08 	lds	r24, 0x08A0
    19a2:	90 91 a1 08 	lds	r25, 0x08A1
    19a6:	2f dd       	rcall	.-1442   	; 0x1406 <xQueueGenericSend>
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    19a8:	26 e0       	ldi	r18, 0x06	; 6
    19aa:	40 e8       	ldi	r20, 0x80	; 128
    19ac:	55 e2       	ldi	r21, 0x25	; 37
    19ae:	60 e0       	ldi	r22, 0x00	; 0
    19b0:	70 e0       	ldi	r23, 0x00	; 0
    19b2:	8f eb       	ldi	r24, 0xBF	; 191
    19b4:	99 e0       	ldi	r25, 0x09	; 9
    19b6:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <_ZN14HardwareSerial5beginEmh>
	// Starting up serial monitor
	Serial.begin(9600);
	// Setting up compass
	Wire.begin();
    19ba:	8d e6       	ldi	r24, 0x6D	; 109
    19bc:	99 e0       	ldi	r25, 0x09	; 9
    19be:	a3 d7       	rcall	.+3910   	; 0x2906 <_ZN7TwoWire5beginEv>
	compass.init();
    19c0:	42 e0       	ldi	r20, 0x02	; 2
    19c2:	64 e0       	ldi	r22, 0x04	; 4
    19c4:	88 e7       	ldi	r24, 0x78	; 120
    19c6:	98 e0       	ldi	r25, 0x08	; 8
    19c8:	b7 d9       	rcall	.-3218   	; 0xd38 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    19ca:	88 e7       	ldi	r24, 0x78	; 120
    19cc:	98 e0       	ldi	r25, 0x08	; 8
    19ce:	0e d8       	rcall	.-4068   	; 0x9ec <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    19d0:	86 e0       	ldi	r24, 0x06	; 6
    19d2:	e2 e1       	ldi	r30, 0x12	; 18
    19d4:	f2 e0       	ldi	r31, 0x02	; 2
    19d6:	aa e8       	ldi	r26, 0x8A	; 138
    19d8:	b8 e0       	ldi	r27, 0x08	; 8
    19da:	01 90       	ld	r0, Z+
    19dc:	0d 92       	st	X+, r0
    19de:	8a 95       	dec	r24
    19e0:	e1 f7       	brne	.-8      	; 0x19da <setup+0xc6>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    19e2:	86 e0       	ldi	r24, 0x06	; 6
    19e4:	e8 e1       	ldi	r30, 0x18	; 24
    19e6:	f2 e0       	ldi	r31, 0x02	; 2
    19e8:	a4 e8       	ldi	r26, 0x84	; 132
    19ea:	b8 e0       	ldi	r27, 0x08	; 8
    19ec:	01 90       	ld	r0, Z+
    19ee:	0d 92       	st	X+, r0
    19f0:	8a 95       	dec	r24
    19f2:	e1 f7       	brne	.-8      	; 0x19ec <setup+0xd8>
	gyro.init();
    19f4:	42 e0       	ldi	r20, 0x02	; 2
    19f6:	63 e0       	ldi	r22, 0x03	; 3
    19f8:	8c e6       	ldi	r24, 0x6C	; 108
    19fa:	98 e0       	ldi	r25, 0x08	; 8
    19fc:	0e 94 6d 03 	call	0x6da	; 0x6da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
	gyro.enableDefault();
    1a00:	8c e6       	ldi	r24, 0x6C	; 108
    1a02:	98 e0       	ldi	r25, 0x08	; 8
    1a04:	0e 94 b4 02 	call	0x568	; 0x568 <_ZN3L3G13enableDefaultEv>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    1a08:	61 e0       	ldi	r22, 0x01	; 1
    1a0a:	80 91 00 02 	lds	r24, 0x0200
    1a0e:	0e 94 26 1a 	call	0x344c	; 0x344c <pinMode>
	pinMode(echo_1, INPUT);
    1a12:	60 e0       	ldi	r22, 0x00	; 0
    1a14:	80 91 02 02 	lds	r24, 0x0202
    1a18:	0c 94 26 1a 	jmp	0x344c	; 0x344c <pinMode>
    1a1c:	08 95       	ret

00001a1e <main>:
}

int main(void)
{
    1a1e:	af 92       	push	r10
    1a20:	bf 92       	push	r11
    1a22:	cf 92       	push	r12
    1a24:	df 92       	push	r13
    1a26:	ef 92       	push	r14
    1a28:	ff 92       	push	r15
    1a2a:	0f 93       	push	r16
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
    1a30:	cd b7       	in	r28, 0x3d	; 61
    1a32:	de b7       	in	r29, 0x3e	; 62
    1a34:	28 97       	sbiw	r28, 0x08	; 8
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	de bf       	out	0x3e, r29	; 62
    1a3c:	0f be       	out	0x3f, r0	; 63
    1a3e:	cd bf       	out	0x3d, r28	; 61
	init();
    1a40:	0e 94 5e 19 	call	0x32bc	; 0x32bc <init>
	setup();
    1a44:	67 df       	rcall	.-306    	; 0x1914 <setup>
	TaskHandle_t t1, t2, t3, t4, t5;
	// Create tasks
	xTaskCreate(printArray, "printA", STACK_DEPTH, NULL, 10, &t1);
    1a46:	a1 2c       	mov	r10, r1
    1a48:	b1 2c       	mov	r11, r1
    1a4a:	c1 2c       	mov	r12, r1
    1a4c:	d1 2c       	mov	r13, r1
    1a4e:	ce 01       	movw	r24, r28
    1a50:	07 96       	adiw	r24, 0x07	; 7
    1a52:	7c 01       	movw	r14, r24
    1a54:	0a e0       	ldi	r16, 0x0A	; 10
    1a56:	20 e0       	ldi	r18, 0x00	; 0
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	40 e8       	ldi	r20, 0x80	; 128
    1a5c:	50 e0       	ldi	r21, 0x00	; 0
    1a5e:	6e e1       	ldi	r22, 0x1E	; 30
    1a60:	72 e0       	ldi	r23, 0x02	; 2
    1a62:	85 e7       	ldi	r24, 0x75	; 117
    1a64:	9d e0       	ldi	r25, 0x0D	; 13
    1a66:	d0 d0       	rcall	.+416    	; 0x1c08 <xTaskGenericCreate>
	xTaskCreate(taskReadGyro, "Read Gyrometer", STACK_DEPTH, NULL, 5, &t2);
    1a68:	ce 01       	movw	r24, r28
    1a6a:	05 96       	adiw	r24, 0x05	; 5
    1a6c:	7c 01       	movw	r14, r24
    1a6e:	05 e0       	ldi	r16, 0x05	; 5
    1a70:	20 e0       	ldi	r18, 0x00	; 0
    1a72:	30 e0       	ldi	r19, 0x00	; 0
    1a74:	40 e8       	ldi	r20, 0x80	; 128
    1a76:	50 e0       	ldi	r21, 0x00	; 0
    1a78:	65 e2       	ldi	r22, 0x25	; 37
    1a7a:	72 e0       	ldi	r23, 0x02	; 2
    1a7c:	8a e3       	ldi	r24, 0x3A	; 58
    1a7e:	9c e0       	ldi	r25, 0x0C	; 12
    1a80:	c3 d0       	rcall	.+390    	; 0x1c08 <xTaskGenericCreate>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 5, &t3);
    1a82:	ce 01       	movw	r24, r28
    1a84:	03 96       	adiw	r24, 0x03	; 3
    1a86:	7c 01       	movw	r14, r24
    1a88:	20 e0       	ldi	r18, 0x00	; 0
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	40 e8       	ldi	r20, 0x80	; 128
    1a8e:	50 e0       	ldi	r21, 0x00	; 0
    1a90:	64 e3       	ldi	r22, 0x34	; 52
    1a92:	72 e0       	ldi	r23, 0x02	; 2
    1a94:	81 e9       	ldi	r24, 0x91	; 145
    1a96:	9b e0       	ldi	r25, 0x0B	; 11
    1a98:	b7 d0       	rcall	.+366    	; 0x1c08 <xTaskGenericCreate>
	//xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 5, &t4);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t5);
    1a9a:	ce 01       	movw	r24, r28
    1a9c:	01 96       	adiw	r24, 0x01	; 1
    1a9e:	7c 01       	movw	r14, r24
    1aa0:	20 e0       	ldi	r18, 0x00	; 0
    1aa2:	30 e0       	ldi	r19, 0x00	; 0
    1aa4:	40 e8       	ldi	r20, 0x80	; 128
    1aa6:	50 e0       	ldi	r21, 0x00	; 0
    1aa8:	67 e4       	ldi	r22, 0x47	; 71
    1aaa:	72 e0       	ldi	r23, 0x02	; 2
    1aac:	82 e3       	ldi	r24, 0x32	; 50
    1aae:	9b e0       	ldi	r25, 0x0B	; 11
    1ab0:	ab d0       	rcall	.+342    	; 0x1c08 <xTaskGenericCreate>
	vTaskStartScheduler();
    1ab2:	b2 d1       	rcall	.+868    	; 0x1e18 <vTaskStartScheduler>
}
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	90 e0       	ldi	r25, 0x00	; 0
    1ab8:	28 96       	adiw	r28, 0x08	; 8
    1aba:	0f b6       	in	r0, 0x3f	; 63
    1abc:	f8 94       	cli
    1abe:	de bf       	out	0x3e, r29	; 62
    1ac0:	0f be       	out	0x3f, r0	; 63
    1ac2:	cd bf       	out	0x3d, r28	; 61
    1ac4:	df 91       	pop	r29
    1ac6:	cf 91       	pop	r28
    1ac8:	0f 91       	pop	r16
    1aca:	ff 90       	pop	r15
    1acc:	ef 90       	pop	r14
    1ace:	df 90       	pop	r13
    1ad0:	cf 90       	pop	r12
    1ad2:	bf 90       	pop	r11
    1ad4:	af 90       	pop	r10
    1ad6:	08 95       	ret

00001ad8 <_GLOBAL__sub_I_sonarSema>:
xSemaphoreHandle sonarSema, magnetoSema, gyroSema, acceSema = 0;
int echo_1 = 3; //pin 3 for sonar echo
int trigger_1 = 4; //pin 4 for sonar trigger
int analog_1 = 0; 
int numOfData = 8;
LSM303 compass;
    1ad8:	88 e7       	ldi	r24, 0x78	; 120
    1ada:	98 e0       	ldi	r25, 0x08	; 8
    1adc:	0e 94 8f 04 	call	0x91e	; 0x91e <_ZN6LSM303C1Ev>
L3G gyro;
    1ae0:	8c e6       	ldi	r24, 0x6C	; 108
    1ae2:	98 e0       	ldi	r25, 0x08	; 8
    1ae4:	0c 94 8d 02 	jmp	0x51a	; 0x51a <_ZN3L3GC1Ev>
    1ae8:	08 95       	ret

00001aea <_Z10printArrayPv>:
	
}

void printArray(void *p) {
	int i;
	char canRead = '0';
    1aea:	c0 e3       	ldi	r28, 0x30	; 48
    1aec:	0f 2e       	mov	r0, r31
    1aee:	fe e5       	ldi	r31, 0x5E	; 94
    1af0:	ef 2e       	mov	r14, r31
    1af2:	f8 e0       	ldi	r31, 0x08	; 8
    1af4:	ff 2e       	mov	r15, r31
    1af6:	f0 2d       	mov	r31, r0
    1af8:	0c e6       	ldi	r16, 0x6C	; 108
    1afa:	18 e0       	ldi	r17, 0x08	; 8
	while(1) {
		if(Serial.available()){
    1afc:	8f eb       	ldi	r24, 0xBF	; 191
    1afe:	99 e0       	ldi	r25, 0x09	; 9
    1b00:	0e 94 49 16 	call	0x2c92	; 0x2c92 <_ZN14HardwareSerial9availableEv>
    1b04:	89 2b       	or	r24, r25
    1b06:	29 f0       	breq	.+10     	; 0x1b12 <_Z10printArrayPv+0x28>
			canRead = Serial.read();
    1b08:	8f eb       	ldi	r24, 0xBF	; 191
    1b0a:	99 e0       	ldi	r25, 0x09	; 9
    1b0c:	0e 94 62 16 	call	0x2cc4	; 0x2cc4 <_ZN14HardwareSerial4readEv>
    1b10:	c8 2f       	mov	r28, r24
		}
		if(canRead - '0'){
    1b12:	c0 33       	cpi	r28, 0x30	; 48
    1b14:	f9 f0       	breq	.+62     	; 0x1b54 <_Z10printArrayPv+0x6a>
			Serial.print(7);
    1b16:	4a e0       	ldi	r20, 0x0A	; 10
    1b18:	50 e0       	ldi	r21, 0x00	; 0
    1b1a:	67 e0       	ldi	r22, 0x07	; 7
    1b1c:	70 e0       	ldi	r23, 0x00	; 0
    1b1e:	8f eb       	ldi	r24, 0xBF	; 191
    1b20:	99 e0       	ldi	r25, 0x09	; 9
    1b22:	0e 94 f5 18 	call	0x31ea	; 0x31ea <_ZN5Print5printEii>
			Serial.print('\r');
    1b26:	6d e0       	ldi	r22, 0x0D	; 13
    1b28:	8f eb       	ldi	r24, 0xBF	; 191
    1b2a:	99 e0       	ldi	r25, 0x09	; 9
    1b2c:	0e 94 3b 18 	call	0x3076	; 0x3076 <_ZN5Print5printEc>
    1b30:	e7 01       	movw	r28, r14
			for(i = 1; i < 8; i++) {
				Serial.print(data[i]);
    1b32:	69 91       	ld	r22, Y+
    1b34:	79 91       	ld	r23, Y+
    1b36:	4a e0       	ldi	r20, 0x0A	; 10
    1b38:	50 e0       	ldi	r21, 0x00	; 0
    1b3a:	8f eb       	ldi	r24, 0xBF	; 191
    1b3c:	99 e0       	ldi	r25, 0x09	; 9
    1b3e:	0e 94 f5 18 	call	0x31ea	; 0x31ea <_ZN5Print5printEii>
				Serial.print('\r');
    1b42:	6d e0       	ldi	r22, 0x0D	; 13
    1b44:	8f eb       	ldi	r24, 0xBF	; 191
    1b46:	99 e0       	ldi	r25, 0x09	; 9
    1b48:	0e 94 3b 18 	call	0x3076	; 0x3076 <_ZN5Print5printEc>
			canRead = Serial.read();
		}
		if(canRead - '0'){
			Serial.print(7);
			Serial.print('\r');
			for(i = 1; i < 8; i++) {
    1b4c:	c0 17       	cp	r28, r16
    1b4e:	d1 07       	cpc	r29, r17
    1b50:	81 f7       	brne	.-32     	; 0x1b32 <_Z10printArrayPv+0x48>
				Serial.print(data[i]);
				Serial.print('\r');
			}
			canRead = '0';
    1b52:	c0 e3       	ldi	r28, 0x30	; 48
		}
		vTaskDelay(1000);
    1b54:	88 ee       	ldi	r24, 0xE8	; 232
    1b56:	93 e0       	ldi	r25, 0x03	; 3
    1b58:	ce d2       	rcall	.+1436   	; 0x20f6 <vTaskDelay>
			Serial.print(-12);
			Serial.print('\r');
			Serial.print(456.2);
			Serial.print('\r');
		*/
	}
    1b5a:	d0 cf       	rjmp	.-96     	; 0x1afc <_Z10printArrayPv+0x12>

00001b5c <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1b5c:	e0 91 c5 08 	lds	r30, 0x08C5
    1b60:	f0 91 c6 08 	lds	r31, 0x08C6
    1b64:	80 81       	ld	r24, Z
    1b66:	81 11       	cpse	r24, r1
    1b68:	07 c0       	rjmp	.+14     	; 0x1b78 <prvResetNextTaskUnblockTime+0x1c>
    1b6a:	8f ef       	ldi	r24, 0xFF	; 255
    1b6c:	9f ef       	ldi	r25, 0xFF	; 255
    1b6e:	90 93 05 02 	sts	0x0205, r25
    1b72:	80 93 04 02 	sts	0x0204, r24
    1b76:	08 95       	ret
    1b78:	e0 91 c5 08 	lds	r30, 0x08C5
    1b7c:	f0 91 c6 08 	lds	r31, 0x08C6
    1b80:	05 80       	ldd	r0, Z+5	; 0x05
    1b82:	f6 81       	ldd	r31, Z+6	; 0x06
    1b84:	e0 2d       	mov	r30, r0
    1b86:	06 80       	ldd	r0, Z+6	; 0x06
    1b88:	f7 81       	ldd	r31, Z+7	; 0x07
    1b8a:	e0 2d       	mov	r30, r0
    1b8c:	82 81       	ldd	r24, Z+2	; 0x02
    1b8e:	93 81       	ldd	r25, Z+3	; 0x03
    1b90:	90 93 05 02 	sts	0x0205, r25
    1b94:	80 93 04 02 	sts	0x0204, r24
    1b98:	08 95       	ret

00001b9a <prvAddCurrentTaskToDelayedList>:
    1b9a:	cf 93       	push	r28
    1b9c:	df 93       	push	r29
    1b9e:	ec 01       	movw	r28, r24
    1ba0:	e0 91 fd 08 	lds	r30, 0x08FD
    1ba4:	f0 91 fe 08 	lds	r31, 0x08FE
    1ba8:	93 83       	std	Z+3, r25	; 0x03
    1baa:	82 83       	std	Z+2, r24	; 0x02
    1bac:	80 91 ad 08 	lds	r24, 0x08AD
    1bb0:	90 91 ae 08 	lds	r25, 0x08AE
    1bb4:	c8 17       	cp	r28, r24
    1bb6:	d9 07       	cpc	r29, r25
    1bb8:	68 f4       	brcc	.+26     	; 0x1bd4 <prvAddCurrentTaskToDelayedList+0x3a>
    1bba:	60 91 fd 08 	lds	r22, 0x08FD
    1bbe:	70 91 fe 08 	lds	r23, 0x08FE
    1bc2:	80 91 c3 08 	lds	r24, 0x08C3
    1bc6:	90 91 c4 08 	lds	r25, 0x08C4
    1bca:	6e 5f       	subi	r22, 0xFE	; 254
    1bcc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bce:	0e 94 38 04 	call	0x870	; 0x870 <vListInsert>
    1bd2:	17 c0       	rjmp	.+46     	; 0x1c02 <prvAddCurrentTaskToDelayedList+0x68>
    1bd4:	60 91 fd 08 	lds	r22, 0x08FD
    1bd8:	70 91 fe 08 	lds	r23, 0x08FE
    1bdc:	80 91 c5 08 	lds	r24, 0x08C5
    1be0:	90 91 c6 08 	lds	r25, 0x08C6
    1be4:	6e 5f       	subi	r22, 0xFE	; 254
    1be6:	7f 4f       	sbci	r23, 0xFF	; 255
    1be8:	0e 94 38 04 	call	0x870	; 0x870 <vListInsert>
    1bec:	80 91 04 02 	lds	r24, 0x0204
    1bf0:	90 91 05 02 	lds	r25, 0x0205
    1bf4:	c8 17       	cp	r28, r24
    1bf6:	d9 07       	cpc	r29, r25
    1bf8:	20 f4       	brcc	.+8      	; 0x1c02 <prvAddCurrentTaskToDelayedList+0x68>
    1bfa:	d0 93 05 02 	sts	0x0205, r29
    1bfe:	c0 93 04 02 	sts	0x0204, r28
    1c02:	df 91       	pop	r29
    1c04:	cf 91       	pop	r28
    1c06:	08 95       	ret

00001c08 <xTaskGenericCreate>:
    1c08:	4f 92       	push	r4
    1c0a:	5f 92       	push	r5
    1c0c:	6f 92       	push	r6
    1c0e:	7f 92       	push	r7
    1c10:	8f 92       	push	r8
    1c12:	9f 92       	push	r9
    1c14:	af 92       	push	r10
    1c16:	bf 92       	push	r11
    1c18:	cf 92       	push	r12
    1c1a:	df 92       	push	r13
    1c1c:	ef 92       	push	r14
    1c1e:	ff 92       	push	r15
    1c20:	0f 93       	push	r16
    1c22:	1f 93       	push	r17
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	4c 01       	movw	r8, r24
    1c2a:	5b 01       	movw	r10, r22
    1c2c:	2a 01       	movw	r4, r20
    1c2e:	39 01       	movw	r6, r18
    1c30:	81 e2       	ldi	r24, 0x21	; 33
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	0e 94 57 02 	call	0x4ae	; 0x4ae <pvPortMalloc>
    1c38:	ec 01       	movw	r28, r24
    1c3a:	00 97       	sbiw	r24, 0x00	; 0
    1c3c:	09 f4       	brne	.+2      	; 0x1c40 <xTaskGenericCreate+0x38>
    1c3e:	da c0       	rjmp	.+436    	; 0x1df4 <xTaskGenericCreate+0x1ec>
    1c40:	c1 14       	cp	r12, r1
    1c42:	d1 04       	cpc	r13, r1
    1c44:	09 f0       	breq	.+2      	; 0x1c48 <xTaskGenericCreate+0x40>
    1c46:	bf c0       	rjmp	.+382    	; 0x1dc6 <xTaskGenericCreate+0x1be>
    1c48:	c2 01       	movw	r24, r4
    1c4a:	0e 94 57 02 	call	0x4ae	; 0x4ae <pvPortMalloc>
    1c4e:	98 8f       	std	Y+24, r25	; 0x18
    1c50:	8f 8b       	std	Y+23, r24	; 0x17
    1c52:	89 2b       	or	r24, r25
    1c54:	09 f0       	breq	.+2      	; 0x1c58 <xTaskGenericCreate+0x50>
    1c56:	b9 c0       	rjmp	.+370    	; 0x1dca <xTaskGenericCreate+0x1c2>
    1c58:	ce 01       	movw	r24, r28
    1c5a:	0e 94 8c 02 	call	0x518	; 0x518 <vPortFree>
    1c5e:	ca c0       	rjmp	.+404    	; 0x1df4 <xTaskGenericCreate+0x1ec>
    1c60:	cf 01       	movw	r24, r30
    1c62:	31 91       	ld	r19, Z+
    1c64:	da 01       	movw	r26, r20
    1c66:	3d 93       	st	X+, r19
    1c68:	ad 01       	movw	r20, r26
    1c6a:	dc 01       	movw	r26, r24
    1c6c:	8c 91       	ld	r24, X
    1c6e:	88 23       	and	r24, r24
    1c70:	11 f0       	breq	.+4      	; 0x1c76 <xTaskGenericCreate+0x6e>
    1c72:	21 50       	subi	r18, 0x01	; 1
    1c74:	a9 f7       	brne	.-22     	; 0x1c60 <xTaskGenericCreate+0x58>
    1c76:	18 a2       	std	Y+32, r1	; 0x20
    1c78:	10 2f       	mov	r17, r16
    1c7a:	04 30       	cpi	r16, 0x04	; 4
    1c7c:	08 f0       	brcs	.+2      	; 0x1c80 <xTaskGenericCreate+0x78>
    1c7e:	13 e0       	ldi	r17, 0x03	; 3
    1c80:	1e 8b       	std	Y+22, r17	; 0x16
    1c82:	5e 01       	movw	r10, r28
    1c84:	b2 e0       	ldi	r27, 0x02	; 2
    1c86:	ab 0e       	add	r10, r27
    1c88:	b1 1c       	adc	r11, r1
    1c8a:	c5 01       	movw	r24, r10
    1c8c:	0e 94 13 04 	call	0x826	; 0x826 <vListInitialiseItem>
    1c90:	ce 01       	movw	r24, r28
    1c92:	0c 96       	adiw	r24, 0x0c	; 12
    1c94:	0e 94 13 04 	call	0x826	; 0x826 <vListInitialiseItem>
    1c98:	d9 87       	std	Y+9, r29	; 0x09
    1c9a:	c8 87       	std	Y+8, r28	; 0x08
    1c9c:	84 e0       	ldi	r24, 0x04	; 4
    1c9e:	90 e0       	ldi	r25, 0x00	; 0
    1ca0:	81 1b       	sub	r24, r17
    1ca2:	91 09       	sbc	r25, r1
    1ca4:	9d 87       	std	Y+13, r25	; 0x0d
    1ca6:	8c 87       	std	Y+12, r24	; 0x0c
    1ca8:	db 8b       	std	Y+19, r29	; 0x13
    1caa:	ca 8b       	std	Y+18, r28	; 0x12
    1cac:	a3 01       	movw	r20, r6
    1cae:	b4 01       	movw	r22, r8
    1cb0:	c6 01       	movw	r24, r12
    1cb2:	1e d9       	rcall	.-3524   	; 0xef0 <pxPortInitialiseStack>
    1cb4:	99 83       	std	Y+1, r25	; 0x01
    1cb6:	88 83       	st	Y, r24
    1cb8:	e1 14       	cp	r14, r1
    1cba:	f1 04       	cpc	r15, r1
    1cbc:	19 f0       	breq	.+6      	; 0x1cc4 <xTaskGenericCreate+0xbc>
    1cbe:	f7 01       	movw	r30, r14
    1cc0:	d1 83       	std	Z+1, r29	; 0x01
    1cc2:	c0 83       	st	Z, r28
    1cc4:	0f b6       	in	r0, 0x3f	; 63
    1cc6:	f8 94       	cli
    1cc8:	0f 92       	push	r0
    1cca:	80 91 af 08 	lds	r24, 0x08AF
    1cce:	8f 5f       	subi	r24, 0xFF	; 255
    1cd0:	80 93 af 08 	sts	0x08AF, r24
    1cd4:	80 91 fd 08 	lds	r24, 0x08FD
    1cd8:	90 91 fe 08 	lds	r25, 0x08FE
    1cdc:	89 2b       	or	r24, r25
    1cde:	a9 f5       	brne	.+106    	; 0x1d4a <xTaskGenericCreate+0x142>
    1ce0:	d0 93 fe 08 	sts	0x08FE, r29
    1ce4:	c0 93 fd 08 	sts	0x08FD, r28
    1ce8:	80 91 af 08 	lds	r24, 0x08AF
    1cec:	81 30       	cpi	r24, 0x01	; 1
    1cee:	e1 f5       	brne	.+120    	; 0x1d68 <xTaskGenericCreate+0x160>
    1cf0:	89 ed       	ldi	r24, 0xD9	; 217
    1cf2:	98 e0       	ldi	r25, 0x08	; 8
    1cf4:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1cf8:	82 ee       	ldi	r24, 0xE2	; 226
    1cfa:	98 e0       	ldi	r25, 0x08	; 8
    1cfc:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d00:	8b ee       	ldi	r24, 0xEB	; 235
    1d02:	98 e0       	ldi	r25, 0x08	; 8
    1d04:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d08:	84 ef       	ldi	r24, 0xF4	; 244
    1d0a:	98 e0       	ldi	r25, 0x08	; 8
    1d0c:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d10:	80 ed       	ldi	r24, 0xD0	; 208
    1d12:	98 e0       	ldi	r25, 0x08	; 8
    1d14:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d18:	87 ec       	ldi	r24, 0xC7	; 199
    1d1a:	98 e0       	ldi	r25, 0x08	; 8
    1d1c:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d20:	8a eb       	ldi	r24, 0xBA	; 186
    1d22:	98 e0       	ldi	r25, 0x08	; 8
    1d24:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d28:	81 eb       	ldi	r24, 0xB1	; 177
    1d2a:	98 e0       	ldi	r25, 0x08	; 8
    1d2c:	0e 94 05 04 	call	0x80a	; 0x80a <vListInitialise>
    1d30:	80 ed       	ldi	r24, 0xD0	; 208
    1d32:	98 e0       	ldi	r25, 0x08	; 8
    1d34:	90 93 c6 08 	sts	0x08C6, r25
    1d38:	80 93 c5 08 	sts	0x08C5, r24
    1d3c:	87 ec       	ldi	r24, 0xC7	; 199
    1d3e:	98 e0       	ldi	r25, 0x08	; 8
    1d40:	90 93 c4 08 	sts	0x08C4, r25
    1d44:	80 93 c3 08 	sts	0x08C3, r24
    1d48:	0f c0       	rjmp	.+30     	; 0x1d68 <xTaskGenericCreate+0x160>
    1d4a:	80 91 ab 08 	lds	r24, 0x08AB
    1d4e:	81 11       	cpse	r24, r1
    1d50:	0b c0       	rjmp	.+22     	; 0x1d68 <xTaskGenericCreate+0x160>
    1d52:	e0 91 fd 08 	lds	r30, 0x08FD
    1d56:	f0 91 fe 08 	lds	r31, 0x08FE
    1d5a:	86 89       	ldd	r24, Z+22	; 0x16
    1d5c:	08 17       	cp	r16, r24
    1d5e:	20 f0       	brcs	.+8      	; 0x1d68 <xTaskGenericCreate+0x160>
    1d60:	d0 93 fe 08 	sts	0x08FE, r29
    1d64:	c0 93 fd 08 	sts	0x08FD, r28
    1d68:	80 91 a7 08 	lds	r24, 0x08A7
    1d6c:	8f 5f       	subi	r24, 0xFF	; 255
    1d6e:	80 93 a7 08 	sts	0x08A7, r24
    1d72:	8e 89       	ldd	r24, Y+22	; 0x16
    1d74:	90 91 ac 08 	lds	r25, 0x08AC
    1d78:	98 17       	cp	r25, r24
    1d7a:	10 f4       	brcc	.+4      	; 0x1d80 <xTaskGenericCreate+0x178>
    1d7c:	80 93 ac 08 	sts	0x08AC, r24
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	9c 01       	movw	r18, r24
    1d84:	22 0f       	add	r18, r18
    1d86:	33 1f       	adc	r19, r19
    1d88:	22 0f       	add	r18, r18
    1d8a:	33 1f       	adc	r19, r19
    1d8c:	22 0f       	add	r18, r18
    1d8e:	33 1f       	adc	r19, r19
    1d90:	82 0f       	add	r24, r18
    1d92:	93 1f       	adc	r25, r19
    1d94:	b5 01       	movw	r22, r10
    1d96:	87 52       	subi	r24, 0x27	; 39
    1d98:	97 4f       	sbci	r25, 0xF7	; 247
    1d9a:	0e 94 17 04 	call	0x82e	; 0x82e <vListInsertEnd>
    1d9e:	0f 90       	pop	r0
    1da0:	0f be       	out	0x3f, r0	; 63
    1da2:	80 91 ab 08 	lds	r24, 0x08AB
    1da6:	88 23       	and	r24, r24
    1da8:	51 f0       	breq	.+20     	; 0x1dbe <xTaskGenericCreate+0x1b6>
    1daa:	e0 91 fd 08 	lds	r30, 0x08FD
    1dae:	f0 91 fe 08 	lds	r31, 0x08FE
    1db2:	86 89       	ldd	r24, Z+22	; 0x16
    1db4:	80 17       	cp	r24, r16
    1db6:	28 f4       	brcc	.+10     	; 0x1dc2 <xTaskGenericCreate+0x1ba>
    1db8:	4e d9       	rcall	.-3428   	; 0x1056 <vPortYield>
    1dba:	81 e0       	ldi	r24, 0x01	; 1
    1dbc:	1c c0       	rjmp	.+56     	; 0x1df6 <xTaskGenericCreate+0x1ee>
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	1a c0       	rjmp	.+52     	; 0x1df6 <xTaskGenericCreate+0x1ee>
    1dc2:	81 e0       	ldi	r24, 0x01	; 1
    1dc4:	18 c0       	rjmp	.+48     	; 0x1df6 <xTaskGenericCreate+0x1ee>
    1dc6:	d8 8e       	std	Y+24, r13	; 0x18
    1dc8:	cf 8a       	std	Y+23, r12	; 0x17
    1dca:	f1 e0       	ldi	r31, 0x01	; 1
    1dcc:	4f 1a       	sub	r4, r31
    1dce:	51 08       	sbc	r5, r1
    1dd0:	cf 88       	ldd	r12, Y+23	; 0x17
    1dd2:	d8 8c       	ldd	r13, Y+24	; 0x18
    1dd4:	c4 0c       	add	r12, r4
    1dd6:	d5 1c       	adc	r13, r5
    1dd8:	d5 01       	movw	r26, r10
    1dda:	8c 91       	ld	r24, X
    1ddc:	89 8f       	std	Y+25, r24	; 0x19
    1dde:	8c 91       	ld	r24, X
    1de0:	88 23       	and	r24, r24
    1de2:	09 f4       	brne	.+2      	; 0x1de6 <xTaskGenericCreate+0x1de>
    1de4:	48 cf       	rjmp	.-368    	; 0x1c76 <xTaskGenericCreate+0x6e>
    1de6:	ae 01       	movw	r20, r28
    1de8:	46 5e       	subi	r20, 0xE6	; 230
    1dea:	5f 4f       	sbci	r21, 0xFF	; 255
    1dec:	f5 01       	movw	r30, r10
    1dee:	31 96       	adiw	r30, 0x01	; 1
    1df0:	27 e0       	ldi	r18, 0x07	; 7
    1df2:	36 cf       	rjmp	.-404    	; 0x1c60 <xTaskGenericCreate+0x58>
    1df4:	8f ef       	ldi	r24, 0xFF	; 255
    1df6:	df 91       	pop	r29
    1df8:	cf 91       	pop	r28
    1dfa:	1f 91       	pop	r17
    1dfc:	0f 91       	pop	r16
    1dfe:	ff 90       	pop	r15
    1e00:	ef 90       	pop	r14
    1e02:	df 90       	pop	r13
    1e04:	cf 90       	pop	r12
    1e06:	bf 90       	pop	r11
    1e08:	af 90       	pop	r10
    1e0a:	9f 90       	pop	r9
    1e0c:	8f 90       	pop	r8
    1e0e:	7f 90       	pop	r7
    1e10:	6f 90       	pop	r6
    1e12:	5f 90       	pop	r5
    1e14:	4f 90       	pop	r4
    1e16:	08 95       	ret

00001e18 <vTaskStartScheduler>:
    1e18:	af 92       	push	r10
    1e1a:	bf 92       	push	r11
    1e1c:	cf 92       	push	r12
    1e1e:	df 92       	push	r13
    1e20:	ef 92       	push	r14
    1e22:	ff 92       	push	r15
    1e24:	0f 93       	push	r16
    1e26:	a1 2c       	mov	r10, r1
    1e28:	b1 2c       	mov	r11, r1
    1e2a:	c1 2c       	mov	r12, r1
    1e2c:	d1 2c       	mov	r13, r1
    1e2e:	e1 2c       	mov	r14, r1
    1e30:	f1 2c       	mov	r15, r1
    1e32:	00 e0       	ldi	r16, 0x00	; 0
    1e34:	20 e0       	ldi	r18, 0x00	; 0
    1e36:	30 e0       	ldi	r19, 0x00	; 0
    1e38:	45 e5       	ldi	r20, 0x55	; 85
    1e3a:	50 e0       	ldi	r21, 0x00	; 0
    1e3c:	67 e5       	ldi	r22, 0x57	; 87
    1e3e:	72 e0       	ldi	r23, 0x02	; 2
    1e40:	88 e9       	ldi	r24, 0x98	; 152
    1e42:	90 e1       	ldi	r25, 0x10	; 16
    1e44:	e1 de       	rcall	.-574    	; 0x1c08 <xTaskGenericCreate>
    1e46:	81 30       	cpi	r24, 0x01	; 1
    1e48:	41 f4       	brne	.+16     	; 0x1e5a <vTaskStartScheduler+0x42>
    1e4a:	f8 94       	cli
    1e4c:	80 93 ab 08 	sts	0x08AB, r24
    1e50:	10 92 ae 08 	sts	0x08AE, r1
    1e54:	10 92 ad 08 	sts	0x08AD, r1
    1e58:	bd d8       	rcall	.-3718   	; 0xfd4 <xPortStartScheduler>
    1e5a:	0f 91       	pop	r16
    1e5c:	ff 90       	pop	r15
    1e5e:	ef 90       	pop	r14
    1e60:	df 90       	pop	r13
    1e62:	cf 90       	pop	r12
    1e64:	bf 90       	pop	r11
    1e66:	af 90       	pop	r10
    1e68:	08 95       	ret

00001e6a <vTaskSuspendAll>:
    1e6a:	80 91 a6 08 	lds	r24, 0x08A6
    1e6e:	8f 5f       	subi	r24, 0xFF	; 255
    1e70:	80 93 a6 08 	sts	0x08A6, r24
    1e74:	08 95       	ret

00001e76 <xTaskIncrementTick>:
    1e76:	cf 92       	push	r12
    1e78:	df 92       	push	r13
    1e7a:	ef 92       	push	r14
    1e7c:	ff 92       	push	r15
    1e7e:	0f 93       	push	r16
    1e80:	1f 93       	push	r17
    1e82:	cf 93       	push	r28
    1e84:	df 93       	push	r29
    1e86:	80 91 a6 08 	lds	r24, 0x08A6
    1e8a:	81 11       	cpse	r24, r1
    1e8c:	99 c0       	rjmp	.+306    	; 0x1fc0 <xTaskIncrementTick+0x14a>
    1e8e:	80 91 ad 08 	lds	r24, 0x08AD
    1e92:	90 91 ae 08 	lds	r25, 0x08AE
    1e96:	01 96       	adiw	r24, 0x01	; 1
    1e98:	90 93 ae 08 	sts	0x08AE, r25
    1e9c:	80 93 ad 08 	sts	0x08AD, r24
    1ea0:	e0 90 ad 08 	lds	r14, 0x08AD
    1ea4:	f0 90 ae 08 	lds	r15, 0x08AE
    1ea8:	e1 14       	cp	r14, r1
    1eaa:	f1 04       	cpc	r15, r1
    1eac:	b1 f4       	brne	.+44     	; 0x1eda <xTaskIncrementTick+0x64>
    1eae:	80 91 c5 08 	lds	r24, 0x08C5
    1eb2:	90 91 c6 08 	lds	r25, 0x08C6
    1eb6:	20 91 c3 08 	lds	r18, 0x08C3
    1eba:	30 91 c4 08 	lds	r19, 0x08C4
    1ebe:	30 93 c6 08 	sts	0x08C6, r19
    1ec2:	20 93 c5 08 	sts	0x08C5, r18
    1ec6:	90 93 c4 08 	sts	0x08C4, r25
    1eca:	80 93 c3 08 	sts	0x08C3, r24
    1ece:	80 91 a8 08 	lds	r24, 0x08A8
    1ed2:	8f 5f       	subi	r24, 0xFF	; 255
    1ed4:	80 93 a8 08 	sts	0x08A8, r24
    1ed8:	41 de       	rcall	.-894    	; 0x1b5c <prvResetNextTaskUnblockTime>
    1eda:	80 91 04 02 	lds	r24, 0x0204
    1ede:	90 91 05 02 	lds	r25, 0x0205
    1ee2:	e8 16       	cp	r14, r24
    1ee4:	f9 06       	cpc	r15, r25
    1ee6:	08 f4       	brcc	.+2      	; 0x1eea <xTaskIncrementTick+0x74>
    1ee8:	54 c0       	rjmp	.+168    	; 0x1f92 <xTaskIncrementTick+0x11c>
    1eea:	d1 2c       	mov	r13, r1
    1eec:	cc 24       	eor	r12, r12
    1eee:	c3 94       	inc	r12
    1ef0:	01 c0       	rjmp	.+2      	; 0x1ef4 <xTaskIncrementTick+0x7e>
    1ef2:	dc 2c       	mov	r13, r12
    1ef4:	e0 91 c5 08 	lds	r30, 0x08C5
    1ef8:	f0 91 c6 08 	lds	r31, 0x08C6
    1efc:	80 81       	ld	r24, Z
    1efe:	81 11       	cpse	r24, r1
    1f00:	07 c0       	rjmp	.+14     	; 0x1f10 <xTaskIncrementTick+0x9a>
    1f02:	8f ef       	ldi	r24, 0xFF	; 255
    1f04:	9f ef       	ldi	r25, 0xFF	; 255
    1f06:	90 93 05 02 	sts	0x0205, r25
    1f0a:	80 93 04 02 	sts	0x0204, r24
    1f0e:	42 c0       	rjmp	.+132    	; 0x1f94 <xTaskIncrementTick+0x11e>
    1f10:	e0 91 c5 08 	lds	r30, 0x08C5
    1f14:	f0 91 c6 08 	lds	r31, 0x08C6
    1f18:	05 80       	ldd	r0, Z+5	; 0x05
    1f1a:	f6 81       	ldd	r31, Z+6	; 0x06
    1f1c:	e0 2d       	mov	r30, r0
    1f1e:	c6 81       	ldd	r28, Z+6	; 0x06
    1f20:	d7 81       	ldd	r29, Z+7	; 0x07
    1f22:	2a 81       	ldd	r18, Y+2	; 0x02
    1f24:	3b 81       	ldd	r19, Y+3	; 0x03
    1f26:	e2 16       	cp	r14, r18
    1f28:	f3 06       	cpc	r15, r19
    1f2a:	28 f4       	brcc	.+10     	; 0x1f36 <xTaskIncrementTick+0xc0>
    1f2c:	30 93 05 02 	sts	0x0205, r19
    1f30:	20 93 04 02 	sts	0x0204, r18
    1f34:	2f c0       	rjmp	.+94     	; 0x1f94 <xTaskIncrementTick+0x11e>
    1f36:	8e 01       	movw	r16, r28
    1f38:	0e 5f       	subi	r16, 0xFE	; 254
    1f3a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f3c:	c8 01       	movw	r24, r16
    1f3e:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    1f42:	8c 89       	ldd	r24, Y+20	; 0x14
    1f44:	9d 89       	ldd	r25, Y+21	; 0x15
    1f46:	89 2b       	or	r24, r25
    1f48:	21 f0       	breq	.+8      	; 0x1f52 <xTaskIncrementTick+0xdc>
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	0c 96       	adiw	r24, 0x0c	; 12
    1f4e:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    1f52:	2e 89       	ldd	r18, Y+22	; 0x16
    1f54:	80 91 ac 08 	lds	r24, 0x08AC
    1f58:	82 17       	cp	r24, r18
    1f5a:	10 f4       	brcc	.+4      	; 0x1f60 <xTaskIncrementTick+0xea>
    1f5c:	20 93 ac 08 	sts	0x08AC, r18
    1f60:	30 e0       	ldi	r19, 0x00	; 0
    1f62:	c9 01       	movw	r24, r18
    1f64:	88 0f       	add	r24, r24
    1f66:	99 1f       	adc	r25, r25
    1f68:	88 0f       	add	r24, r24
    1f6a:	99 1f       	adc	r25, r25
    1f6c:	88 0f       	add	r24, r24
    1f6e:	99 1f       	adc	r25, r25
    1f70:	82 0f       	add	r24, r18
    1f72:	93 1f       	adc	r25, r19
    1f74:	b8 01       	movw	r22, r16
    1f76:	87 52       	subi	r24, 0x27	; 39
    1f78:	97 4f       	sbci	r25, 0xF7	; 247
    1f7a:	0e 94 17 04 	call	0x82e	; 0x82e <vListInsertEnd>
    1f7e:	e0 91 fd 08 	lds	r30, 0x08FD
    1f82:	f0 91 fe 08 	lds	r31, 0x08FE
    1f86:	9e 89       	ldd	r25, Y+22	; 0x16
    1f88:	86 89       	ldd	r24, Z+22	; 0x16
    1f8a:	98 17       	cp	r25, r24
    1f8c:	08 f0       	brcs	.+2      	; 0x1f90 <xTaskIncrementTick+0x11a>
    1f8e:	b1 cf       	rjmp	.-158    	; 0x1ef2 <xTaskIncrementTick+0x7c>
    1f90:	b1 cf       	rjmp	.-158    	; 0x1ef4 <xTaskIncrementTick+0x7e>
    1f92:	d1 2c       	mov	r13, r1
    1f94:	e0 91 fd 08 	lds	r30, 0x08FD
    1f98:	f0 91 fe 08 	lds	r31, 0x08FE
    1f9c:	86 89       	ldd	r24, Z+22	; 0x16
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	fc 01       	movw	r30, r24
    1fa2:	ee 0f       	add	r30, r30
    1fa4:	ff 1f       	adc	r31, r31
    1fa6:	ee 0f       	add	r30, r30
    1fa8:	ff 1f       	adc	r31, r31
    1faa:	ee 0f       	add	r30, r30
    1fac:	ff 1f       	adc	r31, r31
    1fae:	8e 0f       	add	r24, r30
    1fb0:	9f 1f       	adc	r25, r31
    1fb2:	fc 01       	movw	r30, r24
    1fb4:	e7 52       	subi	r30, 0x27	; 39
    1fb6:	f7 4f       	sbci	r31, 0xF7	; 247
    1fb8:	80 81       	ld	r24, Z
    1fba:	82 30       	cpi	r24, 0x02	; 2
    1fbc:	40 f4       	brcc	.+16     	; 0x1fce <xTaskIncrementTick+0x158>
    1fbe:	09 c0       	rjmp	.+18     	; 0x1fd2 <xTaskIncrementTick+0x15c>
    1fc0:	80 91 aa 08 	lds	r24, 0x08AA
    1fc4:	8f 5f       	subi	r24, 0xFF	; 255
    1fc6:	80 93 aa 08 	sts	0x08AA, r24
    1fca:	d1 2c       	mov	r13, r1
    1fcc:	02 c0       	rjmp	.+4      	; 0x1fd2 <xTaskIncrementTick+0x15c>
    1fce:	dd 24       	eor	r13, r13
    1fd0:	d3 94       	inc	r13
    1fd2:	80 91 a9 08 	lds	r24, 0x08A9
    1fd6:	88 23       	and	r24, r24
    1fd8:	11 f0       	breq	.+4      	; 0x1fde <xTaskIncrementTick+0x168>
    1fda:	dd 24       	eor	r13, r13
    1fdc:	d3 94       	inc	r13
    1fde:	8d 2d       	mov	r24, r13
    1fe0:	df 91       	pop	r29
    1fe2:	cf 91       	pop	r28
    1fe4:	1f 91       	pop	r17
    1fe6:	0f 91       	pop	r16
    1fe8:	ff 90       	pop	r15
    1fea:	ef 90       	pop	r14
    1fec:	df 90       	pop	r13
    1fee:	cf 90       	pop	r12
    1ff0:	08 95       	ret

00001ff2 <xTaskResumeAll>:
    1ff2:	df 92       	push	r13
    1ff4:	ef 92       	push	r14
    1ff6:	ff 92       	push	r15
    1ff8:	0f 93       	push	r16
    1ffa:	1f 93       	push	r17
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	0f b6       	in	r0, 0x3f	; 63
    2002:	f8 94       	cli
    2004:	0f 92       	push	r0
    2006:	80 91 a6 08 	lds	r24, 0x08A6
    200a:	81 50       	subi	r24, 0x01	; 1
    200c:	80 93 a6 08 	sts	0x08A6, r24
    2010:	80 91 a6 08 	lds	r24, 0x08A6
    2014:	81 11       	cpse	r24, r1
    2016:	60 c0       	rjmp	.+192    	; 0x20d8 <xTaskResumeAll+0xe6>
    2018:	80 91 af 08 	lds	r24, 0x08AF
    201c:	88 23       	and	r24, r24
    201e:	09 f4       	brne	.+2      	; 0x2022 <xTaskResumeAll+0x30>
    2020:	5d c0       	rjmp	.+186    	; 0x20dc <xTaskResumeAll+0xea>
    2022:	0f 2e       	mov	r0, r31
    2024:	fa eb       	ldi	r31, 0xBA	; 186
    2026:	ef 2e       	mov	r14, r31
    2028:	f8 e0       	ldi	r31, 0x08	; 8
    202a:	ff 2e       	mov	r15, r31
    202c:	f0 2d       	mov	r31, r0
    202e:	dd 24       	eor	r13, r13
    2030:	d3 94       	inc	r13
    2032:	30 c0       	rjmp	.+96     	; 0x2094 <xTaskResumeAll+0xa2>
    2034:	e0 91 bf 08 	lds	r30, 0x08BF
    2038:	f0 91 c0 08 	lds	r31, 0x08C0
    203c:	c6 81       	ldd	r28, Z+6	; 0x06
    203e:	d7 81       	ldd	r29, Z+7	; 0x07
    2040:	ce 01       	movw	r24, r28
    2042:	0c 96       	adiw	r24, 0x0c	; 12
    2044:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    2048:	8e 01       	movw	r16, r28
    204a:	0e 5f       	subi	r16, 0xFE	; 254
    204c:	1f 4f       	sbci	r17, 0xFF	; 255
    204e:	c8 01       	movw	r24, r16
    2050:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    2054:	8e 89       	ldd	r24, Y+22	; 0x16
    2056:	90 91 ac 08 	lds	r25, 0x08AC
    205a:	98 17       	cp	r25, r24
    205c:	10 f4       	brcc	.+4      	; 0x2062 <xTaskResumeAll+0x70>
    205e:	80 93 ac 08 	sts	0x08AC, r24
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	9c 01       	movw	r18, r24
    2066:	22 0f       	add	r18, r18
    2068:	33 1f       	adc	r19, r19
    206a:	22 0f       	add	r18, r18
    206c:	33 1f       	adc	r19, r19
    206e:	22 0f       	add	r18, r18
    2070:	33 1f       	adc	r19, r19
    2072:	82 0f       	add	r24, r18
    2074:	93 1f       	adc	r25, r19
    2076:	b8 01       	movw	r22, r16
    2078:	87 52       	subi	r24, 0x27	; 39
    207a:	97 4f       	sbci	r25, 0xF7	; 247
    207c:	0e 94 17 04 	call	0x82e	; 0x82e <vListInsertEnd>
    2080:	e0 91 fd 08 	lds	r30, 0x08FD
    2084:	f0 91 fe 08 	lds	r31, 0x08FE
    2088:	9e 89       	ldd	r25, Y+22	; 0x16
    208a:	86 89       	ldd	r24, Z+22	; 0x16
    208c:	98 17       	cp	r25, r24
    208e:	10 f0       	brcs	.+4      	; 0x2094 <xTaskResumeAll+0xa2>
    2090:	d0 92 a9 08 	sts	0x08A9, r13
    2094:	f7 01       	movw	r30, r14
    2096:	80 81       	ld	r24, Z
    2098:	81 11       	cpse	r24, r1
    209a:	cc cf       	rjmp	.-104    	; 0x2034 <xTaskResumeAll+0x42>
    209c:	80 91 aa 08 	lds	r24, 0x08AA
    20a0:	88 23       	and	r24, r24
    20a2:	91 f0       	breq	.+36     	; 0x20c8 <xTaskResumeAll+0xd6>
    20a4:	80 91 aa 08 	lds	r24, 0x08AA
    20a8:	88 23       	and	r24, r24
    20aa:	71 f0       	breq	.+28     	; 0x20c8 <xTaskResumeAll+0xd6>
    20ac:	c1 e0       	ldi	r28, 0x01	; 1
    20ae:	e3 de       	rcall	.-570    	; 0x1e76 <xTaskIncrementTick>
    20b0:	81 11       	cpse	r24, r1
    20b2:	c0 93 a9 08 	sts	0x08A9, r28
    20b6:	80 91 aa 08 	lds	r24, 0x08AA
    20ba:	81 50       	subi	r24, 0x01	; 1
    20bc:	80 93 aa 08 	sts	0x08AA, r24
    20c0:	80 91 aa 08 	lds	r24, 0x08AA
    20c4:	81 11       	cpse	r24, r1
    20c6:	f3 cf       	rjmp	.-26     	; 0x20ae <xTaskResumeAll+0xbc>
    20c8:	80 91 a9 08 	lds	r24, 0x08A9
    20cc:	81 30       	cpi	r24, 0x01	; 1
    20ce:	41 f4       	brne	.+16     	; 0x20e0 <xTaskResumeAll+0xee>
    20d0:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortYield>
    20d4:	81 e0       	ldi	r24, 0x01	; 1
    20d6:	05 c0       	rjmp	.+10     	; 0x20e2 <xTaskResumeAll+0xf0>
    20d8:	80 e0       	ldi	r24, 0x00	; 0
    20da:	03 c0       	rjmp	.+6      	; 0x20e2 <xTaskResumeAll+0xf0>
    20dc:	80 e0       	ldi	r24, 0x00	; 0
    20de:	01 c0       	rjmp	.+2      	; 0x20e2 <xTaskResumeAll+0xf0>
    20e0:	80 e0       	ldi	r24, 0x00	; 0
    20e2:	0f 90       	pop	r0
    20e4:	0f be       	out	0x3f, r0	; 63
    20e6:	df 91       	pop	r29
    20e8:	cf 91       	pop	r28
    20ea:	1f 91       	pop	r17
    20ec:	0f 91       	pop	r16
    20ee:	ff 90       	pop	r15
    20f0:	ef 90       	pop	r14
    20f2:	df 90       	pop	r13
    20f4:	08 95       	ret

000020f6 <vTaskDelay>:
    20f6:	cf 93       	push	r28
    20f8:	df 93       	push	r29
    20fa:	ec 01       	movw	r28, r24
    20fc:	00 97       	sbiw	r24, 0x00	; 0
    20fe:	99 f0       	breq	.+38     	; 0x2126 <vTaskDelay+0x30>
    2100:	b4 de       	rcall	.-664    	; 0x1e6a <vTaskSuspendAll>
    2102:	80 91 ad 08 	lds	r24, 0x08AD
    2106:	90 91 ae 08 	lds	r25, 0x08AE
    210a:	c8 0f       	add	r28, r24
    210c:	d9 1f       	adc	r29, r25
    210e:	80 91 fd 08 	lds	r24, 0x08FD
    2112:	90 91 fe 08 	lds	r25, 0x08FE
    2116:	02 96       	adiw	r24, 0x02	; 2
    2118:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    211c:	ce 01       	movw	r24, r28
    211e:	3d dd       	rcall	.-1414   	; 0x1b9a <prvAddCurrentTaskToDelayedList>
    2120:	68 df       	rcall	.-304    	; 0x1ff2 <xTaskResumeAll>
    2122:	81 11       	cpse	r24, r1
    2124:	02 c0       	rjmp	.+4      	; 0x212a <vTaskDelay+0x34>
    2126:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortYield>
    212a:	df 91       	pop	r29
    212c:	cf 91       	pop	r28
    212e:	08 95       	ret

00002130 <prvIdleTask>:
    2130:	0f 2e       	mov	r0, r31
    2132:	f9 ed       	ldi	r31, 0xD9	; 217
    2134:	ef 2e       	mov	r14, r31
    2136:	f8 e0       	ldi	r31, 0x08	; 8
    2138:	ff 2e       	mov	r15, r31
    213a:	f0 2d       	mov	r31, r0
    213c:	c1 eb       	ldi	r28, 0xB1	; 177
    213e:	d8 e0       	ldi	r29, 0x08	; 8
    2140:	26 c0       	rjmp	.+76     	; 0x218e <prvIdleTask+0x5e>
    2142:	93 de       	rcall	.-730    	; 0x1e6a <vTaskSuspendAll>
    2144:	18 81       	ld	r17, Y
    2146:	55 df       	rcall	.-342    	; 0x1ff2 <xTaskResumeAll>
    2148:	11 23       	and	r17, r17
    214a:	09 f1       	breq	.+66     	; 0x218e <prvIdleTask+0x5e>
    214c:	0f b6       	in	r0, 0x3f	; 63
    214e:	f8 94       	cli
    2150:	0f 92       	push	r0
    2152:	e0 91 b6 08 	lds	r30, 0x08B6
    2156:	f0 91 b7 08 	lds	r31, 0x08B7
    215a:	06 81       	ldd	r16, Z+6	; 0x06
    215c:	17 81       	ldd	r17, Z+7	; 0x07
    215e:	c8 01       	movw	r24, r16
    2160:	02 96       	adiw	r24, 0x02	; 2
    2162:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    2166:	80 91 af 08 	lds	r24, 0x08AF
    216a:	81 50       	subi	r24, 0x01	; 1
    216c:	80 93 af 08 	sts	0x08AF, r24
    2170:	80 91 b0 08 	lds	r24, 0x08B0
    2174:	81 50       	subi	r24, 0x01	; 1
    2176:	80 93 b0 08 	sts	0x08B0, r24
    217a:	0f 90       	pop	r0
    217c:	0f be       	out	0x3f, r0	; 63
    217e:	f8 01       	movw	r30, r16
    2180:	87 89       	ldd	r24, Z+23	; 0x17
    2182:	90 8d       	ldd	r25, Z+24	; 0x18
    2184:	0e 94 8c 02 	call	0x518	; 0x518 <vPortFree>
    2188:	c8 01       	movw	r24, r16
    218a:	0e 94 8c 02 	call	0x518	; 0x518 <vPortFree>
    218e:	80 91 b0 08 	lds	r24, 0x08B0
    2192:	81 11       	cpse	r24, r1
    2194:	d6 cf       	rjmp	.-84     	; 0x2142 <prvIdleTask+0x12>
    2196:	f7 01       	movw	r30, r14
    2198:	80 81       	ld	r24, Z
    219a:	82 30       	cpi	r24, 0x02	; 2
    219c:	c0 f3       	brcs	.-16     	; 0x218e <prvIdleTask+0x5e>
    219e:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortYield>
    21a2:	f5 cf       	rjmp	.-22     	; 0x218e <prvIdleTask+0x5e>

000021a4 <vTaskSwitchContext>:
    21a4:	80 91 a6 08 	lds	r24, 0x08A6
    21a8:	88 23       	and	r24, r24
    21aa:	21 f0       	breq	.+8      	; 0x21b4 <vTaskSwitchContext+0x10>
    21ac:	81 e0       	ldi	r24, 0x01	; 1
    21ae:	80 93 a9 08 	sts	0x08A9, r24
    21b2:	08 95       	ret
    21b4:	10 92 a9 08 	sts	0x08A9, r1
    21b8:	80 91 ac 08 	lds	r24, 0x08AC
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	fc 01       	movw	r30, r24
    21c0:	ee 0f       	add	r30, r30
    21c2:	ff 1f       	adc	r31, r31
    21c4:	ee 0f       	add	r30, r30
    21c6:	ff 1f       	adc	r31, r31
    21c8:	ee 0f       	add	r30, r30
    21ca:	ff 1f       	adc	r31, r31
    21cc:	8e 0f       	add	r24, r30
    21ce:	9f 1f       	adc	r25, r31
    21d0:	fc 01       	movw	r30, r24
    21d2:	e7 52       	subi	r30, 0x27	; 39
    21d4:	f7 4f       	sbci	r31, 0xF7	; 247
    21d6:	80 81       	ld	r24, Z
    21d8:	81 11       	cpse	r24, r1
    21da:	17 c0       	rjmp	.+46     	; 0x220a <__stack+0xb>
    21dc:	80 91 ac 08 	lds	r24, 0x08AC
    21e0:	81 50       	subi	r24, 0x01	; 1
    21e2:	80 93 ac 08 	sts	0x08AC, r24
    21e6:	80 91 ac 08 	lds	r24, 0x08AC
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	fc 01       	movw	r30, r24
    21ee:	ee 0f       	add	r30, r30
    21f0:	ff 1f       	adc	r31, r31
    21f2:	ee 0f       	add	r30, r30
    21f4:	ff 1f       	adc	r31, r31
    21f6:	ee 0f       	add	r30, r30
    21f8:	ff 1f       	adc	r31, r31
    21fa:	8e 0f       	add	r24, r30
    21fc:	9f 1f       	adc	r25, r31
    21fe:	fc 01       	movw	r30, r24
    2200:	e7 52       	subi	r30, 0x27	; 39
    2202:	f7 4f       	sbci	r31, 0xF7	; 247
    2204:	80 81       	ld	r24, Z
    2206:	88 23       	and	r24, r24
    2208:	49 f3       	breq	.-46     	; 0x21dc <vTaskSwitchContext+0x38>
    220a:	e0 91 ac 08 	lds	r30, 0x08AC
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	cf 01       	movw	r24, r30
    2212:	88 0f       	add	r24, r24
    2214:	99 1f       	adc	r25, r25
    2216:	88 0f       	add	r24, r24
    2218:	99 1f       	adc	r25, r25
    221a:	88 0f       	add	r24, r24
    221c:	99 1f       	adc	r25, r25
    221e:	e8 0f       	add	r30, r24
    2220:	f9 1f       	adc	r31, r25
    2222:	e7 52       	subi	r30, 0x27	; 39
    2224:	f7 4f       	sbci	r31, 0xF7	; 247
    2226:	a1 81       	ldd	r26, Z+1	; 0x01
    2228:	b2 81       	ldd	r27, Z+2	; 0x02
    222a:	12 96       	adiw	r26, 0x02	; 2
    222c:	0d 90       	ld	r0, X+
    222e:	bc 91       	ld	r27, X
    2230:	a0 2d       	mov	r26, r0
    2232:	b2 83       	std	Z+2, r27	; 0x02
    2234:	a1 83       	std	Z+1, r26	; 0x01
    2236:	cf 01       	movw	r24, r30
    2238:	03 96       	adiw	r24, 0x03	; 3
    223a:	a8 17       	cp	r26, r24
    223c:	b9 07       	cpc	r27, r25
    223e:	31 f4       	brne	.+12     	; 0x224c <__stack+0x4d>
    2240:	12 96       	adiw	r26, 0x02	; 2
    2242:	8d 91       	ld	r24, X+
    2244:	9c 91       	ld	r25, X
    2246:	13 97       	sbiw	r26, 0x03	; 3
    2248:	92 83       	std	Z+2, r25	; 0x02
    224a:	81 83       	std	Z+1, r24	; 0x01
    224c:	01 80       	ldd	r0, Z+1	; 0x01
    224e:	f2 81       	ldd	r31, Z+2	; 0x02
    2250:	e0 2d       	mov	r30, r0
    2252:	86 81       	ldd	r24, Z+6	; 0x06
    2254:	97 81       	ldd	r25, Z+7	; 0x07
    2256:	90 93 fe 08 	sts	0x08FE, r25
    225a:	80 93 fd 08 	sts	0x08FD, r24
    225e:	08 95       	ret

00002260 <vTaskPlaceOnEventList>:
    2260:	cf 93       	push	r28
    2262:	df 93       	push	r29
    2264:	eb 01       	movw	r28, r22
    2266:	60 91 fd 08 	lds	r22, 0x08FD
    226a:	70 91 fe 08 	lds	r23, 0x08FE
    226e:	64 5f       	subi	r22, 0xF4	; 244
    2270:	7f 4f       	sbci	r23, 0xFF	; 255
    2272:	0e 94 38 04 	call	0x870	; 0x870 <vListInsert>
    2276:	80 91 fd 08 	lds	r24, 0x08FD
    227a:	90 91 fe 08 	lds	r25, 0x08FE
    227e:	02 96       	adiw	r24, 0x02	; 2
    2280:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    2284:	80 91 ad 08 	lds	r24, 0x08AD
    2288:	90 91 ae 08 	lds	r25, 0x08AE
    228c:	8c 0f       	add	r24, r28
    228e:	9d 1f       	adc	r25, r29
    2290:	84 dc       	rcall	.-1784   	; 0x1b9a <prvAddCurrentTaskToDelayedList>
    2292:	df 91       	pop	r29
    2294:	cf 91       	pop	r28
    2296:	08 95       	ret

00002298 <xTaskRemoveFromEventList>:
    2298:	0f 93       	push	r16
    229a:	1f 93       	push	r17
    229c:	cf 93       	push	r28
    229e:	df 93       	push	r29
    22a0:	dc 01       	movw	r26, r24
    22a2:	15 96       	adiw	r26, 0x05	; 5
    22a4:	ed 91       	ld	r30, X+
    22a6:	fc 91       	ld	r31, X
    22a8:	16 97       	sbiw	r26, 0x06	; 6
    22aa:	c6 81       	ldd	r28, Z+6	; 0x06
    22ac:	d7 81       	ldd	r29, Z+7	; 0x07
    22ae:	8e 01       	movw	r16, r28
    22b0:	04 5f       	subi	r16, 0xF4	; 244
    22b2:	1f 4f       	sbci	r17, 0xFF	; 255
    22b4:	c8 01       	movw	r24, r16
    22b6:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    22ba:	80 91 a6 08 	lds	r24, 0x08A6
    22be:	81 11       	cpse	r24, r1
    22c0:	1c c0       	rjmp	.+56     	; 0x22fa <xTaskRemoveFromEventList+0x62>
    22c2:	0a 50       	subi	r16, 0x0A	; 10
    22c4:	11 09       	sbc	r17, r1
    22c6:	c8 01       	movw	r24, r16
    22c8:	0e 94 69 04 	call	0x8d2	; 0x8d2 <uxListRemove>
    22cc:	8e 89       	ldd	r24, Y+22	; 0x16
    22ce:	90 91 ac 08 	lds	r25, 0x08AC
    22d2:	98 17       	cp	r25, r24
    22d4:	10 f4       	brcc	.+4      	; 0x22da <xTaskRemoveFromEventList+0x42>
    22d6:	80 93 ac 08 	sts	0x08AC, r24
    22da:	90 e0       	ldi	r25, 0x00	; 0
    22dc:	9c 01       	movw	r18, r24
    22de:	22 0f       	add	r18, r18
    22e0:	33 1f       	adc	r19, r19
    22e2:	22 0f       	add	r18, r18
    22e4:	33 1f       	adc	r19, r19
    22e6:	22 0f       	add	r18, r18
    22e8:	33 1f       	adc	r19, r19
    22ea:	82 0f       	add	r24, r18
    22ec:	93 1f       	adc	r25, r19
    22ee:	b8 01       	movw	r22, r16
    22f0:	87 52       	subi	r24, 0x27	; 39
    22f2:	97 4f       	sbci	r25, 0xF7	; 247
    22f4:	0e 94 17 04 	call	0x82e	; 0x82e <vListInsertEnd>
    22f8:	05 c0       	rjmp	.+10     	; 0x2304 <xTaskRemoveFromEventList+0x6c>
    22fa:	b8 01       	movw	r22, r16
    22fc:	8a eb       	ldi	r24, 0xBA	; 186
    22fe:	98 e0       	ldi	r25, 0x08	; 8
    2300:	0e 94 17 04 	call	0x82e	; 0x82e <vListInsertEnd>
    2304:	e0 91 fd 08 	lds	r30, 0x08FD
    2308:	f0 91 fe 08 	lds	r31, 0x08FE
    230c:	9e 89       	ldd	r25, Y+22	; 0x16
    230e:	86 89       	ldd	r24, Z+22	; 0x16
    2310:	89 17       	cp	r24, r25
    2312:	20 f4       	brcc	.+8      	; 0x231c <xTaskRemoveFromEventList+0x84>
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	80 93 a9 08 	sts	0x08A9, r24
    231a:	01 c0       	rjmp	.+2      	; 0x231e <xTaskRemoveFromEventList+0x86>
    231c:	80 e0       	ldi	r24, 0x00	; 0
    231e:	df 91       	pop	r29
    2320:	cf 91       	pop	r28
    2322:	1f 91       	pop	r17
    2324:	0f 91       	pop	r16
    2326:	08 95       	ret

00002328 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2328:	20 91 a8 08 	lds	r18, 0x08A8
    232c:	fc 01       	movw	r30, r24
    232e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2330:	20 91 ad 08 	lds	r18, 0x08AD
    2334:	30 91 ae 08 	lds	r19, 0x08AE
    2338:	32 83       	std	Z+2, r19	; 0x02
    233a:	21 83       	std	Z+1, r18	; 0x01
    233c:	08 95       	ret

0000233e <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2344:	20 91 ad 08 	lds	r18, 0x08AD
    2348:	30 91 ae 08 	lds	r19, 0x08AE
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    234c:	40 91 a8 08 	lds	r20, 0x08A8
    2350:	dc 01       	movw	r26, r24
    2352:	5c 91       	ld	r21, X
    2354:	54 17       	cp	r21, r20
    2356:	39 f0       	breq	.+14     	; 0x2366 <xTaskCheckForTimeOut+0x28>
    2358:	11 96       	adiw	r26, 0x01	; 1
    235a:	4d 91       	ld	r20, X+
    235c:	5c 91       	ld	r21, X
    235e:	12 97       	sbiw	r26, 0x02	; 2
    2360:	24 17       	cp	r18, r20
    2362:	35 07       	cpc	r19, r21
    2364:	c0 f4       	brcc	.+48     	; 0x2396 <xTaskCheckForTimeOut+0x58>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2366:	dc 01       	movw	r26, r24
    2368:	11 96       	adiw	r26, 0x01	; 1
    236a:	ed 91       	ld	r30, X+
    236c:	fc 91       	ld	r31, X
    236e:	12 97       	sbiw	r26, 0x02	; 2
    2370:	db 01       	movw	r26, r22
    2372:	4d 91       	ld	r20, X+
    2374:	5c 91       	ld	r21, X
    2376:	d9 01       	movw	r26, r18
    2378:	ae 1b       	sub	r26, r30
    237a:	bf 0b       	sbc	r27, r31
    237c:	a4 17       	cp	r26, r20
    237e:	b5 07       	cpc	r27, r21
    2380:	60 f4       	brcc	.+24     	; 0x239a <xTaskCheckForTimeOut+0x5c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2382:	e2 1b       	sub	r30, r18
    2384:	f3 0b       	sbc	r31, r19
    2386:	4e 0f       	add	r20, r30
    2388:	5f 1f       	adc	r21, r31
    238a:	fb 01       	movw	r30, r22
    238c:	51 83       	std	Z+1, r21	; 0x01
    238e:	40 83       	st	Z, r20
			vTaskSetTimeOutState( pxTimeOut );
    2390:	cb df       	rcall	.-106    	; 0x2328 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2392:	80 e0       	ldi	r24, 0x00	; 0
    2394:	03 c0       	rjmp	.+6      	; 0x239c <xTaskCheckForTimeOut+0x5e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	01 c0       	rjmp	.+2      	; 0x239c <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    239a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    239c:	0f 90       	pop	r0
    239e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    23a0:	08 95       	ret

000023a2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	80 93 a9 08 	sts	0x08A9, r24
    23a8:	08 95       	ret

000023aa <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    23aa:	10 92 6c 09 	sts	0x096C, r1
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	80 93 6a 09 	sts	0x096A, r24
    23b4:	10 92 69 09 	sts	0x0969, r1
    23b8:	61 e0       	ldi	r22, 0x01	; 1
    23ba:	84 e1       	ldi	r24, 0x14	; 20
    23bc:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <digitalWrite>
    23c0:	61 e0       	ldi	r22, 0x01	; 1
    23c2:	85 e1       	ldi	r24, 0x15	; 21
    23c4:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <digitalWrite>
    23c8:	e9 eb       	ldi	r30, 0xB9	; 185
    23ca:	f0 e0       	ldi	r31, 0x00	; 0
    23cc:	80 81       	ld	r24, Z
    23ce:	8e 7f       	andi	r24, 0xFE	; 254
    23d0:	80 83       	st	Z, r24
    23d2:	80 81       	ld	r24, Z
    23d4:	8d 7f       	andi	r24, 0xFD	; 253
    23d6:	80 83       	st	Z, r24
    23d8:	8d ef       	ldi	r24, 0xFD	; 253
    23da:	80 93 b8 00 	sts	0x00B8, r24
    23de:	85 e4       	ldi	r24, 0x45	; 69
    23e0:	80 93 bc 00 	sts	0x00BC, r24
    23e4:	08 95       	ret

000023e6 <twi_readFrom>:
    23e6:	41 32       	cpi	r20, 0x21	; 33
    23e8:	08 f0       	brcs	.+2      	; 0x23ec <twi_readFrom+0x6>
    23ea:	45 c0       	rjmp	.+138    	; 0x2476 <twi_readFrom+0x90>
    23ec:	90 91 6c 09 	lds	r25, 0x096C
    23f0:	91 11       	cpse	r25, r1
    23f2:	fc cf       	rjmp	.-8      	; 0x23ec <twi_readFrom+0x6>
    23f4:	91 e0       	ldi	r25, 0x01	; 1
    23f6:	90 93 6c 09 	sts	0x096C, r25
    23fa:	20 93 6a 09 	sts	0x096A, r18
    23fe:	2f ef       	ldi	r18, 0xFF	; 255
    2400:	20 93 ff 08 	sts	0x08FF, r18
    2404:	10 92 44 09 	sts	0x0944, r1
    2408:	24 0f       	add	r18, r20
    240a:	20 93 43 09 	sts	0x0943, r18
    240e:	90 93 6b 09 	sts	0x096B, r25
    2412:	90 91 6b 09 	lds	r25, 0x096B
    2416:	88 0f       	add	r24, r24
    2418:	89 2b       	or	r24, r25
    241a:	80 93 6b 09 	sts	0x096B, r24
    241e:	80 91 69 09 	lds	r24, 0x0969
    2422:	81 30       	cpi	r24, 0x01	; 1
    2424:	51 f4       	brne	.+20     	; 0x243a <twi_readFrom+0x54>
    2426:	10 92 69 09 	sts	0x0969, r1
    242a:	80 91 6b 09 	lds	r24, 0x096B
    242e:	80 93 bb 00 	sts	0x00BB, r24
    2432:	85 ec       	ldi	r24, 0xC5	; 197
    2434:	80 93 bc 00 	sts	0x00BC, r24
    2438:	03 c0       	rjmp	.+6      	; 0x2440 <twi_readFrom+0x5a>
    243a:	85 ee       	ldi	r24, 0xE5	; 229
    243c:	80 93 bc 00 	sts	0x00BC, r24
    2440:	80 91 6c 09 	lds	r24, 0x096C
    2444:	81 30       	cpi	r24, 0x01	; 1
    2446:	e1 f3       	breq	.-8      	; 0x2440 <twi_readFrom+0x5a>
    2448:	80 91 44 09 	lds	r24, 0x0944
    244c:	84 17       	cp	r24, r20
    244e:	10 f4       	brcc	.+4      	; 0x2454 <twi_readFrom+0x6e>
    2450:	40 91 44 09 	lds	r20, 0x0944
    2454:	44 23       	and	r20, r20
    2456:	89 f0       	breq	.+34     	; 0x247a <twi_readFrom+0x94>
    2458:	e5 e4       	ldi	r30, 0x45	; 69
    245a:	f9 e0       	ldi	r31, 0x09	; 9
    245c:	a6 2f       	mov	r26, r22
    245e:	b7 2f       	mov	r27, r23
    2460:	2f ef       	ldi	r18, 0xFF	; 255
    2462:	24 0f       	add	r18, r20
    2464:	30 e0       	ldi	r19, 0x00	; 0
    2466:	2a 5b       	subi	r18, 0xBA	; 186
    2468:	36 4f       	sbci	r19, 0xF6	; 246
    246a:	91 91       	ld	r25, Z+
    246c:	9d 93       	st	X+, r25
    246e:	e2 17       	cp	r30, r18
    2470:	f3 07       	cpc	r31, r19
    2472:	d9 f7       	brne	.-10     	; 0x246a <twi_readFrom+0x84>
    2474:	04 c0       	rjmp	.+8      	; 0x247e <twi_readFrom+0x98>
    2476:	80 e0       	ldi	r24, 0x00	; 0
    2478:	08 95       	ret
    247a:	84 2f       	mov	r24, r20
    247c:	08 95       	ret
    247e:	84 2f       	mov	r24, r20
    2480:	08 95       	ret

00002482 <twi_writeTo>:
    2482:	0f 93       	push	r16
    2484:	41 32       	cpi	r20, 0x21	; 33
    2486:	08 f0       	brcs	.+2      	; 0x248a <twi_writeTo+0x8>
    2488:	50 c0       	rjmp	.+160    	; 0x252a <twi_writeTo+0xa8>
    248a:	90 91 6c 09 	lds	r25, 0x096C
    248e:	91 11       	cpse	r25, r1
    2490:	fc cf       	rjmp	.-8      	; 0x248a <twi_writeTo+0x8>
    2492:	92 e0       	ldi	r25, 0x02	; 2
    2494:	90 93 6c 09 	sts	0x096C, r25
    2498:	00 93 6a 09 	sts	0x096A, r16
    249c:	9f ef       	ldi	r25, 0xFF	; 255
    249e:	90 93 ff 08 	sts	0x08FF, r25
    24a2:	10 92 44 09 	sts	0x0944, r1
    24a6:	40 93 43 09 	sts	0x0943, r20
    24aa:	44 23       	and	r20, r20
    24ac:	69 f0       	breq	.+26     	; 0x24c8 <twi_writeTo+0x46>
    24ae:	fb 01       	movw	r30, r22
    24b0:	a5 e4       	ldi	r26, 0x45	; 69
    24b2:	b9 e0       	ldi	r27, 0x09	; 9
    24b4:	6f 5f       	subi	r22, 0xFF	; 255
    24b6:	7f 4f       	sbci	r23, 0xFF	; 255
    24b8:	41 50       	subi	r20, 0x01	; 1
    24ba:	64 0f       	add	r22, r20
    24bc:	71 1d       	adc	r23, r1
    24be:	91 91       	ld	r25, Z+
    24c0:	9d 93       	st	X+, r25
    24c2:	e6 17       	cp	r30, r22
    24c4:	f7 07       	cpc	r31, r23
    24c6:	d9 f7       	brne	.-10     	; 0x24be <twi_writeTo+0x3c>
    24c8:	10 92 6b 09 	sts	0x096B, r1
    24cc:	90 91 6b 09 	lds	r25, 0x096B
    24d0:	88 0f       	add	r24, r24
    24d2:	89 2b       	or	r24, r25
    24d4:	80 93 6b 09 	sts	0x096B, r24
    24d8:	80 91 69 09 	lds	r24, 0x0969
    24dc:	81 30       	cpi	r24, 0x01	; 1
    24de:	51 f4       	brne	.+20     	; 0x24f4 <twi_writeTo+0x72>
    24e0:	10 92 69 09 	sts	0x0969, r1
    24e4:	80 91 6b 09 	lds	r24, 0x096B
    24e8:	80 93 bb 00 	sts	0x00BB, r24
    24ec:	85 ec       	ldi	r24, 0xC5	; 197
    24ee:	80 93 bc 00 	sts	0x00BC, r24
    24f2:	03 c0       	rjmp	.+6      	; 0x24fa <twi_writeTo+0x78>
    24f4:	85 ee       	ldi	r24, 0xE5	; 229
    24f6:	80 93 bc 00 	sts	0x00BC, r24
    24fa:	22 23       	and	r18, r18
    24fc:	41 f0       	breq	.+16     	; 0x250e <twi_writeTo+0x8c>
    24fe:	80 91 6c 09 	lds	r24, 0x096C
    2502:	82 30       	cpi	r24, 0x02	; 2
    2504:	21 f4       	brne	.+8      	; 0x250e <twi_writeTo+0x8c>
    2506:	80 91 6c 09 	lds	r24, 0x096C
    250a:	82 30       	cpi	r24, 0x02	; 2
    250c:	e1 f3       	breq	.-8      	; 0x2506 <twi_writeTo+0x84>
    250e:	80 91 ff 08 	lds	r24, 0x08FF
    2512:	8f 3f       	cpi	r24, 0xFF	; 255
    2514:	61 f0       	breq	.+24     	; 0x252e <twi_writeTo+0xac>
    2516:	80 91 ff 08 	lds	r24, 0x08FF
    251a:	80 32       	cpi	r24, 0x20	; 32
    251c:	51 f0       	breq	.+20     	; 0x2532 <twi_writeTo+0xb0>
    251e:	80 91 ff 08 	lds	r24, 0x08FF
    2522:	80 33       	cpi	r24, 0x30	; 48
    2524:	41 f4       	brne	.+16     	; 0x2536 <twi_writeTo+0xb4>
    2526:	83 e0       	ldi	r24, 0x03	; 3
    2528:	07 c0       	rjmp	.+14     	; 0x2538 <twi_writeTo+0xb6>
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	05 c0       	rjmp	.+10     	; 0x2538 <twi_writeTo+0xb6>
    252e:	80 e0       	ldi	r24, 0x00	; 0
    2530:	03 c0       	rjmp	.+6      	; 0x2538 <twi_writeTo+0xb6>
    2532:	82 e0       	ldi	r24, 0x02	; 2
    2534:	01 c0       	rjmp	.+2      	; 0x2538 <twi_writeTo+0xb6>
    2536:	84 e0       	ldi	r24, 0x04	; 4
    2538:	0f 91       	pop	r16
    253a:	08 95       	ret

0000253c <twi_transmit>:
    253c:	61 32       	cpi	r22, 0x21	; 33
    253e:	a8 f4       	brcc	.+42     	; 0x256a <twi_transmit+0x2e>
    2540:	20 91 6c 09 	lds	r18, 0x096C
    2544:	24 30       	cpi	r18, 0x04	; 4
    2546:	99 f4       	brne	.+38     	; 0x256e <twi_transmit+0x32>
    2548:	60 93 21 09 	sts	0x0921, r22
    254c:	66 23       	and	r22, r22
    254e:	89 f0       	breq	.+34     	; 0x2572 <twi_transmit+0x36>
    2550:	fc 01       	movw	r30, r24
    2552:	a3 e2       	ldi	r26, 0x23	; 35
    2554:	b9 e0       	ldi	r27, 0x09	; 9
    2556:	01 96       	adiw	r24, 0x01	; 1
    2558:	61 50       	subi	r22, 0x01	; 1
    255a:	86 0f       	add	r24, r22
    255c:	91 1d       	adc	r25, r1
    255e:	21 91       	ld	r18, Z+
    2560:	2d 93       	st	X+, r18
    2562:	e8 17       	cp	r30, r24
    2564:	f9 07       	cpc	r31, r25
    2566:	d9 f7       	brne	.-10     	; 0x255e <twi_transmit+0x22>
    2568:	06 c0       	rjmp	.+12     	; 0x2576 <twi_transmit+0x3a>
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	08 95       	ret
    256e:	82 e0       	ldi	r24, 0x02	; 2
    2570:	08 95       	ret
    2572:	80 e0       	ldi	r24, 0x00	; 0
    2574:	08 95       	ret
    2576:	80 e0       	ldi	r24, 0x00	; 0
    2578:	08 95       	ret

0000257a <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    257a:	85 ed       	ldi	r24, 0xD5	; 213
    257c:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    2580:	ec eb       	ldi	r30, 0xBC	; 188
    2582:	f0 e0       	ldi	r31, 0x00	; 0
    2584:	80 81       	ld	r24, Z
    2586:	84 fd       	sbrc	r24, 4
    2588:	fd cf       	rjmp	.-6      	; 0x2584 <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    258a:	10 92 6c 09 	sts	0x096C, r1
    258e:	08 95       	ret

00002590 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2590:	85 ec       	ldi	r24, 0xC5	; 197
    2592:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2596:	10 92 6c 09 	sts	0x096C, r1
    259a:	08 95       	ret

0000259c <__vector_39>:
}

ISR(TWI_vect)
{
    259c:	1f 92       	push	r1
    259e:	0f 92       	push	r0
    25a0:	0f b6       	in	r0, 0x3f	; 63
    25a2:	0f 92       	push	r0
    25a4:	11 24       	eor	r1, r1
    25a6:	0b b6       	in	r0, 0x3b	; 59
    25a8:	0f 92       	push	r0
    25aa:	2f 93       	push	r18
    25ac:	3f 93       	push	r19
    25ae:	4f 93       	push	r20
    25b0:	5f 93       	push	r21
    25b2:	6f 93       	push	r22
    25b4:	7f 93       	push	r23
    25b6:	8f 93       	push	r24
    25b8:	9f 93       	push	r25
    25ba:	af 93       	push	r26
    25bc:	bf 93       	push	r27
    25be:	ef 93       	push	r30
    25c0:	ff 93       	push	r31
  switch(TW_STATUS){
    25c2:	80 91 b9 00 	lds	r24, 0x00B9
    25c6:	88 7f       	andi	r24, 0xF8	; 248
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	89 3c       	cpi	r24, 0xC9	; 201
    25cc:	91 05       	cpc	r25, r1
    25ce:	08 f0       	brcs	.+2      	; 0x25d2 <__vector_39+0x36>
    25d0:	ed c0       	rjmp	.+474    	; 0x27ac <__vector_39+0x210>
    25d2:	fc 01       	movw	r30, r24
    25d4:	ee 58       	subi	r30, 0x8E	; 142
    25d6:	ff 4f       	sbci	r31, 0xFF	; 255
    25d8:	f8 c7       	rjmp	.+4080   	; 0x35ca <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    25da:	80 91 6b 09 	lds	r24, 0x096B
    25de:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    25e2:	85 ec       	ldi	r24, 0xC5	; 197
    25e4:	80 93 bc 00 	sts	0x00BC, r24
    25e8:	e1 c0       	rjmp	.+450    	; 0x27ac <__vector_39+0x210>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    25ea:	90 91 44 09 	lds	r25, 0x0944
    25ee:	80 91 43 09 	lds	r24, 0x0943
    25f2:	98 17       	cp	r25, r24
    25f4:	80 f4       	brcc	.+32     	; 0x2616 <__vector_39+0x7a>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    25f6:	e0 91 44 09 	lds	r30, 0x0944
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	8e 0f       	add	r24, r30
    25fe:	80 93 44 09 	sts	0x0944, r24
    2602:	f0 e0       	ldi	r31, 0x00	; 0
    2604:	eb 5b       	subi	r30, 0xBB	; 187
    2606:	f6 4f       	sbci	r31, 0xF6	; 246
    2608:	80 81       	ld	r24, Z
    260a:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    260e:	85 ec       	ldi	r24, 0xC5	; 197
    2610:	80 93 bc 00 	sts	0x00BC, r24
    2614:	cb c0       	rjmp	.+406    	; 0x27ac <__vector_39+0x210>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    2616:	80 91 6a 09 	lds	r24, 0x096A
    261a:	88 23       	and	r24, r24
    261c:	11 f0       	breq	.+4      	; 0x2622 <__vector_39+0x86>
          twi_stop();
    261e:	ad df       	rcall	.-166    	; 0x257a <twi_stop>
    2620:	c5 c0       	rjmp	.+394    	; 0x27ac <__vector_39+0x210>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2622:	81 e0       	ldi	r24, 0x01	; 1
    2624:	80 93 69 09 	sts	0x0969, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2628:	84 ea       	ldi	r24, 0xA4	; 164
    262a:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    262e:	10 92 6c 09 	sts	0x096C, r1
    2632:	bc c0       	rjmp	.+376    	; 0x27ac <__vector_39+0x210>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    2634:	80 e2       	ldi	r24, 0x20	; 32
    2636:	80 93 ff 08 	sts	0x08FF, r24
      twi_stop();
    263a:	9f df       	rcall	.-194    	; 0x257a <twi_stop>
      break;
    263c:	b7 c0       	rjmp	.+366    	; 0x27ac <__vector_39+0x210>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    263e:	80 e3       	ldi	r24, 0x30	; 48
    2640:	80 93 ff 08 	sts	0x08FF, r24
      twi_stop();
    2644:	9a df       	rcall	.-204    	; 0x257a <twi_stop>
      break;
    2646:	b2 c0       	rjmp	.+356    	; 0x27ac <__vector_39+0x210>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    2648:	88 e3       	ldi	r24, 0x38	; 56
    264a:	80 93 ff 08 	sts	0x08FF, r24
      twi_releaseBus();
    264e:	a0 df       	rcall	.-192    	; 0x2590 <twi_releaseBus>
      break;
    2650:	ad c0       	rjmp	.+346    	; 0x27ac <__vector_39+0x210>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2652:	e0 91 44 09 	lds	r30, 0x0944
    2656:	81 e0       	ldi	r24, 0x01	; 1
    2658:	8e 0f       	add	r24, r30
    265a:	80 93 44 09 	sts	0x0944, r24
    265e:	80 91 bb 00 	lds	r24, 0x00BB
    2662:	f0 e0       	ldi	r31, 0x00	; 0
    2664:	eb 5b       	subi	r30, 0xBB	; 187
    2666:	f6 4f       	sbci	r31, 0xF6	; 246
    2668:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    266a:	90 91 44 09 	lds	r25, 0x0944
    266e:	80 91 43 09 	lds	r24, 0x0943
    2672:	98 17       	cp	r25, r24
    2674:	20 f4       	brcc	.+8      	; 0x267e <__vector_39+0xe2>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2676:	85 ec       	ldi	r24, 0xC5	; 197
    2678:	80 93 bc 00 	sts	0x00BC, r24
    267c:	97 c0       	rjmp	.+302    	; 0x27ac <__vector_39+0x210>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    267e:	85 e8       	ldi	r24, 0x85	; 133
    2680:	80 93 bc 00 	sts	0x00BC, r24
    2684:	93 c0       	rjmp	.+294    	; 0x27ac <__vector_39+0x210>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2686:	e0 91 44 09 	lds	r30, 0x0944
    268a:	81 e0       	ldi	r24, 0x01	; 1
    268c:	8e 0f       	add	r24, r30
    268e:	80 93 44 09 	sts	0x0944, r24
    2692:	80 91 bb 00 	lds	r24, 0x00BB
    2696:	f0 e0       	ldi	r31, 0x00	; 0
    2698:	eb 5b       	subi	r30, 0xBB	; 187
    269a:	f6 4f       	sbci	r31, 0xF6	; 246
    269c:	80 83       	st	Z, r24
	if (twi_sendStop)
    269e:	80 91 6a 09 	lds	r24, 0x096A
    26a2:	88 23       	and	r24, r24
    26a4:	11 f0       	breq	.+4      	; 0x26aa <__vector_39+0x10e>
          twi_stop();
    26a6:	69 df       	rcall	.-302    	; 0x257a <twi_stop>
    26a8:	81 c0       	rjmp	.+258    	; 0x27ac <__vector_39+0x210>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	80 93 69 09 	sts	0x0969, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    26b0:	84 ea       	ldi	r24, 0xA4	; 164
    26b2:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    26b6:	10 92 6c 09 	sts	0x096C, r1
    26ba:	78 c0       	rjmp	.+240    	; 0x27ac <__vector_39+0x210>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    26bc:	5e df       	rcall	.-324    	; 0x257a <twi_stop>
      break;
    26be:	76 c0       	rjmp	.+236    	; 0x27ac <__vector_39+0x210>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    26c0:	83 e0       	ldi	r24, 0x03	; 3
    26c2:	80 93 6c 09 	sts	0x096C, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    26c6:	10 92 00 09 	sts	0x0900, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    26ca:	85 ec       	ldi	r24, 0xC5	; 197
    26cc:	80 93 bc 00 	sts	0x00BC, r24
    26d0:	6d c0       	rjmp	.+218    	; 0x27ac <__vector_39+0x210>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    26d2:	80 91 00 09 	lds	r24, 0x0900
    26d6:	80 32       	cpi	r24, 0x20	; 32
    26d8:	80 f4       	brcc	.+32     	; 0x26fa <__vector_39+0x15e>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    26da:	e0 91 00 09 	lds	r30, 0x0900
    26de:	81 e0       	ldi	r24, 0x01	; 1
    26e0:	8e 0f       	add	r24, r30
    26e2:	80 93 00 09 	sts	0x0900, r24
    26e6:	80 91 bb 00 	lds	r24, 0x00BB
    26ea:	f0 e0       	ldi	r31, 0x00	; 0
    26ec:	ef 5f       	subi	r30, 0xFF	; 255
    26ee:	f6 4f       	sbci	r31, 0xF6	; 246
    26f0:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    26f2:	85 ec       	ldi	r24, 0xC5	; 197
    26f4:	80 93 bc 00 	sts	0x00BC, r24
    26f8:	59 c0       	rjmp	.+178    	; 0x27ac <__vector_39+0x210>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    26fa:	85 e8       	ldi	r24, 0x85	; 133
    26fc:	80 93 bc 00 	sts	0x00BC, r24
    2700:	55 c0       	rjmp	.+170    	; 0x27ac <__vector_39+0x210>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    2702:	80 91 00 09 	lds	r24, 0x0900
    2706:	80 32       	cpi	r24, 0x20	; 32
    2708:	30 f4       	brcc	.+12     	; 0x2716 <__vector_39+0x17a>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    270a:	e0 91 00 09 	lds	r30, 0x0900
    270e:	f0 e0       	ldi	r31, 0x00	; 0
    2710:	ef 5f       	subi	r30, 0xFF	; 255
    2712:	f6 4f       	sbci	r31, 0xF6	; 246
    2714:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    2716:	31 df       	rcall	.-414    	; 0x257a <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    2718:	60 91 00 09 	lds	r22, 0x0900
    271c:	70 e0       	ldi	r23, 0x00	; 0
    271e:	e0 91 65 09 	lds	r30, 0x0965
    2722:	f0 91 66 09 	lds	r31, 0x0966
    2726:	81 e0       	ldi	r24, 0x01	; 1
    2728:	99 e0       	ldi	r25, 0x09	; 9
    272a:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    272c:	10 92 00 09 	sts	0x0900, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    2730:	2f df       	rcall	.-418    	; 0x2590 <twi_releaseBus>
      break;
    2732:	3c c0       	rjmp	.+120    	; 0x27ac <__vector_39+0x210>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2734:	85 e8       	ldi	r24, 0x85	; 133
    2736:	80 93 bc 00 	sts	0x00BC, r24
    273a:	38 c0       	rjmp	.+112    	; 0x27ac <__vector_39+0x210>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    273c:	84 e0       	ldi	r24, 0x04	; 4
    273e:	80 93 6c 09 	sts	0x096C, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    2742:	10 92 22 09 	sts	0x0922, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2746:	10 92 21 09 	sts	0x0921, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    274a:	e0 91 67 09 	lds	r30, 0x0967
    274e:	f0 91 68 09 	lds	r31, 0x0968
    2752:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2754:	80 91 21 09 	lds	r24, 0x0921
    2758:	81 11       	cpse	r24, r1
    275a:	05 c0       	rjmp	.+10     	; 0x2766 <__vector_39+0x1ca>
        twi_txBufferLength = 1;
    275c:	81 e0       	ldi	r24, 0x01	; 1
    275e:	80 93 21 09 	sts	0x0921, r24
        twi_txBuffer[0] = 0x00;
    2762:	10 92 23 09 	sts	0x0923, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2766:	e0 91 22 09 	lds	r30, 0x0922
    276a:	81 e0       	ldi	r24, 0x01	; 1
    276c:	8e 0f       	add	r24, r30
    276e:	80 93 22 09 	sts	0x0922, r24
    2772:	f0 e0       	ldi	r31, 0x00	; 0
    2774:	ed 5d       	subi	r30, 0xDD	; 221
    2776:	f6 4f       	sbci	r31, 0xF6	; 246
    2778:	80 81       	ld	r24, Z
    277a:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    277e:	90 91 22 09 	lds	r25, 0x0922
    2782:	80 91 21 09 	lds	r24, 0x0921
    2786:	98 17       	cp	r25, r24
    2788:	20 f4       	brcc	.+8      	; 0x2792 <__vector_39+0x1f6>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    278a:	85 ec       	ldi	r24, 0xC5	; 197
    278c:	80 93 bc 00 	sts	0x00BC, r24
    2790:	0d c0       	rjmp	.+26     	; 0x27ac <__vector_39+0x210>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2792:	85 e8       	ldi	r24, 0x85	; 133
    2794:	80 93 bc 00 	sts	0x00BC, r24
    2798:	09 c0       	rjmp	.+18     	; 0x27ac <__vector_39+0x210>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    279a:	85 ec       	ldi	r24, 0xC5	; 197
    279c:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    27a0:	10 92 6c 09 	sts	0x096C, r1
      break;
    27a4:	03 c0       	rjmp	.+6      	; 0x27ac <__vector_39+0x210>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    27a6:	10 92 ff 08 	sts	0x08FF, r1
      twi_stop();
    27aa:	e7 de       	rcall	.-562    	; 0x257a <twi_stop>
      break;
  }
}
    27ac:	ff 91       	pop	r31
    27ae:	ef 91       	pop	r30
    27b0:	bf 91       	pop	r27
    27b2:	af 91       	pop	r26
    27b4:	9f 91       	pop	r25
    27b6:	8f 91       	pop	r24
    27b8:	7f 91       	pop	r23
    27ba:	6f 91       	pop	r22
    27bc:	5f 91       	pop	r21
    27be:	4f 91       	pop	r20
    27c0:	3f 91       	pop	r19
    27c2:	2f 91       	pop	r18
    27c4:	0f 90       	pop	r0
    27c6:	0b be       	out	0x3b, r0	; 59
    27c8:	0f 90       	pop	r0
    27ca:	0f be       	out	0x3f, r0	; 63
    27cc:	0f 90       	pop	r0
    27ce:	1f 90       	pop	r1
    27d0:	18 95       	reti

000027d2 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    27d2:	80 91 9d 09 	lds	r24, 0x099D
    27d6:	90 e0       	ldi	r25, 0x00	; 0
    27d8:	20 91 9e 09 	lds	r18, 0x099E
    27dc:	82 1b       	sub	r24, r18
    27de:	91 09       	sbc	r25, r1
    27e0:	08 95       	ret

000027e2 <_ZN7TwoWire4readEv>:
    27e2:	20 91 9e 09 	lds	r18, 0x099E
    27e6:	80 91 9d 09 	lds	r24, 0x099D
    27ea:	28 17       	cp	r18, r24
    27ec:	50 f4       	brcc	.+20     	; 0x2802 <_ZN7TwoWire4readEv+0x20>
    27ee:	e2 2f       	mov	r30, r18
    27f0:	f0 e0       	ldi	r31, 0x00	; 0
    27f2:	e1 56       	subi	r30, 0x61	; 97
    27f4:	f6 4f       	sbci	r31, 0xF6	; 246
    27f6:	80 81       	ld	r24, Z
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	2f 5f       	subi	r18, 0xFF	; 255
    27fc:	20 93 9e 09 	sts	0x099E, r18
    2800:	08 95       	ret
    2802:	8f ef       	ldi	r24, 0xFF	; 255
    2804:	9f ef       	ldi	r25, 0xFF	; 255
    2806:	08 95       	ret

00002808 <_ZN7TwoWire4peekEv>:
    2808:	e0 91 9e 09 	lds	r30, 0x099E
    280c:	80 91 9d 09 	lds	r24, 0x099D
    2810:	e8 17       	cp	r30, r24
    2812:	30 f4       	brcc	.+12     	; 0x2820 <_ZN7TwoWire4peekEv+0x18>
    2814:	f0 e0       	ldi	r31, 0x00	; 0
    2816:	e1 56       	subi	r30, 0x61	; 97
    2818:	f6 4f       	sbci	r31, 0xF6	; 246
    281a:	80 81       	ld	r24, Z
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	08 95       	ret
    2820:	8f ef       	ldi	r24, 0xFF	; 255
    2822:	9f ef       	ldi	r25, 0xFF	; 255
    2824:	08 95       	ret

00002826 <_ZN7TwoWire5flushEv>:
    2826:	08 95       	ret

00002828 <_ZN7TwoWire5writeEPKhj>:
    2828:	cf 92       	push	r12
    282a:	df 92       	push	r13
    282c:	ef 92       	push	r14
    282e:	ff 92       	push	r15
    2830:	0f 93       	push	r16
    2832:	1f 93       	push	r17
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
    2838:	8c 01       	movw	r16, r24
    283a:	7b 01       	movw	r14, r22
    283c:	6a 01       	movw	r12, r20
    283e:	80 91 79 09 	lds	r24, 0x0979
    2842:	88 23       	and	r24, r24
    2844:	99 f0       	breq	.+38     	; 0x286c <_ZN7TwoWire5writeEPKhj+0x44>
    2846:	41 15       	cp	r20, r1
    2848:	51 05       	cpc	r21, r1
    284a:	99 f0       	breq	.+38     	; 0x2872 <_ZN7TwoWire5writeEPKhj+0x4a>
    284c:	eb 01       	movw	r28, r22
    284e:	e4 0e       	add	r14, r20
    2850:	f5 1e       	adc	r15, r21
    2852:	69 91       	ld	r22, Y+
    2854:	d8 01       	movw	r26, r16
    2856:	ed 91       	ld	r30, X+
    2858:	fc 91       	ld	r31, X
    285a:	01 90       	ld	r0, Z+
    285c:	f0 81       	ld	r31, Z
    285e:	e0 2d       	mov	r30, r0
    2860:	c8 01       	movw	r24, r16
    2862:	19 95       	eicall
    2864:	ce 15       	cp	r28, r14
    2866:	df 05       	cpc	r29, r15
    2868:	a1 f7       	brne	.-24     	; 0x2852 <_ZN7TwoWire5writeEPKhj+0x2a>
    286a:	03 c0       	rjmp	.+6      	; 0x2872 <_ZN7TwoWire5writeEPKhj+0x4a>
    286c:	64 2f       	mov	r22, r20
    286e:	c7 01       	movw	r24, r14
    2870:	65 de       	rcall	.-822    	; 0x253c <twi_transmit>
    2872:	c6 01       	movw	r24, r12
    2874:	df 91       	pop	r29
    2876:	cf 91       	pop	r28
    2878:	1f 91       	pop	r17
    287a:	0f 91       	pop	r16
    287c:	ff 90       	pop	r15
    287e:	ef 90       	pop	r14
    2880:	df 90       	pop	r13
    2882:	cf 90       	pop	r12
    2884:	08 95       	ret

00002886 <_ZN7TwoWire5writeEh>:
    2886:	cf 93       	push	r28
    2888:	df 93       	push	r29
    288a:	1f 92       	push	r1
    288c:	cd b7       	in	r28, 0x3d	; 61
    288e:	de b7       	in	r29, 0x3e	; 62
    2890:	69 83       	std	Y+1, r22	; 0x01
    2892:	20 91 79 09 	lds	r18, 0x0979
    2896:	22 23       	and	r18, r18
    2898:	e1 f0       	breq	.+56     	; 0x28d2 <_ZN7TwoWire5writeEh+0x4c>
    289a:	20 91 7a 09 	lds	r18, 0x097A
    289e:	20 32       	cpi	r18, 0x20	; 32
    28a0:	40 f0       	brcs	.+16     	; 0x28b2 <_ZN7TwoWire5writeEh+0x2c>
    28a2:	21 e0       	ldi	r18, 0x01	; 1
    28a4:	30 e0       	ldi	r19, 0x00	; 0
    28a6:	fc 01       	movw	r30, r24
    28a8:	33 83       	std	Z+3, r19	; 0x03
    28aa:	22 83       	std	Z+2, r18	; 0x02
    28ac:	80 e0       	ldi	r24, 0x00	; 0
    28ae:	90 e0       	ldi	r25, 0x00	; 0
    28b0:	16 c0       	rjmp	.+44     	; 0x28de <_ZN7TwoWire5writeEh+0x58>
    28b2:	80 91 7b 09 	lds	r24, 0x097B
    28b6:	e8 2f       	mov	r30, r24
    28b8:	f0 e0       	ldi	r31, 0x00	; 0
    28ba:	e4 58       	subi	r30, 0x84	; 132
    28bc:	f6 4f       	sbci	r31, 0xF6	; 246
    28be:	99 81       	ldd	r25, Y+1	; 0x01
    28c0:	90 83       	st	Z, r25
    28c2:	8f 5f       	subi	r24, 0xFF	; 255
    28c4:	80 93 7b 09 	sts	0x097B, r24
    28c8:	80 93 7a 09 	sts	0x097A, r24
    28cc:	81 e0       	ldi	r24, 0x01	; 1
    28ce:	90 e0       	ldi	r25, 0x00	; 0
    28d0:	06 c0       	rjmp	.+12     	; 0x28de <_ZN7TwoWire5writeEh+0x58>
    28d2:	61 e0       	ldi	r22, 0x01	; 1
    28d4:	ce 01       	movw	r24, r28
    28d6:	01 96       	adiw	r24, 0x01	; 1
    28d8:	31 de       	rcall	.-926    	; 0x253c <twi_transmit>
    28da:	81 e0       	ldi	r24, 0x01	; 1
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	0f 90       	pop	r0
    28e0:	df 91       	pop	r29
    28e2:	cf 91       	pop	r28
    28e4:	08 95       	ret

000028e6 <_ZN7TwoWireC1Ev>:
    28e6:	fc 01       	movw	r30, r24
    28e8:	13 82       	std	Z+3, r1	; 0x03
    28ea:	12 82       	std	Z+2, r1	; 0x02
    28ec:	48 ee       	ldi	r20, 0xE8	; 232
    28ee:	53 e0       	ldi	r21, 0x03	; 3
    28f0:	60 e0       	ldi	r22, 0x00	; 0
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	44 83       	std	Z+4, r20	; 0x04
    28f6:	55 83       	std	Z+5, r21	; 0x05
    28f8:	66 83       	std	Z+6, r22	; 0x06
    28fa:	77 83       	std	Z+7, r23	; 0x07
    28fc:	80 e6       	ldi	r24, 0x60	; 96
    28fe:	92 e0       	ldi	r25, 0x02	; 2
    2900:	91 83       	std	Z+1, r25	; 0x01
    2902:	80 83       	st	Z, r24
    2904:	08 95       	ret

00002906 <_ZN7TwoWire5beginEv>:
    2906:	10 92 9e 09 	sts	0x099E, r1
    290a:	10 92 9d 09 	sts	0x099D, r1
    290e:	10 92 7b 09 	sts	0x097B, r1
    2912:	10 92 7a 09 	sts	0x097A, r1
    2916:	49 cd       	rjmp	.-1390   	; 0x23aa <twi_init>
    2918:	08 95       	ret

0000291a <_ZN7TwoWire11requestFromEhhh>:
    291a:	86 2f       	mov	r24, r22
    291c:	41 32       	cpi	r20, 0x21	; 33
    291e:	08 f0       	brcs	.+2      	; 0x2922 <_ZN7TwoWire11requestFromEhhh+0x8>
    2920:	40 e2       	ldi	r20, 0x20	; 32
    2922:	6f e9       	ldi	r22, 0x9F	; 159
    2924:	79 e0       	ldi	r23, 0x09	; 9
    2926:	5f dd       	rcall	.-1346   	; 0x23e6 <twi_readFrom>
    2928:	10 92 9e 09 	sts	0x099E, r1
    292c:	80 93 9d 09 	sts	0x099D, r24
    2930:	08 95       	ret

00002932 <_ZN7TwoWire11requestFromEhh>:
    2932:	21 e0       	ldi	r18, 0x01	; 1
    2934:	f2 cf       	rjmp	.-28     	; 0x291a <_ZN7TwoWire11requestFromEhhh>
    2936:	08 95       	ret

00002938 <_ZN7TwoWire17beginTransmissionEh>:
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	80 93 79 09 	sts	0x0979, r24
    293e:	60 93 9c 09 	sts	0x099C, r22
    2942:	10 92 7b 09 	sts	0x097B, r1
    2946:	10 92 7a 09 	sts	0x097A, r1
    294a:	08 95       	ret

0000294c <_ZN7TwoWire15endTransmissionEh>:
    294c:	0f 93       	push	r16
    294e:	06 2f       	mov	r16, r22
    2950:	21 e0       	ldi	r18, 0x01	; 1
    2952:	40 91 7a 09 	lds	r20, 0x097A
    2956:	6c e7       	ldi	r22, 0x7C	; 124
    2958:	79 e0       	ldi	r23, 0x09	; 9
    295a:	80 91 9c 09 	lds	r24, 0x099C
    295e:	91 dd       	rcall	.-1246   	; 0x2482 <twi_writeTo>
    2960:	10 92 7b 09 	sts	0x097B, r1
    2964:	10 92 7a 09 	sts	0x097A, r1
    2968:	10 92 79 09 	sts	0x0979, r1
    296c:	0f 91       	pop	r16
    296e:	08 95       	ret

00002970 <_ZN7TwoWire15endTransmissionEv>:
    2970:	61 e0       	ldi	r22, 0x01	; 1
    2972:	ec cf       	rjmp	.-40     	; 0x294c <_ZN7TwoWire15endTransmissionEh>
    2974:	08 95       	ret

00002976 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2976:	8d e6       	ldi	r24, 0x6D	; 109
    2978:	99 e0       	ldi	r25, 0x09	; 9
    297a:	b5 cf       	rjmp	.-150    	; 0x28e6 <_ZN7TwoWireC1Ev>
    297c:	08 95       	ret

0000297e <__divsf3>:
    297e:	0c d0       	rcall	.+24     	; 0x2998 <__divsf3x>
    2980:	eb c0       	rjmp	.+470    	; 0x2b58 <__fp_round>
    2982:	e3 d0       	rcall	.+454    	; 0x2b4a <__fp_pscB>
    2984:	40 f0       	brcs	.+16     	; 0x2996 <__divsf3+0x18>
    2986:	da d0       	rcall	.+436    	; 0x2b3c <__fp_pscA>
    2988:	30 f0       	brcs	.+12     	; 0x2996 <__divsf3+0x18>
    298a:	21 f4       	brne	.+8      	; 0x2994 <__divsf3+0x16>
    298c:	5f 3f       	cpi	r21, 0xFF	; 255
    298e:	19 f0       	breq	.+6      	; 0x2996 <__divsf3+0x18>
    2990:	cc c0       	rjmp	.+408    	; 0x2b2a <__fp_inf>
    2992:	51 11       	cpse	r21, r1
    2994:	15 c1       	rjmp	.+554    	; 0x2bc0 <__fp_szero>
    2996:	cf c0       	rjmp	.+414    	; 0x2b36 <__fp_nan>

00002998 <__divsf3x>:
    2998:	f0 d0       	rcall	.+480    	; 0x2b7a <__fp_split3>
    299a:	98 f3       	brcs	.-26     	; 0x2982 <__divsf3+0x4>

0000299c <__divsf3_pse>:
    299c:	99 23       	and	r25, r25
    299e:	c9 f3       	breq	.-14     	; 0x2992 <__divsf3+0x14>
    29a0:	55 23       	and	r21, r21
    29a2:	b1 f3       	breq	.-20     	; 0x2990 <__divsf3+0x12>
    29a4:	95 1b       	sub	r25, r21
    29a6:	55 0b       	sbc	r21, r21
    29a8:	bb 27       	eor	r27, r27
    29aa:	aa 27       	eor	r26, r26
    29ac:	62 17       	cp	r22, r18
    29ae:	73 07       	cpc	r23, r19
    29b0:	84 07       	cpc	r24, r20
    29b2:	38 f0       	brcs	.+14     	; 0x29c2 <__divsf3_pse+0x26>
    29b4:	9f 5f       	subi	r25, 0xFF	; 255
    29b6:	5f 4f       	sbci	r21, 0xFF	; 255
    29b8:	22 0f       	add	r18, r18
    29ba:	33 1f       	adc	r19, r19
    29bc:	44 1f       	adc	r20, r20
    29be:	aa 1f       	adc	r26, r26
    29c0:	a9 f3       	breq	.-22     	; 0x29ac <__divsf3_pse+0x10>
    29c2:	33 d0       	rcall	.+102    	; 0x2a2a <__divsf3_pse+0x8e>
    29c4:	0e 2e       	mov	r0, r30
    29c6:	3a f0       	brmi	.+14     	; 0x29d6 <__divsf3_pse+0x3a>
    29c8:	e0 e8       	ldi	r30, 0x80	; 128
    29ca:	30 d0       	rcall	.+96     	; 0x2a2c <__divsf3_pse+0x90>
    29cc:	91 50       	subi	r25, 0x01	; 1
    29ce:	50 40       	sbci	r21, 0x00	; 0
    29d0:	e6 95       	lsr	r30
    29d2:	00 1c       	adc	r0, r0
    29d4:	ca f7       	brpl	.-14     	; 0x29c8 <__divsf3_pse+0x2c>
    29d6:	29 d0       	rcall	.+82     	; 0x2a2a <__divsf3_pse+0x8e>
    29d8:	fe 2f       	mov	r31, r30
    29da:	27 d0       	rcall	.+78     	; 0x2a2a <__divsf3_pse+0x8e>
    29dc:	66 0f       	add	r22, r22
    29de:	77 1f       	adc	r23, r23
    29e0:	88 1f       	adc	r24, r24
    29e2:	bb 1f       	adc	r27, r27
    29e4:	26 17       	cp	r18, r22
    29e6:	37 07       	cpc	r19, r23
    29e8:	48 07       	cpc	r20, r24
    29ea:	ab 07       	cpc	r26, r27
    29ec:	b0 e8       	ldi	r27, 0x80	; 128
    29ee:	09 f0       	breq	.+2      	; 0x29f2 <__divsf3_pse+0x56>
    29f0:	bb 0b       	sbc	r27, r27
    29f2:	80 2d       	mov	r24, r0
    29f4:	bf 01       	movw	r22, r30
    29f6:	ff 27       	eor	r31, r31
    29f8:	93 58       	subi	r25, 0x83	; 131
    29fa:	5f 4f       	sbci	r21, 0xFF	; 255
    29fc:	2a f0       	brmi	.+10     	; 0x2a08 <__divsf3_pse+0x6c>
    29fe:	9e 3f       	cpi	r25, 0xFE	; 254
    2a00:	51 05       	cpc	r21, r1
    2a02:	68 f0       	brcs	.+26     	; 0x2a1e <__divsf3_pse+0x82>
    2a04:	92 c0       	rjmp	.+292    	; 0x2b2a <__fp_inf>
    2a06:	dc c0       	rjmp	.+440    	; 0x2bc0 <__fp_szero>
    2a08:	5f 3f       	cpi	r21, 0xFF	; 255
    2a0a:	ec f3       	brlt	.-6      	; 0x2a06 <__divsf3_pse+0x6a>
    2a0c:	98 3e       	cpi	r25, 0xE8	; 232
    2a0e:	dc f3       	brlt	.-10     	; 0x2a06 <__divsf3_pse+0x6a>
    2a10:	86 95       	lsr	r24
    2a12:	77 95       	ror	r23
    2a14:	67 95       	ror	r22
    2a16:	b7 95       	ror	r27
    2a18:	f7 95       	ror	r31
    2a1a:	9f 5f       	subi	r25, 0xFF	; 255
    2a1c:	c9 f7       	brne	.-14     	; 0x2a10 <__divsf3_pse+0x74>
    2a1e:	88 0f       	add	r24, r24
    2a20:	91 1d       	adc	r25, r1
    2a22:	96 95       	lsr	r25
    2a24:	87 95       	ror	r24
    2a26:	97 f9       	bld	r25, 7
    2a28:	08 95       	ret
    2a2a:	e1 e0       	ldi	r30, 0x01	; 1
    2a2c:	66 0f       	add	r22, r22
    2a2e:	77 1f       	adc	r23, r23
    2a30:	88 1f       	adc	r24, r24
    2a32:	bb 1f       	adc	r27, r27
    2a34:	62 17       	cp	r22, r18
    2a36:	73 07       	cpc	r23, r19
    2a38:	84 07       	cpc	r24, r20
    2a3a:	ba 07       	cpc	r27, r26
    2a3c:	20 f0       	brcs	.+8      	; 0x2a46 <__divsf3_pse+0xaa>
    2a3e:	62 1b       	sub	r22, r18
    2a40:	73 0b       	sbc	r23, r19
    2a42:	84 0b       	sbc	r24, r20
    2a44:	ba 0b       	sbc	r27, r26
    2a46:	ee 1f       	adc	r30, r30
    2a48:	88 f7       	brcc	.-30     	; 0x2a2c <__divsf3_pse+0x90>
    2a4a:	e0 95       	com	r30
    2a4c:	08 95       	ret

00002a4e <__fixsfsi>:
    2a4e:	04 d0       	rcall	.+8      	; 0x2a58 <__fixunssfsi>
    2a50:	68 94       	set
    2a52:	b1 11       	cpse	r27, r1
    2a54:	b5 c0       	rjmp	.+362    	; 0x2bc0 <__fp_szero>
    2a56:	08 95       	ret

00002a58 <__fixunssfsi>:
    2a58:	98 d0       	rcall	.+304    	; 0x2b8a <__fp_splitA>
    2a5a:	88 f0       	brcs	.+34     	; 0x2a7e <__fixunssfsi+0x26>
    2a5c:	9f 57       	subi	r25, 0x7F	; 127
    2a5e:	90 f0       	brcs	.+36     	; 0x2a84 <__fixunssfsi+0x2c>
    2a60:	b9 2f       	mov	r27, r25
    2a62:	99 27       	eor	r25, r25
    2a64:	b7 51       	subi	r27, 0x17	; 23
    2a66:	a0 f0       	brcs	.+40     	; 0x2a90 <__fixunssfsi+0x38>
    2a68:	d1 f0       	breq	.+52     	; 0x2a9e <__fixunssfsi+0x46>
    2a6a:	66 0f       	add	r22, r22
    2a6c:	77 1f       	adc	r23, r23
    2a6e:	88 1f       	adc	r24, r24
    2a70:	99 1f       	adc	r25, r25
    2a72:	1a f0       	brmi	.+6      	; 0x2a7a <__fixunssfsi+0x22>
    2a74:	ba 95       	dec	r27
    2a76:	c9 f7       	brne	.-14     	; 0x2a6a <__fixunssfsi+0x12>
    2a78:	12 c0       	rjmp	.+36     	; 0x2a9e <__fixunssfsi+0x46>
    2a7a:	b1 30       	cpi	r27, 0x01	; 1
    2a7c:	81 f0       	breq	.+32     	; 0x2a9e <__fixunssfsi+0x46>
    2a7e:	9f d0       	rcall	.+318    	; 0x2bbe <__fp_zero>
    2a80:	b1 e0       	ldi	r27, 0x01	; 1
    2a82:	08 95       	ret
    2a84:	9c c0       	rjmp	.+312    	; 0x2bbe <__fp_zero>
    2a86:	67 2f       	mov	r22, r23
    2a88:	78 2f       	mov	r23, r24
    2a8a:	88 27       	eor	r24, r24
    2a8c:	b8 5f       	subi	r27, 0xF8	; 248
    2a8e:	39 f0       	breq	.+14     	; 0x2a9e <__fixunssfsi+0x46>
    2a90:	b9 3f       	cpi	r27, 0xF9	; 249
    2a92:	cc f3       	brlt	.-14     	; 0x2a86 <__fixunssfsi+0x2e>
    2a94:	86 95       	lsr	r24
    2a96:	77 95       	ror	r23
    2a98:	67 95       	ror	r22
    2a9a:	b3 95       	inc	r27
    2a9c:	d9 f7       	brne	.-10     	; 0x2a94 <__fixunssfsi+0x3c>
    2a9e:	3e f4       	brtc	.+14     	; 0x2aae <__fixunssfsi+0x56>
    2aa0:	90 95       	com	r25
    2aa2:	80 95       	com	r24
    2aa4:	70 95       	com	r23
    2aa6:	61 95       	neg	r22
    2aa8:	7f 4f       	sbci	r23, 0xFF	; 255
    2aaa:	8f 4f       	sbci	r24, 0xFF	; 255
    2aac:	9f 4f       	sbci	r25, 0xFF	; 255
    2aae:	08 95       	ret

00002ab0 <__floatunsisf>:
    2ab0:	e8 94       	clt
    2ab2:	09 c0       	rjmp	.+18     	; 0x2ac6 <__floatsisf+0x12>

00002ab4 <__floatsisf>:
    2ab4:	97 fb       	bst	r25, 7
    2ab6:	3e f4       	brtc	.+14     	; 0x2ac6 <__floatsisf+0x12>
    2ab8:	90 95       	com	r25
    2aba:	80 95       	com	r24
    2abc:	70 95       	com	r23
    2abe:	61 95       	neg	r22
    2ac0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ac2:	8f 4f       	sbci	r24, 0xFF	; 255
    2ac4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ac6:	99 23       	and	r25, r25
    2ac8:	a9 f0       	breq	.+42     	; 0x2af4 <__floatsisf+0x40>
    2aca:	f9 2f       	mov	r31, r25
    2acc:	96 e9       	ldi	r25, 0x96	; 150
    2ace:	bb 27       	eor	r27, r27
    2ad0:	93 95       	inc	r25
    2ad2:	f6 95       	lsr	r31
    2ad4:	87 95       	ror	r24
    2ad6:	77 95       	ror	r23
    2ad8:	67 95       	ror	r22
    2ada:	b7 95       	ror	r27
    2adc:	f1 11       	cpse	r31, r1
    2ade:	f8 cf       	rjmp	.-16     	; 0x2ad0 <__floatsisf+0x1c>
    2ae0:	fa f4       	brpl	.+62     	; 0x2b20 <__floatsisf+0x6c>
    2ae2:	bb 0f       	add	r27, r27
    2ae4:	11 f4       	brne	.+4      	; 0x2aea <__floatsisf+0x36>
    2ae6:	60 ff       	sbrs	r22, 0
    2ae8:	1b c0       	rjmp	.+54     	; 0x2b20 <__floatsisf+0x6c>
    2aea:	6f 5f       	subi	r22, 0xFF	; 255
    2aec:	7f 4f       	sbci	r23, 0xFF	; 255
    2aee:	8f 4f       	sbci	r24, 0xFF	; 255
    2af0:	9f 4f       	sbci	r25, 0xFF	; 255
    2af2:	16 c0       	rjmp	.+44     	; 0x2b20 <__floatsisf+0x6c>
    2af4:	88 23       	and	r24, r24
    2af6:	11 f0       	breq	.+4      	; 0x2afc <__floatsisf+0x48>
    2af8:	96 e9       	ldi	r25, 0x96	; 150
    2afa:	11 c0       	rjmp	.+34     	; 0x2b1e <__floatsisf+0x6a>
    2afc:	77 23       	and	r23, r23
    2afe:	21 f0       	breq	.+8      	; 0x2b08 <__floatsisf+0x54>
    2b00:	9e e8       	ldi	r25, 0x8E	; 142
    2b02:	87 2f       	mov	r24, r23
    2b04:	76 2f       	mov	r23, r22
    2b06:	05 c0       	rjmp	.+10     	; 0x2b12 <__floatsisf+0x5e>
    2b08:	66 23       	and	r22, r22
    2b0a:	71 f0       	breq	.+28     	; 0x2b28 <__floatsisf+0x74>
    2b0c:	96 e8       	ldi	r25, 0x86	; 134
    2b0e:	86 2f       	mov	r24, r22
    2b10:	70 e0       	ldi	r23, 0x00	; 0
    2b12:	60 e0       	ldi	r22, 0x00	; 0
    2b14:	2a f0       	brmi	.+10     	; 0x2b20 <__floatsisf+0x6c>
    2b16:	9a 95       	dec	r25
    2b18:	66 0f       	add	r22, r22
    2b1a:	77 1f       	adc	r23, r23
    2b1c:	88 1f       	adc	r24, r24
    2b1e:	da f7       	brpl	.-10     	; 0x2b16 <__floatsisf+0x62>
    2b20:	88 0f       	add	r24, r24
    2b22:	96 95       	lsr	r25
    2b24:	87 95       	ror	r24
    2b26:	97 f9       	bld	r25, 7
    2b28:	08 95       	ret

00002b2a <__fp_inf>:
    2b2a:	97 f9       	bld	r25, 7
    2b2c:	9f 67       	ori	r25, 0x7F	; 127
    2b2e:	80 e8       	ldi	r24, 0x80	; 128
    2b30:	70 e0       	ldi	r23, 0x00	; 0
    2b32:	60 e0       	ldi	r22, 0x00	; 0
    2b34:	08 95       	ret

00002b36 <__fp_nan>:
    2b36:	9f ef       	ldi	r25, 0xFF	; 255
    2b38:	80 ec       	ldi	r24, 0xC0	; 192
    2b3a:	08 95       	ret

00002b3c <__fp_pscA>:
    2b3c:	00 24       	eor	r0, r0
    2b3e:	0a 94       	dec	r0
    2b40:	16 16       	cp	r1, r22
    2b42:	17 06       	cpc	r1, r23
    2b44:	18 06       	cpc	r1, r24
    2b46:	09 06       	cpc	r0, r25
    2b48:	08 95       	ret

00002b4a <__fp_pscB>:
    2b4a:	00 24       	eor	r0, r0
    2b4c:	0a 94       	dec	r0
    2b4e:	12 16       	cp	r1, r18
    2b50:	13 06       	cpc	r1, r19
    2b52:	14 06       	cpc	r1, r20
    2b54:	05 06       	cpc	r0, r21
    2b56:	08 95       	ret

00002b58 <__fp_round>:
    2b58:	09 2e       	mov	r0, r25
    2b5a:	03 94       	inc	r0
    2b5c:	00 0c       	add	r0, r0
    2b5e:	11 f4       	brne	.+4      	; 0x2b64 <__fp_round+0xc>
    2b60:	88 23       	and	r24, r24
    2b62:	52 f0       	brmi	.+20     	; 0x2b78 <__fp_round+0x20>
    2b64:	bb 0f       	add	r27, r27
    2b66:	40 f4       	brcc	.+16     	; 0x2b78 <__fp_round+0x20>
    2b68:	bf 2b       	or	r27, r31
    2b6a:	11 f4       	brne	.+4      	; 0x2b70 <__fp_round+0x18>
    2b6c:	60 ff       	sbrs	r22, 0
    2b6e:	04 c0       	rjmp	.+8      	; 0x2b78 <__fp_round+0x20>
    2b70:	6f 5f       	subi	r22, 0xFF	; 255
    2b72:	7f 4f       	sbci	r23, 0xFF	; 255
    2b74:	8f 4f       	sbci	r24, 0xFF	; 255
    2b76:	9f 4f       	sbci	r25, 0xFF	; 255
    2b78:	08 95       	ret

00002b7a <__fp_split3>:
    2b7a:	57 fd       	sbrc	r21, 7
    2b7c:	90 58       	subi	r25, 0x80	; 128
    2b7e:	44 0f       	add	r20, r20
    2b80:	55 1f       	adc	r21, r21
    2b82:	59 f0       	breq	.+22     	; 0x2b9a <__fp_splitA+0x10>
    2b84:	5f 3f       	cpi	r21, 0xFF	; 255
    2b86:	71 f0       	breq	.+28     	; 0x2ba4 <__fp_splitA+0x1a>
    2b88:	47 95       	ror	r20

00002b8a <__fp_splitA>:
    2b8a:	88 0f       	add	r24, r24
    2b8c:	97 fb       	bst	r25, 7
    2b8e:	99 1f       	adc	r25, r25
    2b90:	61 f0       	breq	.+24     	; 0x2baa <__fp_splitA+0x20>
    2b92:	9f 3f       	cpi	r25, 0xFF	; 255
    2b94:	79 f0       	breq	.+30     	; 0x2bb4 <__fp_splitA+0x2a>
    2b96:	87 95       	ror	r24
    2b98:	08 95       	ret
    2b9a:	12 16       	cp	r1, r18
    2b9c:	13 06       	cpc	r1, r19
    2b9e:	14 06       	cpc	r1, r20
    2ba0:	55 1f       	adc	r21, r21
    2ba2:	f2 cf       	rjmp	.-28     	; 0x2b88 <__fp_split3+0xe>
    2ba4:	46 95       	lsr	r20
    2ba6:	f1 df       	rcall	.-30     	; 0x2b8a <__fp_splitA>
    2ba8:	08 c0       	rjmp	.+16     	; 0x2bba <__fp_splitA+0x30>
    2baa:	16 16       	cp	r1, r22
    2bac:	17 06       	cpc	r1, r23
    2bae:	18 06       	cpc	r1, r24
    2bb0:	99 1f       	adc	r25, r25
    2bb2:	f1 cf       	rjmp	.-30     	; 0x2b96 <__fp_splitA+0xc>
    2bb4:	86 95       	lsr	r24
    2bb6:	71 05       	cpc	r23, r1
    2bb8:	61 05       	cpc	r22, r1
    2bba:	08 94       	sec
    2bbc:	08 95       	ret

00002bbe <__fp_zero>:
    2bbe:	e8 94       	clt

00002bc0 <__fp_szero>:
    2bc0:	bb 27       	eor	r27, r27
    2bc2:	66 27       	eor	r22, r22
    2bc4:	77 27       	eor	r23, r23
    2bc6:	cb 01       	movw	r24, r22
    2bc8:	97 f9       	bld	r25, 7
    2bca:	08 95       	ret

00002bcc <__mulsf3>:
    2bcc:	0b d0       	rcall	.+22     	; 0x2be4 <__mulsf3x>
    2bce:	c4 cf       	rjmp	.-120    	; 0x2b58 <__fp_round>
    2bd0:	b5 df       	rcall	.-150    	; 0x2b3c <__fp_pscA>
    2bd2:	28 f0       	brcs	.+10     	; 0x2bde <__mulsf3+0x12>
    2bd4:	ba df       	rcall	.-140    	; 0x2b4a <__fp_pscB>
    2bd6:	18 f0       	brcs	.+6      	; 0x2bde <__mulsf3+0x12>
    2bd8:	95 23       	and	r25, r21
    2bda:	09 f0       	breq	.+2      	; 0x2bde <__mulsf3+0x12>
    2bdc:	a6 cf       	rjmp	.-180    	; 0x2b2a <__fp_inf>
    2bde:	ab cf       	rjmp	.-170    	; 0x2b36 <__fp_nan>
    2be0:	11 24       	eor	r1, r1
    2be2:	ee cf       	rjmp	.-36     	; 0x2bc0 <__fp_szero>

00002be4 <__mulsf3x>:
    2be4:	ca df       	rcall	.-108    	; 0x2b7a <__fp_split3>
    2be6:	a0 f3       	brcs	.-24     	; 0x2bd0 <__mulsf3+0x4>

00002be8 <__mulsf3_pse>:
    2be8:	95 9f       	mul	r25, r21
    2bea:	d1 f3       	breq	.-12     	; 0x2be0 <__mulsf3+0x14>
    2bec:	95 0f       	add	r25, r21
    2bee:	50 e0       	ldi	r21, 0x00	; 0
    2bf0:	55 1f       	adc	r21, r21
    2bf2:	62 9f       	mul	r22, r18
    2bf4:	f0 01       	movw	r30, r0
    2bf6:	72 9f       	mul	r23, r18
    2bf8:	bb 27       	eor	r27, r27
    2bfa:	f0 0d       	add	r31, r0
    2bfc:	b1 1d       	adc	r27, r1
    2bfe:	63 9f       	mul	r22, r19
    2c00:	aa 27       	eor	r26, r26
    2c02:	f0 0d       	add	r31, r0
    2c04:	b1 1d       	adc	r27, r1
    2c06:	aa 1f       	adc	r26, r26
    2c08:	64 9f       	mul	r22, r20
    2c0a:	66 27       	eor	r22, r22
    2c0c:	b0 0d       	add	r27, r0
    2c0e:	a1 1d       	adc	r26, r1
    2c10:	66 1f       	adc	r22, r22
    2c12:	82 9f       	mul	r24, r18
    2c14:	22 27       	eor	r18, r18
    2c16:	b0 0d       	add	r27, r0
    2c18:	a1 1d       	adc	r26, r1
    2c1a:	62 1f       	adc	r22, r18
    2c1c:	73 9f       	mul	r23, r19
    2c1e:	b0 0d       	add	r27, r0
    2c20:	a1 1d       	adc	r26, r1
    2c22:	62 1f       	adc	r22, r18
    2c24:	83 9f       	mul	r24, r19
    2c26:	a0 0d       	add	r26, r0
    2c28:	61 1d       	adc	r22, r1
    2c2a:	22 1f       	adc	r18, r18
    2c2c:	74 9f       	mul	r23, r20
    2c2e:	33 27       	eor	r19, r19
    2c30:	a0 0d       	add	r26, r0
    2c32:	61 1d       	adc	r22, r1
    2c34:	23 1f       	adc	r18, r19
    2c36:	84 9f       	mul	r24, r20
    2c38:	60 0d       	add	r22, r0
    2c3a:	21 1d       	adc	r18, r1
    2c3c:	82 2f       	mov	r24, r18
    2c3e:	76 2f       	mov	r23, r22
    2c40:	6a 2f       	mov	r22, r26
    2c42:	11 24       	eor	r1, r1
    2c44:	9f 57       	subi	r25, 0x7F	; 127
    2c46:	50 40       	sbci	r21, 0x00	; 0
    2c48:	8a f0       	brmi	.+34     	; 0x2c6c <__mulsf3_pse+0x84>
    2c4a:	e1 f0       	breq	.+56     	; 0x2c84 <__mulsf3_pse+0x9c>
    2c4c:	88 23       	and	r24, r24
    2c4e:	4a f0       	brmi	.+18     	; 0x2c62 <__mulsf3_pse+0x7a>
    2c50:	ee 0f       	add	r30, r30
    2c52:	ff 1f       	adc	r31, r31
    2c54:	bb 1f       	adc	r27, r27
    2c56:	66 1f       	adc	r22, r22
    2c58:	77 1f       	adc	r23, r23
    2c5a:	88 1f       	adc	r24, r24
    2c5c:	91 50       	subi	r25, 0x01	; 1
    2c5e:	50 40       	sbci	r21, 0x00	; 0
    2c60:	a9 f7       	brne	.-22     	; 0x2c4c <__mulsf3_pse+0x64>
    2c62:	9e 3f       	cpi	r25, 0xFE	; 254
    2c64:	51 05       	cpc	r21, r1
    2c66:	70 f0       	brcs	.+28     	; 0x2c84 <__mulsf3_pse+0x9c>
    2c68:	60 cf       	rjmp	.-320    	; 0x2b2a <__fp_inf>
    2c6a:	aa cf       	rjmp	.-172    	; 0x2bc0 <__fp_szero>
    2c6c:	5f 3f       	cpi	r21, 0xFF	; 255
    2c6e:	ec f3       	brlt	.-6      	; 0x2c6a <__mulsf3_pse+0x82>
    2c70:	98 3e       	cpi	r25, 0xE8	; 232
    2c72:	dc f3       	brlt	.-10     	; 0x2c6a <__mulsf3_pse+0x82>
    2c74:	86 95       	lsr	r24
    2c76:	77 95       	ror	r23
    2c78:	67 95       	ror	r22
    2c7a:	b7 95       	ror	r27
    2c7c:	f7 95       	ror	r31
    2c7e:	e7 95       	ror	r30
    2c80:	9f 5f       	subi	r25, 0xFF	; 255
    2c82:	c1 f7       	brne	.-16     	; 0x2c74 <__mulsf3_pse+0x8c>
    2c84:	fe 2b       	or	r31, r30
    2c86:	88 0f       	add	r24, r24
    2c88:	91 1d       	adc	r25, r1
    2c8a:	96 95       	lsr	r25
    2c8c:	87 95       	ror	r24
    2c8e:	97 f9       	bld	r25, 7
    2c90:	08 95       	ret

00002c92 <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    2c92:	fc 01       	movw	r30, r24
    2c94:	81 8d       	ldd	r24, Z+25	; 0x19
    2c96:	22 8d       	ldd	r18, Z+26	; 0x1a
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	80 5c       	subi	r24, 0xC0	; 192
    2c9c:	9f 4f       	sbci	r25, 0xFF	; 255
    2c9e:	82 1b       	sub	r24, r18
    2ca0:	91 09       	sbc	r25, r1
    2ca2:	8f 73       	andi	r24, 0x3F	; 63
    2ca4:	99 27       	eor	r25, r25
    2ca6:	08 95       	ret

00002ca8 <_ZN14HardwareSerial4peekEv>:
    2ca8:	fc 01       	movw	r30, r24
    2caa:	91 8d       	ldd	r25, Z+25	; 0x19
    2cac:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cae:	98 17       	cp	r25, r24
    2cb0:	31 f0       	breq	.+12     	; 0x2cbe <_ZN14HardwareSerial4peekEv+0x16>
    2cb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cb4:	e8 0f       	add	r30, r24
    2cb6:	f1 1d       	adc	r31, r1
    2cb8:	85 8d       	ldd	r24, Z+29	; 0x1d
    2cba:	90 e0       	ldi	r25, 0x00	; 0
    2cbc:	08 95       	ret
    2cbe:	8f ef       	ldi	r24, 0xFF	; 255
    2cc0:	9f ef       	ldi	r25, 0xFF	; 255
    2cc2:	08 95       	ret

00002cc4 <_ZN14HardwareSerial4readEv>:
    2cc4:	fc 01       	movw	r30, r24
    2cc6:	91 8d       	ldd	r25, Z+25	; 0x19
    2cc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cca:	98 17       	cp	r25, r24
    2ccc:	61 f0       	breq	.+24     	; 0x2ce6 <_ZN14HardwareSerial4readEv+0x22>
    2cce:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cd0:	df 01       	movw	r26, r30
    2cd2:	a8 0f       	add	r26, r24
    2cd4:	b1 1d       	adc	r27, r1
    2cd6:	5d 96       	adiw	r26, 0x1d	; 29
    2cd8:	8c 91       	ld	r24, X
    2cda:	92 8d       	ldd	r25, Z+26	; 0x1a
    2cdc:	9f 5f       	subi	r25, 0xFF	; 255
    2cde:	9f 73       	andi	r25, 0x3F	; 63
    2ce0:	92 8f       	std	Z+26, r25	; 0x1a
    2ce2:	90 e0       	ldi	r25, 0x00	; 0
    2ce4:	08 95       	ret
    2ce6:	8f ef       	ldi	r24, 0xFF	; 255
    2ce8:	9f ef       	ldi	r25, 0xFF	; 255
    2cea:	08 95       	ret

00002cec <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    2cec:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    2cee:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cf0:	df 01       	movw	r26, r30
    2cf2:	a8 0f       	add	r26, r24
    2cf4:	b1 1d       	adc	r27, r1
    2cf6:	a3 5a       	subi	r26, 0xA3	; 163
    2cf8:	bf 4f       	sbci	r27, 0xFF	; 255
    2cfa:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    2cfc:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cfe:	90 e0       	ldi	r25, 0x00	; 0
    2d00:	01 96       	adiw	r24, 0x01	; 1
    2d02:	8f 73       	andi	r24, 0x3F	; 63
    2d04:	90 78       	andi	r25, 0x80	; 128
    2d06:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    2d08:	a6 89       	ldd	r26, Z+22	; 0x16
    2d0a:	b7 89       	ldd	r27, Z+23	; 0x17
    2d0c:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    2d0e:	a0 89       	ldd	r26, Z+16	; 0x10
    2d10:	b1 89       	ldd	r27, Z+17	; 0x11
    2d12:	8c 91       	ld	r24, X
    2d14:	80 64       	ori	r24, 0x40	; 64
    2d16:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    2d18:	93 8d       	ldd	r25, Z+27	; 0x1b
    2d1a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d1c:	98 13       	cpse	r25, r24
    2d1e:	06 c0       	rjmp	.+12     	; 0x2d2c <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    2d20:	02 88       	ldd	r0, Z+18	; 0x12
    2d22:	f3 89       	ldd	r31, Z+19	; 0x13
    2d24:	e0 2d       	mov	r30, r0
    2d26:	80 81       	ld	r24, Z
    2d28:	8f 7d       	andi	r24, 0xDF	; 223
    2d2a:	80 83       	st	Z, r24
    2d2c:	08 95       	ret

00002d2e <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    2d2e:	cf 93       	push	r28
    2d30:	df 93       	push	r29
    2d32:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    2d34:	88 8d       	ldd	r24, Y+24	; 0x18
    2d36:	81 11       	cpse	r24, r1
    2d38:	0a c0       	rjmp	.+20     	; 0x2d4e <_ZN14HardwareSerial5flushEv+0x20>
    2d3a:	1a c0       	rjmp	.+52     	; 0x2d70 <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    2d3c:	0f b6       	in	r0, 0x3f	; 63
    2d3e:	07 fc       	sbrc	r0, 7
    2d40:	08 c0       	rjmp	.+16     	; 0x2d52 <_ZN14HardwareSerial5flushEv+0x24>
    2d42:	80 81       	ld	r24, Z
    2d44:	85 ff       	sbrs	r24, 5
    2d46:	05 c0       	rjmp	.+10     	; 0x2d52 <_ZN14HardwareSerial5flushEv+0x24>
    2d48:	0d c0       	rjmp	.+26     	; 0x2d64 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    2d4a:	ce 01       	movw	r24, r28
    2d4c:	cf df       	rcall	.-98     	; 0x2cec <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    2d4e:	ea 89       	ldd	r30, Y+18	; 0x12
    2d50:	fb 89       	ldd	r31, Y+19	; 0x13
    2d52:	80 81       	ld	r24, Z
    2d54:	85 fd       	sbrc	r24, 5
    2d56:	f2 cf       	rjmp	.-28     	; 0x2d3c <_ZN14HardwareSerial5flushEv+0xe>
    2d58:	a8 89       	ldd	r26, Y+16	; 0x10
    2d5a:	b9 89       	ldd	r27, Y+17	; 0x11
    2d5c:	8c 91       	ld	r24, X
    2d5e:	86 ff       	sbrs	r24, 6
    2d60:	ed cf       	rjmp	.-38     	; 0x2d3c <_ZN14HardwareSerial5flushEv+0xe>
    2d62:	06 c0       	rjmp	.+12     	; 0x2d70 <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    2d64:	a8 89       	ldd	r26, Y+16	; 0x10
    2d66:	b9 89       	ldd	r27, Y+17	; 0x11
    2d68:	8c 91       	ld	r24, X
    2d6a:	85 ff       	sbrs	r24, 5
    2d6c:	f2 cf       	rjmp	.-28     	; 0x2d52 <_ZN14HardwareSerial5flushEv+0x24>
    2d6e:	ed cf       	rjmp	.-38     	; 0x2d4a <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    2d70:	df 91       	pop	r29
    2d72:	cf 91       	pop	r28
    2d74:	08 95       	ret

00002d76 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    2d76:	0f 93       	push	r16
    2d78:	1f 93       	push	r17
    2d7a:	cf 93       	push	r28
    2d7c:	df 93       	push	r29
    2d7e:	ec 01       	movw	r28, r24
    2d80:	16 2f       	mov	r17, r22
  _written = true;
    2d82:	81 e0       	ldi	r24, 0x01	; 1
    2d84:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    2d86:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2d88:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2d8a:	98 13       	cpse	r25, r24
    2d8c:	21 c0       	rjmp	.+66     	; 0x2dd0 <_ZN14HardwareSerial5writeEh+0x5a>
    2d8e:	e8 89       	ldd	r30, Y+16	; 0x10
    2d90:	f9 89       	ldd	r31, Y+17	; 0x11
    2d92:	80 81       	ld	r24, Z
    2d94:	85 fd       	sbrc	r24, 5
    2d96:	23 c0       	rjmp	.+70     	; 0x2dde <_ZN14HardwareSerial5writeEh+0x68>
    2d98:	1b c0       	rjmp	.+54     	; 0x2dd0 <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    2d9a:	0f b6       	in	r0, 0x3f	; 63
    2d9c:	07 fc       	sbrc	r0, 7
    2d9e:	07 c0       	rjmp	.+14     	; 0x2dae <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    2da0:	e8 89       	ldd	r30, Y+16	; 0x10
    2da2:	f9 89       	ldd	r31, Y+17	; 0x11
    2da4:	80 81       	ld	r24, Z
    2da6:	85 ff       	sbrs	r24, 5
    2da8:	02 c0       	rjmp	.+4      	; 0x2dae <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    2daa:	ce 01       	movw	r24, r28
    2dac:	9f df       	rcall	.-194    	; 0x2cec <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2dae:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2db0:	09 17       	cp	r16, r25
    2db2:	99 f3       	breq	.-26     	; 0x2d9a <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    2db4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2db6:	fe 01       	movw	r30, r28
    2db8:	e8 0f       	add	r30, r24
    2dba:	f1 1d       	adc	r31, r1
    2dbc:	e3 5a       	subi	r30, 0xA3	; 163
    2dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    2dc0:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    2dc2:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    2dc4:	ea 89       	ldd	r30, Y+18	; 0x12
    2dc6:	fb 89       	ldd	r31, Y+19	; 0x13
    2dc8:	80 81       	ld	r24, Z
    2dca:	80 62       	ori	r24, 0x20	; 32
    2dcc:	80 83       	st	Z, r24
  
  return 1;
    2dce:	0f c0       	rjmp	.+30     	; 0x2dee <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    2dd0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2dd2:	90 e0       	ldi	r25, 0x00	; 0
    2dd4:	01 96       	adiw	r24, 0x01	; 1
    2dd6:	8f 73       	andi	r24, 0x3F	; 63
    2dd8:	90 78       	andi	r25, 0x80	; 128
    2dda:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2ddc:	e8 cf       	rjmp	.-48     	; 0x2dae <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    2dde:	ee 89       	ldd	r30, Y+22	; 0x16
    2de0:	ff 89       	ldd	r31, Y+23	; 0x17
    2de2:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    2de4:	e8 89       	ldd	r30, Y+16	; 0x10
    2de6:	f9 89       	ldd	r31, Y+17	; 0x11
    2de8:	80 81       	ld	r24, Z
    2dea:	80 64       	ori	r24, 0x40	; 64
    2dec:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    2dee:	81 e0       	ldi	r24, 0x01	; 1
    2df0:	90 e0       	ldi	r25, 0x00	; 0
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	1f 91       	pop	r17
    2df8:	0f 91       	pop	r16
    2dfa:	08 95       	ret

00002dfc <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    2dfc:	cf 92       	push	r12
    2dfe:	df 92       	push	r13
    2e00:	ef 92       	push	r14
    2e02:	ff 92       	push	r15
    2e04:	1f 93       	push	r17
    2e06:	cf 93       	push	r28
    2e08:	df 93       	push	r29
    2e0a:	ec 01       	movw	r28, r24
    2e0c:	6a 01       	movw	r12, r20
    2e0e:	7b 01       	movw	r14, r22
    2e10:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    2e12:	e8 89       	ldd	r30, Y+16	; 0x10
    2e14:	f9 89       	ldd	r31, Y+17	; 0x11
    2e16:	82 e0       	ldi	r24, 0x02	; 2
    2e18:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2e1a:	41 15       	cp	r20, r1
    2e1c:	81 ee       	ldi	r24, 0xE1	; 225
    2e1e:	58 07       	cpc	r21, r24
    2e20:	61 05       	cpc	r22, r1
    2e22:	71 05       	cpc	r23, r1
    2e24:	a9 f0       	breq	.+42     	; 0x2e50 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    2e26:	60 e0       	ldi	r22, 0x00	; 0
    2e28:	79 e0       	ldi	r23, 0x09	; 9
    2e2a:	8d e3       	ldi	r24, 0x3D	; 61
    2e2c:	90 e0       	ldi	r25, 0x00	; 0
    2e2e:	a7 01       	movw	r20, r14
    2e30:	96 01       	movw	r18, r12
    2e32:	a9 d3       	rcall	.+1874   	; 0x3586 <__udivmodsi4>
    2e34:	ba 01       	movw	r22, r20
    2e36:	a9 01       	movw	r20, r18
    2e38:	41 50       	subi	r20, 0x01	; 1
    2e3a:	51 09       	sbc	r21, r1
    2e3c:	61 09       	sbc	r22, r1
    2e3e:	71 09       	sbc	r23, r1
    2e40:	76 95       	lsr	r23
    2e42:	67 95       	ror	r22
    2e44:	57 95       	ror	r21
    2e46:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2e48:	41 15       	cp	r20, r1
    2e4a:	80 e1       	ldi	r24, 0x10	; 16
    2e4c:	58 07       	cpc	r21, r24
    2e4e:	a0 f0       	brcs	.+40     	; 0x2e78 <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    2e50:	e8 89       	ldd	r30, Y+16	; 0x10
    2e52:	f9 89       	ldd	r31, Y+17	; 0x11
    2e54:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    2e56:	60 e8       	ldi	r22, 0x80	; 128
    2e58:	74 e8       	ldi	r23, 0x84	; 132
    2e5a:	8e e1       	ldi	r24, 0x1E	; 30
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	a7 01       	movw	r20, r14
    2e60:	96 01       	movw	r18, r12
    2e62:	91 d3       	rcall	.+1826   	; 0x3586 <__udivmodsi4>
    2e64:	ba 01       	movw	r22, r20
    2e66:	a9 01       	movw	r20, r18
    2e68:	41 50       	subi	r20, 0x01	; 1
    2e6a:	51 09       	sbc	r21, r1
    2e6c:	61 09       	sbc	r22, r1
    2e6e:	71 09       	sbc	r23, r1
    2e70:	76 95       	lsr	r23
    2e72:	67 95       	ror	r22
    2e74:	57 95       	ror	r21
    2e76:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    2e78:	ec 85       	ldd	r30, Y+12	; 0x0c
    2e7a:	fd 85       	ldd	r31, Y+13	; 0x0d
    2e7c:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    2e7e:	ee 85       	ldd	r30, Y+14	; 0x0e
    2e80:	ff 85       	ldd	r31, Y+15	; 0x0f
    2e82:	40 83       	st	Z, r20

  _written = false;
    2e84:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    2e86:	ec 89       	ldd	r30, Y+20	; 0x14
    2e88:	fd 89       	ldd	r31, Y+21	; 0x15
    2e8a:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    2e8c:	ea 89       	ldd	r30, Y+18	; 0x12
    2e8e:	fb 89       	ldd	r31, Y+19	; 0x13
    2e90:	80 81       	ld	r24, Z
    2e92:	80 61       	ori	r24, 0x10	; 16
    2e94:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    2e96:	ea 89       	ldd	r30, Y+18	; 0x12
    2e98:	fb 89       	ldd	r31, Y+19	; 0x13
    2e9a:	80 81       	ld	r24, Z
    2e9c:	88 60       	ori	r24, 0x08	; 8
    2e9e:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    2ea0:	ea 89       	ldd	r30, Y+18	; 0x12
    2ea2:	fb 89       	ldd	r31, Y+19	; 0x13
    2ea4:	80 81       	ld	r24, Z
    2ea6:	80 68       	ori	r24, 0x80	; 128
    2ea8:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    2eaa:	ea 89       	ldd	r30, Y+18	; 0x12
    2eac:	fb 89       	ldd	r31, Y+19	; 0x13
    2eae:	80 81       	ld	r24, Z
    2eb0:	8f 7d       	andi	r24, 0xDF	; 223
    2eb2:	80 83       	st	Z, r24
}
    2eb4:	df 91       	pop	r29
    2eb6:	cf 91       	pop	r28
    2eb8:	1f 91       	pop	r17
    2eba:	ff 90       	pop	r15
    2ebc:	ef 90       	pop	r14
    2ebe:	df 90       	pop	r13
    2ec0:	cf 90       	pop	r12
    2ec2:	08 95       	ret

00002ec4 <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    2ec4:	1f 92       	push	r1
    2ec6:	0f 92       	push	r0
    2ec8:	0f b6       	in	r0, 0x3f	; 63
    2eca:	0f 92       	push	r0
    2ecc:	11 24       	eor	r1, r1
    2ece:	0b b6       	in	r0, 0x3b	; 59
    2ed0:	0f 92       	push	r0
    2ed2:	2f 93       	push	r18
    2ed4:	8f 93       	push	r24
    2ed6:	9f 93       	push	r25
    2ed8:	af 93       	push	r26
    2eda:	bf 93       	push	r27
    2edc:	ef 93       	push	r30
    2ede:	ff 93       	push	r31
    2ee0:	e0 91 cf 09 	lds	r30, 0x09CF
    2ee4:	f0 91 d0 09 	lds	r31, 0x09D0
    2ee8:	80 81       	ld	r24, Z
    2eea:	82 fd       	sbrc	r24, 2
    2eec:	17 c0       	rjmp	.+46     	; 0x2f1c <__vector_25+0x58>
    2eee:	e0 91 d5 09 	lds	r30, 0x09D5
    2ef2:	f0 91 d6 09 	lds	r31, 0x09D6
    2ef6:	20 81       	ld	r18, Z
    2ef8:	80 91 d8 09 	lds	r24, 0x09D8
    2efc:	8f 5f       	subi	r24, 0xFF	; 255
    2efe:	8f 73       	andi	r24, 0x3F	; 63
    2f00:	90 91 d9 09 	lds	r25, 0x09D9
    2f04:	89 17       	cp	r24, r25
    2f06:	79 f0       	breq	.+30     	; 0x2f26 <__vector_25+0x62>
    2f08:	e8 ed       	ldi	r30, 0xD8	; 216
    2f0a:	f9 e0       	ldi	r31, 0x09	; 9
    2f0c:	a0 81       	ld	r26, Z
    2f0e:	b0 e0       	ldi	r27, 0x00	; 0
    2f10:	a1 54       	subi	r26, 0x41	; 65
    2f12:	b6 4f       	sbci	r27, 0xF6	; 246
    2f14:	5d 96       	adiw	r26, 0x1d	; 29
    2f16:	2c 93       	st	X, r18
    2f18:	80 83       	st	Z, r24
    2f1a:	05 c0       	rjmp	.+10     	; 0x2f26 <__vector_25+0x62>
    2f1c:	e0 91 d5 09 	lds	r30, 0x09D5
    2f20:	f0 91 d6 09 	lds	r31, 0x09D6
    2f24:	80 81       	ld	r24, Z
    2f26:	ff 91       	pop	r31
    2f28:	ef 91       	pop	r30
    2f2a:	bf 91       	pop	r27
    2f2c:	af 91       	pop	r26
    2f2e:	9f 91       	pop	r25
    2f30:	8f 91       	pop	r24
    2f32:	2f 91       	pop	r18
    2f34:	0f 90       	pop	r0
    2f36:	0b be       	out	0x3b, r0	; 59
    2f38:	0f 90       	pop	r0
    2f3a:	0f be       	out	0x3f, r0	; 63
    2f3c:	0f 90       	pop	r0
    2f3e:	1f 90       	pop	r1
    2f40:	18 95       	reti

00002f42 <__vector_26>:
    2f42:	1f 92       	push	r1
    2f44:	0f 92       	push	r0
    2f46:	0f b6       	in	r0, 0x3f	; 63
    2f48:	0f 92       	push	r0
    2f4a:	11 24       	eor	r1, r1
    2f4c:	0b b6       	in	r0, 0x3b	; 59
    2f4e:	0f 92       	push	r0
    2f50:	2f 93       	push	r18
    2f52:	3f 93       	push	r19
    2f54:	4f 93       	push	r20
    2f56:	5f 93       	push	r21
    2f58:	6f 93       	push	r22
    2f5a:	7f 93       	push	r23
    2f5c:	8f 93       	push	r24
    2f5e:	9f 93       	push	r25
    2f60:	af 93       	push	r26
    2f62:	bf 93       	push	r27
    2f64:	ef 93       	push	r30
    2f66:	ff 93       	push	r31
    2f68:	8f eb       	ldi	r24, 0xBF	; 191
    2f6a:	99 e0       	ldi	r25, 0x09	; 9
    2f6c:	bf de       	rcall	.-642    	; 0x2cec <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    2f6e:	ff 91       	pop	r31
    2f70:	ef 91       	pop	r30
    2f72:	bf 91       	pop	r27
    2f74:	af 91       	pop	r26
    2f76:	9f 91       	pop	r25
    2f78:	8f 91       	pop	r24
    2f7a:	7f 91       	pop	r23
    2f7c:	6f 91       	pop	r22
    2f7e:	5f 91       	pop	r21
    2f80:	4f 91       	pop	r20
    2f82:	3f 91       	pop	r19
    2f84:	2f 91       	pop	r18
    2f86:	0f 90       	pop	r0
    2f88:	0b be       	out	0x3b, r0	; 59
    2f8a:	0f 90       	pop	r0
    2f8c:	0f be       	out	0x3f, r0	; 63
    2f8e:	0f 90       	pop	r0
    2f90:	1f 90       	pop	r1
    2f92:	18 95       	reti

00002f94 <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2f94:	10 92 c2 09 	sts	0x09C2, r1
    2f98:	10 92 c1 09 	sts	0x09C1, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    2f9c:	88 ee       	ldi	r24, 0xE8	; 232
    2f9e:	93 e0       	ldi	r25, 0x03	; 3
    2fa0:	a0 e0       	ldi	r26, 0x00	; 0
    2fa2:	b0 e0       	ldi	r27, 0x00	; 0
    2fa4:	80 93 c3 09 	sts	0x09C3, r24
    2fa8:	90 93 c4 09 	sts	0x09C4, r25
    2fac:	a0 93 c5 09 	sts	0x09C5, r26
    2fb0:	b0 93 c6 09 	sts	0x09C6, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    2fb4:	80 e7       	ldi	r24, 0x70	; 112
    2fb6:	92 e0       	ldi	r25, 0x02	; 2
    2fb8:	90 93 c0 09 	sts	0x09C0, r25
    2fbc:	80 93 bf 09 	sts	0x09BF, r24
    2fc0:	85 ec       	ldi	r24, 0xC5	; 197
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	90 93 cc 09 	sts	0x09CC, r25
    2fc8:	80 93 cb 09 	sts	0x09CB, r24
    2fcc:	84 ec       	ldi	r24, 0xC4	; 196
    2fce:	90 e0       	ldi	r25, 0x00	; 0
    2fd0:	90 93 ce 09 	sts	0x09CE, r25
    2fd4:	80 93 cd 09 	sts	0x09CD, r24
    2fd8:	80 ec       	ldi	r24, 0xC0	; 192
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	90 93 d0 09 	sts	0x09D0, r25
    2fe0:	80 93 cf 09 	sts	0x09CF, r24
    2fe4:	81 ec       	ldi	r24, 0xC1	; 193
    2fe6:	90 e0       	ldi	r25, 0x00	; 0
    2fe8:	90 93 d2 09 	sts	0x09D2, r25
    2fec:	80 93 d1 09 	sts	0x09D1, r24
    2ff0:	82 ec       	ldi	r24, 0xC2	; 194
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	90 93 d4 09 	sts	0x09D4, r25
    2ff8:	80 93 d3 09 	sts	0x09D3, r24
    2ffc:	86 ec       	ldi	r24, 0xC6	; 198
    2ffe:	90 e0       	ldi	r25, 0x00	; 0
    3000:	90 93 d6 09 	sts	0x09D6, r25
    3004:	80 93 d5 09 	sts	0x09D5, r24
    3008:	10 92 d8 09 	sts	0x09D8, r1
    300c:	10 92 d9 09 	sts	0x09D9, r1
    3010:	10 92 da 09 	sts	0x09DA, r1
    3014:	10 92 db 09 	sts	0x09DB, r1
    3018:	08 95       	ret

0000301a <_ZN5Print5writeEPKhj>:
size_t Print::println(const Printable& x)
{
  size_t n = print(x);
  n += println();
  return n;
}
    301a:	cf 92       	push	r12
    301c:	df 92       	push	r13
    301e:	ef 92       	push	r14
    3020:	ff 92       	push	r15
    3022:	0f 93       	push	r16
    3024:	1f 93       	push	r17
    3026:	cf 93       	push	r28
    3028:	df 93       	push	r29
    302a:	6c 01       	movw	r12, r24
    302c:	41 15       	cp	r20, r1
    302e:	51 05       	cpc	r21, r1
    3030:	b1 f0       	breq	.+44     	; 0x305e <_ZN5Print5writeEPKhj+0x44>
    3032:	06 2f       	mov	r16, r22
    3034:	17 2f       	mov	r17, r23
    3036:	ea 01       	movw	r28, r20
    3038:	e1 2c       	mov	r14, r1
    303a:	f1 2c       	mov	r15, r1
    303c:	d8 01       	movw	r26, r16
    303e:	6d 91       	ld	r22, X+
    3040:	8d 01       	movw	r16, r26
    3042:	d6 01       	movw	r26, r12
    3044:	ed 91       	ld	r30, X+
    3046:	fc 91       	ld	r31, X
    3048:	01 90       	ld	r0, Z+
    304a:	f0 81       	ld	r31, Z
    304c:	e0 2d       	mov	r30, r0
    304e:	c6 01       	movw	r24, r12
    3050:	19 95       	eicall
    3052:	e8 0e       	add	r14, r24
    3054:	f9 1e       	adc	r15, r25
    3056:	21 97       	sbiw	r28, 0x01	; 1
    3058:	20 97       	sbiw	r28, 0x00	; 0
    305a:	81 f7       	brne	.-32     	; 0x303c <_ZN5Print5writeEPKhj+0x22>
    305c:	02 c0       	rjmp	.+4      	; 0x3062 <_ZN5Print5writeEPKhj+0x48>
    305e:	e1 2c       	mov	r14, r1
    3060:	f1 2c       	mov	r15, r1
    3062:	c7 01       	movw	r24, r14
    3064:	df 91       	pop	r29
    3066:	cf 91       	pop	r28
    3068:	1f 91       	pop	r17
    306a:	0f 91       	pop	r16
    306c:	ff 90       	pop	r15
    306e:	ef 90       	pop	r14
    3070:	df 90       	pop	r13
    3072:	cf 90       	pop	r12
    3074:	08 95       	ret

00003076 <_ZN5Print5printEc>:
    3076:	dc 01       	movw	r26, r24
    3078:	ed 91       	ld	r30, X+
    307a:	fc 91       	ld	r31, X
    307c:	01 90       	ld	r0, Z+
    307e:	f0 81       	ld	r31, Z
    3080:	e0 2d       	mov	r30, r0
    3082:	19 95       	eicall
    3084:	08 95       	ret

00003086 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
    3086:	6f 92       	push	r6
    3088:	7f 92       	push	r7
    308a:	8f 92       	push	r8
    308c:	9f 92       	push	r9
    308e:	af 92       	push	r10
    3090:	bf 92       	push	r11
    3092:	cf 92       	push	r12
    3094:	df 92       	push	r13
    3096:	ef 92       	push	r14
    3098:	ff 92       	push	r15
    309a:	0f 93       	push	r16
    309c:	1f 93       	push	r17
    309e:	cf 93       	push	r28
    30a0:	df 93       	push	r29
    30a2:	cd b7       	in	r28, 0x3d	; 61
    30a4:	de b7       	in	r29, 0x3e	; 62
    30a6:	a1 97       	sbiw	r28, 0x21	; 33
    30a8:	0f b6       	in	r0, 0x3f	; 63
    30aa:	f8 94       	cli
    30ac:	de bf       	out	0x3e, r29	; 62
    30ae:	0f be       	out	0x3f, r0	; 63
    30b0:	cd bf       	out	0x3d, r28	; 61
    30b2:	6c 01       	movw	r12, r24
    30b4:	74 2e       	mov	r7, r20
    30b6:	35 2f       	mov	r19, r21
    30b8:	86 2f       	mov	r24, r22
    30ba:	97 2f       	mov	r25, r23
    30bc:	62 2e       	mov	r6, r18
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    30be:	19 a2       	std	Y+33, r1	; 0x21

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    30c0:	21 e0       	ldi	r18, 0x01	; 1
    30c2:	26 15       	cp	r18, r6
    30c4:	20 f0       	brcs	.+8      	; 0x30ce <_ZN5Print11printNumberEmh+0x48>
    30c6:	0f 2e       	mov	r0, r31
    30c8:	fa e0       	ldi	r31, 0x0A	; 10
    30ca:	6f 2e       	mov	r6, r31
    30cc:	f0 2d       	mov	r31, r0
    30ce:	7e 01       	movw	r14, r28
    30d0:	a1 e2       	ldi	r26, 0x21	; 33
    30d2:	ea 0e       	add	r14, r26
    30d4:	f1 1c       	adc	r15, r1

  do {
    unsigned long m = n;
    n /= base;
    30d6:	86 2c       	mov	r8, r6
    30d8:	91 2c       	mov	r9, r1
    30da:	a1 2c       	mov	r10, r1
    30dc:	b1 2c       	mov	r11, r1
    30de:	67 2d       	mov	r22, r7
    30e0:	73 2f       	mov	r23, r19
    30e2:	a5 01       	movw	r20, r10
    30e4:	94 01       	movw	r18, r8
    30e6:	4f d2       	rcall	.+1182   	; 0x3586 <__udivmodsi4>
    30e8:	e2 2f       	mov	r30, r18
    30ea:	73 2f       	mov	r23, r19
    30ec:	02 2f       	mov	r16, r18
    30ee:	13 2f       	mov	r17, r19
    30f0:	24 2f       	mov	r18, r20
    30f2:	35 2f       	mov	r19, r21
    char c = m - base * n;
    30f4:	f7 2d       	mov	r31, r7
    30f6:	6e 9e       	mul	r6, r30
    30f8:	f0 19       	sub	r31, r0
    30fa:	11 24       	eor	r1, r1
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    30fc:	b1 e0       	ldi	r27, 0x01	; 1
    30fe:	eb 1a       	sub	r14, r27
    3100:	f1 08       	sbc	r15, r1
    3102:	fa 30       	cpi	r31, 0x0A	; 10
    3104:	10 f4       	brcc	.+4      	; 0x310a <_ZN5Print11printNumberEmh+0x84>
    3106:	f0 5d       	subi	r31, 0xD0	; 208
    3108:	01 c0       	rjmp	.+2      	; 0x310c <_ZN5Print11printNumberEmh+0x86>
    310a:	f9 5c       	subi	r31, 0xC9	; 201
    310c:	d7 01       	movw	r26, r14
    310e:	fc 93       	st	X, r31
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    3110:	01 2b       	or	r16, r17
    3112:	02 2b       	or	r16, r18
    3114:	03 2b       	or	r16, r19
    3116:	29 f0       	breq	.+10     	; 0x3122 <_ZN5Print11printNumberEmh+0x9c>
    unsigned long m = n;
    n /= base;
    3118:	7e 2e       	mov	r7, r30
    311a:	37 2f       	mov	r19, r23
    311c:	84 2f       	mov	r24, r20
    311e:	95 2f       	mov	r25, r21
    3120:	de cf       	rjmp	.-68     	; 0x30de <_ZN5Print11printNumberEmh+0x58>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    3122:	e1 14       	cp	r14, r1
    3124:	f1 04       	cpc	r15, r1
    3126:	91 f0       	breq	.+36     	; 0x314c <_ZN5Print11printNumberEmh+0xc6>
      return write((const uint8_t *)str, strlen(str));
    3128:	f7 01       	movw	r30, r14
    312a:	01 90       	ld	r0, Z+
    312c:	00 20       	and	r0, r0
    312e:	e9 f7       	brne	.-6      	; 0x312a <_ZN5Print11printNumberEmh+0xa4>
    3130:	31 97       	sbiw	r30, 0x01	; 1
    3132:	af 01       	movw	r20, r30
    3134:	4e 19       	sub	r20, r14
    3136:	5f 09       	sbc	r21, r15
    3138:	d6 01       	movw	r26, r12
    313a:	ed 91       	ld	r30, X+
    313c:	fc 91       	ld	r31, X
    313e:	02 80       	ldd	r0, Z+2	; 0x02
    3140:	f3 81       	ldd	r31, Z+3	; 0x03
    3142:	e0 2d       	mov	r30, r0
    3144:	b7 01       	movw	r22, r14
    3146:	c6 01       	movw	r24, r12
    3148:	19 95       	eicall
    314a:	02 c0       	rjmp	.+4      	; 0x3150 <_ZN5Print11printNumberEmh+0xca>
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    314c:	80 e0       	ldi	r24, 0x00	; 0
    314e:	90 e0       	ldi	r25, 0x00	; 0
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
}
    3150:	a1 96       	adiw	r28, 0x21	; 33
    3152:	0f b6       	in	r0, 0x3f	; 63
    3154:	f8 94       	cli
    3156:	de bf       	out	0x3e, r29	; 62
    3158:	0f be       	out	0x3f, r0	; 63
    315a:	cd bf       	out	0x3d, r28	; 61
    315c:	df 91       	pop	r29
    315e:	cf 91       	pop	r28
    3160:	1f 91       	pop	r17
    3162:	0f 91       	pop	r16
    3164:	ff 90       	pop	r15
    3166:	ef 90       	pop	r14
    3168:	df 90       	pop	r13
    316a:	cf 90       	pop	r12
    316c:	bf 90       	pop	r11
    316e:	af 90       	pop	r10
    3170:	9f 90       	pop	r9
    3172:	8f 90       	pop	r8
    3174:	7f 90       	pop	r7
    3176:	6f 90       	pop	r6
    3178:	08 95       	ret

0000317a <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    317a:	cf 92       	push	r12
    317c:	df 92       	push	r13
    317e:	ef 92       	push	r14
    3180:	ff 92       	push	r15
    3182:	0f 93       	push	r16
    3184:	1f 93       	push	r17
    3186:	cf 93       	push	r28
    3188:	df 93       	push	r29
    318a:	ec 01       	movw	r28, r24
    318c:	6a 01       	movw	r12, r20
    318e:	7b 01       	movw	r14, r22
  if (base == 0) {
    3190:	21 15       	cp	r18, r1
    3192:	31 05       	cpc	r19, r1
    3194:	41 f4       	brne	.+16     	; 0x31a6 <_ZN5Print5printEli+0x2c>
    return write(n);
    3196:	e8 81       	ld	r30, Y
    3198:	f9 81       	ldd	r31, Y+1	; 0x01
    319a:	01 90       	ld	r0, Z+
    319c:	f0 81       	ld	r31, Z
    319e:	e0 2d       	mov	r30, r0
    31a0:	64 2f       	mov	r22, r20
    31a2:	19 95       	eicall
    31a4:	19 c0       	rjmp	.+50     	; 0x31d8 <_ZN5Print5printEli+0x5e>
  } else if (base == 10) {
    31a6:	2a 30       	cpi	r18, 0x0A	; 10
    31a8:	31 05       	cpc	r19, r1
    31aa:	a9 f4       	brne	.+42     	; 0x31d6 <_ZN5Print5printEli+0x5c>
    if (n < 0) {
    31ac:	77 23       	and	r23, r23
    31ae:	84 f4       	brge	.+32     	; 0x31d0 <_ZN5Print5printEli+0x56>
      int t = print('-');
    31b0:	6d e2       	ldi	r22, 0x2D	; 45
    31b2:	61 df       	rcall	.-318    	; 0x3076 <_ZN5Print5printEc>
    31b4:	8c 01       	movw	r16, r24
      n = -n;
    31b6:	44 27       	eor	r20, r20
    31b8:	55 27       	eor	r21, r21
    31ba:	ba 01       	movw	r22, r20
    31bc:	4c 19       	sub	r20, r12
    31be:	5d 09       	sbc	r21, r13
    31c0:	6e 09       	sbc	r22, r14
    31c2:	7f 09       	sbc	r23, r15
      return printNumber(n, 10) + t;
    31c4:	2a e0       	ldi	r18, 0x0A	; 10
    31c6:	ce 01       	movw	r24, r28
    31c8:	5e df       	rcall	.-324    	; 0x3086 <_ZN5Print11printNumberEmh>
    31ca:	80 0f       	add	r24, r16
    31cc:	91 1f       	adc	r25, r17
    31ce:	04 c0       	rjmp	.+8      	; 0x31d8 <_ZN5Print5printEli+0x5e>
    }
    return printNumber(n, 10);
    31d0:	2a e0       	ldi	r18, 0x0A	; 10
    31d2:	59 df       	rcall	.-334    	; 0x3086 <_ZN5Print11printNumberEmh>
    31d4:	01 c0       	rjmp	.+2      	; 0x31d8 <_ZN5Print5printEli+0x5e>
  } else {
    return printNumber(n, base);
    31d6:	57 df       	rcall	.-338    	; 0x3086 <_ZN5Print11printNumberEmh>
  }
}
    31d8:	df 91       	pop	r29
    31da:	cf 91       	pop	r28
    31dc:	1f 91       	pop	r17
    31de:	0f 91       	pop	r16
    31e0:	ff 90       	pop	r15
    31e2:	ef 90       	pop	r14
    31e4:	df 90       	pop	r13
    31e6:	cf 90       	pop	r12
    31e8:	08 95       	ret

000031ea <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    31ea:	9a 01       	movw	r18, r20
  return print((long) n, base);
    31ec:	ab 01       	movw	r20, r22
    31ee:	66 27       	eor	r22, r22
    31f0:	57 fd       	sbrc	r21, 7
    31f2:	60 95       	com	r22
    31f4:	76 2f       	mov	r23, r22
    31f6:	c1 cf       	rjmp	.-126    	; 0x317a <_ZN5Print5printEli>
}
    31f8:	08 95       	ret

000031fa <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    31fa:	1f 92       	push	r1
    31fc:	0f 92       	push	r0
    31fe:	0f b6       	in	r0, 0x3f	; 63
    3200:	0f 92       	push	r0
    3202:	11 24       	eor	r1, r1
    3204:	2f 93       	push	r18
    3206:	3f 93       	push	r19
    3208:	8f 93       	push	r24
    320a:	9f 93       	push	r25
    320c:	af 93       	push	r26
    320e:	bf 93       	push	r27
    3210:	80 91 5d 0a 	lds	r24, 0x0A5D
    3214:	90 91 5e 0a 	lds	r25, 0x0A5E
    3218:	a0 91 5f 0a 	lds	r26, 0x0A5F
    321c:	b0 91 60 0a 	lds	r27, 0x0A60
    3220:	30 91 5c 0a 	lds	r19, 0x0A5C
    3224:	23 e0       	ldi	r18, 0x03	; 3
    3226:	23 0f       	add	r18, r19
    3228:	2d 37       	cpi	r18, 0x7D	; 125
    322a:	20 f4       	brcc	.+8      	; 0x3234 <__vector_23+0x3a>
    322c:	01 96       	adiw	r24, 0x01	; 1
    322e:	a1 1d       	adc	r26, r1
    3230:	b1 1d       	adc	r27, r1
    3232:	05 c0       	rjmp	.+10     	; 0x323e <__vector_23+0x44>
    3234:	26 e8       	ldi	r18, 0x86	; 134
    3236:	23 0f       	add	r18, r19
    3238:	02 96       	adiw	r24, 0x02	; 2
    323a:	a1 1d       	adc	r26, r1
    323c:	b1 1d       	adc	r27, r1
    323e:	20 93 5c 0a 	sts	0x0A5C, r18
    3242:	80 93 5d 0a 	sts	0x0A5D, r24
    3246:	90 93 5e 0a 	sts	0x0A5E, r25
    324a:	a0 93 5f 0a 	sts	0x0A5F, r26
    324e:	b0 93 60 0a 	sts	0x0A60, r27
    3252:	80 91 61 0a 	lds	r24, 0x0A61
    3256:	90 91 62 0a 	lds	r25, 0x0A62
    325a:	a0 91 63 0a 	lds	r26, 0x0A63
    325e:	b0 91 64 0a 	lds	r27, 0x0A64
    3262:	01 96       	adiw	r24, 0x01	; 1
    3264:	a1 1d       	adc	r26, r1
    3266:	b1 1d       	adc	r27, r1
    3268:	80 93 61 0a 	sts	0x0A61, r24
    326c:	90 93 62 0a 	sts	0x0A62, r25
    3270:	a0 93 63 0a 	sts	0x0A63, r26
    3274:	b0 93 64 0a 	sts	0x0A64, r27
    3278:	bf 91       	pop	r27
    327a:	af 91       	pop	r26
    327c:	9f 91       	pop	r25
    327e:	8f 91       	pop	r24
    3280:	3f 91       	pop	r19
    3282:	2f 91       	pop	r18
    3284:	0f 90       	pop	r0
    3286:	0f be       	out	0x3f, r0	; 63
    3288:	0f 90       	pop	r0
    328a:	1f 90       	pop	r1
    328c:	18 95       	reti

0000328e <millis>:
    328e:	2f b7       	in	r18, 0x3f	; 63
    3290:	f8 94       	cli
    3292:	60 91 5d 0a 	lds	r22, 0x0A5D
    3296:	70 91 5e 0a 	lds	r23, 0x0A5E
    329a:	80 91 5f 0a 	lds	r24, 0x0A5F
    329e:	90 91 60 0a 	lds	r25, 0x0A60
    32a2:	2f bf       	out	0x3f, r18	; 63
    32a4:	08 95       	ret

000032a6 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    32a6:	82 30       	cpi	r24, 0x02	; 2
    32a8:	91 05       	cpc	r25, r1
    32aa:	38 f0       	brcs	.+14     	; 0x32ba <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    32ac:	88 0f       	add	r24, r24
    32ae:	99 1f       	adc	r25, r25
    32b0:	88 0f       	add	r24, r24
    32b2:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    32b4:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    32b6:	01 97       	sbiw	r24, 0x01	; 1
    32b8:	f1 f7       	brne	.-4      	; 0x32b6 <delayMicroseconds+0x10>
    32ba:	08 95       	ret

000032bc <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    32bc:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    32be:	84 b5       	in	r24, 0x24	; 36
    32c0:	82 60       	ori	r24, 0x02	; 2
    32c2:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    32c4:	84 b5       	in	r24, 0x24	; 36
    32c6:	81 60       	ori	r24, 0x01	; 1
    32c8:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    32ca:	85 b5       	in	r24, 0x25	; 37
    32cc:	82 60       	ori	r24, 0x02	; 2
    32ce:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    32d0:	85 b5       	in	r24, 0x25	; 37
    32d2:	81 60       	ori	r24, 0x01	; 1
    32d4:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    32d6:	ee e6       	ldi	r30, 0x6E	; 110
    32d8:	f0 e0       	ldi	r31, 0x00	; 0
    32da:	80 81       	ld	r24, Z
    32dc:	81 60       	ori	r24, 0x01	; 1
    32de:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    32e0:	e1 e8       	ldi	r30, 0x81	; 129
    32e2:	f0 e0       	ldi	r31, 0x00	; 0
    32e4:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    32e6:	80 81       	ld	r24, Z
    32e8:	82 60       	ori	r24, 0x02	; 2
    32ea:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    32ec:	80 81       	ld	r24, Z
    32ee:	81 60       	ori	r24, 0x01	; 1
    32f0:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    32f2:	e0 e8       	ldi	r30, 0x80	; 128
    32f4:	f0 e0       	ldi	r31, 0x00	; 0
    32f6:	80 81       	ld	r24, Z
    32f8:	81 60       	ori	r24, 0x01	; 1
    32fa:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    32fc:	e1 eb       	ldi	r30, 0xB1	; 177
    32fe:	f0 e0       	ldi	r31, 0x00	; 0
    3300:	80 81       	ld	r24, Z
    3302:	84 60       	ori	r24, 0x04	; 4
    3304:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    3306:	e0 eb       	ldi	r30, 0xB0	; 176
    3308:	f0 e0       	ldi	r31, 0x00	; 0
    330a:	80 81       	ld	r24, Z
    330c:	81 60       	ori	r24, 0x01	; 1
    330e:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    3310:	e1 e9       	ldi	r30, 0x91	; 145
    3312:	f0 e0       	ldi	r31, 0x00	; 0
    3314:	80 81       	ld	r24, Z
    3316:	82 60       	ori	r24, 0x02	; 2
    3318:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    331a:	80 81       	ld	r24, Z
    331c:	81 60       	ori	r24, 0x01	; 1
    331e:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    3320:	e0 e9       	ldi	r30, 0x90	; 144
    3322:	f0 e0       	ldi	r31, 0x00	; 0
    3324:	80 81       	ld	r24, Z
    3326:	81 60       	ori	r24, 0x01	; 1
    3328:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    332a:	e1 ea       	ldi	r30, 0xA1	; 161
    332c:	f0 e0       	ldi	r31, 0x00	; 0
    332e:	80 81       	ld	r24, Z
    3330:	82 60       	ori	r24, 0x02	; 2
    3332:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    3334:	80 81       	ld	r24, Z
    3336:	81 60       	ori	r24, 0x01	; 1
    3338:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    333a:	e0 ea       	ldi	r30, 0xA0	; 160
    333c:	f0 e0       	ldi	r31, 0x00	; 0
    333e:	80 81       	ld	r24, Z
    3340:	81 60       	ori	r24, 0x01	; 1
    3342:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    3344:	e1 e2       	ldi	r30, 0x21	; 33
    3346:	f1 e0       	ldi	r31, 0x01	; 1
    3348:	80 81       	ld	r24, Z
    334a:	82 60       	ori	r24, 0x02	; 2
    334c:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    334e:	80 81       	ld	r24, Z
    3350:	81 60       	ori	r24, 0x01	; 1
    3352:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    3354:	e0 e2       	ldi	r30, 0x20	; 32
    3356:	f1 e0       	ldi	r31, 0x01	; 1
    3358:	80 81       	ld	r24, Z
    335a:	81 60       	ori	r24, 0x01	; 1
    335c:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    335e:	ea e7       	ldi	r30, 0x7A	; 122
    3360:	f0 e0       	ldi	r31, 0x00	; 0
    3362:	80 81       	ld	r24, Z
    3364:	84 60       	ori	r24, 0x04	; 4
    3366:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    3368:	80 81       	ld	r24, Z
    336a:	82 60       	ori	r24, 0x02	; 2
    336c:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    336e:	80 81       	ld	r24, Z
    3370:	81 60       	ori	r24, 0x01	; 1
    3372:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    3374:	80 81       	ld	r24, Z
    3376:	80 68       	ori	r24, 0x80	; 128
    3378:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    337a:	10 92 c1 00 	sts	0x00C1, r1
    337e:	08 95       	ret

00003380 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	fc 01       	movw	r30, r24
    3384:	31 97       	sbiw	r30, 0x01	; 1
    3386:	e2 31       	cpi	r30, 0x12	; 18
    3388:	f1 05       	cpc	r31, r1
    338a:	08 f0       	brcs	.+2      	; 0x338e <turnOffPWM+0xe>
    338c:	5e c0       	rjmp	.+188    	; 0x344a <turnOffPWM+0xca>
    338e:	e5 5c       	subi	r30, 0xC5	; 197
    3390:	fe 4f       	sbci	r31, 0xFE	; 254
    3392:	1b c1       	rjmp	.+566    	; 0x35ca <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    3394:	e0 e8       	ldi	r30, 0x80	; 128
    3396:	f0 e0       	ldi	r31, 0x00	; 0
    3398:	80 81       	ld	r24, Z
    339a:	8f 77       	andi	r24, 0x7F	; 127
    339c:	80 83       	st	Z, r24
    339e:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    33a0:	e0 e8       	ldi	r30, 0x80	; 128
    33a2:	f0 e0       	ldi	r31, 0x00	; 0
    33a4:	80 81       	ld	r24, Z
    33a6:	8f 7d       	andi	r24, 0xDF	; 223
    33a8:	80 83       	st	Z, r24
    33aa:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    33ac:	e0 e8       	ldi	r30, 0x80	; 128
    33ae:	f0 e0       	ldi	r31, 0x00	; 0
    33b0:	80 81       	ld	r24, Z
    33b2:	87 7f       	andi	r24, 0xF7	; 247
    33b4:	80 83       	st	Z, r24
    33b6:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    33b8:	84 b5       	in	r24, 0x24	; 36
    33ba:	8f 77       	andi	r24, 0x7F	; 127
    33bc:	84 bd       	out	0x24, r24	; 36
    33be:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    33c0:	84 b5       	in	r24, 0x24	; 36
    33c2:	8f 7d       	andi	r24, 0xDF	; 223
    33c4:	84 bd       	out	0x24, r24	; 36
    33c6:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    33c8:	e0 eb       	ldi	r30, 0xB0	; 176
    33ca:	f0 e0       	ldi	r31, 0x00	; 0
    33cc:	80 81       	ld	r24, Z
    33ce:	8f 77       	andi	r24, 0x7F	; 127
    33d0:	80 83       	st	Z, r24
    33d2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    33d4:	e0 eb       	ldi	r30, 0xB0	; 176
    33d6:	f0 e0       	ldi	r31, 0x00	; 0
    33d8:	80 81       	ld	r24, Z
    33da:	8f 7d       	andi	r24, 0xDF	; 223
    33dc:	80 83       	st	Z, r24
    33de:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    33e0:	e0 e9       	ldi	r30, 0x90	; 144
    33e2:	f0 e0       	ldi	r31, 0x00	; 0
    33e4:	80 81       	ld	r24, Z
    33e6:	8f 77       	andi	r24, 0x7F	; 127
    33e8:	80 83       	st	Z, r24
    33ea:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    33ec:	e0 e9       	ldi	r30, 0x90	; 144
    33ee:	f0 e0       	ldi	r31, 0x00	; 0
    33f0:	80 81       	ld	r24, Z
    33f2:	8f 7d       	andi	r24, 0xDF	; 223
    33f4:	80 83       	st	Z, r24
    33f6:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    33f8:	e0 e9       	ldi	r30, 0x90	; 144
    33fa:	f0 e0       	ldi	r31, 0x00	; 0
    33fc:	80 81       	ld	r24, Z
    33fe:	87 7f       	andi	r24, 0xF7	; 247
    3400:	80 83       	st	Z, r24
    3402:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    3404:	e0 ea       	ldi	r30, 0xA0	; 160
    3406:	f0 e0       	ldi	r31, 0x00	; 0
    3408:	80 81       	ld	r24, Z
    340a:	8f 77       	andi	r24, 0x7F	; 127
    340c:	80 83       	st	Z, r24
    340e:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    3410:	e0 ea       	ldi	r30, 0xA0	; 160
    3412:	f0 e0       	ldi	r31, 0x00	; 0
    3414:	80 81       	ld	r24, Z
    3416:	8f 7d       	andi	r24, 0xDF	; 223
    3418:	80 83       	st	Z, r24
    341a:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    341c:	e0 ea       	ldi	r30, 0xA0	; 160
    341e:	f0 e0       	ldi	r31, 0x00	; 0
    3420:	80 81       	ld	r24, Z
    3422:	87 7f       	andi	r24, 0xF7	; 247
    3424:	80 83       	st	Z, r24
    3426:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3428:	e0 e2       	ldi	r30, 0x20	; 32
    342a:	f1 e0       	ldi	r31, 0x01	; 1
    342c:	80 81       	ld	r24, Z
    342e:	8f 77       	andi	r24, 0x7F	; 127
    3430:	80 83       	st	Z, r24
    3432:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    3434:	e0 e2       	ldi	r30, 0x20	; 32
    3436:	f1 e0       	ldi	r31, 0x01	; 1
    3438:	80 81       	ld	r24, Z
    343a:	8f 7d       	andi	r24, 0xDF	; 223
    343c:	80 83       	st	Z, r24
    343e:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    3440:	e0 e2       	ldi	r30, 0x20	; 32
    3442:	f1 e0       	ldi	r31, 0x01	; 1
    3444:	80 81       	ld	r24, Z
    3446:	87 7f       	andi	r24, 0xF7	; 247
    3448:	80 83       	st	Z, r24
    344a:	08 95       	ret

0000344c <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    344c:	cf 93       	push	r28
    344e:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	fc 01       	movw	r30, r24
    3454:	e0 52       	subi	r30, 0x20	; 32
    3456:	fd 4f       	sbci	r31, 0xFD	; 253
    3458:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    345a:	fc 01       	movw	r30, r24
    345c:	ea 5d       	subi	r30, 0xDA	; 218
    345e:	fc 4f       	sbci	r31, 0xFC	; 252
    3460:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    3462:	88 23       	and	r24, r24
    3464:	71 f1       	breq	.+92     	; 0x34c2 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3466:	90 e0       	ldi	r25, 0x00	; 0
    3468:	88 0f       	add	r24, r24
    346a:	99 1f       	adc	r25, r25
    346c:	fc 01       	movw	r30, r24
    346e:	e0 56       	subi	r30, 0x60	; 96
    3470:	fc 4f       	sbci	r31, 0xFC	; 252
    3472:	a5 91       	lpm	r26, Z+
    3474:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    3476:	8a 57       	subi	r24, 0x7A	; 122
    3478:	9c 4f       	sbci	r25, 0xFC	; 252
    347a:	fc 01       	movw	r30, r24
    347c:	c5 91       	lpm	r28, Z+
    347e:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    3480:	61 11       	cpse	r22, r1
    3482:	0b c0       	rjmp	.+22     	; 0x349a <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    3484:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3486:	f8 94       	cli
		*reg &= ~bit;
    3488:	9c 91       	ld	r25, X
    348a:	20 95       	com	r18
    348c:	92 23       	and	r25, r18
    348e:	9c 93       	st	X, r25
		*out &= ~bit;
    3490:	e8 81       	ld	r30, Y
    3492:	2e 23       	and	r18, r30
    3494:	28 83       	st	Y, r18
		SREG = oldSREG;
    3496:	8f bf       	out	0x3f, r24	; 63
    3498:	14 c0       	rjmp	.+40     	; 0x34c2 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    349a:	62 30       	cpi	r22, 0x02	; 2
    349c:	61 f4       	brne	.+24     	; 0x34b6 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    349e:	8f b7       	in	r24, 0x3f	; 63
                cli();
    34a0:	f8 94       	cli
		*reg &= ~bit;
    34a2:	3c 91       	ld	r19, X
    34a4:	92 2f       	mov	r25, r18
    34a6:	90 95       	com	r25
    34a8:	93 23       	and	r25, r19
    34aa:	9c 93       	st	X, r25
		*out |= bit;
    34ac:	e8 81       	ld	r30, Y
    34ae:	2e 2b       	or	r18, r30
    34b0:	28 83       	st	Y, r18
		SREG = oldSREG;
    34b2:	8f bf       	out	0x3f, r24	; 63
    34b4:	06 c0       	rjmp	.+12     	; 0x34c2 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    34b6:	8f b7       	in	r24, 0x3f	; 63
                cli();
    34b8:	f8 94       	cli
		*reg |= bit;
    34ba:	ec 91       	ld	r30, X
    34bc:	2e 2b       	or	r18, r30
    34be:	2c 93       	st	X, r18
		SREG = oldSREG;
    34c0:	8f bf       	out	0x3f, r24	; 63
	}
}
    34c2:	df 91       	pop	r29
    34c4:	cf 91       	pop	r28
    34c6:	08 95       	ret

000034c8 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    34c8:	1f 93       	push	r17
    34ca:	cf 93       	push	r28
    34cc:	df 93       	push	r29
    34ce:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    34d0:	28 2f       	mov	r18, r24
    34d2:	30 e0       	ldi	r19, 0x00	; 0
    34d4:	f9 01       	movw	r30, r18
    34d6:	e6 56       	subi	r30, 0x66	; 102
    34d8:	fd 4f       	sbci	r31, 0xFD	; 253
    34da:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    34dc:	f9 01       	movw	r30, r18
    34de:	e0 52       	subi	r30, 0x20	; 32
    34e0:	fd 4f       	sbci	r31, 0xFD	; 253
    34e2:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    34e4:	f9 01       	movw	r30, r18
    34e6:	ea 5d       	subi	r30, 0xDA	; 218
    34e8:	fc 4f       	sbci	r31, 0xFC	; 252
    34ea:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    34ec:	dd 23       	and	r29, r29
    34ee:	c1 f0       	breq	.+48     	; 0x3520 <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    34f0:	81 11       	cpse	r24, r1
    34f2:	46 df       	rcall	.-372    	; 0x3380 <turnOffPWM>

	out = portOutputRegister(port);
    34f4:	2d 2f       	mov	r18, r29
    34f6:	30 e0       	ldi	r19, 0x00	; 0
    34f8:	f9 01       	movw	r30, r18
    34fa:	ee 0f       	add	r30, r30
    34fc:	ff 1f       	adc	r31, r31
    34fe:	ea 57       	subi	r30, 0x7A	; 122
    3500:	fc 4f       	sbci	r31, 0xFC	; 252
    3502:	a5 91       	lpm	r26, Z+
    3504:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    3506:	8f b7       	in	r24, 0x3f	; 63
	cli();
    3508:	f8 94       	cli

	if (val == LOW) {
    350a:	c1 11       	cpse	r28, r1
    350c:	05 c0       	rjmp	.+10     	; 0x3518 <digitalWrite+0x50>
		*out &= ~bit;
    350e:	ec 91       	ld	r30, X
    3510:	10 95       	com	r17
    3512:	1e 23       	and	r17, r30
    3514:	1c 93       	st	X, r17
    3516:	03 c0       	rjmp	.+6      	; 0x351e <digitalWrite+0x56>
	} else {
		*out |= bit;
    3518:	ec 91       	ld	r30, X
    351a:	1e 2b       	or	r17, r30
    351c:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    351e:	8f bf       	out	0x3f, r24	; 63
}
    3520:	df 91       	pop	r29
    3522:	cf 91       	pop	r28
    3524:	1f 91       	pop	r17
    3526:	08 95       	ret

00003528 <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3528:	0f 93       	push	r16
    352a:	1f 93       	push	r17
    352c:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    352e:	90 e0       	ldi	r25, 0x00	; 0
    3530:	fc 01       	movw	r30, r24
    3532:	e0 52       	subi	r30, 0x20	; 32
    3534:	fd 4f       	sbci	r31, 0xFD	; 253
    3536:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    3538:	fc 01       	movw	r30, r24
    353a:	ea 5d       	subi	r30, 0xDA	; 218
    353c:	fc 4f       	sbci	r31, 0xFC	; 252
    353e:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    3540:	71 11       	cpse	r23, r1
    3542:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3544:	f0 e0       	ldi	r31, 0x00	; 0
    3546:	ee 0f       	add	r30, r30
    3548:	ff 1f       	adc	r31, r31
    354a:	e4 59       	subi	r30, 0x94	; 148
    354c:	fc 4f       	sbci	r31, 0xFC	; 252
    354e:	85 91       	lpm	r24, Z+
    3550:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    3552:	89 01       	movw	r16, r18
    3554:	9a 01       	movw	r18, r20
    3556:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3558:	47 2f       	mov	r20, r23
    355a:	0e 94 12 02 	call	0x424	; 0x424 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    355e:	61 15       	cp	r22, r1
    3560:	71 05       	cpc	r23, r1
    3562:	81 05       	cpc	r24, r1
    3564:	91 05       	cpc	r25, r1
    3566:	49 f0       	breq	.+18     	; 0x357a <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    3568:	dc 01       	movw	r26, r24
    356a:	cb 01       	movw	r24, r22
    356c:	01 96       	adiw	r24, 0x01	; 1
    356e:	a1 1d       	adc	r26, r1
    3570:	b1 1d       	adc	r27, r1
    3572:	bc 01       	movw	r22, r24
    3574:	cd 01       	movw	r24, r26
    3576:	9f 70       	andi	r25, 0x0F	; 15
    3578:	03 c0       	rjmp	.+6      	; 0x3580 <pulseIn+0x58>
	else
		return 0;
    357a:	60 e0       	ldi	r22, 0x00	; 0
    357c:	70 e0       	ldi	r23, 0x00	; 0
    357e:	cb 01       	movw	r24, r22
}
    3580:	1f 91       	pop	r17
    3582:	0f 91       	pop	r16
    3584:	08 95       	ret

00003586 <__udivmodsi4>:
    3586:	a1 e2       	ldi	r26, 0x21	; 33
    3588:	1a 2e       	mov	r1, r26
    358a:	aa 1b       	sub	r26, r26
    358c:	bb 1b       	sub	r27, r27
    358e:	fd 01       	movw	r30, r26
    3590:	0d c0       	rjmp	.+26     	; 0x35ac <__udivmodsi4_ep>

00003592 <__udivmodsi4_loop>:
    3592:	aa 1f       	adc	r26, r26
    3594:	bb 1f       	adc	r27, r27
    3596:	ee 1f       	adc	r30, r30
    3598:	ff 1f       	adc	r31, r31
    359a:	a2 17       	cp	r26, r18
    359c:	b3 07       	cpc	r27, r19
    359e:	e4 07       	cpc	r30, r20
    35a0:	f5 07       	cpc	r31, r21
    35a2:	20 f0       	brcs	.+8      	; 0x35ac <__udivmodsi4_ep>
    35a4:	a2 1b       	sub	r26, r18
    35a6:	b3 0b       	sbc	r27, r19
    35a8:	e4 0b       	sbc	r30, r20
    35aa:	f5 0b       	sbc	r31, r21

000035ac <__udivmodsi4_ep>:
    35ac:	66 1f       	adc	r22, r22
    35ae:	77 1f       	adc	r23, r23
    35b0:	88 1f       	adc	r24, r24
    35b2:	99 1f       	adc	r25, r25
    35b4:	1a 94       	dec	r1
    35b6:	69 f7       	brne	.-38     	; 0x3592 <__udivmodsi4_loop>
    35b8:	60 95       	com	r22
    35ba:	70 95       	com	r23
    35bc:	80 95       	com	r24
    35be:	90 95       	com	r25
    35c0:	9b 01       	movw	r18, r22
    35c2:	ac 01       	movw	r20, r24
    35c4:	bd 01       	movw	r22, r26
    35c6:	cf 01       	movw	r24, r30
    35c8:	08 95       	ret

000035ca <__tablejump2__>:
    35ca:	ee 0f       	add	r30, r30
    35cc:	ff 1f       	adc	r31, r31

000035ce <__tablejump__>:
    35ce:	05 90       	lpm	r0, Z+
    35d0:	f4 91       	lpm	r31, Z
    35d2:	e0 2d       	mov	r30, r0
    35d4:	19 94       	eijmp

000035d6 <__tablejump_elpm__>:
    35d6:	07 90       	elpm	r0, Z+
    35d8:	f6 91       	elpm	r31, Z
    35da:	e0 2d       	mov	r30, r0
    35dc:	19 94       	eijmp

000035de <memcpy>:
    35de:	fb 01       	movw	r30, r22
    35e0:	dc 01       	movw	r26, r24
    35e2:	02 c0       	rjmp	.+4      	; 0x35e8 <memcpy+0xa>
    35e4:	01 90       	ld	r0, Z+
    35e6:	0d 92       	st	X+, r0
    35e8:	41 50       	subi	r20, 0x01	; 1
    35ea:	50 40       	sbci	r21, 0x00	; 0
    35ec:	d8 f7       	brcc	.-10     	; 0x35e4 <memcpy+0x6>
    35ee:	08 95       	ret

000035f0 <_exit>:
    35f0:	f8 94       	cli

000035f2 <__stop_program>:
    35f2:	ff cf       	rjmp	.-2      	; 0x35f2 <__stop_program>
