
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ac  00800200  00003fea  0000407e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003fea  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007f7  008002ac  008002ac  0000412a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000412a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000768  00000000  00000000  00004160  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000f5c9  00000000  00000000  000048c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002d91  00000000  00000000  00013e91  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000051e2  00000000  00000000  00016c22  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000015ec  00000000  00000000  0001be04  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003705  00000000  00000000  0001d3f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00007982  00000000  00000000  00020af5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000728  00000000  00000000  00028477  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	37 c2       	rjmp	.+1134   	; 0x470 <__ctors_end>
       2:	00 00       	nop
       4:	66 c2       	rjmp	.+1228   	; 0x4d2 <__bad_interrupt>
       6:	00 00       	nop
       8:	64 c2       	rjmp	.+1224   	; 0x4d2 <__bad_interrupt>
       a:	00 00       	nop
       c:	62 c2       	rjmp	.+1220   	; 0x4d2 <__bad_interrupt>
       e:	00 00       	nop
      10:	60 c2       	rjmp	.+1216   	; 0x4d2 <__bad_interrupt>
      12:	00 00       	nop
      14:	5e c2       	rjmp	.+1212   	; 0x4d2 <__bad_interrupt>
      16:	00 00       	nop
      18:	5c c2       	rjmp	.+1208   	; 0x4d2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5a c2       	rjmp	.+1204   	; 0x4d2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	58 c2       	rjmp	.+1200   	; 0x4d2 <__bad_interrupt>
      22:	00 00       	nop
      24:	56 c2       	rjmp	.+1196   	; 0x4d2 <__bad_interrupt>
      26:	00 00       	nop
      28:	54 c2       	rjmp	.+1192   	; 0x4d2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	52 c2       	rjmp	.+1188   	; 0x4d2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	50 c2       	rjmp	.+1184   	; 0x4d2 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 7d 0c 	jmp	0x18fa	; 0x18fa <__vector_13>
      38:	4c c2       	rjmp	.+1176   	; 0x4d2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4a c2       	rjmp	.+1172   	; 0x4d2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	48 c2       	rjmp	.+1168   	; 0x4d2 <__bad_interrupt>
      42:	00 00       	nop
      44:	46 c2       	rjmp	.+1164   	; 0x4d2 <__bad_interrupt>
      46:	00 00       	nop
      48:	44 c2       	rjmp	.+1160   	; 0x4d2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	42 c2       	rjmp	.+1156   	; 0x4d2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	40 c2       	rjmp	.+1152   	; 0x4d2 <__bad_interrupt>
      52:	00 00       	nop
      54:	3e c2       	rjmp	.+1148   	; 0x4d2 <__bad_interrupt>
      56:	00 00       	nop
      58:	3c c2       	rjmp	.+1144   	; 0x4d2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 30 1d 	jmp	0x3a60	; 0x3a60 <__vector_23>
      60:	38 c2       	rjmp	.+1136   	; 0x4d2 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 7b 1b 	jmp	0x36f6	; 0x36f6 <__vector_25>
      68:	0c 94 ba 1b 	jmp	0x3774	; 0x3774 <__vector_26>
      6c:	32 c2       	rjmp	.+1124   	; 0x4d2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	30 c2       	rjmp	.+1120   	; 0x4d2 <__bad_interrupt>
      72:	00 00       	nop
      74:	2e c2       	rjmp	.+1116   	; 0x4d2 <__bad_interrupt>
      76:	00 00       	nop
      78:	2c c2       	rjmp	.+1112   	; 0x4d2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2a c2       	rjmp	.+1108   	; 0x4d2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	28 c2       	rjmp	.+1104   	; 0x4d2 <__bad_interrupt>
      82:	00 00       	nop
      84:	26 c2       	rjmp	.+1100   	; 0x4d2 <__bad_interrupt>
      86:	00 00       	nop
      88:	24 c2       	rjmp	.+1096   	; 0x4d2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	22 c2       	rjmp	.+1092   	; 0x4d2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	20 c2       	rjmp	.+1088   	; 0x4d2 <__bad_interrupt>
      92:	00 00       	nop
      94:	1e c2       	rjmp	.+1084   	; 0x4d2 <__bad_interrupt>
      96:	00 00       	nop
      98:	1c c2       	rjmp	.+1080   	; 0x4d2 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 46 14 	jmp	0x288c	; 0x288c <__vector_39>
      a0:	18 c2       	rjmp	.+1072   	; 0x4d2 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	16 c2       	rjmp	.+1068   	; 0x4d2 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	14 c2       	rjmp	.+1064   	; 0x4d2 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	12 c2       	rjmp	.+1060   	; 0x4d2 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	10 c2       	rjmp	.+1056   	; 0x4d2 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0e c2       	rjmp	.+1052   	; 0x4d2 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	0c c2       	rjmp	.+1048   	; 0x4d2 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0a c2       	rjmp	.+1044   	; 0x4d2 <__bad_interrupt>
      be:	00 00       	nop
      c0:	08 c2       	rjmp	.+1040   	; 0x4d2 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	06 c2       	rjmp	.+1036   	; 0x4d2 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	04 c2       	rjmp	.+1032   	; 0x4d2 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	02 c2       	rjmp	.+1028   	; 0x4d2 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	00 c2       	rjmp	.+1024   	; 0x4d2 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	fe c1       	rjmp	.+1020   	; 0x4d2 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	fc c1       	rjmp	.+1016   	; 0x4d2 <__bad_interrupt>
      da:	00 00       	nop
      dc:	fa c1       	rjmp	.+1012   	; 0x4d2 <__bad_interrupt>
      de:	00 00       	nop
      e0:	f8 c1       	rjmp	.+1008   	; 0x4d2 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	4c 15       	cp	r20, r12
      e6:	4f 15       	cp	r20, r15
      e8:	4f 15       	cp	r20, r15
      ea:	4f 15       	cp	r20, r15
      ec:	4f 15       	cp	r20, r15
      ee:	4f 15       	cp	r20, r15
      f0:	4f 15       	cp	r20, r15
      f2:	4f 15       	cp	r20, r15
      f4:	66 14       	cp	r6, r6
      f6:	4f 15       	cp	r20, r15
      f8:	4f 15       	cp	r20, r15
      fa:	4f 15       	cp	r20, r15
      fc:	4f 15       	cp	r20, r15
      fe:	4f 15       	cp	r20, r15
     100:	4f 15       	cp	r20, r15
     102:	4f 15       	cp	r20, r15
     104:	66 14       	cp	r6, r6
     106:	4f 15       	cp	r20, r15
     108:	4f 15       	cp	r20, r15
     10a:	4f 15       	cp	r20, r15
     10c:	4f 15       	cp	r20, r15
     10e:	4f 15       	cp	r20, r15
     110:	4f 15       	cp	r20, r15
     112:	4f 15       	cp	r20, r15
     114:	6e 14       	cp	r6, r14
     116:	4f 15       	cp	r20, r15
     118:	4f 15       	cp	r20, r15
     11a:	4f 15       	cp	r20, r15
     11c:	4f 15       	cp	r20, r15
     11e:	4f 15       	cp	r20, r15
     120:	4f 15       	cp	r20, r15
     122:	4f 15       	cp	r20, r15
     124:	93 14       	cp	r9, r3
     126:	4f 15       	cp	r20, r15
     128:	4f 15       	cp	r20, r15
     12a:	4f 15       	cp	r20, r15
     12c:	4f 15       	cp	r20, r15
     12e:	4f 15       	cp	r20, r15
     130:	4f 15       	cp	r20, r15
     132:	4f 15       	cp	r20, r15
     134:	6e 14       	cp	r6, r14
     136:	4f 15       	cp	r20, r15
     138:	4f 15       	cp	r20, r15
     13a:	4f 15       	cp	r20, r15
     13c:	4f 15       	cp	r20, r15
     13e:	4f 15       	cp	r20, r15
     140:	4f 15       	cp	r20, r15
     142:	4f 15       	cp	r20, r15
     144:	98 14       	cp	r9, r8
     146:	4f 15       	cp	r20, r15
     148:	4f 15       	cp	r20, r15
     14a:	4f 15       	cp	r20, r15
     14c:	4f 15       	cp	r20, r15
     14e:	4f 15       	cp	r20, r15
     150:	4f 15       	cp	r20, r15
     152:	4f 15       	cp	r20, r15
     154:	9d 14       	cp	r9, r13
     156:	4f 15       	cp	r20, r15
     158:	4f 15       	cp	r20, r15
     15a:	4f 15       	cp	r20, r15
     15c:	4f 15       	cp	r20, r15
     15e:	4f 15       	cp	r20, r15
     160:	4f 15       	cp	r20, r15
     162:	4f 15       	cp	r20, r15
     164:	ae 14       	cp	r10, r14
     166:	4f 15       	cp	r20, r15
     168:	4f 15       	cp	r20, r15
     16a:	4f 15       	cp	r20, r15
     16c:	4f 15       	cp	r20, r15
     16e:	4f 15       	cp	r20, r15
     170:	4f 15       	cp	r20, r15
     172:	4f 15       	cp	r20, r15
     174:	d7 14       	cp	r13, r7
     176:	4f 15       	cp	r20, r15
     178:	4f 15       	cp	r20, r15
     17a:	4f 15       	cp	r20, r15
     17c:	4f 15       	cp	r20, r15
     17e:	4f 15       	cp	r20, r15
     180:	4f 15       	cp	r20, r15
     182:	4f 15       	cp	r20, r15
     184:	a2 14       	cp	r10, r2
     186:	4f 15       	cp	r20, r15
     188:	4f 15       	cp	r20, r15
     18a:	4f 15       	cp	r20, r15
     18c:	4f 15       	cp	r20, r15
     18e:	4f 15       	cp	r20, r15
     190:	4f 15       	cp	r20, r15
     192:	4f 15       	cp	r20, r15
     194:	bc 14       	cp	r11, r12
     196:	4f 15       	cp	r20, r15
     198:	4f 15       	cp	r20, r15
     19a:	4f 15       	cp	r20, r15
     19c:	4f 15       	cp	r20, r15
     19e:	4f 15       	cp	r20, r15
     1a0:	4f 15       	cp	r20, r15
     1a2:	4f 15       	cp	r20, r15
     1a4:	d9 14       	cp	r13, r9
     1a6:	4f 15       	cp	r20, r15
     1a8:	4f 15       	cp	r20, r15
     1aa:	4f 15       	cp	r20, r15
     1ac:	4f 15       	cp	r20, r15
     1ae:	4f 15       	cp	r20, r15
     1b0:	4f 15       	cp	r20, r15
     1b2:	4f 15       	cp	r20, r15
     1b4:	d9 14       	cp	r13, r9
     1b6:	4f 15       	cp	r20, r15
     1b8:	4f 15       	cp	r20, r15
     1ba:	4f 15       	cp	r20, r15
     1bc:	4f 15       	cp	r20, r15
     1be:	4f 15       	cp	r20, r15
     1c0:	4f 15       	cp	r20, r15
     1c2:	4f 15       	cp	r20, r15
     1c4:	d9 14       	cp	r13, r9
     1c6:	4f 15       	cp	r20, r15
     1c8:	4f 15       	cp	r20, r15
     1ca:	4f 15       	cp	r20, r15
     1cc:	4f 15       	cp	r20, r15
     1ce:	4f 15       	cp	r20, r15
     1d0:	4f 15       	cp	r20, r15
     1d2:	4f 15       	cp	r20, r15
     1d4:	d9 14       	cp	r13, r9
     1d6:	4f 15       	cp	r20, r15
     1d8:	4f 15       	cp	r20, r15
     1da:	4f 15       	cp	r20, r15
     1dc:	4f 15       	cp	r20, r15
     1de:	4f 15       	cp	r20, r15
     1e0:	4f 15       	cp	r20, r15
     1e2:	4f 15       	cp	r20, r15
     1e4:	e2 14       	cp	r14, r2
     1e6:	4f 15       	cp	r20, r15
     1e8:	4f 15       	cp	r20, r15
     1ea:	4f 15       	cp	r20, r15
     1ec:	4f 15       	cp	r20, r15
     1ee:	4f 15       	cp	r20, r15
     1f0:	4f 15       	cp	r20, r15
     1f2:	4f 15       	cp	r20, r15
     1f4:	13 15       	cp	r17, r3
     1f6:	4f 15       	cp	r20, r15
     1f8:	4f 15       	cp	r20, r15
     1fa:	4f 15       	cp	r20, r15
     1fc:	4f 15       	cp	r20, r15
     1fe:	4f 15       	cp	r20, r15
     200:	4f 15       	cp	r20, r15
     202:	4f 15       	cp	r20, r15
     204:	e2 14       	cp	r14, r2
     206:	4f 15       	cp	r20, r15
     208:	4f 15       	cp	r20, r15
     20a:	4f 15       	cp	r20, r15
     20c:	4f 15       	cp	r20, r15
     20e:	4f 15       	cp	r20, r15
     210:	4f 15       	cp	r20, r15
     212:	4f 15       	cp	r20, r15
     214:	13 15       	cp	r17, r3
     216:	4f 15       	cp	r20, r15
     218:	4f 15       	cp	r20, r15
     21a:	4f 15       	cp	r20, r15
     21c:	4f 15       	cp	r20, r15
     21e:	4f 15       	cp	r20, r15
     220:	4f 15       	cp	r20, r15
     222:	4f 15       	cp	r20, r15
     224:	fa 14       	cp	r15, r10
     226:	4f 15       	cp	r20, r15
     228:	4f 15       	cp	r20, r15
     22a:	4f 15       	cp	r20, r15
     22c:	4f 15       	cp	r20, r15
     22e:	4f 15       	cp	r20, r15
     230:	4f 15       	cp	r20, r15
     232:	4f 15       	cp	r20, r15
     234:	17 15       	cp	r17, r7
     236:	4f 15       	cp	r20, r15
     238:	4f 15       	cp	r20, r15
     23a:	4f 15       	cp	r20, r15
     23c:	4f 15       	cp	r20, r15
     23e:	4f 15       	cp	r20, r15
     240:	4f 15       	cp	r20, r15
     242:	4f 15       	cp	r20, r15
     244:	17 15       	cp	r17, r7
     246:	4f 15       	cp	r20, r15
     248:	4f 15       	cp	r20, r15
     24a:	4f 15       	cp	r20, r15
     24c:	4f 15       	cp	r20, r15
     24e:	4f 15       	cp	r20, r15
     250:	4f 15       	cp	r20, r15
     252:	4f 15       	cp	r20, r15
     254:	2c 15       	cp	r18, r12
     256:	4f 15       	cp	r20, r15
     258:	4f 15       	cp	r20, r15
     25a:	4f 15       	cp	r20, r15
     25c:	4f 15       	cp	r20, r15
     25e:	4f 15       	cp	r20, r15
     260:	4f 15       	cp	r20, r15
     262:	4f 15       	cp	r20, r15
     264:	46 15       	cp	r20, r6
     266:	4f 15       	cp	r20, r15
     268:	4f 15       	cp	r20, r15
     26a:	4f 15       	cp	r20, r15
     26c:	4f 15       	cp	r20, r15
     26e:	4f 15       	cp	r20, r15
     270:	4f 15       	cp	r20, r15
     272:	4f 15       	cp	r20, r15
     274:	46 15       	cp	r20, r6
     276:	08 4a       	sbci	r16, 0xA8	; 168
     278:	d7 3b       	cpi	r29, 0xB7	; 183
     27a:	3b ce       	rjmp	.-906    	; 0xfffffef2 <__eeprom_end+0xff7efef2>
     27c:	01 6e       	ori	r16, 0xE1	; 225
     27e:	84 bc       	out	0x24, r8	; 36
     280:	bf fd       	.word	0xfdbf	; ????
     282:	c1 2f       	mov	r28, r17
     284:	3d 6c       	ori	r19, 0xCD	; 205
     286:	74 31       	cpi	r23, 0x14	; 20
     288:	9a bd       	out	0x2a, r25	; 42
     28a:	56 83       	std	Z+6, r21	; 0x06
     28c:	3d da       	rcall	.-2950   	; 0xfffff708 <__eeprom_end+0xff7ef708>
     28e:	3d 00       	.word	0x003d	; ????
     290:	c7 7f       	andi	r28, 0xF7	; 247
     292:	11 be       	out	0x31, r1	; 49
     294:	d9 e4       	ldi	r29, 0x49	; 73
     296:	bb 4c       	sbci	r27, 0xCB	; 203
     298:	3e 91       	ld	r19, -X
     29a:	6b aa       	std	Y+51, r6	; 0x33
     29c:	aa be       	out	0x3a, r10	; 58
     29e:	00 00       	nop
     2a0:	00 80       	ld	r0, Z
     2a2:	3f 07       	cpc	r19, r31
     2a4:	63 42       	sbci	r22, 0x23	; 35
     2a6:	36 b7       	in	r19, 0x36	; 54
     2a8:	9b d8       	rcall	.-3786   	; 0xfffff3e0 <__eeprom_end+0xff7ef3e0>
     2aa:	a7 1a       	sub	r10, r23
     2ac:	39 68       	ori	r19, 0x89	; 137
     2ae:	56 18       	sub	r5, r6
     2b0:	ae ba       	out	0x1e, r10	; 30
     2b2:	ab 55       	subi	r26, 0x5B	; 91
     2b4:	8c 1d       	adc	r24, r12
     2b6:	3c b7       	in	r19, 0x3c	; 60
     2b8:	cc 57       	subi	r28, 0x7C	; 124
     2ba:	63 bd       	out	0x23, r22	; 35
     2bc:	6d ed       	ldi	r22, 0xDD	; 221
     2be:	fd 75       	andi	r31, 0x5D	; 93
     2c0:	3e f6       	brtc	.-114    	; 0x250 <__SREG__+0x211>
     2c2:	17 72       	andi	r17, 0x27	; 39
     2c4:	31 bf       	out	0x31, r19	; 49
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 08       	sbc	r3, r15
     2cc:	00 00       	nop
     2ce:	00 be       	out	0x30, r0	; 48
     2d0:	92 24       	eor	r9, r2
     2d2:	49 12       	cpse	r4, r25
     2d4:	3e ab       	std	Y+54, r19	; 0x36
     2d6:	aa aa       	std	Y+50, r10	; 0x32
     2d8:	2a be       	out	0x3a, r2	; 58
     2da:	cd cc       	rjmp	.-1638   	; 0xfffffc76 <__eeprom_end+0xff7efc76>
     2dc:	cc 4c       	sbci	r28, 0xCC	; 204
     2de:	3e 00       	.word	0x003e	; ????
     2e0:	00 00       	nop
     2e2:	80 be       	out	0x30, r8	; 48
     2e4:	ab aa       	std	Y+51, r10	; 0x33
     2e6:	aa aa       	std	Y+50, r10	; 0x32
     2e8:	3e 00       	.word	0x003e	; ????
     2ea:	00 00       	nop
     2ec:	00 bf       	out	0x30, r16	; 48
     2ee:	00 00       	nop
     2f0:	00 80       	ld	r0, Z
     2f2:	3f 00       	.word	0x003f	; ????
     2f4:	00 00       	nop
     2f6:	00 00       	nop
     2f8:	08 41       	sbci	r16, 0x18	; 24
     2fa:	78 d3       	rcall	.+1776   	; 0x9ec <_ZN6LSM303C1Ev+0x1e>
     2fc:	bb 43       	sbci	r27, 0x3B	; 59
     2fe:	87 d1       	rcall	.+782    	; 0x60e <_ZN3L3G8writeRegEhh+0x36>
     300:	13 3d       	cpi	r17, 0xD3	; 211
     302:	19 0e       	add	r1, r25
     304:	3c c3       	rjmp	.+1656   	; 0x97e <vListInsert+0x5e>
     306:	bd 42       	sbci	r27, 0x2D	; 45
     308:	82 ad       	ldd	r24, Z+58	; 0x3a
     30a:	2b 3e       	cpi	r18, 0xEB	; 235
     30c:	68 ec       	ldi	r22, 0xC8	; 200
     30e:	82 76       	andi	r24, 0x62	; 98
     310:	be d9       	rcall	.-3204   	; 0xfffff68e <__eeprom_end+0xff7ef68e>
     312:	8f e1       	ldi	r24, 0x1F	; 31
     314:	a9 3e       	cpi	r26, 0xE9	; 233
     316:	4c 80       	ldd	r4, Y+4	; 0x04
     318:	ef ff       	.word	0xffef	; ????
     31a:	be 01       	movw	r22, r28
     31c:	c4 ff       	sbrs	r28, 4
     31e:	7f 3f       	cpi	r23, 0xFF	; 255
     320:	00 00       	nop
     322:	00 00       	nop
     324:	00 00       	nop
     326:	36 1e       	adc	r3, r22
     328:	3a 1e       	adc	r3, r26
     32a:	24 1e       	adc	r2, r20
     32c:	2a 1e       	adc	r2, r26
     32e:	30 1e       	adc	r3, r16
     330:	7f 1e       	adc	r7, r31
     332:	3e 1e       	adc	r3, r30
     334:	44 1e       	adc	r4, r20
     336:	4a 1e       	adc	r4, r26
     338:	50 1e       	adc	r5, r16
     33a:	56 1e       	adc	r5, r22
     33c:	5c 1e       	adc	r5, r28
     33e:	62 1e       	adc	r6, r18
     340:	68 1e       	adc	r6, r24
     342:	7f 1e       	adc	r7, r31
     344:	6e 1e       	adc	r6, r30
     346:	74 1e       	adc	r7, r20
     348:	7a 1e       	adc	r7, r26

0000034a <__trampolines_end>:
     34a:	00 00       	nop
     34c:	0a 0b       	sbc	r16, r26
     34e:	02 09       	sbc	r16, r2
     350:	0c 0d       	add	r16, r12
     352:	0e 08       	sbc	r0, r14
     354:	07 03       	mulsu	r16, r23
     356:	04 01       	movw	r0, r8
	...
     374:	00 00       	nop
     376:	12 11       	cpse	r17, r2
     378:	10 00       	.word	0x0010	; ????
	...

00000390 <digital_pin_to_bit_mask_PGM>:
     390:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     3a0:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     3b0:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     3c0:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     3d0:	04 08 10 20 40 80                                   ... @.

000003d6 <digital_pin_to_port_PGM>:
     3d6:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     3e6:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     3f6:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     406:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     416:	0b 0b 0b 0b 0b 0b                                   ......

0000041c <port_to_input_PGM>:
     41c:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     42c:	00 01 00 00 03 01 06 01 09 01                       ..........

00000436 <port_to_output_PGM>:
     436:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     446:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000450 <port_to_mode_PGM>:
     450:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     460:	01 01 00 00 04 01 07 01 0a 01                       ..........

0000046a <__ctors_start>:
     46a:	be 0e       	add	r11, r30
     46c:	34 16       	cp	r3, r20
     46e:	e3 1b       	sub	r30, r19

00000470 <__ctors_end>:
     470:	11 24       	eor	r1, r1
     472:	1f be       	out	0x3f, r1	; 63
     474:	cf ef       	ldi	r28, 0xFF	; 255
     476:	d1 e2       	ldi	r29, 0x21	; 33
     478:	de bf       	out	0x3e, r29	; 62
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	00 e0       	ldi	r16, 0x00	; 0
     47e:	0c bf       	out	0x3c, r16	; 60

00000480 <__do_copy_data>:
     480:	12 e0       	ldi	r17, 0x02	; 2
     482:	a0 e0       	ldi	r26, 0x00	; 0
     484:	b2 e0       	ldi	r27, 0x02	; 2
     486:	ea ee       	ldi	r30, 0xEA	; 234
     488:	ff e3       	ldi	r31, 0x3F	; 63
     48a:	00 e0       	ldi	r16, 0x00	; 0
     48c:	0b bf       	out	0x3b, r16	; 59
     48e:	02 c0       	rjmp	.+4      	; 0x494 <__do_copy_data+0x14>
     490:	07 90       	elpm	r0, Z+
     492:	0d 92       	st	X+, r0
     494:	ac 3a       	cpi	r26, 0xAC	; 172
     496:	b1 07       	cpc	r27, r17
     498:	d9 f7       	brne	.-10     	; 0x490 <__do_copy_data+0x10>

0000049a <__do_clear_bss>:
     49a:	2a e0       	ldi	r18, 0x0A	; 10
     49c:	ac ea       	ldi	r26, 0xAC	; 172
     49e:	b2 e0       	ldi	r27, 0x02	; 2
     4a0:	01 c0       	rjmp	.+2      	; 0x4a4 <.do_clear_bss_start>

000004a2 <.do_clear_bss_loop>:
     4a2:	1d 92       	st	X+, r1

000004a4 <.do_clear_bss_start>:
     4a4:	a3 3a       	cpi	r26, 0xA3	; 163
     4a6:	b2 07       	cpc	r27, r18
     4a8:	e1 f7       	brne	.-8      	; 0x4a2 <.do_clear_bss_loop>

000004aa <__do_global_ctors>:
     4aa:	14 e0       	ldi	r17, 0x04	; 4
     4ac:	c0 e7       	ldi	r28, 0x70	; 112
     4ae:	d4 e0       	ldi	r29, 0x04	; 4
     4b0:	00 e0       	ldi	r16, 0x00	; 0
     4b2:	06 c0       	rjmp	.+12     	; 0x4c0 <__do_global_ctors+0x16>
     4b4:	22 97       	sbiw	r28, 0x02	; 2
     4b6:	01 09       	sbc	r16, r1
     4b8:	fe 01       	movw	r30, r28
     4ba:	0b bf       	out	0x3b, r16	; 59
     4bc:	0e 94 cc 1f 	call	0x3f98	; 0x3f98 <__tablejump_elpm__>
     4c0:	ca 36       	cpi	r28, 0x6A	; 106
     4c2:	d1 07       	cpc	r29, r17
     4c4:	80 e0       	ldi	r24, 0x00	; 0
     4c6:	08 07       	cpc	r16, r24
     4c8:	a9 f7       	brne	.-22     	; 0x4b4 <__do_global_ctors+0xa>
     4ca:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <main>
     4ce:	0c 94 f3 1f 	jmp	0x3fe6	; 0x3fe6 <_exit>

000004d2 <__bad_interrupt>:
     4d2:	96 cd       	rjmp	.-1236   	; 0x0 <__vectors>

000004d4 <countPulseASM>:

countPulseASM:

.LM0:
.LFBB1:
    push r12   ;   ;  130 pushqi1/1 [length = 1]
     4d4:	cf 92       	push	r12
    push r13   ;   ;  131 pushqi1/1 [length = 1]
     4d6:	df 92       	push	r13
    push r14   ;   ;  132 pushqi1/1 [length = 1]
     4d8:	ef 92       	push	r14
    push r15   ;   ;  133 pushqi1/1 [length = 1]
     4da:	ff 92       	push	r15
    push r16   ;   ;  134 pushqi1/1 [length = 1]
     4dc:	0f 93       	push	r16
    push r17   ;   ;  135 pushqi1/1 [length = 1]
     4de:	1f 93       	push	r17
/* prologue: function */
/* frame size = 0 */
/* stack size = 6 */
.L__stack_usage = 6
    mov r30,r24  ;  port, port   ;  2 *movhi/1  [length = 2]
     4e0:	e8 2f       	mov	r30, r24
    mov r31,r25  ;  port, port
     4e2:	f9 2f       	mov	r31, r25
/*     unsigned long width = 0;
***     // wait for any previous pulse to end
***     while ((*port & bit) == stateMask)
*/
.LM1:
    rjmp .L2   ;   ;  181 jump  [length = 1]
     4e4:	05 c0       	rjmp	.+10     	; 0x4f0 <countPulseASM+0x1c>
.L4:
/*         if (--maxloops == 0) */
.LM2:
    subi r16,1   ;  maxloops,  ;  17  addsi3/2  [length = 4]
     4e6:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4e8:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4ea:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     4ec:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  19  branch  [length = 1]
     4ee:	61 f1       	breq	.+88     	; 0x548 <countPulseASM+0x74>
.L2:
/*         if (--maxloops == 0) */
.LM3:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  22  movqi_insn/4  [length = 1]
     4f0:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  24  andqi3/1  [length = 1]
     4f2:	96 23       	and	r25, r22
    cp r25,r20   ;  D.1554, stateMask  ;  25  *cmpqi/2  [length = 1]
     4f4:	94 17       	cp	r25, r20
    breq .L4   ; ,   ;  26  branch  [length = 1]
     4f6:	b9 f3       	breq	.-18     	; 0x4e6 <countPulseASM+0x12>
    rjmp .L6   ;   ;  184 jump  [length = 1]
     4f8:	05 c0       	rjmp	.+10     	; 0x504 <countPulseASM+0x30>
***     // wait for the pulse to start
***     while ((*port & bit) != stateMask)
***         if (--maxloops == 0)
*/
.LM4:
    subi r16,1   ;  maxloops,  ;  31  addsi3/2  [length = 4]
     4fa:	01 50       	subi	r16, 0x01	; 1
    sbc r17, r1   ;  maxloops
     4fc:	11 09       	sbc	r17, r1
    sbc r18, r1   ;  maxloops
     4fe:	21 09       	sbc	r18, r1
    sbc r19, r1   ;  maxloops
     500:	31 09       	sbc	r19, r1
    breq .L13  ; ,   ;  33  branch  [length = 1]
     502:	11 f1       	breq	.+68     	; 0x548 <countPulseASM+0x74>
.L6:
/*         if (--maxloops == 0) */
.LM5:
    ld r25,Z   ;  D.1554, *port_7(D)   ;  41  movqi_insn/4  [length = 1]
     504:	90 81       	ld	r25, Z
    and r25,r22  ;  D.1554, bit  ;  43  andqi3/1  [length = 1]
     506:	96 23       	and	r25, r22
    cpse r25,r20   ;  D.1554, stateMask  ;  44  enable_interrupt-3  [length = 1]
     508:	94 13       	cpse	r25, r20
    rjmp .L7   ;
     50a:	f7 cf       	rjmp	.-18     	; 0x4fa <countPulseASM+0x26>
    mov r12, r1   ;  width  ;  7 *movsi/2  [length = 4]
     50c:	c1 2c       	mov	r12, r1
    mov r13, r1   ;  width
     50e:	d1 2c       	mov	r13, r1
    mov r14, r1   ;  width
     510:	e1 2c       	mov	r14, r1
    mov r15, r1   ;  width
     512:	f1 2c       	mov	r15, r1
    rjmp .L9   ;   ;  186 jump  [length = 1]
     514:	0a c0       	rjmp	.+20     	; 0x52a <countPulseASM+0x56>
***     // wait for the pulse to stop
***     while ((*port & bit) == stateMask) {
***         if (++width == maxloops)
*/
.LM6:
    ldi r24,-1   ; ,   ;  50  addsi3/3  [length = 5]
     516:	8f ef       	ldi	r24, 0xFF	; 255
    sub r12,r24  ;  width,
     518:	c8 1a       	sub	r12, r24
    sbc r13,r24  ;  width,
     51a:	d8 0a       	sbc	r13, r24
    sbc r14,r24  ;  width,
     51c:	e8 0a       	sbc	r14, r24
    sbc r15,r24  ;  width,
     51e:	f8 0a       	sbc	r15, r24
    cp r16,r12   ;  maxloops, width  ;  51  *cmpsi/2  [length = 4]
     520:	0c 15       	cp	r16, r12
    cpc r17,r13  ;  maxloops, width
     522:	1d 05       	cpc	r17, r13
    cpc r18,r14  ;  maxloops, width
     524:	2e 05       	cpc	r18, r14
    cpc r19,r15  ;  maxloops, width
     526:	3f 05       	cpc	r19, r15
    breq .L13  ; ,   ;  52  branch  [length = 1]
     528:	79 f0       	breq	.+30     	; 0x548 <countPulseASM+0x74>
.L9:
/*         if (++width == maxloops) */
.LM7:
    ld r24,Z   ;  D.1554, *port_7(D)   ;  60  movqi_insn/4  [length = 1]
     52a:	80 81       	ld	r24, Z
    and r24,r22  ;  D.1554, bit  ;  62  andqi3/1  [length = 1]
     52c:	86 23       	and	r24, r22
    cp r24,r20   ;  D.1554, stateMask  ;  63  *cmpqi/2  [length = 1]
     52e:	84 17       	cp	r24, r20
    breq .L10  ; ,   ;  64  branch  [length = 1]
     530:	91 f3       	breq	.-28     	; 0x516 <countPulseASM+0x42>
/*             return 0;
***     }
***     return width;
*/
.LM8:
    mov r22,r12  ;  D.1553, width  ;  108 movqi_insn/1  [length = 1]
     532:	6c 2d       	mov	r22, r12
    mov r23,r13  ;  D.1553, width  ;  109 movqi_insn/1  [length = 1]
     534:	7d 2d       	mov	r23, r13
    mov r24,r14  ;  D.1553, width  ;  110 movqi_insn/1  [length = 1]
     536:	8e 2d       	mov	r24, r14
    mov r25,r15  ;  D.1553, width  ;  111 movqi_insn/1  [length = 1]
     538:	9f 2d       	mov	r25, r15
/* epilogue start */
.LM9:
    pop r17  ;   ;  171 popqi [length = 1]
     53a:	1f 91       	pop	r17
    pop r16  ;   ;  172 popqi [length = 1]
     53c:	0f 91       	pop	r16
    pop r15  ;   ;  173 popqi [length = 1]
     53e:	ff 90       	pop	r15
    pop r14  ;   ;  174 popqi [length = 1]
     540:	ef 90       	pop	r14
    pop r13  ;   ;  175 popqi [length = 1]
     542:	df 90       	pop	r13
    pop r12  ;   ;  176 popqi [length = 1]
     544:	cf 90       	pop	r12
    ret  ;  177 return_from_epilogue  [length = 1]
     546:	08 95       	ret
.L13:
.LM10:
    ldi r22,0  ;  D.1553   ;  120 movqi_insn/1  [length = 1]
     548:	60 e0       	ldi	r22, 0x00	; 0
    ldi r23,0  ;  D.1553   ;  121 movqi_insn/1  [length = 1]
     54a:	70 e0       	ldi	r23, 0x00	; 0
    ldi r24,0  ;  D.1553   ;  122 movqi_insn/1  [length = 1]
     54c:	80 e0       	ldi	r24, 0x00	; 0
    ldi r25,0  ;  D.1553   ;  123 movqi_insn/1  [length = 1]
     54e:	90 e0       	ldi	r25, 0x00	; 0
/* epilogue start */
.LM11:
    pop r17  ;   ;  138 popqi [length = 1]
     550:	1f 91       	pop	r17
    pop r16  ;   ;  139 popqi [length = 1]
     552:	0f 91       	pop	r16
    pop r15  ;   ;  140 popqi [length = 1]
     554:	ff 90       	pop	r15
    pop r14  ;   ;  141 popqi [length = 1]
     556:	ef 90       	pop	r14
    pop r13  ;   ;  142 popqi [length = 1]
     558:	df 90       	pop	r13
    pop r12  ;   ;  143 popqi [length = 1]
     55a:	cf 90       	pop	r12
    ret  ;  144 return_from_epilogue  [length = 1]
     55c:	08 95       	ret

0000055e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     55e:	cf 93       	push	r28
     560:	df 93       	push	r29
     562:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     564:	0e 94 55 11 	call	0x22aa	; 0x22aa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     568:	80 91 ac 02 	lds	r24, 0x02AC
     56c:	90 91 ad 02 	lds	r25, 0x02AD
     570:	89 2b       	or	r24, r25
     572:	31 f4       	brne	.+12     	; 0x580 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     574:	81 eb       	ldi	r24, 0xB1	; 177
     576:	92 e0       	ldi	r25, 0x02	; 2
     578:	90 93 ad 02 	sts	0x02AD, r25
     57c:	80 93 ac 02 	sts	0x02AC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     580:	40 91 ae 02 	lds	r20, 0x02AE
     584:	50 91 af 02 	lds	r21, 0x02AF
     588:	9e 01       	movw	r18, r28
     58a:	24 0f       	add	r18, r20
     58c:	35 1f       	adc	r19, r21
     58e:	2b 3d       	cpi	r18, 0xDB	; 219
     590:	85 e0       	ldi	r24, 0x05	; 5
     592:	38 07       	cpc	r19, r24
     594:	70 f4       	brcc	.+28     	; 0x5b2 <pvPortMalloc+0x54>
     596:	42 17       	cp	r20, r18
     598:	53 07       	cpc	r21, r19
     59a:	70 f4       	brcc	.+28     	; 0x5b8 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     59c:	c0 91 ac 02 	lds	r28, 0x02AC
     5a0:	d0 91 ad 02 	lds	r29, 0x02AD
     5a4:	c4 0f       	add	r28, r20
     5a6:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     5a8:	30 93 af 02 	sts	0x02AF, r19
     5ac:	20 93 ae 02 	sts	0x02AE, r18
     5b0:	05 c0       	rjmp	.+10     	; 0x5bc <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5b2:	c0 e0       	ldi	r28, 0x00	; 0
     5b4:	d0 e0       	ldi	r29, 0x00	; 0
     5b6:	02 c0       	rjmp	.+4      	; 0x5bc <pvPortMalloc+0x5e>
     5b8:	c0 e0       	ldi	r28, 0x00	; 0
     5ba:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5bc:	0e 94 19 12 	call	0x2432	; 0x2432 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5c0:	ce 01       	movw	r24, r28
     5c2:	df 91       	pop	r29
     5c4:	cf 91       	pop	r28
     5c6:	08 95       	ret

000005c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5c8:	08 95       	ret

000005ca <_ZN3L3GC1Ev>:
  Wire.requestFrom(address, (byte)1);
  value = Wire.read();
  Wire.endTransmission();

  return value;
}
     5ca:	fc 01       	movw	r30, r24
     5cc:	83 e0       	ldi	r24, 0x03	; 3
     5ce:	87 83       	std	Z+7, r24	; 0x07
     5d0:	12 86       	std	Z+10, r1	; 0x0a
     5d2:	11 86       	std	Z+9, r1	; 0x09
     5d4:	13 86       	std	Z+11, r1	; 0x0b
     5d6:	08 95       	ret

000005d8 <_ZN3L3G8writeRegEhh>:
     5d8:	0f 93       	push	r16
     5da:	1f 93       	push	r17
     5dc:	cf 93       	push	r28
     5de:	df 93       	push	r29
     5e0:	ec 01       	movw	r28, r24
     5e2:	06 2f       	mov	r16, r22
     5e4:	14 2f       	mov	r17, r20
     5e6:	68 85       	ldd	r22, Y+8	; 0x08
     5e8:	87 ea       	ldi	r24, 0xA7	; 167
     5ea:	99 e0       	ldi	r25, 0x09	; 9
     5ec:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
     5f0:	60 2f       	mov	r22, r16
     5f2:	87 ea       	ldi	r24, 0xA7	; 167
     5f4:	99 e0       	ldi	r25, 0x09	; 9
     5f6:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
     5fa:	61 2f       	mov	r22, r17
     5fc:	87 ea       	ldi	r24, 0xA7	; 167
     5fe:	99 e0       	ldi	r25, 0x09	; 9
     600:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
     604:	87 ea       	ldi	r24, 0xA7	; 167
     606:	99 e0       	ldi	r25, 0x09	; 9
     608:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
     60c:	8e 83       	std	Y+6, r24	; 0x06
     60e:	df 91       	pop	r29
     610:	cf 91       	pop	r28
     612:	1f 91       	pop	r17
     614:	0f 91       	pop	r16
     616:	08 95       	ret

00000618 <_ZN3L3G13enableDefaultEv>:
     618:	cf 93       	push	r28
     61a:	df 93       	push	r29
     61c:	ec 01       	movw	r28, r24
     61e:	8f 81       	ldd	r24, Y+7	; 0x07
     620:	82 30       	cpi	r24, 0x02	; 2
     622:	21 f4       	brne	.+8      	; 0x62c <_ZN3L3G13enableDefaultEv+0x14>
     624:	40 e0       	ldi	r20, 0x00	; 0
     626:	69 e3       	ldi	r22, 0x39	; 57
     628:	ce 01       	movw	r24, r28
     62a:	d6 df       	rcall	.-84     	; 0x5d8 <_ZN3L3G8writeRegEhh>
     62c:	40 e0       	ldi	r20, 0x00	; 0
     62e:	63 e2       	ldi	r22, 0x23	; 35
     630:	ce 01       	movw	r24, r28
     632:	d2 df       	rcall	.-92     	; 0x5d8 <_ZN3L3G8writeRegEhh>
     634:	4f e6       	ldi	r20, 0x6F	; 111
     636:	60 e2       	ldi	r22, 0x20	; 32
     638:	ce 01       	movw	r24, r28
     63a:	ce df       	rcall	.-100    	; 0x5d8 <_ZN3L3G8writeRegEhh>
     63c:	df 91       	pop	r29
     63e:	cf 91       	pop	r28
     640:	08 95       	ret

00000642 <_ZN3L3G4readEv>:

// Reads the 3 gyro channels and stores them in vector g
void L3G::read()
{
     642:	9f 92       	push	r9
     644:	af 92       	push	r10
     646:	bf 92       	push	r11
     648:	cf 92       	push	r12
     64a:	df 92       	push	r13
     64c:	ef 92       	push	r14
     64e:	ff 92       	push	r15
     650:	0f 93       	push	r16
     652:	1f 93       	push	r17
     654:	cf 93       	push	r28
     656:	df 93       	push	r29
     658:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     65a:	68 85       	ldd	r22, Y+8	; 0x08
     65c:	87 ea       	ldi	r24, 0xA7	; 167
     65e:	99 e0       	ldi	r25, 0x09	; 9
     660:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     664:	e0 91 a7 09 	lds	r30, 0x09A7
     668:	f0 91 a8 09 	lds	r31, 0x09A8
     66c:	01 90       	ld	r0, Z+
     66e:	f0 81       	ld	r31, Z
     670:	e0 2d       	mov	r30, r0
     672:	68 ea       	ldi	r22, 0xA8	; 168
     674:	87 ea       	ldi	r24, 0xA7	; 167
     676:	99 e0       	ldi	r25, 0x09	; 9
     678:	19 95       	eicall
  // assert the MSB of the address to get the gyro
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
     67a:	87 ea       	ldi	r24, 0xA7	; 167
     67c:	99 e0       	ldi	r25, 0x09	; 9
     67e:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)6);
     682:	46 e0       	ldi	r20, 0x06	; 6
     684:	68 85       	ldd	r22, Y+8	; 0x08
     686:	87 ea       	ldi	r24, 0xA7	; 167
     688:	99 e0       	ldi	r25, 0x09	; 9
     68a:	0e 94 12 16 	call	0x2c24	; 0x2c24 <_ZN7TwoWire11requestFromEhh>
  
  unsigned int millis_start = millis();
     68e:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <millis>
     692:	8b 01       	movw	r16, r22
  while (Wire.available() < 6)
     694:	10 c0       	rjmp	.+32     	; 0x6b6 <_ZN3L3G4readEv+0x74>
  {
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
     696:	89 85       	ldd	r24, Y+9	; 0x09
     698:	9a 85       	ldd	r25, Y+10	; 0x0a
     69a:	89 2b       	or	r24, r25
     69c:	61 f0       	breq	.+24     	; 0x6b6 <_ZN3L3G4readEv+0x74>
     69e:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <millis>
     6a2:	60 1b       	sub	r22, r16
     6a4:	71 0b       	sbc	r23, r17
     6a6:	89 85       	ldd	r24, Y+9	; 0x09
     6a8:	9a 85       	ldd	r25, Y+10	; 0x0a
     6aa:	86 17       	cp	r24, r22
     6ac:	97 07       	cpc	r25, r23
     6ae:	18 f4       	brcc	.+6      	; 0x6b6 <_ZN3L3G4readEv+0x74>
    {
      did_timeout = true;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	8b 87       	std	Y+11, r24	; 0x0b
      return;
     6b4:	32 c0       	rjmp	.+100    	; 0x71a <_ZN3L3G4readEv+0xd8>
  Wire.write(OUT_X_L | (1 << 7));
  Wire.endTransmission();
  Wire.requestFrom(address, (byte)6);
  
  unsigned int millis_start = millis();
  while (Wire.available() < 6)
     6b6:	87 ea       	ldi	r24, 0xA7	; 167
     6b8:	99 e0       	ldi	r25, 0x09	; 9
     6ba:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN7TwoWire9availableEv>
     6be:	06 97       	sbiw	r24, 0x06	; 6
     6c0:	54 f3       	brlt	.-44     	; 0x696 <_ZN3L3G4readEv+0x54>
      did_timeout = true;
      return;
    }
  }

  uint8_t xlg = Wire.read();
     6c2:	87 ea       	ldi	r24, 0xA7	; 167
     6c4:	99 e0       	ldi	r25, 0x09	; 9
     6c6:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
     6ca:	a8 2e       	mov	r10, r24
  uint8_t xhg = Wire.read();
     6cc:	87 ea       	ldi	r24, 0xA7	; 167
     6ce:	99 e0       	ldi	r25, 0x09	; 9
     6d0:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
     6d4:	98 2e       	mov	r9, r24
  uint8_t ylg = Wire.read();
     6d6:	87 ea       	ldi	r24, 0xA7	; 167
     6d8:	99 e0       	ldi	r25, 0x09	; 9
     6da:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
     6de:	08 2f       	mov	r16, r24
  uint8_t yhg = Wire.read();
     6e0:	87 ea       	ldi	r24, 0xA7	; 167
     6e2:	99 e0       	ldi	r25, 0x09	; 9
     6e4:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
     6e8:	b8 2e       	mov	r11, r24
  uint8_t zlg = Wire.read();
     6ea:	87 ea       	ldi	r24, 0xA7	; 167
     6ec:	99 e0       	ldi	r25, 0x09	; 9
     6ee:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
     6f2:	18 2f       	mov	r17, r24
  uint8_t zhg = Wire.read();
     6f4:	87 ea       	ldi	r24, 0xA7	; 167
     6f6:	99 e0       	ldi	r25, 0x09	; 9
     6f8:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
     6fc:	d9 2c       	mov	r13, r9
     6fe:	c1 2c       	mov	r12, r1
     700:	ca 28       	or	r12, r10
     702:	d9 82       	std	Y+1, r13	; 0x01
     704:	c8 82       	st	Y, r12
  g.y = (int16_t)(yhg << 8 | ylg);
     706:	fb 2c       	mov	r15, r11
     708:	e1 2c       	mov	r14, r1
     70a:	e0 2a       	or	r14, r16
     70c:	fb 82       	std	Y+3, r15	; 0x03
     70e:	ea 82       	std	Y+2, r14	; 0x02
  g.z = (int16_t)(zhg << 8 | zlg);
     710:	98 2f       	mov	r25, r24
     712:	88 27       	eor	r24, r24
     714:	81 2b       	or	r24, r17
     716:	9d 83       	std	Y+5, r25	; 0x05
     718:	8c 83       	std	Y+4, r24	; 0x04
}
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	ff 90       	pop	r15
     724:	ef 90       	pop	r14
     726:	df 90       	pop	r13
     728:	cf 90       	pop	r12
     72a:	bf 90       	pop	r11
     72c:	af 90       	pop	r10
     72e:	9f 90       	pop	r9
     730:	08 95       	ret

00000732 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	c6 2f       	mov	r28, r22
     738:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     73a:	87 ea       	ldi	r24, 0xA7	; 167
     73c:	99 e0       	ldi	r25, 0x09	; 9
     73e:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     742:	6d 2f       	mov	r22, r29
     744:	87 ea       	ldi	r24, 0xA7	; 167
     746:	99 e0       	ldi	r25, 0x09	; 9
     748:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     74c:	87 ea       	ldi	r24, 0xA7	; 167
     74e:	99 e0       	ldi	r25, 0x09	; 9
     750:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
     754:	81 11       	cpse	r24, r1
     756:	11 c0       	rjmp	.+34     	; 0x77a <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     758:	41 e0       	ldi	r20, 0x01	; 1
     75a:	6c 2f       	mov	r22, r28
     75c:	87 ea       	ldi	r24, 0xA7	; 167
     75e:	99 e0       	ldi	r25, 0x09	; 9
     760:	0e 94 12 16 	call	0x2c24	; 0x2c24 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     764:	87 ea       	ldi	r24, 0xA7	; 167
     766:	99 e0       	ldi	r25, 0x09	; 9
     768:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN7TwoWire9availableEv>
     76c:	89 2b       	or	r24, r25
     76e:	41 f0       	breq	.+16     	; 0x780 <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     770:	87 ea       	ldi	r24, 0xA7	; 167
     772:	99 e0       	ldi	r25, 0x09	; 9
     774:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
     778:	05 c0       	rjmp	.+10     	; 0x784 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     77a:	8f ef       	ldi	r24, 0xFF	; 255
     77c:	9f ef       	ldi	r25, 0xFF	; 255
     77e:	02 c0       	rjmp	.+4      	; 0x784 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     780:	8f ef       	ldi	r24, 0xFF	; 255
     782:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	08 95       	ret

0000078a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     78a:	0f 93       	push	r16
     78c:	1f 93       	push	r17
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29
     792:	ec 01       	movw	r28, r24
     794:	16 2f       	mov	r17, r22
     796:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     798:	63 30       	cpi	r22, 0x03	; 3
     79a:	09 f4       	brne	.+2      	; 0x79e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     79c:	56 c0       	rjmp	.+172    	; 0x84a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     79e:	42 30       	cpi	r20, 0x02	; 2
     7a0:	c9 f5       	brne	.+114    	; 0x814 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     7a2:	56 c0       	rjmp	.+172    	; 0x850 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     7a4:	13 30       	cpi	r17, 0x03	; 3
     7a6:	09 f0       	breq	.+2      	; 0x7aa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     7a8:	58 c0       	rjmp	.+176    	; 0x85a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7aa:	87 3d       	cpi	r24, 0xD7	; 215
     7ac:	91 05       	cpc	r25, r1
     7ae:	09 f4       	brne	.+2      	; 0x7b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     7b0:	58 c0       	rjmp	.+176    	; 0x862 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7b2:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7b4:	11 e0       	ldi	r17, 0x01	; 1
     7b6:	2c c0       	rjmp	.+88     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7b8:	01 30       	cpi	r16, 0x01	; 1
     7ba:	91 f0       	breq	.+36     	; 0x7e0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     7bc:	4f e0       	ldi	r20, 0x0F	; 15
     7be:	6a e6       	ldi	r22, 0x6A	; 106
     7c0:	ce 01       	movw	r24, r28
     7c2:	b7 df       	rcall	.-146    	; 0x732 <_ZN3L3G7testRegEhNS_7regAddrE>
     7c4:	8f 3f       	cpi	r24, 0xFF	; 255
     7c6:	2f ef       	ldi	r18, 0xFF	; 255
     7c8:	92 07       	cpc	r25, r18
     7ca:	51 f0       	breq	.+20     	; 0x7e0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     7cc:	13 30       	cpi	r17, 0x03	; 3
     7ce:	09 f0       	breq	.+2      	; 0x7d2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     7d0:	46 c0       	rjmp	.+140    	; 0x85e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7d2:	87 3d       	cpi	r24, 0xD7	; 215
     7d4:	91 05       	cpc	r25, r1
     7d6:	09 f0       	breq	.+2      	; 0x7da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     7d8:	47 c0       	rjmp	.+142    	; 0x868 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     7da:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7dc:	12 e0       	ldi	r17, 0x02	; 2
     7de:	18 c0       	rjmp	.+48     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     7e0:	13 30       	cpi	r17, 0x03	; 3
     7e2:	11 f0       	breq	.+4      	; 0x7e8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     7e4:	11 11       	cpse	r17, r1
     7e6:	14 c0       	rjmp	.+40     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7e8:	00 23       	and	r16, r16
     7ea:	49 f0       	breq	.+18     	; 0x7fe <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     7ec:	4f e0       	ldi	r20, 0x0F	; 15
     7ee:	69 e6       	ldi	r22, 0x69	; 105
     7f0:	ce 01       	movw	r24, r28
     7f2:	9f df       	rcall	.-194    	; 0x732 <_ZN3L3G7testRegEhNS_7regAddrE>
     7f4:	83 3d       	cpi	r24, 0xD3	; 211
     7f6:	91 05       	cpc	r25, r1
     7f8:	d1 f1       	breq	.+116    	; 0x86e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     7fa:	01 30       	cpi	r16, 0x01	; 1
     7fc:	39 f0       	breq	.+14     	; 0x80c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     7fe:	4f e0       	ldi	r20, 0x0F	; 15
     800:	68 e6       	ldi	r22, 0x68	; 104
     802:	ce 01       	movw	r24, r28
     804:	96 df       	rcall	.-212    	; 0x732 <_ZN3L3G7testRegEhNS_7regAddrE>
     806:	83 3d       	cpi	r24, 0xD3	; 211
     808:	91 05       	cpc	r25, r1
     80a:	99 f1       	breq	.+102    	; 0x872 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     80c:	13 30       	cpi	r17, 0x03	; 3
     80e:	b9 f0       	breq	.+46     	; 0x83e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     810:	02 30       	cpi	r16, 0x02	; 2
     812:	b9 f0       	breq	.+46     	; 0x842 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     814:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     816:	11 23       	and	r17, r17
     818:	51 f0       	breq	.+20     	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     81a:	13 30       	cpi	r17, 0x03	; 3
     81c:	a0 f4       	brcc	.+40     	; 0x846 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     81e:	01 30       	cpi	r16, 0x01	; 1
     820:	11 f4       	brne	.+4      	; 0x826 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     822:	8b e6       	ldi	r24, 0x6B	; 107
     824:	01 c0       	rjmp	.+2      	; 0x828 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     826:	8a e6       	ldi	r24, 0x6A	; 106
     828:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     82a:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     82c:	41 c0       	rjmp	.+130    	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     82e:	01 30       	cpi	r16, 0x01	; 1
     830:	11 f4       	brne	.+4      	; 0x836 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     832:	89 e6       	ldi	r24, 0x69	; 105
     834:	01 c0       	rjmp	.+2      	; 0x838 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     836:	88 e6       	ldi	r24, 0x68	; 104
     838:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     83a:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     83c:	39 c0       	rjmp	.+114    	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	37 c0       	rjmp	.+110    	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     842:	80 e0       	ldi	r24, 0x00	; 0
     844:	35 c0       	rjmp	.+106    	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     846:	81 e0       	ldi	r24, 0x01	; 1
     848:	33 c0       	rjmp	.+102    	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     84a:	44 23       	and	r20, r20
     84c:	41 f1       	breq	.+80     	; 0x89e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     84e:	1e c0       	rjmp	.+60     	; 0x88c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     850:	8f ef       	ldi	r24, 0xFF	; 255
     852:	86 0f       	add	r24, r22
     854:	83 30       	cpi	r24, 0x03	; 3
     856:	30 f6       	brcc	.-116    	; 0x7e4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     858:	0f c0       	rjmp	.+30     	; 0x878 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     85a:	01 e0       	ldi	r16, 0x01	; 1
     85c:	c3 cf       	rjmp	.-122    	; 0x7e4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     85e:	00 e0       	ldi	r16, 0x00	; 0
     860:	c1 cf       	rjmp	.-126    	; 0x7e4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     862:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     864:	12 e0       	ldi	r17, 0x02	; 2
     866:	d4 cf       	rjmp	.-88     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     868:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     86a:	11 e0       	ldi	r17, 0x01	; 1
     86c:	d1 cf       	rjmp	.-94     	; 0x810 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     86e:	01 e0       	ldi	r16, 0x01	; 1
     870:	01 c0       	rjmp	.+2      	; 0x874 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     872:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     874:	1f 82       	std	Y+7, r1	; 0x07
     876:	db cf       	rjmp	.-74     	; 0x82e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     878:	4f e0       	ldi	r20, 0x0F	; 15
     87a:	6b e6       	ldi	r22, 0x6B	; 107
     87c:	ce 01       	movw	r24, r28
     87e:	59 df       	rcall	.-334    	; 0x732 <_ZN3L3G7testRegEhNS_7regAddrE>
     880:	8f 3f       	cpi	r24, 0xFF	; 255
     882:	2f ef       	ldi	r18, 0xFF	; 255
     884:	92 07       	cpc	r25, r18
     886:	09 f0       	breq	.+2      	; 0x88a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     888:	8d cf       	rjmp	.-230    	; 0x7a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     88a:	98 cf       	rjmp	.-208    	; 0x7bc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     88c:	4f e0       	ldi	r20, 0x0F	; 15
     88e:	6b e6       	ldi	r22, 0x6B	; 107
     890:	50 df       	rcall	.-352    	; 0x732 <_ZN3L3G7testRegEhNS_7regAddrE>
     892:	8f 3f       	cpi	r24, 0xFF	; 255
     894:	2f ef       	ldi	r18, 0xFF	; 255
     896:	92 07       	cpc	r25, r18
     898:	09 f0       	breq	.+2      	; 0x89c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     89a:	87 cf       	rjmp	.-242    	; 0x7aa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     89c:	8d cf       	rjmp	.-230    	; 0x7b8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     89e:	4f e0       	ldi	r20, 0x0F	; 15
     8a0:	6a e6       	ldi	r22, 0x6A	; 106
     8a2:	47 df       	rcall	.-370    	; 0x732 <_ZN3L3G7testRegEhNS_7regAddrE>
     8a4:	8f 3f       	cpi	r24, 0xFF	; 255
     8a6:	2f ef       	ldi	r18, 0xFF	; 255
     8a8:	92 07       	cpc	r25, r18
     8aa:	09 f0       	breq	.+2      	; 0x8ae <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     8ac:	92 cf       	rjmp	.-220    	; 0x7d2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     8ae:	98 cf       	rjmp	.-208    	; 0x7e0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     8b0:	df 91       	pop	r29
     8b2:	cf 91       	pop	r28
     8b4:	1f 91       	pop	r17
     8b6:	0f 91       	pop	r16
     8b8:	08 95       	ret

000008ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8bc:	03 96       	adiw	r24, 0x03	; 3
     8be:	92 83       	std	Z+2, r25	; 0x02
     8c0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8c2:	2f ef       	ldi	r18, 0xFF	; 255
     8c4:	3f ef       	ldi	r19, 0xFF	; 255
     8c6:	34 83       	std	Z+4, r19	; 0x04
     8c8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ca:	96 83       	std	Z+6, r25	; 0x06
     8cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ce:	90 87       	std	Z+8, r25	; 0x08
     8d0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8d2:	10 82       	st	Z, r1
     8d4:	08 95       	ret

000008d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8d6:	fc 01       	movw	r30, r24
     8d8:	11 86       	std	Z+9, r1	; 0x09
     8da:	10 86       	std	Z+8, r1	; 0x08
     8dc:	08 95       	ret

000008de <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8de:	cf 93       	push	r28
     8e0:	df 93       	push	r29
     8e2:	9c 01       	movw	r18, r24
     8e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8e6:	dc 01       	movw	r26, r24
     8e8:	11 96       	adiw	r26, 0x01	; 1
     8ea:	cd 91       	ld	r28, X+
     8ec:	dc 91       	ld	r29, X
     8ee:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8f0:	d3 83       	std	Z+3, r29	; 0x03
     8f2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8f4:	8c 81       	ldd	r24, Y+4	; 0x04
     8f6:	9d 81       	ldd	r25, Y+5	; 0x05
     8f8:	95 83       	std	Z+5, r25	; 0x05
     8fa:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8fc:	8c 81       	ldd	r24, Y+4	; 0x04
     8fe:	9d 81       	ldd	r25, Y+5	; 0x05
     900:	dc 01       	movw	r26, r24
     902:	13 96       	adiw	r26, 0x03	; 3
     904:	7c 93       	st	X, r23
     906:	6e 93       	st	-X, r22
     908:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     90a:	7d 83       	std	Y+5, r23	; 0x05
     90c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     90e:	31 87       	std	Z+9, r19	; 0x09
     910:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     912:	f9 01       	movw	r30, r18
     914:	80 81       	ld	r24, Z
     916:	8f 5f       	subi	r24, 0xFF	; 255
     918:	80 83       	st	Z, r24
}
     91a:	df 91       	pop	r29
     91c:	cf 91       	pop	r28
     91e:	08 95       	ret

00000920 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     920:	cf 93       	push	r28
     922:	df 93       	push	r29
     924:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     926:	48 81       	ld	r20, Y
     928:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     92a:	4f 3f       	cpi	r20, 0xFF	; 255
     92c:	2f ef       	ldi	r18, 0xFF	; 255
     92e:	52 07       	cpc	r21, r18
     930:	21 f4       	brne	.+8      	; 0x93a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     932:	fc 01       	movw	r30, r24
     934:	a7 81       	ldd	r26, Z+7	; 0x07
     936:	b0 85       	ldd	r27, Z+8	; 0x08
     938:	0d c0       	rjmp	.+26     	; 0x954 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     93a:	dc 01       	movw	r26, r24
     93c:	13 96       	adiw	r26, 0x03	; 3
     93e:	12 96       	adiw	r26, 0x02	; 2
     940:	ed 91       	ld	r30, X+
     942:	fc 91       	ld	r31, X
     944:	13 97       	sbiw	r26, 0x03	; 3
     946:	20 81       	ld	r18, Z
     948:	31 81       	ldd	r19, Z+1	; 0x01
     94a:	42 17       	cp	r20, r18
     94c:	53 07       	cpc	r21, r19
     94e:	10 f0       	brcs	.+4      	; 0x954 <vListInsert+0x34>
     950:	df 01       	movw	r26, r30
     952:	f5 cf       	rjmp	.-22     	; 0x93e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     954:	12 96       	adiw	r26, 0x02	; 2
     956:	ed 91       	ld	r30, X+
     958:	fc 91       	ld	r31, X
     95a:	13 97       	sbiw	r26, 0x03	; 3
     95c:	fb 83       	std	Y+3, r31	; 0x03
     95e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     960:	d5 83       	std	Z+5, r29	; 0x05
     962:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     964:	bd 83       	std	Y+5, r27	; 0x05
     966:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     968:	13 96       	adiw	r26, 0x03	; 3
     96a:	dc 93       	st	X, r29
     96c:	ce 93       	st	-X, r28
     96e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     970:	99 87       	std	Y+9, r25	; 0x09
     972:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     974:	fc 01       	movw	r30, r24
     976:	20 81       	ld	r18, Z
     978:	2f 5f       	subi	r18, 0xFF	; 255
     97a:	20 83       	st	Z, r18
}
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	08 95       	ret

00000982 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     988:	a0 85       	ldd	r26, Z+8	; 0x08
     98a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     98c:	c2 81       	ldd	r28, Z+2	; 0x02
     98e:	d3 81       	ldd	r29, Z+3	; 0x03
     990:	84 81       	ldd	r24, Z+4	; 0x04
     992:	95 81       	ldd	r25, Z+5	; 0x05
     994:	9d 83       	std	Y+5, r25	; 0x05
     996:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     998:	c4 81       	ldd	r28, Z+4	; 0x04
     99a:	d5 81       	ldd	r29, Z+5	; 0x05
     99c:	82 81       	ldd	r24, Z+2	; 0x02
     99e:	93 81       	ldd	r25, Z+3	; 0x03
     9a0:	9b 83       	std	Y+3, r25	; 0x03
     9a2:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9a4:	11 96       	adiw	r26, 0x01	; 1
     9a6:	cd 91       	ld	r28, X+
     9a8:	dc 91       	ld	r29, X
     9aa:	12 97       	sbiw	r26, 0x02	; 2
     9ac:	ce 17       	cp	r28, r30
     9ae:	df 07       	cpc	r29, r31
     9b0:	31 f4       	brne	.+12     	; 0x9be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9b2:	8c 81       	ldd	r24, Y+4	; 0x04
     9b4:	9d 81       	ldd	r25, Y+5	; 0x05
     9b6:	12 96       	adiw	r26, 0x02	; 2
     9b8:	9c 93       	st	X, r25
     9ba:	8e 93       	st	-X, r24
     9bc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9be:	11 86       	std	Z+9, r1	; 0x09
     9c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9c2:	8c 91       	ld	r24, X
     9c4:	81 50       	subi	r24, 0x01	; 1
     9c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     9c8:	df 91       	pop	r29
     9ca:	cf 91       	pop	r28
     9cc:	08 95       	ret

000009ce <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
     9ce:	cf 93       	push	r28
     9d0:	df 93       	push	r29
     9d2:	ec 01       	movw	r28, r24
     9d4:	86 e0       	ldi	r24, 0x06	; 6
     9d6:	e9 e0       	ldi	r30, 0x09	; 9
     9d8:	f2 e0       	ldi	r31, 0x02	; 2
     9da:	de 01       	movw	r26, r28
     9dc:	52 96       	adiw	r26, 0x12	; 18
     9de:	01 90       	ld	r0, Z+
     9e0:	0d 92       	st	X+, r0
     9e2:	8a 95       	dec	r24
     9e4:	e1 f7       	brne	.-8      	; 0x9de <_ZN6LSM303C1Ev+0x10>
     9e6:	86 e0       	ldi	r24, 0x06	; 6
     9e8:	ef e0       	ldi	r30, 0x0F	; 15
     9ea:	f2 e0       	ldi	r31, 0x02	; 2
     9ec:	de 01       	movw	r26, r28
     9ee:	1c 96       	adiw	r26, 0x0c	; 12
     9f0:	01 90       	ld	r0, Z+
     9f2:	0d 92       	st	X+, r0
     9f4:	8a 95       	dec	r24
     9f6:	e1 f7       	brne	.-8      	; 0x9f0 <_ZN6LSM303C1Ev+0x22>
     9f8:	84 e0       	ldi	r24, 0x04	; 4
     9fa:	89 8f       	std	Y+25, r24	; 0x19
     9fc:	1c a2       	std	Y+36, r1	; 0x24
     9fe:	1b a2       	std	Y+35, r1	; 0x23
     a00:	1d a2       	std	Y+37, r1	; 0x25
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>:
     a08:	4f 92       	push	r4
     a0a:	5f 92       	push	r5
     a0c:	6f 92       	push	r6
     a0e:	7f 92       	push	r7
     a10:	8f 92       	push	r8
     a12:	9f 92       	push	r9
     a14:	af 92       	push	r10
     a16:	bf 92       	push	r11
     a18:	cf 92       	push	r12
     a1a:	df 92       	push	r13
     a1c:	ef 92       	push	r14
     a1e:	ff 92       	push	r15
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	00 d0       	rcall	.+0      	; 0xa2a <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE+0x22>
     a2a:	1f 92       	push	r1
     a2c:	cd b7       	in	r28, 0x3d	; 61
     a2e:	de b7       	in	r29, 0x3e	; 62
     a30:	8c 01       	movw	r16, r24
     a32:	dc 01       	movw	r26, r24
     a34:	4d 90       	ld	r4, X+
     a36:	5d 90       	ld	r5, X+
     a38:	6d 90       	ld	r6, X+
     a3a:	7c 90       	ld	r7, X
     a3c:	13 97       	sbiw	r26, 0x03	; 3
     a3e:	14 96       	adiw	r26, 0x04	; 4
     a40:	8d 90       	ld	r8, X+
     a42:	9d 90       	ld	r9, X+
     a44:	ad 90       	ld	r10, X+
     a46:	bc 90       	ld	r11, X
     a48:	17 97       	sbiw	r26, 0x07	; 7
     a4a:	18 96       	adiw	r26, 0x08	; 8
     a4c:	8d 91       	ld	r24, X+
     a4e:	9d 91       	ld	r25, X+
     a50:	0d 90       	ld	r0, X+
     a52:	bc 91       	ld	r27, X
     a54:	a0 2d       	mov	r26, r0
     a56:	89 83       	std	Y+1, r24	; 0x01
     a58:	9a 83       	std	Y+2, r25	; 0x02
     a5a:	ab 83       	std	Y+3, r26	; 0x03
     a5c:	bc 83       	std	Y+4, r27	; 0x04
     a5e:	a3 01       	movw	r20, r6
     a60:	92 01       	movw	r18, r4
     a62:	c3 01       	movw	r24, r6
     a64:	b2 01       	movw	r22, r4
     a66:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     a6a:	6b 01       	movw	r12, r22
     a6c:	7c 01       	movw	r14, r24
     a6e:	a5 01       	movw	r20, r10
     a70:	94 01       	movw	r18, r8
     a72:	c5 01       	movw	r24, r10
     a74:	b4 01       	movw	r22, r8
     a76:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     a7a:	9b 01       	movw	r18, r22
     a7c:	ac 01       	movw	r20, r24
     a7e:	c7 01       	movw	r24, r14
     a80:	b6 01       	movw	r22, r12
     a82:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     a86:	6b 01       	movw	r12, r22
     a88:	7c 01       	movw	r14, r24
     a8a:	29 81       	ldd	r18, Y+1	; 0x01
     a8c:	3a 81       	ldd	r19, Y+2	; 0x02
     a8e:	4b 81       	ldd	r20, Y+3	; 0x03
     a90:	5c 81       	ldd	r21, Y+4	; 0x04
     a92:	ca 01       	movw	r24, r20
     a94:	b9 01       	movw	r22, r18
     a96:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     a9a:	9b 01       	movw	r18, r22
     a9c:	ac 01       	movw	r20, r24
     a9e:	c7 01       	movw	r24, r14
     aa0:	b6 01       	movw	r22, r12
     aa2:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     aa6:	0e 94 2d 19 	call	0x325a	; 0x325a <sqrt>
     aaa:	6b 01       	movw	r12, r22
     aac:	7c 01       	movw	r14, r24
     aae:	9b 01       	movw	r18, r22
     ab0:	ac 01       	movw	r20, r24
     ab2:	c3 01       	movw	r24, r6
     ab4:	b2 01       	movw	r22, r4
     ab6:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
     aba:	f8 01       	movw	r30, r16
     abc:	60 83       	st	Z, r22
     abe:	71 83       	std	Z+1, r23	; 0x01
     ac0:	82 83       	std	Z+2, r24	; 0x02
     ac2:	93 83       	std	Z+3, r25	; 0x03
     ac4:	a7 01       	movw	r20, r14
     ac6:	96 01       	movw	r18, r12
     ac8:	c5 01       	movw	r24, r10
     aca:	b4 01       	movw	r22, r8
     acc:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
     ad0:	d8 01       	movw	r26, r16
     ad2:	14 96       	adiw	r26, 0x04	; 4
     ad4:	6d 93       	st	X+, r22
     ad6:	7d 93       	st	X+, r23
     ad8:	8d 93       	st	X+, r24
     ada:	9c 93       	st	X, r25
     adc:	17 97       	sbiw	r26, 0x07	; 7
     ade:	a7 01       	movw	r20, r14
     ae0:	96 01       	movw	r18, r12
     ae2:	69 81       	ldd	r22, Y+1	; 0x01
     ae4:	7a 81       	ldd	r23, Y+2	; 0x02
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	9c 81       	ldd	r25, Y+4	; 0x04
     aea:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
     aee:	f8 01       	movw	r30, r16
     af0:	60 87       	std	Z+8, r22	; 0x08
     af2:	71 87       	std	Z+9, r23	; 0x09
     af4:	82 87       	std	Z+10, r24	; 0x0a
     af6:	93 87       	std	Z+11, r25	; 0x0b
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	0f 90       	pop	r0
     afe:	0f 90       	pop	r0
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	ef 90       	pop	r14
     b0c:	df 90       	pop	r13
     b0e:	cf 90       	pop	r12
     b10:	bf 90       	pop	r11
     b12:	af 90       	pop	r10
     b14:	9f 90       	pop	r9
     b16:	8f 90       	pop	r8
     b18:	7f 90       	pop	r7
     b1a:	6f 90       	pop	r6
     b1c:	5f 90       	pop	r5
     b1e:	4f 90       	pop	r4
     b20:	08 95       	ret

00000b22 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>:
     b22:	4f 92       	push	r4
     b24:	5f 92       	push	r5
     b26:	6f 92       	push	r6
     b28:	7f 92       	push	r7
     b2a:	8f 92       	push	r8
     b2c:	9f 92       	push	r9
     b2e:	af 92       	push	r10
     b30:	bf 92       	push	r11
     b32:	cf 92       	push	r12
     b34:	df 92       	push	r13
     b36:	ef 92       	push	r14
     b38:	ff 92       	push	r15
     b3a:	0f 93       	push	r16
     b3c:	1f 93       	push	r17
     b3e:	cf 93       	push	r28
     b40:	df 93       	push	r29
     b42:	cd b7       	in	r28, 0x3d	; 61
     b44:	de b7       	in	r29, 0x3e	; 62
     b46:	aa 97       	sbiw	r28, 0x2a	; 42
     b48:	0f b6       	in	r0, 0x3f	; 63
     b4a:	f8 94       	cli
     b4c:	de bf       	out	0x3e, r29	; 62
     b4e:	0f be       	out	0x3f, r0	; 63
     b50:	cd bf       	out	0x3d, r28	; 61
     b52:	8c 01       	movw	r16, r24
     b54:	29 8f       	std	Y+25, r18	; 0x19
     b56:	3a 8f       	std	Y+26, r19	; 0x1a
     b58:	4b 8f       	std	Y+27, r20	; 0x1b
     b5a:	5c 8f       	std	Y+28, r21	; 0x1c
     b5c:	6d 8f       	std	Y+29, r22	; 0x1d
     b5e:	7e 8f       	std	Y+30, r23	; 0x1e
     b60:	dc 01       	movw	r26, r24
     b62:	16 96       	adiw	r26, 0x06	; 6
     b64:	cd 90       	ld	r12, X+
     b66:	dc 90       	ld	r13, X
     b68:	17 97       	sbiw	r26, 0x07	; 7
     b6a:	ee 24       	eor	r14, r14
     b6c:	d7 fc       	sbrc	r13, 7
     b6e:	e0 94       	com	r14
     b70:	fe 2c       	mov	r15, r14
     b72:	52 96       	adiw	r26, 0x12	; 18
     b74:	4d 91       	ld	r20, X+
     b76:	5c 91       	ld	r21, X
     b78:	53 97       	sbiw	r26, 0x13	; 19
     b7a:	66 27       	eor	r22, r22
     b7c:	57 fd       	sbrc	r21, 7
     b7e:	60 95       	com	r22
     b80:	76 2f       	mov	r23, r22
     b82:	1c 96       	adiw	r26, 0x0c	; 12
     b84:	8d 91       	ld	r24, X+
     b86:	9c 91       	ld	r25, X
     b88:	1d 97       	sbiw	r26, 0x0d	; 13
     b8a:	aa 27       	eor	r26, r26
     b8c:	97 fd       	sbrc	r25, 7
     b8e:	a0 95       	com	r26
     b90:	ba 2f       	mov	r27, r26
     b92:	48 0f       	add	r20, r24
     b94:	59 1f       	adc	r21, r25
     b96:	6a 1f       	adc	r22, r26
     b98:	7b 1f       	adc	r23, r27
     b9a:	db 01       	movw	r26, r22
     b9c:	ca 01       	movw	r24, r20
     b9e:	77 23       	and	r23, r23
     ba0:	1c f4       	brge	.+6      	; 0xba8 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x86>
     ba2:	01 96       	adiw	r24, 0x01	; 1
     ba4:	a1 1d       	adc	r26, r1
     ba6:	b1 1d       	adc	r27, r1
     ba8:	b5 95       	asr	r27
     baa:	a7 95       	ror	r26
     bac:	97 95       	ror	r25
     bae:	87 95       	ror	r24
     bb0:	a7 01       	movw	r20, r14
     bb2:	96 01       	movw	r18, r12
     bb4:	28 1b       	sub	r18, r24
     bb6:	39 0b       	sbc	r19, r25
     bb8:	4a 0b       	sbc	r20, r26
     bba:	5b 0b       	sbc	r21, r27
     bbc:	2f 8f       	std	Y+31, r18	; 0x1f
     bbe:	38 a3       	std	Y+32, r19	; 0x20
     bc0:	49 a3       	std	Y+33, r20	; 0x21
     bc2:	5a a3       	std	Y+34, r21	; 0x22
     bc4:	d8 01       	movw	r26, r16
     bc6:	18 96       	adiw	r26, 0x08	; 8
     bc8:	cd 90       	ld	r12, X+
     bca:	dc 90       	ld	r13, X
     bcc:	19 97       	sbiw	r26, 0x09	; 9
     bce:	ee 24       	eor	r14, r14
     bd0:	d7 fc       	sbrc	r13, 7
     bd2:	e0 94       	com	r14
     bd4:	fe 2c       	mov	r15, r14
     bd6:	54 96       	adiw	r26, 0x14	; 20
     bd8:	4d 91       	ld	r20, X+
     bda:	5c 91       	ld	r21, X
     bdc:	55 97       	sbiw	r26, 0x15	; 21
     bde:	66 27       	eor	r22, r22
     be0:	57 fd       	sbrc	r21, 7
     be2:	60 95       	com	r22
     be4:	76 2f       	mov	r23, r22
     be6:	1e 96       	adiw	r26, 0x0e	; 14
     be8:	8d 91       	ld	r24, X+
     bea:	9c 91       	ld	r25, X
     bec:	1f 97       	sbiw	r26, 0x0f	; 15
     bee:	aa 27       	eor	r26, r26
     bf0:	97 fd       	sbrc	r25, 7
     bf2:	a0 95       	com	r26
     bf4:	ba 2f       	mov	r27, r26
     bf6:	48 0f       	add	r20, r24
     bf8:	59 1f       	adc	r21, r25
     bfa:	6a 1f       	adc	r22, r26
     bfc:	7b 1f       	adc	r23, r27
     bfe:	db 01       	movw	r26, r22
     c00:	ca 01       	movw	r24, r20
     c02:	77 23       	and	r23, r23
     c04:	1c f4       	brge	.+6      	; 0xc0c <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0xea>
     c06:	01 96       	adiw	r24, 0x01	; 1
     c08:	a1 1d       	adc	r26, r1
     c0a:	b1 1d       	adc	r27, r1
     c0c:	b5 95       	asr	r27
     c0e:	a7 95       	ror	r26
     c10:	97 95       	ror	r25
     c12:	87 95       	ror	r24
     c14:	a7 01       	movw	r20, r14
     c16:	96 01       	movw	r18, r12
     c18:	28 1b       	sub	r18, r24
     c1a:	39 0b       	sbc	r19, r25
     c1c:	4a 0b       	sbc	r20, r26
     c1e:	5b 0b       	sbc	r21, r27
     c20:	2b a3       	std	Y+35, r18	; 0x23
     c22:	3c a3       	std	Y+36, r19	; 0x24
     c24:	4d a3       	std	Y+37, r20	; 0x25
     c26:	5e a3       	std	Y+38, r21	; 0x26
     c28:	d8 01       	movw	r26, r16
     c2a:	1a 96       	adiw	r26, 0x0a	; 10
     c2c:	4d 90       	ld	r4, X+
     c2e:	5c 90       	ld	r5, X
     c30:	1b 97       	sbiw	r26, 0x0b	; 11
     c32:	66 24       	eor	r6, r6
     c34:	57 fc       	sbrc	r5, 7
     c36:	60 94       	com	r6
     c38:	76 2c       	mov	r7, r6
     c3a:	56 96       	adiw	r26, 0x16	; 22
     c3c:	4d 91       	ld	r20, X+
     c3e:	5c 91       	ld	r21, X
     c40:	57 97       	sbiw	r26, 0x17	; 23
     c42:	66 27       	eor	r22, r22
     c44:	57 fd       	sbrc	r21, 7
     c46:	60 95       	com	r22
     c48:	76 2f       	mov	r23, r22
     c4a:	50 96       	adiw	r26, 0x10	; 16
     c4c:	8d 91       	ld	r24, X+
     c4e:	9c 91       	ld	r25, X
     c50:	51 97       	sbiw	r26, 0x11	; 17
     c52:	aa 27       	eor	r26, r26
     c54:	97 fd       	sbrc	r25, 7
     c56:	a0 95       	com	r26
     c58:	ba 2f       	mov	r27, r26
     c5a:	48 0f       	add	r20, r24
     c5c:	59 1f       	adc	r21, r25
     c5e:	6a 1f       	adc	r22, r26
     c60:	7b 1f       	adc	r23, r27
     c62:	db 01       	movw	r26, r22
     c64:	ca 01       	movw	r24, r20
     c66:	77 23       	and	r23, r23
     c68:	1c f4       	brge	.+6      	; 0xc70 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x14e>
     c6a:	01 96       	adiw	r24, 0x01	; 1
     c6c:	a1 1d       	adc	r26, r1
     c6e:	b1 1d       	adc	r27, r1
     c70:	b5 95       	asr	r27
     c72:	a7 95       	ror	r26
     c74:	97 95       	ror	r25
     c76:	87 95       	ror	r24
     c78:	48 1a       	sub	r4, r24
     c7a:	59 0a       	sbc	r5, r25
     c7c:	6a 0a       	sbc	r6, r26
     c7e:	7b 0a       	sbc	r7, r27
     c80:	f8 01       	movw	r30, r16
     c82:	84 80       	ldd	r8, Z+4	; 0x04
     c84:	95 80       	ldd	r9, Z+5	; 0x05
     c86:	aa 24       	eor	r10, r10
     c88:	97 fc       	sbrc	r9, 7
     c8a:	a0 94       	com	r10
     c8c:	ba 2c       	mov	r11, r10
     c8e:	82 81       	ldd	r24, Z+2	; 0x02
     c90:	93 81       	ldd	r25, Z+3	; 0x03
     c92:	9c 01       	movw	r18, r24
     c94:	44 27       	eor	r20, r20
     c96:	37 fd       	sbrc	r19, 7
     c98:	40 95       	com	r20
     c9a:	54 2f       	mov	r21, r20
     c9c:	2f a3       	std	Y+39, r18	; 0x27
     c9e:	38 a7       	std	Y+40, r19	; 0x28
     ca0:	49 a7       	std	Y+41, r20	; 0x29
     ca2:	5a a7       	std	Y+42, r21	; 0x2a
     ca4:	2b a1       	ldd	r18, Y+35	; 0x23
     ca6:	3c a1       	ldd	r19, Y+36	; 0x24
     ca8:	4d a1       	ldd	r20, Y+37	; 0x25
     caa:	5e a1       	ldd	r21, Y+38	; 0x26
     cac:	c5 01       	movw	r24, r10
     cae:	b4 01       	movw	r22, r8
     cb0:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__mulsi3>
     cb4:	6b 01       	movw	r12, r22
     cb6:	7c 01       	movw	r14, r24
     cb8:	a3 01       	movw	r20, r6
     cba:	92 01       	movw	r18, r4
     cbc:	6f a1       	ldd	r22, Y+39	; 0x27
     cbe:	78 a5       	ldd	r23, Y+40	; 0x28
     cc0:	89 a5       	ldd	r24, Y+41	; 0x29
     cc2:	9a a5       	ldd	r25, Y+42	; 0x2a
     cc4:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__mulsi3>
     cc8:	a7 01       	movw	r20, r14
     cca:	96 01       	movw	r18, r12
     ccc:	26 1b       	sub	r18, r22
     cce:	37 0b       	sbc	r19, r23
     cd0:	48 0b       	sbc	r20, r24
     cd2:	59 0b       	sbc	r21, r25
     cd4:	ca 01       	movw	r24, r20
     cd6:	b9 01       	movw	r22, r18
     cd8:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     cdc:	6d 87       	std	Y+13, r22	; 0x0d
     cde:	7e 87       	std	Y+14, r23	; 0x0e
     ce0:	8f 87       	std	Y+15, r24	; 0x0f
     ce2:	98 8b       	std	Y+16, r25	; 0x10
     ce4:	d8 01       	movw	r26, r16
     ce6:	cd 90       	ld	r12, X+
     ce8:	dc 90       	ld	r13, X
     cea:	ee 24       	eor	r14, r14
     cec:	d7 fc       	sbrc	r13, 7
     cee:	e0 94       	com	r14
     cf0:	fe 2c       	mov	r15, r14
     cf2:	a3 01       	movw	r20, r6
     cf4:	92 01       	movw	r18, r4
     cf6:	c7 01       	movw	r24, r14
     cf8:	b6 01       	movw	r22, r12
     cfa:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__mulsi3>
     cfe:	2b 01       	movw	r4, r22
     d00:	3c 01       	movw	r6, r24
     d02:	2f 8d       	ldd	r18, Y+31	; 0x1f
     d04:	38 a1       	ldd	r19, Y+32	; 0x20
     d06:	49 a1       	ldd	r20, Y+33	; 0x21
     d08:	5a a1       	ldd	r21, Y+34	; 0x22
     d0a:	c5 01       	movw	r24, r10
     d0c:	b4 01       	movw	r22, r8
     d0e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__mulsi3>
     d12:	a3 01       	movw	r20, r6
     d14:	92 01       	movw	r18, r4
     d16:	26 1b       	sub	r18, r22
     d18:	37 0b       	sbc	r19, r23
     d1a:	48 0b       	sbc	r20, r24
     d1c:	59 0b       	sbc	r21, r25
     d1e:	ca 01       	movw	r24, r20
     d20:	b9 01       	movw	r22, r18
     d22:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     d26:	69 8b       	std	Y+17, r22	; 0x11
     d28:	7a 8b       	std	Y+18, r23	; 0x12
     d2a:	8b 8b       	std	Y+19, r24	; 0x13
     d2c:	9c 8b       	std	Y+20, r25	; 0x14
     d2e:	2f 8d       	ldd	r18, Y+31	; 0x1f
     d30:	38 a1       	ldd	r19, Y+32	; 0x20
     d32:	49 a1       	ldd	r20, Y+33	; 0x21
     d34:	5a a1       	ldd	r21, Y+34	; 0x22
     d36:	6f a1       	ldd	r22, Y+39	; 0x27
     d38:	78 a5       	ldd	r23, Y+40	; 0x28
     d3a:	89 a5       	ldd	r24, Y+41	; 0x29
     d3c:	9a a5       	ldd	r25, Y+42	; 0x2a
     d3e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__mulsi3>
     d42:	4b 01       	movw	r8, r22
     d44:	5c 01       	movw	r10, r24
     d46:	2b a1       	ldd	r18, Y+35	; 0x23
     d48:	3c a1       	ldd	r19, Y+36	; 0x24
     d4a:	4d a1       	ldd	r20, Y+37	; 0x25
     d4c:	5e a1       	ldd	r21, Y+38	; 0x26
     d4e:	c7 01       	movw	r24, r14
     d50:	b6 01       	movw	r22, r12
     d52:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <__mulsi3>
     d56:	a5 01       	movw	r20, r10
     d58:	94 01       	movw	r18, r8
     d5a:	26 1b       	sub	r18, r22
     d5c:	37 0b       	sbc	r19, r23
     d5e:	48 0b       	sbc	r20, r24
     d60:	59 0b       	sbc	r21, r25
     d62:	ca 01       	movw	r24, r20
     d64:	b9 01       	movw	r22, r18
     d66:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     d6a:	6d 8b       	std	Y+21, r22	; 0x15
     d6c:	7e 8b       	std	Y+22, r23	; 0x16
     d6e:	8f 8b       	std	Y+23, r24	; 0x17
     d70:	98 8f       	std	Y+24, r25	; 0x18
     d72:	ce 01       	movw	r24, r28
     d74:	0d 96       	adiw	r24, 0x0d	; 13
     d76:	48 de       	rcall	.-880    	; 0xa08 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     d78:	d8 01       	movw	r26, r16
     d7a:	12 96       	adiw	r26, 0x02	; 2
     d7c:	6d 91       	ld	r22, X+
     d7e:	7c 91       	ld	r23, X
     d80:	13 97       	sbiw	r26, 0x03	; 3
     d82:	88 27       	eor	r24, r24
     d84:	77 fd       	sbrc	r23, 7
     d86:	80 95       	com	r24
     d88:	98 2f       	mov	r25, r24
     d8a:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     d8e:	6b 01       	movw	r12, r22
     d90:	7c 01       	movw	r14, r24
     d92:	2d 89       	ldd	r18, Y+21	; 0x15
     d94:	3e 89       	ldd	r19, Y+22	; 0x16
     d96:	4f 89       	ldd	r20, Y+23	; 0x17
     d98:	58 8d       	ldd	r21, Y+24	; 0x18
     d9a:	2f 8f       	std	Y+31, r18	; 0x1f
     d9c:	38 a3       	std	Y+32, r19	; 0x20
     d9e:	49 a3       	std	Y+33, r20	; 0x21
     da0:	5a a3       	std	Y+34, r21	; 0x22
     da2:	d8 01       	movw	r26, r16
     da4:	14 96       	adiw	r26, 0x04	; 4
     da6:	6d 91       	ld	r22, X+
     da8:	7c 91       	ld	r23, X
     daa:	15 97       	sbiw	r26, 0x05	; 5
     dac:	88 27       	eor	r24, r24
     dae:	77 fd       	sbrc	r23, 7
     db0:	80 95       	com	r24
     db2:	98 2f       	mov	r25, r24
     db4:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     db8:	2b 01       	movw	r4, r22
     dba:	3c 01       	movw	r6, r24
     dbc:	29 89       	ldd	r18, Y+17	; 0x11
     dbe:	3a 89       	ldd	r19, Y+18	; 0x12
     dc0:	4b 89       	ldd	r20, Y+19	; 0x13
     dc2:	5c 89       	ldd	r21, Y+20	; 0x14
     dc4:	2b a3       	std	Y+35, r18	; 0x23
     dc6:	3c a3       	std	Y+36, r19	; 0x24
     dc8:	4d a3       	std	Y+37, r20	; 0x25
     dca:	5e a3       	std	Y+38, r21	; 0x26
     dcc:	2f 8d       	ldd	r18, Y+31	; 0x1f
     dce:	38 a1       	ldd	r19, Y+32	; 0x20
     dd0:	49 a1       	ldd	r20, Y+33	; 0x21
     dd2:	5a a1       	ldd	r21, Y+34	; 0x22
     dd4:	c7 01       	movw	r24, r14
     dd6:	b6 01       	movw	r22, r12
     dd8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     ddc:	4b 01       	movw	r8, r22
     dde:	5c 01       	movw	r10, r24
     de0:	2b a1       	ldd	r18, Y+35	; 0x23
     de2:	3c a1       	ldd	r19, Y+36	; 0x24
     de4:	4d a1       	ldd	r20, Y+37	; 0x25
     de6:	5e a1       	ldd	r21, Y+38	; 0x26
     de8:	c3 01       	movw	r24, r6
     dea:	b2 01       	movw	r22, r4
     dec:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     df0:	9b 01       	movw	r18, r22
     df2:	ac 01       	movw	r20, r24
     df4:	c5 01       	movw	r24, r10
     df6:	b4 01       	movw	r22, r8
     df8:	0e 94 38 16 	call	0x2c70	; 0x2c70 <__subsf3>
     dfc:	69 83       	std	Y+1, r22	; 0x01
     dfe:	7a 83       	std	Y+2, r23	; 0x02
     e00:	8b 83       	std	Y+3, r24	; 0x03
     e02:	9c 83       	std	Y+4, r25	; 0x04
     e04:	8d 85       	ldd	r24, Y+13	; 0x0d
     e06:	9e 85       	ldd	r25, Y+14	; 0x0e
     e08:	af 85       	ldd	r26, Y+15	; 0x0f
     e0a:	b8 89       	ldd	r27, Y+16	; 0x10
     e0c:	8f a3       	std	Y+39, r24	; 0x27
     e0e:	98 a7       	std	Y+40, r25	; 0x28
     e10:	a9 a7       	std	Y+41, r26	; 0x29
     e12:	ba a7       	std	Y+42, r27	; 0x2a
     e14:	d8 01       	movw	r26, r16
     e16:	6d 91       	ld	r22, X+
     e18:	7c 91       	ld	r23, X
     e1a:	88 27       	eor	r24, r24
     e1c:	77 fd       	sbrc	r23, 7
     e1e:	80 95       	com	r24
     e20:	98 2f       	mov	r25, r24
     e22:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     e26:	4b 01       	movw	r8, r22
     e28:	5c 01       	movw	r10, r24
     e2a:	2f a1       	ldd	r18, Y+39	; 0x27
     e2c:	38 a5       	ldd	r19, Y+40	; 0x28
     e2e:	49 a5       	ldd	r20, Y+41	; 0x29
     e30:	5a a5       	ldd	r21, Y+42	; 0x2a
     e32:	c3 01       	movw	r24, r6
     e34:	b2 01       	movw	r22, r4
     e36:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     e3a:	2b 01       	movw	r4, r22
     e3c:	3c 01       	movw	r6, r24
     e3e:	a5 01       	movw	r20, r10
     e40:	94 01       	movw	r18, r8
     e42:	6f 8d       	ldd	r22, Y+31	; 0x1f
     e44:	78 a1       	ldd	r23, Y+32	; 0x20
     e46:	89 a1       	ldd	r24, Y+33	; 0x21
     e48:	9a a1       	ldd	r25, Y+34	; 0x22
     e4a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     e4e:	9b 01       	movw	r18, r22
     e50:	ac 01       	movw	r20, r24
     e52:	c3 01       	movw	r24, r6
     e54:	b2 01       	movw	r22, r4
     e56:	0e 94 38 16 	call	0x2c70	; 0x2c70 <__subsf3>
     e5a:	6d 83       	std	Y+5, r22	; 0x05
     e5c:	7e 83       	std	Y+6, r23	; 0x06
     e5e:	8f 83       	std	Y+7, r24	; 0x07
     e60:	98 87       	std	Y+8, r25	; 0x08
     e62:	a5 01       	movw	r20, r10
     e64:	94 01       	movw	r18, r8
     e66:	6b a1       	ldd	r22, Y+35	; 0x23
     e68:	7c a1       	ldd	r23, Y+36	; 0x24
     e6a:	8d a1       	ldd	r24, Y+37	; 0x25
     e6c:	9e a1       	ldd	r25, Y+38	; 0x26
     e6e:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     e72:	4b 01       	movw	r8, r22
     e74:	5c 01       	movw	r10, r24
     e76:	2f a1       	ldd	r18, Y+39	; 0x27
     e78:	38 a5       	ldd	r19, Y+40	; 0x28
     e7a:	49 a5       	ldd	r20, Y+41	; 0x29
     e7c:	5a a5       	ldd	r21, Y+42	; 0x2a
     e7e:	c7 01       	movw	r24, r14
     e80:	b6 01       	movw	r22, r12
     e82:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     e86:	9b 01       	movw	r18, r22
     e88:	ac 01       	movw	r20, r24
     e8a:	c5 01       	movw	r24, r10
     e8c:	b4 01       	movw	r22, r8
     e8e:	0e 94 38 16 	call	0x2c70	; 0x2c70 <__subsf3>
     e92:	69 87       	std	Y+9, r22	; 0x09
     e94:	7a 87       	std	Y+10, r23	; 0x0a
     e96:	8b 87       	std	Y+11, r24	; 0x0b
     e98:	9c 87       	std	Y+12, r25	; 0x0c
     e9a:	ce 01       	movw	r24, r28
     e9c:	01 96       	adiw	r24, 0x01	; 1
     e9e:	b4 dd       	rcall	.-1176   	; 0xa08 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
     ea0:	69 8d       	ldd	r22, Y+25	; 0x19
     ea2:	7a 8d       	ldd	r23, Y+26	; 0x1a
     ea4:	88 27       	eor	r24, r24
     ea6:	77 fd       	sbrc	r23, 7
     ea8:	80 95       	com	r24
     eaa:	98 2f       	mov	r25, r24
     eac:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     eb0:	2b 01       	movw	r4, r22
     eb2:	3c 01       	movw	r6, r24
     eb4:	6b 8d       	ldd	r22, Y+27	; 0x1b
     eb6:	7c 8d       	ldd	r23, Y+28	; 0x1c
     eb8:	88 27       	eor	r24, r24
     eba:	77 fd       	sbrc	r23, 7
     ebc:	80 95       	com	r24
     ebe:	98 2f       	mov	r25, r24
     ec0:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     ec4:	4b 01       	movw	r8, r22
     ec6:	5c 01       	movw	r10, r24
     ec8:	6d 8d       	ldd	r22, Y+29	; 0x1d
     eca:	7e 8d       	ldd	r23, Y+30	; 0x1e
     ecc:	88 27       	eor	r24, r24
     ece:	77 fd       	sbrc	r23, 7
     ed0:	80 95       	com	r24
     ed2:	98 2f       	mov	r25, r24
     ed4:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
     ed8:	6b 01       	movw	r12, r22
     eda:	7c 01       	movw	r14, r24
     edc:	29 81       	ldd	r18, Y+1	; 0x01
     ede:	3a 81       	ldd	r19, Y+2	; 0x02
     ee0:	4b 81       	ldd	r20, Y+3	; 0x03
     ee2:	5c 81       	ldd	r21, Y+4	; 0x04
     ee4:	c3 01       	movw	r24, r6
     ee6:	b2 01       	movw	r22, r4
     ee8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     eec:	6f 8f       	std	Y+31, r22	; 0x1f
     eee:	78 a3       	std	Y+32, r23	; 0x20
     ef0:	89 a3       	std	Y+33, r24	; 0x21
     ef2:	9a a3       	std	Y+34, r25	; 0x22
     ef4:	2d 81       	ldd	r18, Y+5	; 0x05
     ef6:	3e 81       	ldd	r19, Y+6	; 0x06
     ef8:	4f 81       	ldd	r20, Y+7	; 0x07
     efa:	58 85       	ldd	r21, Y+8	; 0x08
     efc:	c5 01       	movw	r24, r10
     efe:	b4 01       	movw	r22, r8
     f00:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     f04:	9b 01       	movw	r18, r22
     f06:	ac 01       	movw	r20, r24
     f08:	6f 8d       	ldd	r22, Y+31	; 0x1f
     f0a:	78 a1       	ldd	r23, Y+32	; 0x20
     f0c:	89 a1       	ldd	r24, Y+33	; 0x21
     f0e:	9a a1       	ldd	r25, Y+34	; 0x22
     f10:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     f14:	6f 8f       	std	Y+31, r22	; 0x1f
     f16:	78 a3       	std	Y+32, r23	; 0x20
     f18:	89 a3       	std	Y+33, r24	; 0x21
     f1a:	9a a3       	std	Y+34, r25	; 0x22
     f1c:	29 85       	ldd	r18, Y+9	; 0x09
     f1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     f20:	4b 85       	ldd	r20, Y+11	; 0x0b
     f22:	5c 85       	ldd	r21, Y+12	; 0x0c
     f24:	c7 01       	movw	r24, r14
     f26:	b6 01       	movw	r22, r12
     f28:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     f2c:	9b 01       	movw	r18, r22
     f2e:	ac 01       	movw	r20, r24
     f30:	6f 8d       	ldd	r22, Y+31	; 0x1f
     f32:	78 a1       	ldd	r23, Y+32	; 0x20
     f34:	89 a1       	ldd	r24, Y+33	; 0x21
     f36:	9a a1       	ldd	r25, Y+34	; 0x22
     f38:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     f3c:	6f 8f       	std	Y+31, r22	; 0x1f
     f3e:	78 a3       	std	Y+32, r23	; 0x20
     f40:	89 a3       	std	Y+33, r24	; 0x21
     f42:	9a a3       	std	Y+34, r25	; 0x22
     f44:	2d 85       	ldd	r18, Y+13	; 0x0d
     f46:	3e 85       	ldd	r19, Y+14	; 0x0e
     f48:	4f 85       	ldd	r20, Y+15	; 0x0f
     f4a:	58 89       	ldd	r21, Y+16	; 0x10
     f4c:	c3 01       	movw	r24, r6
     f4e:	b2 01       	movw	r22, r4
     f50:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     f54:	2b 01       	movw	r4, r22
     f56:	3c 01       	movw	r6, r24
     f58:	29 89       	ldd	r18, Y+17	; 0x11
     f5a:	3a 89       	ldd	r19, Y+18	; 0x12
     f5c:	4b 89       	ldd	r20, Y+19	; 0x13
     f5e:	5c 89       	ldd	r21, Y+20	; 0x14
     f60:	c5 01       	movw	r24, r10
     f62:	b4 01       	movw	r22, r8
     f64:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     f68:	9b 01       	movw	r18, r22
     f6a:	ac 01       	movw	r20, r24
     f6c:	c3 01       	movw	r24, r6
     f6e:	b2 01       	movw	r22, r4
     f70:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     f74:	4b 01       	movw	r8, r22
     f76:	5c 01       	movw	r10, r24
     f78:	2d 89       	ldd	r18, Y+21	; 0x15
     f7a:	3e 89       	ldd	r19, Y+22	; 0x16
     f7c:	4f 89       	ldd	r20, Y+23	; 0x17
     f7e:	58 8d       	ldd	r21, Y+24	; 0x18
     f80:	c7 01       	movw	r24, r14
     f82:	b6 01       	movw	r22, r12
     f84:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     f88:	9b 01       	movw	r18, r22
     f8a:	ac 01       	movw	r20, r24
     f8c:	c5 01       	movw	r24, r10
     f8e:	b4 01       	movw	r22, r8
     f90:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     f94:	2f 8d       	ldd	r18, Y+31	; 0x1f
     f96:	38 a1       	ldd	r19, Y+32	; 0x20
     f98:	49 a1       	ldd	r20, Y+33	; 0x21
     f9a:	5a a1       	ldd	r21, Y+34	; 0x22
     f9c:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <atan2>
     fa0:	20 e0       	ldi	r18, 0x00	; 0
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	44 e3       	ldi	r20, 0x34	; 52
     fa6:	53 e4       	ldi	r21, 0x43	; 67
     fa8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
     fac:	2b ed       	ldi	r18, 0xDB	; 219
     fae:	3f e0       	ldi	r19, 0x0F	; 15
     fb0:	49 e4       	ldi	r20, 0x49	; 73
     fb2:	50 e4       	ldi	r21, 0x40	; 64
     fb4:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
     fb8:	6b 01       	movw	r12, r22
     fba:	7c 01       	movw	r14, r24
     fbc:	20 e0       	ldi	r18, 0x00	; 0
     fbe:	30 e0       	ldi	r19, 0x00	; 0
     fc0:	a9 01       	movw	r20, r18
     fc2:	0e 94 ff 16 	call	0x2dfe	; 0x2dfe <__cmpsf2>
     fc6:	88 23       	and	r24, r24
     fc8:	54 f4       	brge	.+20     	; 0xfde <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x4bc>
     fca:	20 e0       	ldi	r18, 0x00	; 0
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	44 eb       	ldi	r20, 0xB4	; 180
     fd0:	53 e4       	ldi	r21, 0x43	; 67
     fd2:	c7 01       	movw	r24, r14
     fd4:	b6 01       	movw	r22, r12
     fd6:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__addsf3>
     fda:	6b 01       	movw	r12, r22
     fdc:	7c 01       	movw	r14, r24
     fde:	c7 01       	movw	r24, r14
     fe0:	b6 01       	movw	r22, r12
     fe2:	aa 96       	adiw	r28, 0x2a	; 42
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	f8 94       	cli
     fe8:	de bf       	out	0x3e, r29	; 62
     fea:	0f be       	out	0x3f, r0	; 63
     fec:	cd bf       	out	0x3d, r28	; 61
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
     ff6:	ff 90       	pop	r15
     ff8:	ef 90       	pop	r14
     ffa:	df 90       	pop	r13
     ffc:	cf 90       	pop	r12
     ffe:	bf 90       	pop	r11
    1000:	af 90       	pop	r10
    1002:	9f 90       	pop	r9
    1004:	8f 90       	pop	r8
    1006:	7f 90       	pop	r7
    1008:	6f 90       	pop	r6
    100a:	5f 90       	pop	r5
    100c:	4f 90       	pop	r4
    100e:	08 95       	ret

00001010 <_ZN6LSM3037headingEv>:
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	cd b7       	in	r28, 0x3d	; 61
    1016:	de b7       	in	r29, 0x3e	; 62
    1018:	2c 97       	sbiw	r28, 0x0c	; 12
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	fc 01       	movw	r30, r24
    1026:	21 8d       	ldd	r18, Z+25	; 0x19
    1028:	23 30       	cpi	r18, 0x03	; 3
    102a:	79 f4       	brne	.+30     	; 0x104a <_ZN6LSM3037headingEv+0x3a>
    102c:	31 e0       	ldi	r19, 0x01	; 1
    102e:	23 2f       	mov	r18, r19
    1030:	3f 83       	std	Y+7, r19	; 0x07
    1032:	18 86       	std	Y+8, r1	; 0x08
    1034:	1a 86       	std	Y+10, r1	; 0x0a
    1036:	19 86       	std	Y+9, r1	; 0x09
    1038:	1c 86       	std	Y+12, r1	; 0x0c
    103a:	1b 86       	std	Y+11, r1	; 0x0b
    103c:	30 e0       	ldi	r19, 0x00	; 0
    103e:	40 e0       	ldi	r20, 0x00	; 0
    1040:	5a 85       	ldd	r21, Y+10	; 0x0a
    1042:	60 e0       	ldi	r22, 0x00	; 0
    1044:	7c 85       	ldd	r23, Y+12	; 0x0c
    1046:	6d dd       	rcall	.-1318   	; 0xb22 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
    1048:	0e c0       	rjmp	.+28     	; 0x1066 <_ZN6LSM3037headingEv+0x56>
    104a:	1a 82       	std	Y+2, r1	; 0x02
    104c:	19 82       	std	Y+1, r1	; 0x01
    104e:	2f ef       	ldi	r18, 0xFF	; 255
    1050:	42 2f       	mov	r20, r18
    1052:	2b 83       	std	Y+3, r18	; 0x03
    1054:	2c 83       	std	Y+4, r18	; 0x04
    1056:	1e 82       	std	Y+6, r1	; 0x06
    1058:	1d 82       	std	Y+5, r1	; 0x05
    105a:	20 e0       	ldi	r18, 0x00	; 0
    105c:	3a 81       	ldd	r19, Y+2	; 0x02
    105e:	5f ef       	ldi	r21, 0xFF	; 255
    1060:	60 e0       	ldi	r22, 0x00	; 0
    1062:	7e 81       	ldd	r23, Y+6	; 0x06
    1064:	5e dd       	rcall	.-1348   	; 0xb22 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
    1066:	2c 96       	adiw	r28, 0x0c	; 12
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_ZN6LSM30311writeAccRegEhh>:
    1078:	0f 93       	push	r16
    107a:	1f 93       	push	r17
    107c:	cf 93       	push	r28
    107e:	df 93       	push	r29
    1080:	ec 01       	movw	r28, r24
    1082:	06 2f       	mov	r16, r22
    1084:	14 2f       	mov	r17, r20
    1086:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1088:	87 ea       	ldi	r24, 0xA7	; 167
    108a:	99 e0       	ldi	r25, 0x09	; 9
    108c:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
    1090:	60 2f       	mov	r22, r16
    1092:	87 ea       	ldi	r24, 0xA7	; 167
    1094:	99 e0       	ldi	r25, 0x09	; 9
    1096:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
    109a:	61 2f       	mov	r22, r17
    109c:	87 ea       	ldi	r24, 0xA7	; 167
    109e:	99 e0       	ldi	r25, 0x09	; 9
    10a0:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
    10a4:	87 ea       	ldi	r24, 0xA7	; 167
    10a6:	99 e0       	ldi	r25, 0x09	; 9
    10a8:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
    10ac:	88 8f       	std	Y+24, r24	; 0x18
    10ae:	df 91       	pop	r29
    10b0:	cf 91       	pop	r28
    10b2:	1f 91       	pop	r17
    10b4:	0f 91       	pop	r16
    10b6:	08 95       	ret

000010b8 <_ZN6LSM30311writeMagRegEhh>:
    10b8:	0f 93       	push	r16
    10ba:	1f 93       	push	r17
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	ec 01       	movw	r28, r24
    10c2:	06 2f       	mov	r16, r22
    10c4:	14 2f       	mov	r17, r20
    10c6:	6b 8d       	ldd	r22, Y+27	; 0x1b
    10c8:	87 ea       	ldi	r24, 0xA7	; 167
    10ca:	99 e0       	ldi	r25, 0x09	; 9
    10cc:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
    10d0:	60 2f       	mov	r22, r16
    10d2:	87 ea       	ldi	r24, 0xA7	; 167
    10d4:	99 e0       	ldi	r25, 0x09	; 9
    10d6:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
    10da:	61 2f       	mov	r22, r17
    10dc:	87 ea       	ldi	r24, 0xA7	; 167
    10de:	99 e0       	ldi	r25, 0x09	; 9
    10e0:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
    10e4:	87 ea       	ldi	r24, 0xA7	; 167
    10e6:	99 e0       	ldi	r25, 0x09	; 9
    10e8:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
    10ec:	88 8f       	std	Y+24, r24	; 0x18
    10ee:	df 91       	pop	r29
    10f0:	cf 91       	pop	r28
    10f2:	1f 91       	pop	r17
    10f4:	0f 91       	pop	r16
    10f6:	08 95       	ret

000010f8 <_ZN6LSM3038writeRegEhh>:
    10f8:	fc 01       	movw	r30, r24
    10fa:	21 8d       	ldd	r18, Z+25	; 0x19
    10fc:	23 30       	cpi	r18, 0x03	; 3
    10fe:	11 f0       	breq	.+4      	; 0x1104 <_ZN6LSM3038writeRegEhh+0xc>
    1100:	60 32       	cpi	r22, 0x20	; 32
    1102:	10 f4       	brcc	.+4      	; 0x1108 <_ZN6LSM3038writeRegEhh+0x10>
    1104:	d9 cf       	rjmp	.-78     	; 0x10b8 <_ZN6LSM30311writeMagRegEhh>
    1106:	08 95       	ret
    1108:	b7 cf       	rjmp	.-146    	; 0x1078 <_ZN6LSM30311writeAccRegEhh>
    110a:	08 95       	ret

0000110c <_ZN6LSM30313enableDefaultEv>:
    110c:	cf 93       	push	r28
    110e:	df 93       	push	r29
    1110:	ec 01       	movw	r28, r24
    1112:	89 8d       	ldd	r24, Y+25	; 0x19
    1114:	83 30       	cpi	r24, 0x03	; 3
    1116:	a9 f4       	brne	.+42     	; 0x1142 <_ZN6LSM30313enableDefaultEv+0x36>
    1118:	40 e0       	ldi	r20, 0x00	; 0
    111a:	61 e2       	ldi	r22, 0x21	; 33
    111c:	ce 01       	movw	r24, r28
    111e:	ec df       	rcall	.-40     	; 0x10f8 <_ZN6LSM3038writeRegEhh>
    1120:	47 e5       	ldi	r20, 0x57	; 87
    1122:	60 e2       	ldi	r22, 0x20	; 32
    1124:	ce 01       	movw	r24, r28
    1126:	e8 df       	rcall	.-48     	; 0x10f8 <_ZN6LSM3038writeRegEhh>
    1128:	44 e6       	ldi	r20, 0x64	; 100
    112a:	64 e2       	ldi	r22, 0x24	; 36
    112c:	ce 01       	movw	r24, r28
    112e:	e4 df       	rcall	.-56     	; 0x10f8 <_ZN6LSM3038writeRegEhh>
    1130:	40 e2       	ldi	r20, 0x20	; 32
    1132:	65 e2       	ldi	r22, 0x25	; 37
    1134:	ce 01       	movw	r24, r28
    1136:	e0 df       	rcall	.-64     	; 0x10f8 <_ZN6LSM3038writeRegEhh>
    1138:	40 e0       	ldi	r20, 0x00	; 0
    113a:	66 e2       	ldi	r22, 0x26	; 38
    113c:	ce 01       	movw	r24, r28
    113e:	dc df       	rcall	.-72     	; 0x10f8 <_ZN6LSM3038writeRegEhh>
    1140:	1f c0       	rjmp	.+62     	; 0x1180 <_ZN6LSM30313enableDefaultEv+0x74>
    1142:	82 30       	cpi	r24, 0x02	; 2
    1144:	49 f4       	brne	.+18     	; 0x1158 <_ZN6LSM30313enableDefaultEv+0x4c>
    1146:	48 e0       	ldi	r20, 0x08	; 8
    1148:	63 e2       	ldi	r22, 0x23	; 35
    114a:	ce 01       	movw	r24, r28
    114c:	95 df       	rcall	.-214    	; 0x1078 <_ZN6LSM30311writeAccRegEhh>
    114e:	47 e4       	ldi	r20, 0x47	; 71
    1150:	60 e2       	ldi	r22, 0x20	; 32
    1152:	ce 01       	movw	r24, r28
    1154:	91 df       	rcall	.-222    	; 0x1078 <_ZN6LSM30311writeAccRegEhh>
    1156:	08 c0       	rjmp	.+16     	; 0x1168 <_ZN6LSM30313enableDefaultEv+0x5c>
    1158:	40 e0       	ldi	r20, 0x00	; 0
    115a:	63 e2       	ldi	r22, 0x23	; 35
    115c:	ce 01       	movw	r24, r28
    115e:	8c df       	rcall	.-232    	; 0x1078 <_ZN6LSM30311writeAccRegEhh>
    1160:	47 e2       	ldi	r20, 0x27	; 39
    1162:	60 e2       	ldi	r22, 0x20	; 32
    1164:	ce 01       	movw	r24, r28
    1166:	88 df       	rcall	.-240    	; 0x1078 <_ZN6LSM30311writeAccRegEhh>
    1168:	4c e0       	ldi	r20, 0x0C	; 12
    116a:	60 e0       	ldi	r22, 0x00	; 0
    116c:	ce 01       	movw	r24, r28
    116e:	a4 df       	rcall	.-184    	; 0x10b8 <_ZN6LSM30311writeMagRegEhh>
    1170:	40 e2       	ldi	r20, 0x20	; 32
    1172:	61 e0       	ldi	r22, 0x01	; 1
    1174:	ce 01       	movw	r24, r28
    1176:	a0 df       	rcall	.-192    	; 0x10b8 <_ZN6LSM30311writeMagRegEhh>
    1178:	40 e0       	ldi	r20, 0x00	; 0
    117a:	62 e0       	ldi	r22, 0x02	; 2
    117c:	ce 01       	movw	r24, r28
    117e:	9c df       	rcall	.-200    	; 0x10b8 <_ZN6LSM30311writeMagRegEhh>
    1180:	df 91       	pop	r29
    1182:	cf 91       	pop	r28
    1184:	08 95       	ret

00001186 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
    1186:	9f 92       	push	r9
    1188:	af 92       	push	r10
    118a:	bf 92       	push	r11
    118c:	cf 92       	push	r12
    118e:	df 92       	push	r13
    1190:	ef 92       	push	r14
    1192:	ff 92       	push	r15
    1194:	0f 93       	push	r16
    1196:	1f 93       	push	r17
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
    119c:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
    119e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    11a0:	87 ea       	ldi	r24, 0xA7	; 167
    11a2:	99 e0       	ldi	r25, 0x09	; 9
    11a4:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
    11a8:	e0 91 a7 09 	lds	r30, 0x09A7
    11ac:	f0 91 a8 09 	lds	r31, 0x09A8
    11b0:	01 90       	ld	r0, Z+
    11b2:	f0 81       	ld	r31, Z
    11b4:	e0 2d       	mov	r30, r0
    11b6:	68 ea       	ldi	r22, 0xA8	; 168
    11b8:	87 ea       	ldi	r24, 0xA7	; 167
    11ba:	99 e0       	ldi	r25, 0x09	; 9
    11bc:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
    11be:	87 ea       	ldi	r24, 0xA7	; 167
    11c0:	99 e0       	ldi	r25, 0x09	; 9
    11c2:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
    11c6:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
    11c8:	46 e0       	ldi	r20, 0x06	; 6
    11ca:	6a 8d       	ldd	r22, Y+26	; 0x1a
    11cc:	87 ea       	ldi	r24, 0xA7	; 167
    11ce:	99 e0       	ldi	r25, 0x09	; 9
    11d0:	0e 94 12 16 	call	0x2c24	; 0x2c24 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    11d4:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <millis>
    11d8:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    11da:	10 c0       	rjmp	.+32     	; 0x11fc <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    11dc:	8b a1       	ldd	r24, Y+35	; 0x23
    11de:	9c a1       	ldd	r25, Y+36	; 0x24
    11e0:	89 2b       	or	r24, r25
    11e2:	61 f0       	breq	.+24     	; 0x11fc <_ZN6LSM3037readAccEv+0x76>
    11e4:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <millis>
    11e8:	60 1b       	sub	r22, r16
    11ea:	71 0b       	sbc	r23, r17
    11ec:	8b a1       	ldd	r24, Y+35	; 0x23
    11ee:	9c a1       	ldd	r25, Y+36	; 0x24
    11f0:	86 17       	cp	r24, r22
    11f2:	97 07       	cpc	r25, r23
    11f4:	18 f4       	brcc	.+6      	; 0x11fc <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	8d a3       	std	Y+37, r24	; 0x25
      return;
    11fa:	32 c0       	rjmp	.+100    	; 0x1260 <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    11fc:	87 ea       	ldi	r24, 0xA7	; 167
    11fe:	99 e0       	ldi	r25, 0x09	; 9
    1200:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN7TwoWire9availableEv>
    1204:	06 97       	sbiw	r24, 0x06	; 6
    1206:	54 f3       	brlt	.-44     	; 0x11dc <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
    1208:	87 ea       	ldi	r24, 0xA7	; 167
    120a:	99 e0       	ldi	r25, 0x09	; 9
    120c:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1210:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
    1212:	87 ea       	ldi	r24, 0xA7	; 167
    1214:	99 e0       	ldi	r25, 0x09	; 9
    1216:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    121a:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
    121c:	87 ea       	ldi	r24, 0xA7	; 167
    121e:	99 e0       	ldi	r25, 0x09	; 9
    1220:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1224:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
    1226:	87 ea       	ldi	r24, 0xA7	; 167
    1228:	99 e0       	ldi	r25, 0x09	; 9
    122a:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    122e:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
    1230:	87 ea       	ldi	r24, 0xA7	; 167
    1232:	99 e0       	ldi	r25, 0x09	; 9
    1234:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1238:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
    123a:	87 ea       	ldi	r24, 0xA7	; 167
    123c:	99 e0       	ldi	r25, 0x09	; 9
    123e:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
    1242:	d9 2c       	mov	r13, r9
    1244:	c1 2c       	mov	r12, r1
    1246:	ca 28       	or	r12, r10
    1248:	d9 82       	std	Y+1, r13	; 0x01
    124a:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
    124c:	fb 2c       	mov	r15, r11
    124e:	e1 2c       	mov	r14, r1
    1250:	e0 2a       	or	r14, r16
    1252:	fb 82       	std	Y+3, r15	; 0x03
    1254:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
    1256:	98 2f       	mov	r25, r24
    1258:	88 27       	eor	r24, r24
    125a:	81 2b       	or	r24, r17
    125c:	9d 83       	std	Y+5, r25	; 0x05
    125e:	8c 83       	std	Y+4, r24	; 0x04
}
    1260:	df 91       	pop	r29
    1262:	cf 91       	pop	r28
    1264:	1f 91       	pop	r17
    1266:	0f 91       	pop	r16
    1268:	ff 90       	pop	r15
    126a:	ef 90       	pop	r14
    126c:	df 90       	pop	r13
    126e:	cf 90       	pop	r12
    1270:	bf 90       	pop	r11
    1272:	af 90       	pop	r10
    1274:	9f 90       	pop	r9
    1276:	08 95       	ret

00001278 <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
    1278:	cf 92       	push	r12
    127a:	df 92       	push	r13
    127c:	ef 92       	push	r14
    127e:	ff 92       	push	r15
    1280:	0f 93       	push	r16
    1282:	1f 93       	push	r17
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
    128a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    128c:	87 ea       	ldi	r24, 0xA7	; 167
    128e:	99 e0       	ldi	r25, 0x09	; 9
    1290:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
    1294:	89 8d       	ldd	r24, Y+25	; 0x19
    1296:	83 30       	cpi	r24, 0x03	; 3
    1298:	31 f4       	brne	.+12     	; 0x12a6 <_ZN6LSM3037readMagEv+0x2e>
    129a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    129c:	77 27       	eor	r23, r23
    129e:	67 fd       	sbrc	r22, 7
    12a0:	70 95       	com	r23
    12a2:	60 68       	ori	r22, 0x80	; 128
    12a4:	04 c0       	rjmp	.+8      	; 0x12ae <_ZN6LSM3037readMagEv+0x36>
    12a6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    12a8:	77 27       	eor	r23, r23
    12aa:	67 fd       	sbrc	r22, 7
    12ac:	70 95       	com	r23
    12ae:	e0 91 a7 09 	lds	r30, 0x09A7
    12b2:	f0 91 a8 09 	lds	r31, 0x09A8
    12b6:	01 90       	ld	r0, Z+
    12b8:	f0 81       	ld	r31, Z
    12ba:	e0 2d       	mov	r30, r0
    12bc:	87 ea       	ldi	r24, 0xA7	; 167
    12be:	99 e0       	ldi	r25, 0x09	; 9
    12c0:	19 95       	eicall
  last_status = Wire.endTransmission();
    12c2:	87 ea       	ldi	r24, 0xA7	; 167
    12c4:	99 e0       	ldi	r25, 0x09	; 9
    12c6:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
    12ca:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
    12cc:	46 e0       	ldi	r20, 0x06	; 6
    12ce:	6b 8d       	ldd	r22, Y+27	; 0x1b
    12d0:	87 ea       	ldi	r24, 0xA7	; 167
    12d2:	99 e0       	ldi	r25, 0x09	; 9
    12d4:	0e 94 12 16 	call	0x2c24	; 0x2c24 <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    12d8:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <millis>
    12dc:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    12de:	10 c0       	rjmp	.+32     	; 0x1300 <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    12e0:	8b a1       	ldd	r24, Y+35	; 0x23
    12e2:	9c a1       	ldd	r25, Y+36	; 0x24
    12e4:	89 2b       	or	r24, r25
    12e6:	61 f0       	breq	.+24     	; 0x1300 <_ZN6LSM3037readMagEv+0x88>
    12e8:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <millis>
    12ec:	60 1b       	sub	r22, r16
    12ee:	71 0b       	sbc	r23, r17
    12f0:	8b a1       	ldd	r24, Y+35	; 0x23
    12f2:	9c a1       	ldd	r25, Y+36	; 0x24
    12f4:	86 17       	cp	r24, r22
    12f6:	97 07       	cpc	r25, r23
    12f8:	18 f4       	brcc	.+6      	; 0x1300 <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	8d a3       	std	Y+37, r24	; 0x25
      return;
    12fe:	6e c0       	rjmp	.+220    	; 0x13dc <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    1300:	87 ea       	ldi	r24, 0xA7	; 167
    1302:	99 e0       	ldi	r25, 0x09	; 9
    1304:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN7TwoWire9availableEv>
    1308:	06 97       	sbiw	r24, 0x06	; 6
    130a:	54 f3       	brlt	.-44     	; 0x12e0 <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
    130c:	89 8d       	ldd	r24, Y+25	; 0x19
    130e:	83 30       	cpi	r24, 0x03	; 3
    1310:	f9 f4       	brne	.+62     	; 0x1350 <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
    1312:	87 ea       	ldi	r24, 0xA7	; 167
    1314:	99 e0       	ldi	r25, 0x09	; 9
    1316:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    131a:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
    131c:	87 ea       	ldi	r24, 0xA7	; 167
    131e:	99 e0       	ldi	r25, 0x09	; 9
    1320:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1324:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
    1326:	87 ea       	ldi	r24, 0xA7	; 167
    1328:	99 e0       	ldi	r25, 0x09	; 9
    132a:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    132e:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
    1330:	87 ea       	ldi	r24, 0xA7	; 167
    1332:	99 e0       	ldi	r25, 0x09	; 9
    1334:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1338:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
    133a:	87 ea       	ldi	r24, 0xA7	; 167
    133c:	99 e0       	ldi	r25, 0x09	; 9
    133e:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1342:	08 2f       	mov	r16, r24
    zhm = Wire.read();
    1344:	87 ea       	ldi	r24, 0xA7	; 167
    1346:	99 e0       	ldi	r25, 0x09	; 9
    1348:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    134c:	18 2f       	mov	r17, r24
    134e:	36 c0       	rjmp	.+108    	; 0x13bc <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
    1350:	87 ea       	ldi	r24, 0xA7	; 167
    1352:	99 e0       	ldi	r25, 0x09	; 9
    1354:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1358:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
    135a:	87 ea       	ldi	r24, 0xA7	; 167
    135c:	99 e0       	ldi	r25, 0x09	; 9
    135e:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1362:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
    1364:	89 8d       	ldd	r24, Y+25	; 0x19
    1366:	81 11       	cpse	r24, r1
    1368:	15 c0       	rjmp	.+42     	; 0x1394 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
    136a:	87 ea       	ldi	r24, 0xA7	; 167
    136c:	99 e0       	ldi	r25, 0x09	; 9
    136e:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1372:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    1374:	87 ea       	ldi	r24, 0xA7	; 167
    1376:	99 e0       	ldi	r25, 0x09	; 9
    1378:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    137c:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
    137e:	87 ea       	ldi	r24, 0xA7	; 167
    1380:	99 e0       	ldi	r25, 0x09	; 9
    1382:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1386:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    1388:	87 ea       	ldi	r24, 0xA7	; 167
    138a:	99 e0       	ldi	r25, 0x09	; 9
    138c:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1390:	08 2f       	mov	r16, r24
    1392:	14 c0       	rjmp	.+40     	; 0x13bc <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
    1394:	87 ea       	ldi	r24, 0xA7	; 167
    1396:	99 e0       	ldi	r25, 0x09	; 9
    1398:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    139c:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    139e:	87 ea       	ldi	r24, 0xA7	; 167
    13a0:	99 e0       	ldi	r25, 0x09	; 9
    13a2:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    13a6:	08 2f       	mov	r16, r24
      yhm = Wire.read();
    13a8:	87 ea       	ldi	r24, 0xA7	; 167
    13aa:	99 e0       	ldi	r25, 0x09	; 9
    13ac:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    13b0:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    13b2:	87 ea       	ldi	r24, 0xA7	; 167
    13b4:	99 e0       	ldi	r25, 0x09	; 9
    13b6:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    13ba:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
    13bc:	6c 2d       	mov	r22, r12
    13be:	70 e0       	ldi	r23, 0x00	; 0
    13c0:	7d 29       	or	r23, r13
    13c2:	7f 83       	std	Y+7, r23	; 0x07
    13c4:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
    13c6:	4e 2d       	mov	r20, r14
    13c8:	50 e0       	ldi	r21, 0x00	; 0
    13ca:	5f 29       	or	r21, r15
    13cc:	59 87       	std	Y+9, r21	; 0x09
    13ce:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
    13d0:	20 2f       	mov	r18, r16
    13d2:	30 e0       	ldi	r19, 0x00	; 0
    13d4:	c9 01       	movw	r24, r18
    13d6:	91 2b       	or	r25, r17
    13d8:	9b 87       	std	Y+11, r25	; 0x0b
    13da:	8a 87       	std	Y+10, r24	; 0x0a
}
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	1f 91       	pop	r17
    13e2:	0f 91       	pop	r16
    13e4:	ff 90       	pop	r15
    13e6:	ef 90       	pop	r14
    13e8:	df 90       	pop	r13
    13ea:	cf 90       	pop	r12
    13ec:	08 95       	ret

000013ee <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
    13ee:	cf 93       	push	r28
    13f0:	df 93       	push	r29
    13f2:	ec 01       	movw	r28, r24
  readAcc();
    13f4:	c8 de       	rcall	.-624    	; 0x1186 <_ZN6LSM3037readAccEv>
  readMag();
    13f6:	ce 01       	movw	r24, r28
    13f8:	3f df       	rcall	.-386    	; 0x1278 <_ZN6LSM3037readMagEv>
}
    13fa:	df 91       	pop	r29
    13fc:	cf 91       	pop	r28
    13fe:	08 95       	ret

00001400 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    1404:	c6 2f       	mov	r28, r22
    1406:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
    1408:	87 ea       	ldi	r24, 0xA7	; 167
    140a:	99 e0       	ldi	r25, 0x09	; 9
    140c:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
    1410:	6d 2f       	mov	r22, r29
    1412:	87 ea       	ldi	r24, 0xA7	; 167
    1414:	99 e0       	ldi	r25, 0x09	; 9
    1416:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
    141a:	87 ea       	ldi	r24, 0xA7	; 167
    141c:	99 e0       	ldi	r25, 0x09	; 9
    141e:	0e 94 31 16 	call	0x2c62	; 0x2c62 <_ZN7TwoWire15endTransmissionEv>
    1422:	81 11       	cpse	r24, r1
    1424:	11 c0       	rjmp	.+34     	; 0x1448 <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
    1426:	41 e0       	ldi	r20, 0x01	; 1
    1428:	6c 2f       	mov	r22, r28
    142a:	87 ea       	ldi	r24, 0xA7	; 167
    142c:	99 e0       	ldi	r25, 0x09	; 9
    142e:	0e 94 12 16 	call	0x2c24	; 0x2c24 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
    1432:	87 ea       	ldi	r24, 0xA7	; 167
    1434:	99 e0       	ldi	r25, 0x09	; 9
    1436:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <_ZN7TwoWire9availableEv>
    143a:	89 2b       	or	r24, r25
    143c:	41 f0       	breq	.+16     	; 0x144e <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
    143e:	87 ea       	ldi	r24, 0xA7	; 167
    1440:	99 e0       	ldi	r25, 0x09	; 9
    1442:	0e 94 6a 15 	call	0x2ad4	; 0x2ad4 <_ZN7TwoWire4readEv>
    1446:	05 c0       	rjmp	.+10     	; 0x1452 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
    1448:	8f ef       	ldi	r24, 0xFF	; 255
    144a:	9f ef       	ldi	r25, 0xFF	; 255
    144c:	02 c0       	rjmp	.+4      	; 0x1452 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
    144e:	8f ef       	ldi	r24, 0xFF	; 255
    1450:	9f ef       	ldi	r25, 0xFF	; 255
  }
    1452:	df 91       	pop	r29
    1454:	cf 91       	pop	r28
    1456:	08 95       	ret

00001458 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
    1460:	ec 01       	movw	r28, r24
    1462:	16 2f       	mov	r17, r22
    1464:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
    1466:	64 30       	cpi	r22, 0x04	; 4
    1468:	09 f4       	brne	.+2      	; 0x146c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
    146a:	ad c0       	rjmp	.+346    	; 0x15c6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
    146c:	42 30       	cpi	r20, 0x02	; 2
    146e:	09 f0       	breq	.+2      	; 0x1472 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
    1470:	47 c0       	rjmp	.+142    	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    1472:	ad c0       	rjmp	.+346    	; 0x15ce <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1474:	4f e0       	ldi	r20, 0x0F	; 15
    1476:	6d e1       	ldi	r22, 0x1D	; 29
    1478:	ce 01       	movw	r24, r28
    147a:	c2 df       	rcall	.-124    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    147c:	89 34       	cpi	r24, 0x49	; 73
    147e:	91 05       	cpc	r25, r1
    1480:	09 f4       	brne	.+2      	; 0x1484 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
    1482:	ab c0       	rjmp	.+342    	; 0x15da <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
    1484:	01 30       	cpi	r16, 0x01	; 1
    1486:	41 f0       	breq	.+16     	; 0x1498 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1488:	4f e0       	ldi	r20, 0x0F	; 15
    148a:	6e e1       	ldi	r22, 0x1E	; 30
    148c:	ce 01       	movw	r24, r28
    148e:	b8 df       	rcall	.-144    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    1490:	89 34       	cpi	r24, 0x49	; 73
    1492:	91 05       	cpc	r25, r1
    1494:	09 f4       	brne	.+2      	; 0x1498 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    1496:	a3 c0       	rjmp	.+326    	; 0x15de <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
    1498:	14 30       	cpi	r17, 0x04	; 4
    149a:	11 f0       	breq	.+4      	; 0x14a0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
    149c:	13 30       	cpi	r17, 0x03	; 3
    149e:	68 f5       	brcc	.+90     	; 0x14fa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    14a0:	00 23       	and	r16, r16
    14a2:	a9 f0       	breq	.+42     	; 0x14ce <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
    14a4:	40 e2       	ldi	r20, 0x20	; 32
    14a6:	69 e1       	ldi	r22, 0x19	; 25
    14a8:	ce 01       	movw	r24, r28
    14aa:	aa df       	rcall	.-172    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    14ac:	01 96       	adiw	r24, 0x01	; 1
    14ae:	69 f0       	breq	.+26     	; 0x14ca <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
    14b0:	14 30       	cpi	r17, 0x04	; 4
    14b2:	09 f0       	breq	.+2      	; 0x14b6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
    14b4:	99 c0       	rjmp	.+306    	; 0x15e8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    14b6:	4f e0       	ldi	r20, 0x0F	; 15
    14b8:	6e e1       	ldi	r22, 0x1E	; 30
    14ba:	ce 01       	movw	r24, r28
    14bc:	a1 df       	rcall	.-190    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    14be:	cc 97       	sbiw	r24, 0x3c	; 60
    14c0:	09 f0       	breq	.+2      	; 0x14c4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
    14c2:	94 c0       	rjmp	.+296    	; 0x15ec <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    14c4:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    14c6:	12 e0       	ldi	r17, 0x02	; 2
    14c8:	1b c0       	rjmp	.+54     	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    14ca:	01 30       	cpi	r16, 0x01	; 1
    14cc:	99 f0       	breq	.+38     	; 0x14f4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
    14ce:	40 e2       	ldi	r20, 0x20	; 32
    14d0:	68 e1       	ldi	r22, 0x18	; 24
    14d2:	ce 01       	movw	r24, r28
    14d4:	95 df       	rcall	.-214    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    14d6:	01 96       	adiw	r24, 0x01	; 1
    14d8:	69 f0       	breq	.+26     	; 0x14f4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
    14da:	14 30       	cpi	r17, 0x04	; 4
    14dc:	09 f0       	breq	.+2      	; 0x14e0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
    14de:	89 c0       	rjmp	.+274    	; 0x15f2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
    14e0:	4f e0       	ldi	r20, 0x0F	; 15
    14e2:	6e e1       	ldi	r22, 0x1E	; 30
    14e4:	ce 01       	movw	r24, r28
    14e6:	8c df       	rcall	.-232    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    14e8:	11 e0       	ldi	r17, 0x01	; 1
    14ea:	cc 97       	sbiw	r24, 0x3c	; 60
    14ec:	09 f0       	breq	.+2      	; 0x14f0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
    14ee:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    14f0:	00 e0       	ldi	r16, 0x00	; 0
    14f2:	06 c0       	rjmp	.+12     	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    14f4:	14 30       	cpi	r17, 0x04	; 4
    14f6:	09 f4       	brne	.+2      	; 0x14fa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    14f8:	60 c0       	rjmp	.+192    	; 0x15ba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
    14fa:	02 30       	cpi	r16, 0x02	; 2
    14fc:	09 f4       	brne	.+2      	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    14fe:	5f c0       	rjmp	.+190    	; 0x15be <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
    1500:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
    1502:	11 30       	cpi	r17, 0x01	; 1
    1504:	71 f1       	breq	.+92     	; 0x1562 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
    1506:	08 f4       	brcc	.+2      	; 0x150a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
    1508:	42 c0       	rjmp	.+132    	; 0x158e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
    150a:	12 30       	cpi	r17, 0x02	; 2
    150c:	c1 f0       	breq	.+48     	; 0x153e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
    150e:	13 30       	cpi	r17, 0x03	; 3
    1510:	09 f0       	breq	.+2      	; 0x1514 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
    1512:	57 c0       	rjmp	.+174    	; 0x15c2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
    1514:	01 30       	cpi	r16, 0x01	; 1
    1516:	11 f4       	brne	.+4      	; 0x151c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
    1518:	8d e1       	ldi	r24, 0x1D	; 29
    151a:	01 c0       	rjmp	.+2      	; 0x151e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
    151c:	8e e1       	ldi	r24, 0x1E	; 30
    151e:	8b 8f       	std	Y+27, r24	; 0x1b
    1520:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
    1522:	88 e0       	ldi	r24, 0x08	; 8
    1524:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
    1526:	89 e0       	ldi	r24, 0x09	; 9
    1528:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
    152a:	8a e0       	ldi	r24, 0x0A	; 10
    152c:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
    152e:	8b e0       	ldi	r24, 0x0B	; 11
    1530:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
    1532:	8c e0       	ldi	r24, 0x0C	; 12
    1534:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
    1536:	8d e0       	ldi	r24, 0x0D	; 13
    1538:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    153a:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
    153c:	64 c0       	rjmp	.+200    	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
    153e:	89 e1       	ldi	r24, 0x19	; 25
    1540:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    1542:	8e e1       	ldi	r24, 0x1E	; 30
    1544:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
    1546:	83 e0       	ldi	r24, 0x03	; 3
    1548:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
    154a:	84 e0       	ldi	r24, 0x04	; 4
    154c:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
    154e:	87 e0       	ldi	r24, 0x07	; 7
    1550:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
    1552:	88 e0       	ldi	r24, 0x08	; 8
    1554:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
    1556:	85 e0       	ldi	r24, 0x05	; 5
    1558:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
    155a:	86 e0       	ldi	r24, 0x06	; 6
    155c:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    155e:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
    1560:	52 c0       	rjmp	.+164    	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    1562:	01 30       	cpi	r16, 0x01	; 1
    1564:	11 f4       	brne	.+4      	; 0x156a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
    1566:	89 e1       	ldi	r24, 0x19	; 25
    1568:	01 c0       	rjmp	.+2      	; 0x156c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
    156a:	88 e1       	ldi	r24, 0x18	; 24
    156c:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    156e:	8e e1       	ldi	r24, 0x1E	; 30
    1570:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
    1572:	83 e0       	ldi	r24, 0x03	; 3
    1574:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
    1576:	84 e0       	ldi	r24, 0x04	; 4
    1578:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
    157a:	87 e0       	ldi	r24, 0x07	; 7
    157c:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
    157e:	88 e0       	ldi	r24, 0x08	; 8
    1580:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
    1582:	85 e0       	ldi	r24, 0x05	; 5
    1584:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
    1586:	86 e0       	ldi	r24, 0x06	; 6
    1588:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    158a:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
    158c:	3c c0       	rjmp	.+120    	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    158e:	01 30       	cpi	r16, 0x01	; 1
    1590:	11 f4       	brne	.+4      	; 0x1596 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
    1592:	89 e1       	ldi	r24, 0x19	; 25
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
    1596:	88 e1       	ldi	r24, 0x18	; 24
    1598:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    159a:	8e e1       	ldi	r24, 0x1E	; 30
    159c:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
    159e:	83 e0       	ldi	r24, 0x03	; 3
    15a0:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
    15a2:	84 e0       	ldi	r24, 0x04	; 4
    15a4:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
    15a6:	85 e0       	ldi	r24, 0x05	; 5
    15a8:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
    15aa:	86 e0       	ldi	r24, 0x06	; 6
    15ac:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
    15ae:	87 e0       	ldi	r24, 0x07	; 7
    15b0:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
    15b2:	88 e0       	ldi	r24, 0x08	; 8
    15b4:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
    15b6:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
    15b8:	26 c0       	rjmp	.+76     	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
    15ba:	80 e0       	ldi	r24, 0x00	; 0
    15bc:	24 c0       	rjmp	.+72     	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    15be:	80 e0       	ldi	r24, 0x00	; 0
    15c0:	22 c0       	rjmp	.+68     	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    15c2:	81 e0       	ldi	r24, 0x01	; 1
    15c4:	20 c0       	rjmp	.+64     	; 0x1606 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    15c6:	44 23       	and	r20, r20
    15c8:	09 f4       	brne	.+2      	; 0x15cc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
    15ca:	5e cf       	rjmp	.-324    	; 0x1488 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
    15cc:	53 cf       	rjmp	.-346    	; 0x1474 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    15ce:	8d ef       	ldi	r24, 0xFD	; 253
    15d0:	86 0f       	add	r24, r22
    15d2:	82 30       	cpi	r24, 0x02	; 2
    15d4:	08 f0       	brcs	.+2      	; 0x15d8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
    15d6:	62 cf       	rjmp	.-316    	; 0x149c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
    15d8:	0e c0       	rjmp	.+28     	; 0x15f6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    15da:	01 e0       	ldi	r16, 0x01	; 1
    15dc:	03 c0       	rjmp	.+6      	; 0x15e4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
    15de:	00 e0       	ldi	r16, 0x00	; 0
    15e0:	01 c0       	rjmp	.+2      	; 0x15e4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    15e2:	01 e0       	ldi	r16, 0x01	; 1
    15e4:	13 e0       	ldi	r17, 0x03	; 3
    15e6:	89 cf       	rjmp	.-238    	; 0x14fa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    15e8:	01 e0       	ldi	r16, 0x01	; 1
    15ea:	8a cf       	rjmp	.-236    	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
    15ec:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    15ee:	10 e0       	ldi	r17, 0x00	; 0
    15f0:	87 cf       	rjmp	.-242    	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    15f2:	00 e0       	ldi	r16, 0x00	; 0
    15f4:	85 cf       	rjmp	.-246    	; 0x1500 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    15f6:	4f e0       	ldi	r20, 0x0F	; 15
    15f8:	6d e1       	ldi	r22, 0x1D	; 29
    15fa:	ce 01       	movw	r24, r28
    15fc:	01 df       	rcall	.-510    	; 0x1400 <_ZN6LSM3037testRegEhNS_7regAddrE>
    15fe:	89 34       	cpi	r24, 0x49	; 73
    1600:	91 05       	cpc	r25, r1
    1602:	79 f3       	breq	.-34     	; 0x15e2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
    1604:	41 cf       	rjmp	.-382    	; 0x1488 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
    1606:	df 91       	pop	r29
    1608:	cf 91       	pop	r28
    160a:	1f 91       	pop	r17
    160c:	0f 91       	pop	r16
    160e:	08 95       	ret

00001610 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1610:	31 e1       	ldi	r19, 0x11	; 17
    1612:	fc 01       	movw	r30, r24
    1614:	30 83       	st	Z, r19
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	22 e2       	ldi	r18, 0x22	; 34
    161a:	20 83       	st	Z, r18
    161c:	31 97       	sbiw	r30, 0x01	; 1
    161e:	a3 e3       	ldi	r26, 0x33	; 51
    1620:	a0 83       	st	Z, r26
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	60 83       	st	Z, r22
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	70 83       	st	Z, r23
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	10 82       	st	Z, r1
    162e:	31 97       	sbiw	r30, 0x01	; 1
    1630:	10 82       	st	Z, r1
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	60 e8       	ldi	r22, 0x80	; 128
    1636:	60 83       	st	Z, r22
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	10 82       	st	Z, r1
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	10 82       	st	Z, r1
    1640:	31 97       	sbiw	r30, 0x01	; 1
    1642:	10 82       	st	Z, r1
    1644:	31 97       	sbiw	r30, 0x01	; 1
    1646:	62 e0       	ldi	r22, 0x02	; 2
    1648:	60 83       	st	Z, r22
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	63 e0       	ldi	r22, 0x03	; 3
    164e:	60 83       	st	Z, r22
    1650:	31 97       	sbiw	r30, 0x01	; 1
    1652:	64 e0       	ldi	r22, 0x04	; 4
    1654:	60 83       	st	Z, r22
    1656:	31 97       	sbiw	r30, 0x01	; 1
    1658:	65 e0       	ldi	r22, 0x05	; 5
    165a:	60 83       	st	Z, r22
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	66 e0       	ldi	r22, 0x06	; 6
    1660:	60 83       	st	Z, r22
    1662:	31 97       	sbiw	r30, 0x01	; 1
    1664:	67 e0       	ldi	r22, 0x07	; 7
    1666:	60 83       	st	Z, r22
    1668:	31 97       	sbiw	r30, 0x01	; 1
    166a:	68 e0       	ldi	r22, 0x08	; 8
    166c:	60 83       	st	Z, r22
    166e:	31 97       	sbiw	r30, 0x01	; 1
    1670:	69 e0       	ldi	r22, 0x09	; 9
    1672:	60 83       	st	Z, r22
    1674:	31 97       	sbiw	r30, 0x01	; 1
    1676:	60 e1       	ldi	r22, 0x10	; 16
    1678:	60 83       	st	Z, r22
    167a:	31 97       	sbiw	r30, 0x01	; 1
    167c:	30 83       	st	Z, r19
    167e:	31 97       	sbiw	r30, 0x01	; 1
    1680:	32 e1       	ldi	r19, 0x12	; 18
    1682:	30 83       	st	Z, r19
    1684:	31 97       	sbiw	r30, 0x01	; 1
    1686:	33 e1       	ldi	r19, 0x13	; 19
    1688:	30 83       	st	Z, r19
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	34 e1       	ldi	r19, 0x14	; 20
    168e:	30 83       	st	Z, r19
    1690:	31 97       	sbiw	r30, 0x01	; 1
    1692:	35 e1       	ldi	r19, 0x15	; 21
    1694:	30 83       	st	Z, r19
    1696:	31 97       	sbiw	r30, 0x01	; 1
    1698:	36 e1       	ldi	r19, 0x16	; 22
    169a:	30 83       	st	Z, r19
    169c:	31 97       	sbiw	r30, 0x01	; 1
    169e:	37 e1       	ldi	r19, 0x17	; 23
    16a0:	30 83       	st	Z, r19
    16a2:	31 97       	sbiw	r30, 0x01	; 1
    16a4:	38 e1       	ldi	r19, 0x18	; 24
    16a6:	30 83       	st	Z, r19
    16a8:	31 97       	sbiw	r30, 0x01	; 1
    16aa:	39 e1       	ldi	r19, 0x19	; 25
    16ac:	30 83       	st	Z, r19
    16ae:	31 97       	sbiw	r30, 0x01	; 1
    16b0:	30 e2       	ldi	r19, 0x20	; 32
    16b2:	30 83       	st	Z, r19
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	31 e2       	ldi	r19, 0x21	; 33
    16b8:	30 83       	st	Z, r19
    16ba:	31 97       	sbiw	r30, 0x01	; 1
    16bc:	20 83       	st	Z, r18
    16be:	31 97       	sbiw	r30, 0x01	; 1
    16c0:	23 e2       	ldi	r18, 0x23	; 35
    16c2:	20 83       	st	Z, r18
    16c4:	31 97       	sbiw	r30, 0x01	; 1
    16c6:	40 83       	st	Z, r20
    16c8:	31 97       	sbiw	r30, 0x01	; 1
    16ca:	50 83       	st	Z, r21
    16cc:	31 97       	sbiw	r30, 0x01	; 1
    16ce:	26 e2       	ldi	r18, 0x26	; 38
    16d0:	20 83       	st	Z, r18
    16d2:	31 97       	sbiw	r30, 0x01	; 1
    16d4:	27 e2       	ldi	r18, 0x27	; 39
    16d6:	20 83       	st	Z, r18
    16d8:	31 97       	sbiw	r30, 0x01	; 1
    16da:	28 e2       	ldi	r18, 0x28	; 40
    16dc:	20 83       	st	Z, r18
    16de:	31 97       	sbiw	r30, 0x01	; 1
    16e0:	29 e2       	ldi	r18, 0x29	; 41
    16e2:	20 83       	st	Z, r18
    16e4:	31 97       	sbiw	r30, 0x01	; 1
    16e6:	20 e3       	ldi	r18, 0x30	; 48
    16e8:	20 83       	st	Z, r18
    16ea:	31 97       	sbiw	r30, 0x01	; 1
    16ec:	21 e3       	ldi	r18, 0x31	; 49
    16ee:	20 83       	st	Z, r18
    16f0:	89 97       	sbiw	r24, 0x29	; 41
    16f2:	08 95       	ret

000016f4 <xPortStartScheduler>:
    16f4:	82 e0       	ldi	r24, 0x02	; 2
    16f6:	80 93 b0 00 	sts	0x00B0, r24
    16fa:	10 92 b2 00 	sts	0x00B2, r1
    16fe:	80 e3       	ldi	r24, 0x30	; 48
    1700:	80 93 b3 00 	sts	0x00B3, r24
    1704:	e0 e7       	ldi	r30, 0x70	; 112
    1706:	f0 e0       	ldi	r31, 0x00	; 0
    1708:	80 81       	ld	r24, Z
    170a:	82 60       	ori	r24, 0x02	; 2
    170c:	80 83       	st	Z, r24
    170e:	84 e0       	ldi	r24, 0x04	; 4
    1710:	80 93 b1 00 	sts	0x00B1, r24
    1714:	a0 91 37 09 	lds	r26, 0x0937
    1718:	b0 91 38 09 	lds	r27, 0x0938
    171c:	cd 91       	ld	r28, X+
    171e:	cd bf       	out	0x3d, r28	; 61
    1720:	dd 91       	ld	r29, X+
    1722:	de bf       	out	0x3e, r29	; 62
    1724:	ff 91       	pop	r31
    1726:	ef 91       	pop	r30
    1728:	df 91       	pop	r29
    172a:	cf 91       	pop	r28
    172c:	bf 91       	pop	r27
    172e:	af 91       	pop	r26
    1730:	9f 91       	pop	r25
    1732:	8f 91       	pop	r24
    1734:	7f 91       	pop	r23
    1736:	6f 91       	pop	r22
    1738:	5f 91       	pop	r21
    173a:	4f 91       	pop	r20
    173c:	3f 91       	pop	r19
    173e:	2f 91       	pop	r18
    1740:	1f 91       	pop	r17
    1742:	0f 91       	pop	r16
    1744:	ff 90       	pop	r15
    1746:	ef 90       	pop	r14
    1748:	df 90       	pop	r13
    174a:	cf 90       	pop	r12
    174c:	bf 90       	pop	r11
    174e:	af 90       	pop	r10
    1750:	9f 90       	pop	r9
    1752:	8f 90       	pop	r8
    1754:	7f 90       	pop	r7
    1756:	6f 90       	pop	r6
    1758:	5f 90       	pop	r5
    175a:	4f 90       	pop	r4
    175c:	3f 90       	pop	r3
    175e:	2f 90       	pop	r2
    1760:	1f 90       	pop	r1
    1762:	0f 90       	pop	r0
    1764:	0c be       	out	0x3c, r0	; 60
    1766:	0f 90       	pop	r0
    1768:	0b be       	out	0x3b, r0	; 59
    176a:	0f 90       	pop	r0
    176c:	0f be       	out	0x3f, r0	; 63
    176e:	0f 90       	pop	r0
    1770:	08 95       	ret
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	08 95       	ret

00001776 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1776:	0f 92       	push	r0
    1778:	0f b6       	in	r0, 0x3f	; 63
    177a:	f8 94       	cli
    177c:	0f 92       	push	r0
    177e:	0c b6       	in	r0, 0x3c	; 60
    1780:	0f 92       	push	r0
    1782:	0b b6       	in	r0, 0x3b	; 59
    1784:	0f 92       	push	r0
    1786:	1f 92       	push	r1
    1788:	11 24       	eor	r1, r1
    178a:	2f 92       	push	r2
    178c:	3f 92       	push	r3
    178e:	4f 92       	push	r4
    1790:	5f 92       	push	r5
    1792:	6f 92       	push	r6
    1794:	7f 92       	push	r7
    1796:	8f 92       	push	r8
    1798:	9f 92       	push	r9
    179a:	af 92       	push	r10
    179c:	bf 92       	push	r11
    179e:	cf 92       	push	r12
    17a0:	df 92       	push	r13
    17a2:	ef 92       	push	r14
    17a4:	ff 92       	push	r15
    17a6:	0f 93       	push	r16
    17a8:	1f 93       	push	r17
    17aa:	2f 93       	push	r18
    17ac:	3f 93       	push	r19
    17ae:	4f 93       	push	r20
    17b0:	5f 93       	push	r21
    17b2:	6f 93       	push	r22
    17b4:	7f 93       	push	r23
    17b6:	8f 93       	push	r24
    17b8:	9f 93       	push	r25
    17ba:	af 93       	push	r26
    17bc:	bf 93       	push	r27
    17be:	cf 93       	push	r28
    17c0:	df 93       	push	r29
    17c2:	ef 93       	push	r30
    17c4:	ff 93       	push	r31
    17c6:	a0 91 37 09 	lds	r26, 0x0937
    17ca:	b0 91 38 09 	lds	r27, 0x0938
    17ce:	0d b6       	in	r0, 0x3d	; 61
    17d0:	0d 92       	st	X+, r0
    17d2:	0e b6       	in	r0, 0x3e	; 62
    17d4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    17d6:	03 d7       	rcall	.+3590   	; 0x25de <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17d8:	a0 91 37 09 	lds	r26, 0x0937
    17dc:	b0 91 38 09 	lds	r27, 0x0938
    17e0:	cd 91       	ld	r28, X+
    17e2:	cd bf       	out	0x3d, r28	; 61
    17e4:	dd 91       	ld	r29, X+
    17e6:	de bf       	out	0x3e, r29	; 62
    17e8:	ff 91       	pop	r31
    17ea:	ef 91       	pop	r30
    17ec:	df 91       	pop	r29
    17ee:	cf 91       	pop	r28
    17f0:	bf 91       	pop	r27
    17f2:	af 91       	pop	r26
    17f4:	9f 91       	pop	r25
    17f6:	8f 91       	pop	r24
    17f8:	7f 91       	pop	r23
    17fa:	6f 91       	pop	r22
    17fc:	5f 91       	pop	r21
    17fe:	4f 91       	pop	r20
    1800:	3f 91       	pop	r19
    1802:	2f 91       	pop	r18
    1804:	1f 91       	pop	r17
    1806:	0f 91       	pop	r16
    1808:	ff 90       	pop	r15
    180a:	ef 90       	pop	r14
    180c:	df 90       	pop	r13
    180e:	cf 90       	pop	r12
    1810:	bf 90       	pop	r11
    1812:	af 90       	pop	r10
    1814:	9f 90       	pop	r9
    1816:	8f 90       	pop	r8
    1818:	7f 90       	pop	r7
    181a:	6f 90       	pop	r6
    181c:	5f 90       	pop	r5
    181e:	4f 90       	pop	r4
    1820:	3f 90       	pop	r3
    1822:	2f 90       	pop	r2
    1824:	1f 90       	pop	r1
    1826:	0f 90       	pop	r0
    1828:	0c be       	out	0x3c, r0	; 60
    182a:	0f 90       	pop	r0
    182c:	0b be       	out	0x3b, r0	; 59
    182e:	0f 90       	pop	r0
    1830:	0f be       	out	0x3f, r0	; 63
    1832:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1834:	08 95       	ret

00001836 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1836:	0f 92       	push	r0
    1838:	0f b6       	in	r0, 0x3f	; 63
    183a:	f8 94       	cli
    183c:	0f 92       	push	r0
    183e:	0c b6       	in	r0, 0x3c	; 60
    1840:	0f 92       	push	r0
    1842:	0b b6       	in	r0, 0x3b	; 59
    1844:	0f 92       	push	r0
    1846:	1f 92       	push	r1
    1848:	11 24       	eor	r1, r1
    184a:	2f 92       	push	r2
    184c:	3f 92       	push	r3
    184e:	4f 92       	push	r4
    1850:	5f 92       	push	r5
    1852:	6f 92       	push	r6
    1854:	7f 92       	push	r7
    1856:	8f 92       	push	r8
    1858:	9f 92       	push	r9
    185a:	af 92       	push	r10
    185c:	bf 92       	push	r11
    185e:	cf 92       	push	r12
    1860:	df 92       	push	r13
    1862:	ef 92       	push	r14
    1864:	ff 92       	push	r15
    1866:	0f 93       	push	r16
    1868:	1f 93       	push	r17
    186a:	2f 93       	push	r18
    186c:	3f 93       	push	r19
    186e:	4f 93       	push	r20
    1870:	5f 93       	push	r21
    1872:	6f 93       	push	r22
    1874:	7f 93       	push	r23
    1876:	8f 93       	push	r24
    1878:	9f 93       	push	r25
    187a:	af 93       	push	r26
    187c:	bf 93       	push	r27
    187e:	cf 93       	push	r28
    1880:	df 93       	push	r29
    1882:	ef 93       	push	r30
    1884:	ff 93       	push	r31
    1886:	a0 91 37 09 	lds	r26, 0x0937
    188a:	b0 91 38 09 	lds	r27, 0x0938
    188e:	0d b6       	in	r0, 0x3d	; 61
    1890:	0d 92       	st	X+, r0
    1892:	0e b6       	in	r0, 0x3e	; 62
    1894:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1896:	0f d5       	rcall	.+2590   	; 0x22b6 <xTaskIncrementTick>
    1898:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    189a:	a1 d6       	rcall	.+3394   	; 0x25de <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    189c:	a0 91 37 09 	lds	r26, 0x0937
    18a0:	b0 91 38 09 	lds	r27, 0x0938
    18a4:	cd 91       	ld	r28, X+
    18a6:	cd bf       	out	0x3d, r28	; 61
    18a8:	dd 91       	ld	r29, X+
    18aa:	de bf       	out	0x3e, r29	; 62
    18ac:	ff 91       	pop	r31
    18ae:	ef 91       	pop	r30
    18b0:	df 91       	pop	r29
    18b2:	cf 91       	pop	r28
    18b4:	bf 91       	pop	r27
    18b6:	af 91       	pop	r26
    18b8:	9f 91       	pop	r25
    18ba:	8f 91       	pop	r24
    18bc:	7f 91       	pop	r23
    18be:	6f 91       	pop	r22
    18c0:	5f 91       	pop	r21
    18c2:	4f 91       	pop	r20
    18c4:	3f 91       	pop	r19
    18c6:	2f 91       	pop	r18
    18c8:	1f 91       	pop	r17
    18ca:	0f 91       	pop	r16
    18cc:	ff 90       	pop	r15
    18ce:	ef 90       	pop	r14
    18d0:	df 90       	pop	r13
    18d2:	cf 90       	pop	r12
    18d4:	bf 90       	pop	r11
    18d6:	af 90       	pop	r10
    18d8:	9f 90       	pop	r9
    18da:	8f 90       	pop	r8
    18dc:	7f 90       	pop	r7
    18de:	6f 90       	pop	r6
    18e0:	5f 90       	pop	r5
    18e2:	4f 90       	pop	r4
    18e4:	3f 90       	pop	r3
    18e6:	2f 90       	pop	r2
    18e8:	1f 90       	pop	r1
    18ea:	0f 90       	pop	r0
    18ec:	0c be       	out	0x3c, r0	; 60
    18ee:	0f 90       	pop	r0
    18f0:	0b be       	out	0x3b, r0	; 59
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63
    18f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18f8:	08 95       	ret

000018fa <__vector_13>:
 * the context is saved at the start of vPortYieldFromTick(). The tick
 * count is incremented after the context is saved.
 */
ISR(TIMER2_COMPA_vect, ISR_NAKED)
{
	vPortYieldFromTick();
    18fa:	9d df       	rcall	.-198    	; 0x1836 <vPortYieldFromTick>
	asm volatile ( "reti" );
    18fc:	18 95       	reti

000018fe <_Z16taskReadInfraredPv>:
		//}
	}
}

void vApplicationIdleHook()
{
    18fe:	cc e9       	ldi	r28, 0x9C	; 156
    1900:	d8 e0       	ldi	r29, 0x08	; 8
    1902:	80 ea       	ldi	r24, 0xA0	; 160
    1904:	98 e0       	ldi	r25, 0x08	; 8
    1906:	0a d3       	rcall	.+1556   	; 0x1f1c <_ZN7SharpIR8distanceEv>
    1908:	99 83       	std	Y+1, r25	; 0x01
    190a:	88 83       	st	Y, r24
    190c:	88 ee       	ldi	r24, 0xE8	; 232
    190e:	93 e0       	ldi	r25, 0x03	; 3
    1910:	11 d6       	rcall	.+3106   	; 0x2534 <vTaskDelay>
    1912:	f7 cf       	rjmp	.-18     	; 0x1902 <_Z16taskReadInfraredPv+0x4>

00001914 <_Z13taskReadSonarPv>:
    1914:	c2 e0       	ldi	r28, 0x02	; 2
    1916:	d2 e0       	ldi	r29, 0x02	; 2
    1918:	04 e0       	ldi	r16, 0x04	; 4
    191a:	12 e0       	ldi	r17, 0x02	; 2
    191c:	0f 2e       	mov	r0, r31
    191e:	fe e8       	ldi	r31, 0x8E	; 142
    1920:	ef 2e       	mov	r14, r31
    1922:	f8 e0       	ldi	r31, 0x08	; 8
    1924:	ff 2e       	mov	r15, r31
    1926:	f0 2d       	mov	r31, r0
    1928:	c0 d4       	rcall	.+2432   	; 0x22aa <vTaskSuspendAll>
    192a:	60 e0       	ldi	r22, 0x00	; 0
    192c:	88 81       	ld	r24, Y
    192e:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <digitalWrite>
    1932:	85 e0       	ldi	r24, 0x05	; 5
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <delayMicroseconds>
    193a:	61 e0       	ldi	r22, 0x01	; 1
    193c:	88 81       	ld	r24, Y
    193e:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <digitalWrite>
    1942:	8a e0       	ldi	r24, 0x0A	; 10
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <delayMicroseconds>
    194a:	60 e0       	ldi	r22, 0x00	; 0
    194c:	88 81       	ld	r24, Y
    194e:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <digitalWrite>
    1952:	60 e0       	ldi	r22, 0x00	; 0
    1954:	f8 01       	movw	r30, r16
    1956:	80 81       	ld	r24, Z
    1958:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <pinMode>
    195c:	20 e4       	ldi	r18, 0x40	; 64
    195e:	32 e4       	ldi	r19, 0x42	; 66
    1960:	4f e0       	ldi	r20, 0x0F	; 15
    1962:	50 e0       	ldi	r21, 0x00	; 0
    1964:	61 e0       	ldi	r22, 0x01	; 1
    1966:	f8 01       	movw	r30, r16
    1968:	80 81       	ld	r24, Z
    196a:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <pulseIn>
    196e:	9b 01       	movw	r18, r22
    1970:	77 23       	and	r23, r23
    1972:	14 f4       	brge	.+4      	; 0x1978 <_Z13taskReadSonarPv+0x64>
    1974:	2f 5f       	subi	r18, 0xFF	; 255
    1976:	3f 4f       	sbci	r19, 0xFF	; 255
    1978:	b9 01       	movw	r22, r18
    197a:	75 95       	asr	r23
    197c:	67 95       	ror	r22
    197e:	88 27       	eor	r24, r24
    1980:	77 fd       	sbrc	r23, 7
    1982:	80 95       	com	r24
    1984:	98 2f       	mov	r25, r24
    1986:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    198a:	2d ec       	ldi	r18, 0xCD	; 205
    198c:	3c ec       	ldi	r19, 0xCC	; 204
    198e:	48 ee       	ldi	r20, 0xE8	; 232
    1990:	51 e4       	ldi	r21, 0x41	; 65
    1992:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    1996:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    199a:	f7 01       	movw	r30, r14
    199c:	71 83       	std	Z+1, r23	; 0x01
    199e:	60 83       	st	Z, r22
    19a0:	48 d5       	rcall	.+2704   	; 0x2432 <xTaskResumeAll>
    19a2:	88 e8       	ldi	r24, 0x88	; 136
    19a4:	93 e1       	ldi	r25, 0x13	; 19
    19a6:	c6 d5       	rcall	.+2956   	; 0x2534 <vTaskDelay>
    19a8:	bf cf       	rjmp	.-130    	; 0x1928 <_Z13taskReadSonarPv+0x14>

000019aa <_Z11taskReadAccPv>:
    19aa:	0f 2e       	mov	r0, r31
    19ac:	fc eb       	ldi	r31, 0xBC	; 188
    19ae:	af 2e       	mov	r10, r31
    19b0:	f8 e0       	ldi	r31, 0x08	; 8
    19b2:	bf 2e       	mov	r11, r31
    19b4:	f0 2d       	mov	r31, r0
    19b6:	0e eb       	ldi	r16, 0xBE	; 190
    19b8:	18 e0       	ldi	r17, 0x08	; 8
    19ba:	c0 e9       	ldi	r28, 0x90	; 144
    19bc:	d8 e0       	ldi	r29, 0x08	; 8
    19be:	0f 2e       	mov	r0, r31
    19c0:	f2 e9       	ldi	r31, 0x92	; 146
    19c2:	8f 2e       	mov	r8, r31
    19c4:	f8 e0       	ldi	r31, 0x08	; 8
    19c6:	9f 2e       	mov	r9, r31
    19c8:	f0 2d       	mov	r31, r0
    19ca:	0f 2e       	mov	r0, r31
    19cc:	f4 e9       	ldi	r31, 0x94	; 148
    19ce:	2f 2e       	mov	r2, r31
    19d0:	f8 e0       	ldi	r31, 0x08	; 8
    19d2:	3f 2e       	mov	r3, r31
    19d4:	f0 2d       	mov	r31, r0
    19d6:	8a eb       	ldi	r24, 0xBA	; 186
    19d8:	98 e0       	ldi	r25, 0x08	; 8
    19da:	09 dd       	rcall	.-1518   	; 0x13ee <_ZN6LSM3034readEv>
    19dc:	f5 01       	movw	r30, r10
    19de:	60 81       	ld	r22, Z
    19e0:	71 81       	ldd	r23, Z+1	; 0x01
    19e2:	88 27       	eor	r24, r24
    19e4:	77 fd       	sbrc	r23, 7
    19e6:	80 95       	com	r24
    19e8:	98 2f       	mov	r25, r24
    19ea:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    19ee:	20 e0       	ldi	r18, 0x00	; 0
    19f0:	30 e0       	ldi	r19, 0x00	; 0
    19f2:	4a e7       	ldi	r20, 0x7A	; 122
    19f4:	54 e4       	ldi	r21, 0x44	; 68
    19f6:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    19fa:	20 e0       	ldi	r18, 0x00	; 0
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	44 e7       	ldi	r20, 0x74	; 116
    1a00:	52 e4       	ldi	r21, 0x42	; 66
    1a02:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a06:	2f e6       	ldi	r18, 0x6F	; 111
    1a08:	32 e1       	ldi	r19, 0x12	; 18
    1a0a:	43 e8       	ldi	r20, 0x83	; 131
    1a0c:	5a e3       	ldi	r21, 0x3A	; 58
    1a0e:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a12:	2d ec       	ldi	r18, 0xCD	; 205
    1a14:	3c ec       	ldi	r19, 0xCC	; 204
    1a16:	4c e1       	ldi	r20, 0x1C	; 28
    1a18:	51 e4       	ldi	r21, 0x41	; 65
    1a1a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a1e:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1a22:	2b 01       	movw	r4, r22
    1a24:	3c 01       	movw	r6, r24
    1a26:	f8 01       	movw	r30, r16
    1a28:	60 81       	ld	r22, Z
    1a2a:	71 81       	ldd	r23, Z+1	; 0x01
    1a2c:	88 27       	eor	r24, r24
    1a2e:	77 fd       	sbrc	r23, 7
    1a30:	80 95       	com	r24
    1a32:	98 2f       	mov	r25, r24
    1a34:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    1a38:	20 e0       	ldi	r18, 0x00	; 0
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	4a e7       	ldi	r20, 0x7A	; 122
    1a3e:	54 e4       	ldi	r21, 0x44	; 68
    1a40:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    1a44:	20 e0       	ldi	r18, 0x00	; 0
    1a46:	30 e0       	ldi	r19, 0x00	; 0
    1a48:	44 e7       	ldi	r20, 0x74	; 116
    1a4a:	52 e4       	ldi	r21, 0x42	; 66
    1a4c:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a50:	2f e6       	ldi	r18, 0x6F	; 111
    1a52:	32 e1       	ldi	r19, 0x12	; 18
    1a54:	43 e8       	ldi	r20, 0x83	; 131
    1a56:	5a e3       	ldi	r21, 0x3A	; 58
    1a58:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a5c:	2d ec       	ldi	r18, 0xCD	; 205
    1a5e:	3c ec       	ldi	r19, 0xCC	; 204
    1a60:	4c e1       	ldi	r20, 0x1C	; 28
    1a62:	51 e4       	ldi	r21, 0x41	; 65
    1a64:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a68:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1a6c:	6b 01       	movw	r12, r22
    1a6e:	7c 01       	movw	r14, r24
    1a70:	80 91 ba 08 	lds	r24, 0x08BA
    1a74:	90 91 bb 08 	lds	r25, 0x08BB
    1a78:	bc 01       	movw	r22, r24
    1a7a:	88 27       	eor	r24, r24
    1a7c:	77 fd       	sbrc	r23, 7
    1a7e:	80 95       	com	r24
    1a80:	98 2f       	mov	r25, r24
    1a82:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    1a86:	20 e0       	ldi	r18, 0x00	; 0
    1a88:	30 e0       	ldi	r19, 0x00	; 0
    1a8a:	4a e7       	ldi	r20, 0x7A	; 122
    1a8c:	54 e4       	ldi	r21, 0x44	; 68
    1a8e:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    1a92:	20 e0       	ldi	r18, 0x00	; 0
    1a94:	30 e0       	ldi	r19, 0x00	; 0
    1a96:	44 e7       	ldi	r20, 0x74	; 116
    1a98:	52 e4       	ldi	r21, 0x42	; 66
    1a9a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1a9e:	2f e6       	ldi	r18, 0x6F	; 111
    1aa0:	32 e1       	ldi	r19, 0x12	; 18
    1aa2:	43 e8       	ldi	r20, 0x83	; 131
    1aa4:	5a e3       	ldi	r21, 0x3A	; 58
    1aa6:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1aaa:	2d ec       	ldi	r18, 0xCD	; 205
    1aac:	3c ec       	ldi	r19, 0xCC	; 204
    1aae:	4c e1       	ldi	r20, 0x1C	; 28
    1ab0:	51 e4       	ldi	r21, 0x41	; 65
    1ab2:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1ab6:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1aba:	79 83       	std	Y+1, r23	; 0x01
    1abc:	68 83       	st	Y, r22
    1abe:	f4 01       	movw	r30, r8
    1ac0:	51 82       	std	Z+1, r5	; 0x01
    1ac2:	40 82       	st	Z, r4
    1ac4:	f1 01       	movw	r30, r2
    1ac6:	d1 82       	std	Z+1, r13	; 0x01
    1ac8:	c0 82       	st	Z, r12
    1aca:	88 ee       	ldi	r24, 0xE8	; 232
    1acc:	93 e0       	ldi	r25, 0x03	; 3
    1ace:	32 d5       	rcall	.+2660   	; 0x2534 <vTaskDelay>
    1ad0:	82 cf       	rjmp	.-252    	; 0x19d6 <_Z11taskReadAccPv+0x2c>

00001ad2 <_Z12taskReadGyroPv>:
    1ad2:	0f 2e       	mov	r0, r31
    1ad4:	f0 eb       	ldi	r31, 0xB0	; 176
    1ad6:	af 2e       	mov	r10, r31
    1ad8:	f8 e0       	ldi	r31, 0x08	; 8
    1ada:	bf 2e       	mov	r11, r31
    1adc:	f0 2d       	mov	r31, r0
    1ade:	02 eb       	ldi	r16, 0xB2	; 178
    1ae0:	18 e0       	ldi	r17, 0x08	; 8
    1ae2:	c6 e9       	ldi	r28, 0x96	; 150
    1ae4:	d8 e0       	ldi	r29, 0x08	; 8
    1ae6:	0f 2e       	mov	r0, r31
    1ae8:	f8 e9       	ldi	r31, 0x98	; 152
    1aea:	8f 2e       	mov	r8, r31
    1aec:	f8 e0       	ldi	r31, 0x08	; 8
    1aee:	9f 2e       	mov	r9, r31
    1af0:	f0 2d       	mov	r31, r0
    1af2:	0f 2e       	mov	r0, r31
    1af4:	fa e9       	ldi	r31, 0x9A	; 154
    1af6:	2f 2e       	mov	r2, r31
    1af8:	f8 e0       	ldi	r31, 0x08	; 8
    1afa:	3f 2e       	mov	r3, r31
    1afc:	f0 2d       	mov	r31, r0
    1afe:	8e ea       	ldi	r24, 0xAE	; 174
    1b00:	98 e0       	ldi	r25, 0x08	; 8
    1b02:	0e 94 21 03 	call	0x642	; 0x642 <_ZN3L3G4readEv>
    1b06:	f5 01       	movw	r30, r10
    1b08:	60 81       	ld	r22, Z
    1b0a:	71 81       	ldd	r23, Z+1	; 0x01
    1b0c:	88 27       	eor	r24, r24
    1b0e:	77 fd       	sbrc	r23, 7
    1b10:	80 95       	com	r24
    1b12:	98 2f       	mov	r25, r24
    1b14:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    1b18:	20 e0       	ldi	r18, 0x00	; 0
    1b1a:	30 e0       	ldi	r19, 0x00	; 0
    1b1c:	4c e0       	ldi	r20, 0x0C	; 12
    1b1e:	51 e4       	ldi	r21, 0x41	; 65
    1b20:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1b24:	20 e0       	ldi	r18, 0x00	; 0
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	4a e7       	ldi	r20, 0x7A	; 122
    1b2a:	54 e4       	ldi	r21, 0x44	; 68
    1b2c:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    1b30:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1b34:	2b 01       	movw	r4, r22
    1b36:	3c 01       	movw	r6, r24
    1b38:	f8 01       	movw	r30, r16
    1b3a:	60 81       	ld	r22, Z
    1b3c:	71 81       	ldd	r23, Z+1	; 0x01
    1b3e:	88 27       	eor	r24, r24
    1b40:	77 fd       	sbrc	r23, 7
    1b42:	80 95       	com	r24
    1b44:	98 2f       	mov	r25, r24
    1b46:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    1b4a:	20 e0       	ldi	r18, 0x00	; 0
    1b4c:	30 e0       	ldi	r19, 0x00	; 0
    1b4e:	4c e0       	ldi	r20, 0x0C	; 12
    1b50:	51 e4       	ldi	r21, 0x41	; 65
    1b52:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	4a e7       	ldi	r20, 0x7A	; 122
    1b5c:	54 e4       	ldi	r21, 0x44	; 68
    1b5e:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    1b62:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1b66:	6b 01       	movw	r12, r22
    1b68:	7c 01       	movw	r14, r24
    1b6a:	80 91 ae 08 	lds	r24, 0x08AE
    1b6e:	90 91 af 08 	lds	r25, 0x08AF
    1b72:	bc 01       	movw	r22, r24
    1b74:	88 27       	eor	r24, r24
    1b76:	77 fd       	sbrc	r23, 7
    1b78:	80 95       	com	r24
    1b7a:	98 2f       	mov	r25, r24
    1b7c:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    1b80:	20 e0       	ldi	r18, 0x00	; 0
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	4c e0       	ldi	r20, 0x0C	; 12
    1b86:	51 e4       	ldi	r21, 0x41	; 65
    1b88:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1b8c:	20 e0       	ldi	r18, 0x00	; 0
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	4a e7       	ldi	r20, 0x7A	; 122
    1b92:	54 e4       	ldi	r21, 0x44	; 68
    1b94:	0e 94 03 17 	call	0x2e06	; 0x2e06 <__divsf3>
    1b98:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1b9c:	79 83       	std	Y+1, r23	; 0x01
    1b9e:	68 83       	st	Y, r22
    1ba0:	f4 01       	movw	r30, r8
    1ba2:	51 82       	std	Z+1, r5	; 0x01
    1ba4:	40 82       	st	Z, r4
    1ba6:	f1 01       	movw	r30, r2
    1ba8:	d1 82       	std	Z+1, r13	; 0x01
    1baa:	c0 82       	st	Z, r12
    1bac:	88 ee       	ldi	r24, 0xE8	; 232
    1bae:	93 e0       	ldi	r25, 0x03	; 3
    1bb0:	c1 d4       	rcall	.+2434   	; 0x2534 <vTaskDelay>
    1bb2:	a5 cf       	rjmp	.-182    	; 0x1afe <_Z12taskReadGyroPv+0x2c>

00001bb4 <_Z15taskReadMagnetoPv>:
    1bb4:	ce e9       	ldi	r28, 0x9E	; 158
    1bb6:	d8 e0       	ldi	r29, 0x08	; 8
    1bb8:	78 d3       	rcall	.+1776   	; 0x22aa <vTaskSuspendAll>
    1bba:	8a eb       	ldi	r24, 0xBA	; 186
    1bbc:	98 e0       	ldi	r25, 0x08	; 8
    1bbe:	17 dc       	rcall	.-2002   	; 0x13ee <_ZN6LSM3034readEv>
    1bc0:	8a eb       	ldi	r24, 0xBA	; 186
    1bc2:	98 e0       	ldi	r25, 0x08	; 8
    1bc4:	25 da       	rcall	.-2998   	; 0x1010 <_ZN6LSM3037headingEv>
    1bc6:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1bca:	79 83       	std	Y+1, r23	; 0x01
    1bcc:	68 83       	st	Y, r22
    1bce:	31 d4       	rcall	.+2146   	; 0x2432 <xTaskResumeAll>
    1bd0:	88 e8       	ldi	r24, 0x88	; 136
    1bd2:	93 e1       	ldi	r25, 0x13	; 19
    1bd4:	af d4       	rcall	.+2398   	; 0x2534 <vTaskDelay>
    1bd6:	f0 cf       	rjmp	.-32     	; 0x1bb8 <_Z15taskReadMagnetoPv+0x4>

00001bd8 <_Z7freeRAMv>:
    1bd8:	cf 93       	push	r28
    1bda:	df 93       	push	r29
    1bdc:	1f 92       	push	r1
    1bde:	1f 92       	push	r1
    1be0:	cd b7       	in	r28, 0x3d	; 61
    1be2:	de b7       	in	r29, 0x3e	; 62
    1be4:	80 91 9f 0a 	lds	r24, 0x0A9F
    1be8:	90 91 a0 0a 	lds	r25, 0x0AA0
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	11 f0       	breq	.+4      	; 0x1bf4 <_Z7freeRAMv+0x1c>
    1bf0:	9c 01       	movw	r18, r24
    1bf2:	02 c0       	rjmp	.+4      	; 0x1bf8 <_Z7freeRAMv+0x20>
    1bf4:	23 ea       	ldi	r18, 0xA3	; 163
    1bf6:	3a e0       	ldi	r19, 0x0A	; 10
    1bf8:	ce 01       	movw	r24, r28
    1bfa:	01 96       	adiw	r24, 0x01	; 1
    1bfc:	82 1b       	sub	r24, r18
    1bfe:	93 0b       	sbc	r25, r19
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	df 91       	pop	r29
    1c06:	cf 91       	pop	r28
    1c08:	08 95       	ret

00001c0a <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1c0a:	26 e0       	ldi	r18, 0x06	; 6
    1c0c:	40 e8       	ldi	r20, 0x80	; 128
    1c0e:	55 e2       	ldi	r21, 0x25	; 37
    1c10:	60 e0       	ldi	r22, 0x00	; 0
    1c12:	70 e0       	ldi	r23, 0x00	; 0
    1c14:	89 ef       	ldi	r24, 0xF9	; 249
    1c16:	99 e0       	ldi	r25, 0x09	; 9
    1c18:	0e 94 17 1b 	call	0x362e	; 0x362e <_ZN14HardwareSerial5beginEmh>
	vSemaphoreCreateBinary(analogSema);
	xSemaphoreGive(gyroSema);*/
	// Starting up serial monitor
	Serial.begin(9600);
	// Setting up compass
	Wire.begin();
    1c1c:	87 ea       	ldi	r24, 0xA7	; 167
    1c1e:	99 e0       	ldi	r25, 0x09	; 9
    1c20:	eb d7       	rcall	.+4054   	; 0x2bf8 <_ZN7TwoWire5beginEv>
	compass.init();
    1c22:	42 e0       	ldi	r20, 0x02	; 2
    1c24:	64 e0       	ldi	r22, 0x04	; 4
    1c26:	8a eb       	ldi	r24, 0xBA	; 186
    1c28:	98 e0       	ldi	r25, 0x08	; 8
    1c2a:	16 dc       	rcall	.-2004   	; 0x1458 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
	compass.enableDefault();
    1c2c:	8a eb       	ldi	r24, 0xBA	; 186
    1c2e:	98 e0       	ldi	r25, 0x08	; 8
    1c30:	6d da       	rcall	.-2854   	; 0x110c <_ZN6LSM30313enableDefaultEv>
	compass.m_min = (LSM303::vector<int16_t>){+1824, +347, +1103};
    1c32:	86 e0       	ldi	r24, 0x06	; 6
    1c34:	e5 e1       	ldi	r30, 0x15	; 21
    1c36:	f2 e0       	ldi	r31, 0x02	; 2
    1c38:	ac ec       	ldi	r26, 0xCC	; 204
    1c3a:	b8 e0       	ldi	r27, 0x08	; 8
    1c3c:	01 90       	ld	r0, Z+
    1c3e:	0d 92       	st	X+, r0
    1c40:	8a 95       	dec	r24
    1c42:	e1 f7       	brne	.-8      	; 0x1c3c <setup+0x32>
	compass.m_max = (LSM303::vector<int16_t>){+1884, +420, +1203};
    1c44:	86 e0       	ldi	r24, 0x06	; 6
    1c46:	eb e1       	ldi	r30, 0x1B	; 27
    1c48:	f2 e0       	ldi	r31, 0x02	; 2
    1c4a:	a6 ec       	ldi	r26, 0xC6	; 198
    1c4c:	b8 e0       	ldi	r27, 0x08	; 8
    1c4e:	01 90       	ld	r0, Z+
    1c50:	0d 92       	st	X+, r0
    1c52:	8a 95       	dec	r24
    1c54:	e1 f7       	brne	.-8      	; 0x1c4e <setup+0x44>
	gyro.init();
    1c56:	42 e0       	ldi	r20, 0x02	; 2
    1c58:	63 e0       	ldi	r22, 0x03	; 3
    1c5a:	8e ea       	ldi	r24, 0xAE	; 174
    1c5c:	98 e0       	ldi	r25, 0x08	; 8
    1c5e:	0e 94 c5 03 	call	0x78a	; 0x78a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
	gyro.enableDefault();
    1c62:	8e ea       	ldi	r24, 0xAE	; 174
    1c64:	98 e0       	ldi	r25, 0x08	; 8
    1c66:	0e 94 0c 03 	call	0x618	; 0x618 <_ZN3L3G13enableDefaultEv>
	// Setting up sonar sensor
	pinMode(trigger_1, OUTPUT);
    1c6a:	61 e0       	ldi	r22, 0x01	; 1
    1c6c:	80 91 02 02 	lds	r24, 0x0202
    1c70:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <pinMode>
	pinMode(echo_1, INPUT);
    1c74:	60 e0       	ldi	r22, 0x00	; 0
    1c76:	80 91 04 02 	lds	r24, 0x0204
    1c7a:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <pinMode>
	pinMode(analog_1, INPUT);
    1c7e:	60 e0       	ldi	r22, 0x00	; 0
    1c80:	80 91 00 02 	lds	r24, 0x0200
    1c84:	0c 94 80 1e 	jmp	0x3d00	; 0x3d00 <pinMode>
    1c88:	08 95       	ret

00001c8a <main>:
}

int main(void)
{
    1c8a:	af 92       	push	r10
    1c8c:	bf 92       	push	r11
    1c8e:	cf 92       	push	r12
    1c90:	df 92       	push	r13
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	cd b7       	in	r28, 0x3d	; 61
    1c9e:	de b7       	in	r29, 0x3e	; 62
    1ca0:	2c 97       	sbiw	r28, 0x0c	; 12
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	de bf       	out	0x3e, r29	; 62
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	cd bf       	out	0x3d, r28	; 61
	init();
    1cac:	0e 94 91 1d 	call	0x3b22	; 0x3b22 <init>
	setup();
    1cb0:	ac df       	rcall	.-168    	; 0x1c0a <setup>
	TaskHandle_t t1, t2, t3, t4, t5, t6;
	// Create tasks
	xTaskCreate(printArray, "printA", STACK_DEPTH, NULL, 10, &t1);
    1cb2:	a1 2c       	mov	r10, r1
    1cb4:	b1 2c       	mov	r11, r1
    1cb6:	c1 2c       	mov	r12, r1
    1cb8:	d1 2c       	mov	r13, r1
    1cba:	ce 01       	movw	r24, r28
    1cbc:	0b 96       	adiw	r24, 0x0b	; 11
    1cbe:	7c 01       	movw	r14, r24
    1cc0:	0a e0       	ldi	r16, 0x0A	; 10
    1cc2:	20 e0       	ldi	r18, 0x00	; 0
    1cc4:	30 e0       	ldi	r19, 0x00	; 0
    1cc6:	40 ea       	ldi	r20, 0xA0	; 160
    1cc8:	50 e0       	ldi	r21, 0x00	; 0
    1cca:	61 e2       	ldi	r22, 0x21	; 33
    1ccc:	72 e0       	ldi	r23, 0x02	; 2
    1cce:	86 ed       	ldi	r24, 0xD6	; 214
    1cd0:	9e e0       	ldi	r25, 0x0E	; 14
    1cd2:	ba d1       	rcall	.+884    	; 0x2048 <xTaskGenericCreate>
	xTaskCreate(taskReadGyro, "Read Gyrometer", STACK_DEPTH, NULL, 4, &t2);
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	09 96       	adiw	r24, 0x09	; 9
    1cd8:	7c 01       	movw	r14, r24
    1cda:	04 e0       	ldi	r16, 0x04	; 4
    1cdc:	20 e0       	ldi	r18, 0x00	; 0
    1cde:	30 e0       	ldi	r19, 0x00	; 0
    1ce0:	40 ea       	ldi	r20, 0xA0	; 160
    1ce2:	50 e0       	ldi	r21, 0x00	; 0
    1ce4:	68 e2       	ldi	r22, 0x28	; 40
    1ce6:	72 e0       	ldi	r23, 0x02	; 2
    1ce8:	89 e6       	ldi	r24, 0x69	; 105
    1cea:	9d e0       	ldi	r25, 0x0D	; 13
    1cec:	ad d1       	rcall	.+858    	; 0x2048 <xTaskGenericCreate>
	xTaskCreate(taskReadAcc, "Read Accelerometer", STACK_DEPTH, NULL, 8, &t3);
    1cee:	ce 01       	movw	r24, r28
    1cf0:	07 96       	adiw	r24, 0x07	; 7
    1cf2:	7c 01       	movw	r14, r24
    1cf4:	08 e0       	ldi	r16, 0x08	; 8
    1cf6:	20 e0       	ldi	r18, 0x00	; 0
    1cf8:	30 e0       	ldi	r19, 0x00	; 0
    1cfa:	40 ea       	ldi	r20, 0xA0	; 160
    1cfc:	50 e0       	ldi	r21, 0x00	; 0
    1cfe:	67 e3       	ldi	r22, 0x37	; 55
    1d00:	72 e0       	ldi	r23, 0x02	; 2
    1d02:	85 ed       	ldi	r24, 0xD5	; 213
    1d04:	9c e0       	ldi	r25, 0x0C	; 12
    1d06:	a0 d1       	rcall	.+832    	; 0x2048 <xTaskGenericCreate>
	xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
    1d08:	ce 01       	movw	r24, r28
    1d0a:	05 96       	adiw	r24, 0x05	; 5
    1d0c:	7c 01       	movw	r14, r24
    1d0e:	07 e0       	ldi	r16, 0x07	; 7
    1d10:	20 e0       	ldi	r18, 0x00	; 0
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	40 ea       	ldi	r20, 0xA0	; 160
    1d16:	50 e0       	ldi	r21, 0x00	; 0
    1d18:	6a e4       	ldi	r22, 0x4A	; 74
    1d1a:	72 e0       	ldi	r23, 0x02	; 2
    1d1c:	8f e7       	ldi	r24, 0x7F	; 127
    1d1e:	9c e0       	ldi	r25, 0x0C	; 12
    1d20:	93 d1       	rcall	.+806    	; 0x2048 <xTaskGenericCreate>
	xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
    1d22:	ce 01       	movw	r24, r28
    1d24:	03 96       	adiw	r24, 0x03	; 3
    1d26:	7c 01       	movw	r14, r24
    1d28:	06 e0       	ldi	r16, 0x06	; 6
    1d2a:	20 e0       	ldi	r18, 0x00	; 0
    1d2c:	30 e0       	ldi	r19, 0x00	; 0
    1d2e:	40 ea       	ldi	r20, 0xA0	; 160
    1d30:	50 e0       	ldi	r21, 0x00	; 0
    1d32:	68 e5       	ldi	r22, 0x58	; 88
    1d34:	72 e0       	ldi	r23, 0x02	; 2
    1d36:	8a ed       	ldi	r24, 0xDA	; 218
    1d38:	9d e0       	ldi	r25, 0x0D	; 13
    1d3a:	86 d1       	rcall	.+780    	; 0x2048 <xTaskGenericCreate>
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
    1d3c:	ce 01       	movw	r24, r28
    1d3e:	01 96       	adiw	r24, 0x01	; 1
    1d40:	7c 01       	movw	r14, r24
    1d42:	05 e0       	ldi	r16, 0x05	; 5
    1d44:	20 e0       	ldi	r18, 0x00	; 0
    1d46:	30 e0       	ldi	r19, 0x00	; 0
    1d48:	40 ea       	ldi	r20, 0xA0	; 160
    1d4a:	50 e0       	ldi	r21, 0x00	; 0
    1d4c:	65 e6       	ldi	r22, 0x65	; 101
    1d4e:	72 e0       	ldi	r23, 0x02	; 2
    1d50:	8a e8       	ldi	r24, 0x8A	; 138
    1d52:	9c e0       	ldi	r25, 0x0C	; 12
    1d54:	79 d1       	rcall	.+754    	; 0x2048 <xTaskGenericCreate>
	//Serial.println(freeRAM());
	vTaskStartScheduler();
    1d56:	80 d2       	rcall	.+1280   	; 0x2258 <vTaskStartScheduler>
}
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	2c 96       	adiw	r28, 0x0c	; 12
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	0f 91       	pop	r16
    1d6e:	ff 90       	pop	r15
    1d70:	ef 90       	pop	r14
    1d72:	df 90       	pop	r13
    1d74:	cf 90       	pop	r12
    1d76:	bf 90       	pop	r11
    1d78:	af 90       	pop	r10
    1d7a:	08 95       	ret

00001d7c <_GLOBAL__sub_I_echo_1>:
    1d7c:	0f 93       	push	r16
    1d7e:	1f 93       	push	r17
// xSemaphoreHandle sonarSema, magnetoSema, gyroSema, acceSema, analogSema = 0;
int echo_1 = 3; //pin 3 for sonar echo
int trigger_1 = 4; //pin 4 for sonar trigger
int analog_1 = A0; 
int numOfData = 9;
LSM303 compass;
    1d80:	8a eb       	ldi	r24, 0xBA	; 186
    1d82:	98 e0       	ldi	r25, 0x08	; 8
    1d84:	0e 94 e7 04 	call	0x9ce	; 0x9ce <_ZN6LSM303C1Ev>
L3G gyro;
    1d88:	8e ea       	ldi	r24, 0xAE	; 174
    1d8a:	98 e0       	ldi	r25, 0x08	; 8
    1d8c:	0e 94 e5 02 	call	0x5ca	; 0x5ca <_ZN3L3GC1Ev>
SharpIR sharp(A0, 25, 93, 20150);
    1d90:	06 eb       	ldi	r16, 0xB6	; 182
    1d92:	1e e4       	ldi	r17, 0x4E	; 78
    1d94:	2d e5       	ldi	r18, 0x5D	; 93
    1d96:	30 e0       	ldi	r19, 0x00	; 0
    1d98:	49 e1       	ldi	r20, 0x19	; 25
    1d9a:	50 e0       	ldi	r21, 0x00	; 0
    1d9c:	66 e3       	ldi	r22, 0x36	; 54
    1d9e:	70 e0       	ldi	r23, 0x00	; 0
    1da0:	80 ea       	ldi	r24, 0xA0	; 160
    1da2:	98 e0       	ldi	r25, 0x08	; 8
    1da4:	37 d0       	rcall	.+110    	; 0x1e14 <_ZN7SharpIRC1Eiiii>
	xTaskCreate(taskReadInfrared, "Read Infrared", STACK_DEPTH, NULL, 7, &t4);
	xTaskCreate(taskReadMagneto, "Read Magneto", STACK_DEPTH, NULL, 6, &t5);
	xTaskCreate(taskReadSonar, "Read Ultrasonic", STACK_DEPTH, NULL, 5, &t6);
	//Serial.println(freeRAM());
	vTaskStartScheduler();
}
    1da6:	1f 91       	pop	r17
    1da8:	0f 91       	pop	r16
    1daa:	08 95       	ret

00001dac <_Z10printArrayPv>:
	return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int)__brkval);
}

void printArray(void *p) {
	int i;
	char canRead = '0';
    1dac:	c0 e3       	ldi	r28, 0x30	; 48
    1dae:	0f 2e       	mov	r0, r31
    1db0:	fe e8       	ldi	r31, 0x8E	; 142
    1db2:	ef 2e       	mov	r14, r31
    1db4:	f8 e0       	ldi	r31, 0x08	; 8
    1db6:	ff 2e       	mov	r15, r31
    1db8:	f0 2d       	mov	r31, r0
    1dba:	00 ea       	ldi	r16, 0xA0	; 160
    1dbc:	18 e0       	ldi	r17, 0x08	; 8
	while(1) {
		if(Serial.available()){
    1dbe:	89 ef       	ldi	r24, 0xF9	; 249
    1dc0:	99 e0       	ldi	r25, 0x09	; 9
    1dc2:	0e 94 62 1a 	call	0x34c4	; 0x34c4 <_ZN14HardwareSerial9availableEv>
    1dc6:	89 2b       	or	r24, r25
    1dc8:	29 f0       	breq	.+10     	; 0x1dd4 <_Z10printArrayPv+0x28>
			canRead = Serial.read();
    1dca:	89 ef       	ldi	r24, 0xF9	; 249
    1dcc:	99 e0       	ldi	r25, 0x09	; 9
    1dce:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <_ZN14HardwareSerial4readEv>
    1dd2:	c8 2f       	mov	r28, r24
		}
		if(canRead - '0'){
    1dd4:	c0 33       	cpi	r28, 0x30	; 48
    1dd6:	d1 f0       	breq	.+52     	; 0x1e0c <_Z10printArrayPv+0x60>
    1dd8:	e7 01       	movw	r28, r14
			//Serial.print(numOfData);
			//Serial.print('\r');
			for(i = 1; i < 10; i++) {
				Serial.println(data[i]);
    1dda:	69 91       	ld	r22, Y+
    1ddc:	79 91       	ld	r23, Y+
    1dde:	4a e0       	ldi	r20, 0x0A	; 10
    1de0:	50 e0       	ldi	r21, 0x00	; 0
    1de2:	89 ef       	ldi	r24, 0xF9	; 249
    1de4:	99 e0       	ldi	r25, 0x09	; 9
    1de6:	0e 94 1a 1d 	call	0x3a34	; 0x3a34 <_ZN5Print7printlnEii>
				Serial.print('\r');
    1dea:	6d e0       	ldi	r22, 0x0D	; 13
    1dec:	89 ef       	ldi	r24, 0xF9	; 249
    1dee:	99 e0       	ldi	r25, 0x09	; 9
    1df0:	0e 94 54 1c 	call	0x38a8	; 0x38a8 <_ZN5Print5printEc>
			canRead = Serial.read();
		}
		if(canRead - '0'){
			//Serial.print(numOfData);
			//Serial.print('\r');
			for(i = 1; i < 10; i++) {
    1df4:	c0 17       	cp	r28, r16
    1df6:	d1 07       	cpc	r29, r17
    1df8:	81 f7       	brne	.-32     	; 0x1dda <_Z10printArrayPv+0x2e>
				Serial.println(data[i]);
				Serial.print('\r');
			}
			Serial.println(freeRAM());
    1dfa:	ee de       	rcall	.-548    	; 0x1bd8 <_Z7freeRAMv>
    1dfc:	4a e0       	ldi	r20, 0x0A	; 10
    1dfe:	50 e0       	ldi	r21, 0x00	; 0
    1e00:	bc 01       	movw	r22, r24
    1e02:	89 ef       	ldi	r24, 0xF9	; 249
    1e04:	99 e0       	ldi	r25, 0x09	; 9
    1e06:	0e 94 1a 1d 	call	0x3a34	; 0x3a34 <_ZN5Print7printlnEii>
			canRead = '0';
    1e0a:	c0 e3       	ldi	r28, 0x30	; 48
		}
		vTaskDelay(1000);
    1e0c:	88 ee       	ldi	r24, 0xE8	; 232
    1e0e:	93 e0       	ldi	r25, 0x03	; 3
    1e10:	91 d3       	rcall	.+1826   	; 0x2534 <vTaskDelay>
	}
    1e12:	d5 cf       	rjmp	.-86     	; 0x1dbe <_Z10printArrayPv+0x12>

00001e14 <_ZN7SharpIRC1Eiiii>:
#include "Arduino.h"
#include "SharpIR.h"



SharpIR::SharpIR(int irPin, int avg, int tolerance, int sensorModel) {
    1e14:	0f 93       	push	r16
    1e16:	1f 93       	push	r17
    1e18:	fc 01       	movw	r30, r24
    1e1a:	c9 01       	movw	r24, r18
  
    _irPin=irPin;
    1e1c:	71 83       	std	Z+1, r23	; 0x01
    1e1e:	60 83       	st	Z, r22
    _avg=avg;
    1e20:	55 83       	std	Z+5, r21	; 0x05
    1e22:	44 83       	std	Z+4, r20	; 0x04
    _tol=tolerance/100;
    1e24:	64 e6       	ldi	r22, 0x64	; 100
    1e26:	70 e0       	ldi	r23, 0x00	; 0
    1e28:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__divmodhi4>
    1e2c:	75 87       	std	Z+13, r23	; 0x0d
    1e2e:	64 87       	std	Z+12, r22	; 0x0c
    _model=sensorModel;
    1e30:	13 83       	std	Z+3, r17	; 0x03
    1e32:	02 83       	std	Z+2, r16	; 0x02
    
    analogReference(DEFAULT);
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <analogReference>
 
}
    1e3a:	1f 91       	pop	r17
    1e3c:	0f 91       	pop	r16
    1e3e:	08 95       	ret

00001e40 <_ZN7SharpIR2cmEv>:
//    distance range they are designed for (in cm)
 



int SharpIR::cm() {
    1e40:	8f 92       	push	r8
    1e42:	9f 92       	push	r9
    1e44:	af 92       	push	r10
    1e46:	bf 92       	push	r11
    1e48:	cf 92       	push	r12
    1e4a:	df 92       	push	r13
    1e4c:	ef 92       	push	r14
    1e4e:	ff 92       	push	r15
    1e50:	0f 93       	push	r16
    1e52:	1f 93       	push	r17
    1e54:	cf 93       	push	r28
    1e56:	df 93       	push	r29
    1e58:	ec 01       	movw	r28, r24
    
    int raw=analogRead(_irPin);
    1e5a:	88 81       	ld	r24, Y
    1e5c:	0e 94 f6 1d 	call	0x3bec	; 0x3bec <analogRead>
    float voltFromRaw=map(raw, 0, 1023, 0, 5000);
    1e60:	bc 01       	movw	r22, r24
    1e62:	88 27       	eor	r24, r24
    1e64:	77 fd       	sbrc	r23, 7
    1e66:	80 95       	com	r24
    1e68:	98 2f       	mov	r25, r24
    1e6a:	1f 92       	push	r1
    1e6c:	1f 92       	push	r1
    1e6e:	23 e1       	ldi	r18, 0x13	; 19
    1e70:	2f 93       	push	r18
    1e72:	28 e8       	ldi	r18, 0x88	; 136
    1e74:	2f 93       	push	r18
    1e76:	a1 2c       	mov	r10, r1
    1e78:	b1 2c       	mov	r11, r1
    1e7a:	65 01       	movw	r12, r10
    1e7c:	ee 24       	eor	r14, r14
    1e7e:	ea 94       	dec	r14
    1e80:	13 e0       	ldi	r17, 0x03	; 3
    1e82:	f1 2e       	mov	r15, r17
    1e84:	00 e0       	ldi	r16, 0x00	; 0
    1e86:	10 e0       	ldi	r17, 0x00	; 0
    1e88:	20 e0       	ldi	r18, 0x00	; 0
    1e8a:	30 e0       	ldi	r19, 0x00	; 0
    1e8c:	a9 01       	movw	r20, r18
    1e8e:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Z3maplllll>
    1e92:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__floatsisf>
    
    int puntualDistance;
    
    if (_model==1080) {
    1e96:	2a 81       	ldd	r18, Y+2	; 0x02
    1e98:	3b 81       	ldd	r19, Y+3	; 0x03
    1e9a:	0f 90       	pop	r0
    1e9c:	0f 90       	pop	r0
    1e9e:	0f 90       	pop	r0
    1ea0:	0f 90       	pop	r0
    1ea2:	28 33       	cpi	r18, 0x38	; 56
    1ea4:	44 e0       	ldi	r20, 0x04	; 4
    1ea6:	34 07       	cpc	r19, r20
    1ea8:	a9 f4       	brne	.+42     	; 0x1ed4 <_ZN7SharpIR2cmEv+0x94>
        
        puntualDistance=27.728*pow(voltFromRaw/1000, -1.2045);
    1eaa:	20 e0       	ldi	r18, 0x00	; 0
    1eac:	30 e0       	ldi	r19, 0x00	; 0
    1eae:	4a e7       	ldi	r20, 0x7A	; 122
    1eb0:	54 e4       	ldi	r21, 0x44	; 68
    1eb2:	a9 d7       	rcall	.+3922   	; 0x2e06 <__divsf3>
    1eb4:	2e e0       	ldi	r18, 0x0E	; 14
    1eb6:	3d e2       	ldi	r19, 0x2D	; 45
    1eb8:	4a e9       	ldi	r20, 0x9A	; 154
    1eba:	5f eb       	ldi	r21, 0xBF	; 191
    1ebc:	0e 94 dd 18 	call	0x31ba	; 0x31ba <pow>
    1ec0:	22 ef       	ldi	r18, 0xF2	; 242
    1ec2:	32 ed       	ldi	r19, 0xD2	; 210
    1ec4:	4d ed       	ldi	r20, 0xDD	; 221
    1ec6:	51 e4       	ldi	r21, 0x41	; 65
    1ec8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1ecc:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <__fixsfsi>
    1ed0:	4b 01       	movw	r8, r22
    1ed2:	16 c0       	rjmp	.+44     	; 0x1f00 <_ZN7SharpIR2cmEv+0xc0>
        
    }else if (_model==20150){
    1ed4:	26 3b       	cpi	r18, 0xB6	; 182
    1ed6:	3e 44       	sbci	r19, 0x4E	; 78
    1ed8:	99 f4       	brne	.+38     	; 0x1f00 <_ZN7SharpIR2cmEv+0xc0>
    
        puntualDistance=61.573*pow(voltFromRaw/1000, -1.1068);
    1eda:	20 e0       	ldi	r18, 0x00	; 0
    1edc:	30 e0       	ldi	r19, 0x00	; 0
    1ede:	4a e7       	ldi	r20, 0x7A	; 122
    1ee0:	54 e4       	ldi	r21, 0x44	; 68
    1ee2:	91 d7       	rcall	.+3874   	; 0x2e06 <__divsf3>
    1ee4:	2f e9       	ldi	r18, 0x9F	; 159
    1ee6:	3b ea       	ldi	r19, 0xAB	; 171
    1ee8:	4d e8       	ldi	r20, 0x8D	; 141
    1eea:	5f eb       	ldi	r21, 0xBF	; 191
    1eec:	0e 94 dd 18 	call	0x31ba	; 0x31ba <pow>
    1ef0:	21 ec       	ldi	r18, 0xC1	; 193
    1ef2:	3a e4       	ldi	r19, 0x4A	; 74
    1ef4:	46 e7       	ldi	r20, 0x76	; 118
    1ef6:	52 e4       	ldi	r21, 0x42	; 66
    1ef8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__mulsf3>
    1efc:	ec d7       	rcall	.+4056   	; 0x2ed6 <__fixsfsi>
    1efe:	4b 01       	movw	r8, r22
    
    
    return puntualDistance;


}
    1f00:	c4 01       	movw	r24, r8
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	ef 90       	pop	r14
    1f0e:	df 90       	pop	r13
    1f10:	cf 90       	pop	r12
    1f12:	bf 90       	pop	r11
    1f14:	af 90       	pop	r10
    1f16:	9f 90       	pop	r9
    1f18:	8f 90       	pop	r8
    1f1a:	08 95       	ret

00001f1c <_ZN7SharpIR8distanceEv>:



int SharpIR::distance() {
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    1f24:	ec 01       	movw	r28, r24

    _p=0;
    1f26:	1f 82       	std	Y+7, r1	; 0x07
    1f28:	1e 82       	std	Y+6, r1	; 0x06
    _sum=0;
    1f2a:	19 86       	std	Y+9, r1	; 0x09
    1f2c:	18 86       	std	Y+8, r1	; 0x08

    
    for (int i=0; i<_avg; i++){
    1f2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f30:	9d 81       	ldd	r25, Y+5	; 0x05
    1f32:	18 16       	cp	r1, r24
    1f34:	19 06       	cpc	r1, r25
    1f36:	34 f5       	brge	.+76     	; 0x1f84 <_ZN7SharpIR8distanceEv+0x68>
    1f38:	00 e0       	ldi	r16, 0x00	; 0
    1f3a:	10 e0       	ldi	r17, 0x00	; 0
        
        int foo=cm();
    1f3c:	ce 01       	movw	r24, r28
    1f3e:	80 df       	rcall	.-256    	; 0x1e40 <_ZN7SharpIR2cmEv>
        
        if (foo>=(_tol*_previousDistance)){
    1f40:	6c 85       	ldd	r22, Y+12	; 0x0c
    1f42:	7d 85       	ldd	r23, Y+13	; 0x0d
    1f44:	4a 85       	ldd	r20, Y+10	; 0x0a
    1f46:	5b 85       	ldd	r21, Y+11	; 0x0b
    1f48:	64 9f       	mul	r22, r20
    1f4a:	90 01       	movw	r18, r0
    1f4c:	65 9f       	mul	r22, r21
    1f4e:	30 0d       	add	r19, r0
    1f50:	74 9f       	mul	r23, r20
    1f52:	30 0d       	add	r19, r0
    1f54:	11 24       	eor	r1, r1
    1f56:	82 17       	cp	r24, r18
    1f58:	93 07       	cpc	r25, r19
    1f5a:	6c f0       	brlt	.+26     	; 0x1f76 <_ZN7SharpIR8distanceEv+0x5a>
        
            _previousDistance=foo;
    1f5c:	9b 87       	std	Y+11, r25	; 0x0b
    1f5e:	8a 87       	std	Y+10, r24	; 0x0a
            _sum=_sum+foo;
    1f60:	28 85       	ldd	r18, Y+8	; 0x08
    1f62:	39 85       	ldd	r19, Y+9	; 0x09
    1f64:	82 0f       	add	r24, r18
    1f66:	93 1f       	adc	r25, r19
    1f68:	99 87       	std	Y+9, r25	; 0x09
    1f6a:	88 87       	std	Y+8, r24	; 0x08
            _p++;
    1f6c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f6e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f70:	01 96       	adiw	r24, 0x01	; 1
    1f72:	9f 83       	std	Y+7, r25	; 0x07
    1f74:	8e 83       	std	Y+6, r24	; 0x06

    _p=0;
    _sum=0;

    
    for (int i=0; i<_avg; i++){
    1f76:	0f 5f       	subi	r16, 0xFF	; 255
    1f78:	1f 4f       	sbci	r17, 0xFF	; 255
    1f7a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f7e:	08 17       	cp	r16, r24
    1f80:	19 07       	cpc	r17, r25
    1f82:	e4 f2       	brlt	.-72     	; 0x1f3c <_ZN7SharpIR8distanceEv+0x20>
        
        
    }

    
    int accurateDistance=_sum/_p;
    1f84:	88 85       	ldd	r24, Y+8	; 0x08
    1f86:	99 85       	ldd	r25, Y+9	; 0x09
    1f88:	6e 81       	ldd	r22, Y+6	; 0x06
    1f8a:	7f 81       	ldd	r23, Y+7	; 0x07
    1f8c:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__divmodhi4>
    1f90:	cb 01       	movw	r24, r22
    
    return accurateDistance;

}
    1f92:	df 91       	pop	r29
    1f94:	cf 91       	pop	r28
    1f96:	1f 91       	pop	r17
    1f98:	0f 91       	pop	r16
    1f9a:	08 95       	ret

00001f9c <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1f9c:	e0 91 ff 08 	lds	r30, 0x08FF
    1fa0:	f0 91 00 09 	lds	r31, 0x0900
    1fa4:	80 81       	ld	r24, Z
    1fa6:	81 11       	cpse	r24, r1
    1fa8:	07 c0       	rjmp	.+14     	; 0x1fb8 <prvResetNextTaskUnblockTime+0x1c>
    1faa:	8f ef       	ldi	r24, 0xFF	; 255
    1fac:	9f ef       	ldi	r25, 0xFF	; 255
    1fae:	90 93 07 02 	sts	0x0207, r25
    1fb2:	80 93 06 02 	sts	0x0206, r24
    1fb6:	08 95       	ret
    1fb8:	e0 91 ff 08 	lds	r30, 0x08FF
    1fbc:	f0 91 00 09 	lds	r31, 0x0900
    1fc0:	05 80       	ldd	r0, Z+5	; 0x05
    1fc2:	f6 81       	ldd	r31, Z+6	; 0x06
    1fc4:	e0 2d       	mov	r30, r0
    1fc6:	06 80       	ldd	r0, Z+6	; 0x06
    1fc8:	f7 81       	ldd	r31, Z+7	; 0x07
    1fca:	e0 2d       	mov	r30, r0
    1fcc:	82 81       	ldd	r24, Z+2	; 0x02
    1fce:	93 81       	ldd	r25, Z+3	; 0x03
    1fd0:	90 93 07 02 	sts	0x0207, r25
    1fd4:	80 93 06 02 	sts	0x0206, r24
    1fd8:	08 95       	ret

00001fda <prvAddCurrentTaskToDelayedList>:
    1fda:	cf 93       	push	r28
    1fdc:	df 93       	push	r29
    1fde:	ec 01       	movw	r28, r24
    1fe0:	e0 91 37 09 	lds	r30, 0x0937
    1fe4:	f0 91 38 09 	lds	r31, 0x0938
    1fe8:	93 83       	std	Z+3, r25	; 0x03
    1fea:	82 83       	std	Z+2, r24	; 0x02
    1fec:	80 91 e7 08 	lds	r24, 0x08E7
    1ff0:	90 91 e8 08 	lds	r25, 0x08E8
    1ff4:	c8 17       	cp	r28, r24
    1ff6:	d9 07       	cpc	r29, r25
    1ff8:	68 f4       	brcc	.+26     	; 0x2014 <prvAddCurrentTaskToDelayedList+0x3a>
    1ffa:	60 91 37 09 	lds	r22, 0x0937
    1ffe:	70 91 38 09 	lds	r23, 0x0938
    2002:	80 91 fd 08 	lds	r24, 0x08FD
    2006:	90 91 fe 08 	lds	r25, 0x08FE
    200a:	6e 5f       	subi	r22, 0xFE	; 254
    200c:	7f 4f       	sbci	r23, 0xFF	; 255
    200e:	0e 94 90 04 	call	0x920	; 0x920 <vListInsert>
    2012:	17 c0       	rjmp	.+46     	; 0x2042 <prvAddCurrentTaskToDelayedList+0x68>
    2014:	60 91 37 09 	lds	r22, 0x0937
    2018:	70 91 38 09 	lds	r23, 0x0938
    201c:	80 91 ff 08 	lds	r24, 0x08FF
    2020:	90 91 00 09 	lds	r25, 0x0900
    2024:	6e 5f       	subi	r22, 0xFE	; 254
    2026:	7f 4f       	sbci	r23, 0xFF	; 255
    2028:	0e 94 90 04 	call	0x920	; 0x920 <vListInsert>
    202c:	80 91 06 02 	lds	r24, 0x0206
    2030:	90 91 07 02 	lds	r25, 0x0207
    2034:	c8 17       	cp	r28, r24
    2036:	d9 07       	cpc	r29, r25
    2038:	20 f4       	brcc	.+8      	; 0x2042 <prvAddCurrentTaskToDelayedList+0x68>
    203a:	d0 93 07 02 	sts	0x0207, r29
    203e:	c0 93 06 02 	sts	0x0206, r28
    2042:	df 91       	pop	r29
    2044:	cf 91       	pop	r28
    2046:	08 95       	ret

00002048 <xTaskGenericCreate>:
    2048:	4f 92       	push	r4
    204a:	5f 92       	push	r5
    204c:	6f 92       	push	r6
    204e:	7f 92       	push	r7
    2050:	8f 92       	push	r8
    2052:	9f 92       	push	r9
    2054:	af 92       	push	r10
    2056:	bf 92       	push	r11
    2058:	cf 92       	push	r12
    205a:	df 92       	push	r13
    205c:	ef 92       	push	r14
    205e:	ff 92       	push	r15
    2060:	0f 93       	push	r16
    2062:	1f 93       	push	r17
    2064:	cf 93       	push	r28
    2066:	df 93       	push	r29
    2068:	4c 01       	movw	r8, r24
    206a:	5b 01       	movw	r10, r22
    206c:	2a 01       	movw	r4, r20
    206e:	39 01       	movw	r6, r18
    2070:	81 e2       	ldi	r24, 0x21	; 33
    2072:	90 e0       	ldi	r25, 0x00	; 0
    2074:	0e 94 af 02 	call	0x55e	; 0x55e <pvPortMalloc>
    2078:	ec 01       	movw	r28, r24
    207a:	00 97       	sbiw	r24, 0x00	; 0
    207c:	09 f4       	brne	.+2      	; 0x2080 <xTaskGenericCreate+0x38>
    207e:	da c0       	rjmp	.+436    	; 0x2234 <__stack+0x35>
    2080:	c1 14       	cp	r12, r1
    2082:	d1 04       	cpc	r13, r1
    2084:	09 f0       	breq	.+2      	; 0x2088 <xTaskGenericCreate+0x40>
    2086:	bf c0       	rjmp	.+382    	; 0x2206 <__stack+0x7>
    2088:	c2 01       	movw	r24, r4
    208a:	0e 94 af 02 	call	0x55e	; 0x55e <pvPortMalloc>
    208e:	98 8f       	std	Y+24, r25	; 0x18
    2090:	8f 8b       	std	Y+23, r24	; 0x17
    2092:	89 2b       	or	r24, r25
    2094:	09 f0       	breq	.+2      	; 0x2098 <xTaskGenericCreate+0x50>
    2096:	b9 c0       	rjmp	.+370    	; 0x220a <__stack+0xb>
    2098:	ce 01       	movw	r24, r28
    209a:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vPortFree>
    209e:	ca c0       	rjmp	.+404    	; 0x2234 <__stack+0x35>
    20a0:	cf 01       	movw	r24, r30
    20a2:	31 91       	ld	r19, Z+
    20a4:	da 01       	movw	r26, r20
    20a6:	3d 93       	st	X+, r19
    20a8:	ad 01       	movw	r20, r26
    20aa:	dc 01       	movw	r26, r24
    20ac:	8c 91       	ld	r24, X
    20ae:	88 23       	and	r24, r24
    20b0:	11 f0       	breq	.+4      	; 0x20b6 <xTaskGenericCreate+0x6e>
    20b2:	21 50       	subi	r18, 0x01	; 1
    20b4:	a9 f7       	brne	.-22     	; 0x20a0 <xTaskGenericCreate+0x58>
    20b6:	18 a2       	std	Y+32, r1	; 0x20
    20b8:	10 2f       	mov	r17, r16
    20ba:	04 30       	cpi	r16, 0x04	; 4
    20bc:	08 f0       	brcs	.+2      	; 0x20c0 <xTaskGenericCreate+0x78>
    20be:	13 e0       	ldi	r17, 0x03	; 3
    20c0:	1e 8b       	std	Y+22, r17	; 0x16
    20c2:	5e 01       	movw	r10, r28
    20c4:	b2 e0       	ldi	r27, 0x02	; 2
    20c6:	ab 0e       	add	r10, r27
    20c8:	b1 1c       	adc	r11, r1
    20ca:	c5 01       	movw	r24, r10
    20cc:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vListInitialiseItem>
    20d0:	ce 01       	movw	r24, r28
    20d2:	0c 96       	adiw	r24, 0x0c	; 12
    20d4:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vListInitialiseItem>
    20d8:	d9 87       	std	Y+9, r29	; 0x09
    20da:	c8 87       	std	Y+8, r28	; 0x08
    20dc:	84 e0       	ldi	r24, 0x04	; 4
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	81 1b       	sub	r24, r17
    20e2:	91 09       	sbc	r25, r1
    20e4:	9d 87       	std	Y+13, r25	; 0x0d
    20e6:	8c 87       	std	Y+12, r24	; 0x0c
    20e8:	db 8b       	std	Y+19, r29	; 0x13
    20ea:	ca 8b       	std	Y+18, r28	; 0x12
    20ec:	a3 01       	movw	r20, r6
    20ee:	b4 01       	movw	r22, r8
    20f0:	c6 01       	movw	r24, r12
    20f2:	8e da       	rcall	.-2788   	; 0x1610 <pxPortInitialiseStack>
    20f4:	99 83       	std	Y+1, r25	; 0x01
    20f6:	88 83       	st	Y, r24
    20f8:	e1 14       	cp	r14, r1
    20fa:	f1 04       	cpc	r15, r1
    20fc:	19 f0       	breq	.+6      	; 0x2104 <xTaskGenericCreate+0xbc>
    20fe:	f7 01       	movw	r30, r14
    2100:	d1 83       	std	Z+1, r29	; 0x01
    2102:	c0 83       	st	Z, r28
    2104:	0f b6       	in	r0, 0x3f	; 63
    2106:	f8 94       	cli
    2108:	0f 92       	push	r0
    210a:	80 91 e9 08 	lds	r24, 0x08E9
    210e:	8f 5f       	subi	r24, 0xFF	; 255
    2110:	80 93 e9 08 	sts	0x08E9, r24
    2114:	80 91 37 09 	lds	r24, 0x0937
    2118:	90 91 38 09 	lds	r25, 0x0938
    211c:	89 2b       	or	r24, r25
    211e:	a9 f5       	brne	.+106    	; 0x218a <xTaskGenericCreate+0x142>
    2120:	d0 93 38 09 	sts	0x0938, r29
    2124:	c0 93 37 09 	sts	0x0937, r28
    2128:	80 91 e9 08 	lds	r24, 0x08E9
    212c:	81 30       	cpi	r24, 0x01	; 1
    212e:	e1 f5       	brne	.+120    	; 0x21a8 <xTaskGenericCreate+0x160>
    2130:	83 e1       	ldi	r24, 0x13	; 19
    2132:	99 e0       	ldi	r25, 0x09	; 9
    2134:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2138:	8c e1       	ldi	r24, 0x1C	; 28
    213a:	99 e0       	ldi	r25, 0x09	; 9
    213c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2140:	85 e2       	ldi	r24, 0x25	; 37
    2142:	99 e0       	ldi	r25, 0x09	; 9
    2144:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2148:	8e e2       	ldi	r24, 0x2E	; 46
    214a:	99 e0       	ldi	r25, 0x09	; 9
    214c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2150:	8a e0       	ldi	r24, 0x0A	; 10
    2152:	99 e0       	ldi	r25, 0x09	; 9
    2154:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2158:	81 e0       	ldi	r24, 0x01	; 1
    215a:	99 e0       	ldi	r25, 0x09	; 9
    215c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2160:	84 ef       	ldi	r24, 0xF4	; 244
    2162:	98 e0       	ldi	r25, 0x08	; 8
    2164:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2168:	8b ee       	ldi	r24, 0xEB	; 235
    216a:	98 e0       	ldi	r25, 0x08	; 8
    216c:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialise>
    2170:	8a e0       	ldi	r24, 0x0A	; 10
    2172:	99 e0       	ldi	r25, 0x09	; 9
    2174:	90 93 00 09 	sts	0x0900, r25
    2178:	80 93 ff 08 	sts	0x08FF, r24
    217c:	81 e0       	ldi	r24, 0x01	; 1
    217e:	99 e0       	ldi	r25, 0x09	; 9
    2180:	90 93 fe 08 	sts	0x08FE, r25
    2184:	80 93 fd 08 	sts	0x08FD, r24
    2188:	0f c0       	rjmp	.+30     	; 0x21a8 <xTaskGenericCreate+0x160>
    218a:	80 91 e5 08 	lds	r24, 0x08E5
    218e:	81 11       	cpse	r24, r1
    2190:	0b c0       	rjmp	.+22     	; 0x21a8 <xTaskGenericCreate+0x160>
    2192:	e0 91 37 09 	lds	r30, 0x0937
    2196:	f0 91 38 09 	lds	r31, 0x0938
    219a:	86 89       	ldd	r24, Z+22	; 0x16
    219c:	08 17       	cp	r16, r24
    219e:	20 f0       	brcs	.+8      	; 0x21a8 <xTaskGenericCreate+0x160>
    21a0:	d0 93 38 09 	sts	0x0938, r29
    21a4:	c0 93 37 09 	sts	0x0937, r28
    21a8:	80 91 e1 08 	lds	r24, 0x08E1
    21ac:	8f 5f       	subi	r24, 0xFF	; 255
    21ae:	80 93 e1 08 	sts	0x08E1, r24
    21b2:	8e 89       	ldd	r24, Y+22	; 0x16
    21b4:	90 91 e6 08 	lds	r25, 0x08E6
    21b8:	98 17       	cp	r25, r24
    21ba:	10 f4       	brcc	.+4      	; 0x21c0 <xTaskGenericCreate+0x178>
    21bc:	80 93 e6 08 	sts	0x08E6, r24
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	9c 01       	movw	r18, r24
    21c4:	22 0f       	add	r18, r18
    21c6:	33 1f       	adc	r19, r19
    21c8:	22 0f       	add	r18, r18
    21ca:	33 1f       	adc	r19, r19
    21cc:	22 0f       	add	r18, r18
    21ce:	33 1f       	adc	r19, r19
    21d0:	82 0f       	add	r24, r18
    21d2:	93 1f       	adc	r25, r19
    21d4:	b5 01       	movw	r22, r10
    21d6:	8d 5e       	subi	r24, 0xED	; 237
    21d8:	96 4f       	sbci	r25, 0xF6	; 246
    21da:	0e 94 6f 04 	call	0x8de	; 0x8de <vListInsertEnd>
    21de:	0f 90       	pop	r0
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	80 91 e5 08 	lds	r24, 0x08E5
    21e6:	88 23       	and	r24, r24
    21e8:	51 f0       	breq	.+20     	; 0x21fe <xTaskGenericCreate+0x1b6>
    21ea:	e0 91 37 09 	lds	r30, 0x0937
    21ee:	f0 91 38 09 	lds	r31, 0x0938
    21f2:	86 89       	ldd	r24, Z+22	; 0x16
    21f4:	80 17       	cp	r24, r16
    21f6:	28 f4       	brcc	.+10     	; 0x2202 <__stack+0x3>
    21f8:	be da       	rcall	.-2692   	; 0x1776 <vPortYield>
    21fa:	81 e0       	ldi	r24, 0x01	; 1
    21fc:	1c c0       	rjmp	.+56     	; 0x2236 <__stack+0x37>
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	1a c0       	rjmp	.+52     	; 0x2236 <__stack+0x37>
    2202:	81 e0       	ldi	r24, 0x01	; 1
    2204:	18 c0       	rjmp	.+48     	; 0x2236 <__stack+0x37>
    2206:	d8 8e       	std	Y+24, r13	; 0x18
    2208:	cf 8a       	std	Y+23, r12	; 0x17
    220a:	f1 e0       	ldi	r31, 0x01	; 1
    220c:	4f 1a       	sub	r4, r31
    220e:	51 08       	sbc	r5, r1
    2210:	cf 88       	ldd	r12, Y+23	; 0x17
    2212:	d8 8c       	ldd	r13, Y+24	; 0x18
    2214:	c4 0c       	add	r12, r4
    2216:	d5 1c       	adc	r13, r5
    2218:	d5 01       	movw	r26, r10
    221a:	8c 91       	ld	r24, X
    221c:	89 8f       	std	Y+25, r24	; 0x19
    221e:	8c 91       	ld	r24, X
    2220:	88 23       	and	r24, r24
    2222:	09 f4       	brne	.+2      	; 0x2226 <__stack+0x27>
    2224:	48 cf       	rjmp	.-368    	; 0x20b6 <xTaskGenericCreate+0x6e>
    2226:	ae 01       	movw	r20, r28
    2228:	46 5e       	subi	r20, 0xE6	; 230
    222a:	5f 4f       	sbci	r21, 0xFF	; 255
    222c:	f5 01       	movw	r30, r10
    222e:	31 96       	adiw	r30, 0x01	; 1
    2230:	27 e0       	ldi	r18, 0x07	; 7
    2232:	36 cf       	rjmp	.-404    	; 0x20a0 <xTaskGenericCreate+0x58>
    2234:	8f ef       	ldi	r24, 0xFF	; 255
    2236:	df 91       	pop	r29
    2238:	cf 91       	pop	r28
    223a:	1f 91       	pop	r17
    223c:	0f 91       	pop	r16
    223e:	ff 90       	pop	r15
    2240:	ef 90       	pop	r14
    2242:	df 90       	pop	r13
    2244:	cf 90       	pop	r12
    2246:	bf 90       	pop	r11
    2248:	af 90       	pop	r10
    224a:	9f 90       	pop	r9
    224c:	8f 90       	pop	r8
    224e:	7f 90       	pop	r7
    2250:	6f 90       	pop	r6
    2252:	5f 90       	pop	r5
    2254:	4f 90       	pop	r4
    2256:	08 95       	ret

00002258 <vTaskStartScheduler>:
    2258:	af 92       	push	r10
    225a:	bf 92       	push	r11
    225c:	cf 92       	push	r12
    225e:	df 92       	push	r13
    2260:	ef 92       	push	r14
    2262:	ff 92       	push	r15
    2264:	0f 93       	push	r16
    2266:	a1 2c       	mov	r10, r1
    2268:	b1 2c       	mov	r11, r1
    226a:	c1 2c       	mov	r12, r1
    226c:	d1 2c       	mov	r13, r1
    226e:	e1 2c       	mov	r14, r1
    2270:	f1 2c       	mov	r15, r1
    2272:	00 e0       	ldi	r16, 0x00	; 0
    2274:	20 e0       	ldi	r18, 0x00	; 0
    2276:	30 e0       	ldi	r19, 0x00	; 0
    2278:	45 e5       	ldi	r20, 0x55	; 85
    227a:	50 e0       	ldi	r21, 0x00	; 0
    227c:	65 e7       	ldi	r22, 0x75	; 117
    227e:	72 e0       	ldi	r23, 0x02	; 2
    2280:	86 eb       	ldi	r24, 0xB6	; 182
    2282:	92 e1       	ldi	r25, 0x12	; 18
    2284:	e1 de       	rcall	.-574    	; 0x2048 <xTaskGenericCreate>
    2286:	81 30       	cpi	r24, 0x01	; 1
    2288:	41 f4       	brne	.+16     	; 0x229a <vTaskStartScheduler+0x42>
    228a:	f8 94       	cli
    228c:	80 93 e5 08 	sts	0x08E5, r24
    2290:	10 92 e8 08 	sts	0x08E8, r1
    2294:	10 92 e7 08 	sts	0x08E7, r1
    2298:	2d da       	rcall	.-2982   	; 0x16f4 <xPortStartScheduler>
    229a:	0f 91       	pop	r16
    229c:	ff 90       	pop	r15
    229e:	ef 90       	pop	r14
    22a0:	df 90       	pop	r13
    22a2:	cf 90       	pop	r12
    22a4:	bf 90       	pop	r11
    22a6:	af 90       	pop	r10
    22a8:	08 95       	ret

000022aa <vTaskSuspendAll>:
    22aa:	80 91 e0 08 	lds	r24, 0x08E0
    22ae:	8f 5f       	subi	r24, 0xFF	; 255
    22b0:	80 93 e0 08 	sts	0x08E0, r24
    22b4:	08 95       	ret

000022b6 <xTaskIncrementTick>:
    22b6:	cf 92       	push	r12
    22b8:	df 92       	push	r13
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	cf 93       	push	r28
    22c4:	df 93       	push	r29
    22c6:	80 91 e0 08 	lds	r24, 0x08E0
    22ca:	81 11       	cpse	r24, r1
    22cc:	99 c0       	rjmp	.+306    	; 0x2400 <xTaskIncrementTick+0x14a>
    22ce:	80 91 e7 08 	lds	r24, 0x08E7
    22d2:	90 91 e8 08 	lds	r25, 0x08E8
    22d6:	01 96       	adiw	r24, 0x01	; 1
    22d8:	90 93 e8 08 	sts	0x08E8, r25
    22dc:	80 93 e7 08 	sts	0x08E7, r24
    22e0:	e0 90 e7 08 	lds	r14, 0x08E7
    22e4:	f0 90 e8 08 	lds	r15, 0x08E8
    22e8:	e1 14       	cp	r14, r1
    22ea:	f1 04       	cpc	r15, r1
    22ec:	b1 f4       	brne	.+44     	; 0x231a <xTaskIncrementTick+0x64>
    22ee:	80 91 ff 08 	lds	r24, 0x08FF
    22f2:	90 91 00 09 	lds	r25, 0x0900
    22f6:	20 91 fd 08 	lds	r18, 0x08FD
    22fa:	30 91 fe 08 	lds	r19, 0x08FE
    22fe:	30 93 00 09 	sts	0x0900, r19
    2302:	20 93 ff 08 	sts	0x08FF, r18
    2306:	90 93 fe 08 	sts	0x08FE, r25
    230a:	80 93 fd 08 	sts	0x08FD, r24
    230e:	80 91 e2 08 	lds	r24, 0x08E2
    2312:	8f 5f       	subi	r24, 0xFF	; 255
    2314:	80 93 e2 08 	sts	0x08E2, r24
    2318:	41 de       	rcall	.-894    	; 0x1f9c <prvResetNextTaskUnblockTime>
    231a:	80 91 06 02 	lds	r24, 0x0206
    231e:	90 91 07 02 	lds	r25, 0x0207
    2322:	e8 16       	cp	r14, r24
    2324:	f9 06       	cpc	r15, r25
    2326:	08 f4       	brcc	.+2      	; 0x232a <xTaskIncrementTick+0x74>
    2328:	54 c0       	rjmp	.+168    	; 0x23d2 <xTaskIncrementTick+0x11c>
    232a:	d1 2c       	mov	r13, r1
    232c:	cc 24       	eor	r12, r12
    232e:	c3 94       	inc	r12
    2330:	01 c0       	rjmp	.+2      	; 0x2334 <xTaskIncrementTick+0x7e>
    2332:	dc 2c       	mov	r13, r12
    2334:	e0 91 ff 08 	lds	r30, 0x08FF
    2338:	f0 91 00 09 	lds	r31, 0x0900
    233c:	80 81       	ld	r24, Z
    233e:	81 11       	cpse	r24, r1
    2340:	07 c0       	rjmp	.+14     	; 0x2350 <xTaskIncrementTick+0x9a>
    2342:	8f ef       	ldi	r24, 0xFF	; 255
    2344:	9f ef       	ldi	r25, 0xFF	; 255
    2346:	90 93 07 02 	sts	0x0207, r25
    234a:	80 93 06 02 	sts	0x0206, r24
    234e:	42 c0       	rjmp	.+132    	; 0x23d4 <xTaskIncrementTick+0x11e>
    2350:	e0 91 ff 08 	lds	r30, 0x08FF
    2354:	f0 91 00 09 	lds	r31, 0x0900
    2358:	05 80       	ldd	r0, Z+5	; 0x05
    235a:	f6 81       	ldd	r31, Z+6	; 0x06
    235c:	e0 2d       	mov	r30, r0
    235e:	c6 81       	ldd	r28, Z+6	; 0x06
    2360:	d7 81       	ldd	r29, Z+7	; 0x07
    2362:	2a 81       	ldd	r18, Y+2	; 0x02
    2364:	3b 81       	ldd	r19, Y+3	; 0x03
    2366:	e2 16       	cp	r14, r18
    2368:	f3 06       	cpc	r15, r19
    236a:	28 f4       	brcc	.+10     	; 0x2376 <xTaskIncrementTick+0xc0>
    236c:	30 93 07 02 	sts	0x0207, r19
    2370:	20 93 06 02 	sts	0x0206, r18
    2374:	2f c0       	rjmp	.+94     	; 0x23d4 <xTaskIncrementTick+0x11e>
    2376:	8e 01       	movw	r16, r28
    2378:	0e 5f       	subi	r16, 0xFE	; 254
    237a:	1f 4f       	sbci	r17, 0xFF	; 255
    237c:	c8 01       	movw	r24, r16
    237e:	0e 94 c1 04 	call	0x982	; 0x982 <uxListRemove>
    2382:	8c 89       	ldd	r24, Y+20	; 0x14
    2384:	9d 89       	ldd	r25, Y+21	; 0x15
    2386:	89 2b       	or	r24, r25
    2388:	21 f0       	breq	.+8      	; 0x2392 <xTaskIncrementTick+0xdc>
    238a:	ce 01       	movw	r24, r28
    238c:	0c 96       	adiw	r24, 0x0c	; 12
    238e:	0e 94 c1 04 	call	0x982	; 0x982 <uxListRemove>
    2392:	2e 89       	ldd	r18, Y+22	; 0x16
    2394:	80 91 e6 08 	lds	r24, 0x08E6
    2398:	82 17       	cp	r24, r18
    239a:	10 f4       	brcc	.+4      	; 0x23a0 <xTaskIncrementTick+0xea>
    239c:	20 93 e6 08 	sts	0x08E6, r18
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	c9 01       	movw	r24, r18
    23a4:	88 0f       	add	r24, r24
    23a6:	99 1f       	adc	r25, r25
    23a8:	88 0f       	add	r24, r24
    23aa:	99 1f       	adc	r25, r25
    23ac:	88 0f       	add	r24, r24
    23ae:	99 1f       	adc	r25, r25
    23b0:	82 0f       	add	r24, r18
    23b2:	93 1f       	adc	r25, r19
    23b4:	b8 01       	movw	r22, r16
    23b6:	8d 5e       	subi	r24, 0xED	; 237
    23b8:	96 4f       	sbci	r25, 0xF6	; 246
    23ba:	0e 94 6f 04 	call	0x8de	; 0x8de <vListInsertEnd>
    23be:	e0 91 37 09 	lds	r30, 0x0937
    23c2:	f0 91 38 09 	lds	r31, 0x0938
    23c6:	9e 89       	ldd	r25, Y+22	; 0x16
    23c8:	86 89       	ldd	r24, Z+22	; 0x16
    23ca:	98 17       	cp	r25, r24
    23cc:	08 f0       	brcs	.+2      	; 0x23d0 <xTaskIncrementTick+0x11a>
    23ce:	b1 cf       	rjmp	.-158    	; 0x2332 <xTaskIncrementTick+0x7c>
    23d0:	b1 cf       	rjmp	.-158    	; 0x2334 <xTaskIncrementTick+0x7e>
    23d2:	d1 2c       	mov	r13, r1
    23d4:	e0 91 37 09 	lds	r30, 0x0937
    23d8:	f0 91 38 09 	lds	r31, 0x0938
    23dc:	86 89       	ldd	r24, Z+22	; 0x16
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	fc 01       	movw	r30, r24
    23e2:	ee 0f       	add	r30, r30
    23e4:	ff 1f       	adc	r31, r31
    23e6:	ee 0f       	add	r30, r30
    23e8:	ff 1f       	adc	r31, r31
    23ea:	ee 0f       	add	r30, r30
    23ec:	ff 1f       	adc	r31, r31
    23ee:	8e 0f       	add	r24, r30
    23f0:	9f 1f       	adc	r25, r31
    23f2:	fc 01       	movw	r30, r24
    23f4:	ed 5e       	subi	r30, 0xED	; 237
    23f6:	f6 4f       	sbci	r31, 0xF6	; 246
    23f8:	80 81       	ld	r24, Z
    23fa:	82 30       	cpi	r24, 0x02	; 2
    23fc:	40 f4       	brcc	.+16     	; 0x240e <xTaskIncrementTick+0x158>
    23fe:	09 c0       	rjmp	.+18     	; 0x2412 <xTaskIncrementTick+0x15c>
    2400:	80 91 e4 08 	lds	r24, 0x08E4
    2404:	8f 5f       	subi	r24, 0xFF	; 255
    2406:	80 93 e4 08 	sts	0x08E4, r24
    240a:	d1 2c       	mov	r13, r1
    240c:	02 c0       	rjmp	.+4      	; 0x2412 <xTaskIncrementTick+0x15c>
    240e:	dd 24       	eor	r13, r13
    2410:	d3 94       	inc	r13
    2412:	80 91 e3 08 	lds	r24, 0x08E3
    2416:	88 23       	and	r24, r24
    2418:	11 f0       	breq	.+4      	; 0x241e <xTaskIncrementTick+0x168>
    241a:	dd 24       	eor	r13, r13
    241c:	d3 94       	inc	r13
    241e:	8d 2d       	mov	r24, r13
    2420:	df 91       	pop	r29
    2422:	cf 91       	pop	r28
    2424:	1f 91       	pop	r17
    2426:	0f 91       	pop	r16
    2428:	ff 90       	pop	r15
    242a:	ef 90       	pop	r14
    242c:	df 90       	pop	r13
    242e:	cf 90       	pop	r12
    2430:	08 95       	ret

00002432 <xTaskResumeAll>:
    2432:	df 92       	push	r13
    2434:	ef 92       	push	r14
    2436:	ff 92       	push	r15
    2438:	0f 93       	push	r16
    243a:	1f 93       	push	r17
    243c:	cf 93       	push	r28
    243e:	df 93       	push	r29
    2440:	0f b6       	in	r0, 0x3f	; 63
    2442:	f8 94       	cli
    2444:	0f 92       	push	r0
    2446:	80 91 e0 08 	lds	r24, 0x08E0
    244a:	81 50       	subi	r24, 0x01	; 1
    244c:	80 93 e0 08 	sts	0x08E0, r24
    2450:	80 91 e0 08 	lds	r24, 0x08E0
    2454:	81 11       	cpse	r24, r1
    2456:	5f c0       	rjmp	.+190    	; 0x2516 <xTaskResumeAll+0xe4>
    2458:	80 91 e9 08 	lds	r24, 0x08E9
    245c:	88 23       	and	r24, r24
    245e:	09 f4       	brne	.+2      	; 0x2462 <xTaskResumeAll+0x30>
    2460:	5c c0       	rjmp	.+184    	; 0x251a <xTaskResumeAll+0xe8>
    2462:	0f 2e       	mov	r0, r31
    2464:	f4 ef       	ldi	r31, 0xF4	; 244
    2466:	ef 2e       	mov	r14, r31
    2468:	f8 e0       	ldi	r31, 0x08	; 8
    246a:	ff 2e       	mov	r15, r31
    246c:	f0 2d       	mov	r31, r0
    246e:	dd 24       	eor	r13, r13
    2470:	d3 94       	inc	r13
    2472:	30 c0       	rjmp	.+96     	; 0x24d4 <xTaskResumeAll+0xa2>
    2474:	e0 91 f9 08 	lds	r30, 0x08F9
    2478:	f0 91 fa 08 	lds	r31, 0x08FA
    247c:	c6 81       	ldd	r28, Z+6	; 0x06
    247e:	d7 81       	ldd	r29, Z+7	; 0x07
    2480:	ce 01       	movw	r24, r28
    2482:	0c 96       	adiw	r24, 0x0c	; 12
    2484:	0e 94 c1 04 	call	0x982	; 0x982 <uxListRemove>
    2488:	8e 01       	movw	r16, r28
    248a:	0e 5f       	subi	r16, 0xFE	; 254
    248c:	1f 4f       	sbci	r17, 0xFF	; 255
    248e:	c8 01       	movw	r24, r16
    2490:	0e 94 c1 04 	call	0x982	; 0x982 <uxListRemove>
    2494:	8e 89       	ldd	r24, Y+22	; 0x16
    2496:	90 91 e6 08 	lds	r25, 0x08E6
    249a:	98 17       	cp	r25, r24
    249c:	10 f4       	brcc	.+4      	; 0x24a2 <xTaskResumeAll+0x70>
    249e:	80 93 e6 08 	sts	0x08E6, r24
    24a2:	90 e0       	ldi	r25, 0x00	; 0
    24a4:	9c 01       	movw	r18, r24
    24a6:	22 0f       	add	r18, r18
    24a8:	33 1f       	adc	r19, r19
    24aa:	22 0f       	add	r18, r18
    24ac:	33 1f       	adc	r19, r19
    24ae:	22 0f       	add	r18, r18
    24b0:	33 1f       	adc	r19, r19
    24b2:	82 0f       	add	r24, r18
    24b4:	93 1f       	adc	r25, r19
    24b6:	b8 01       	movw	r22, r16
    24b8:	8d 5e       	subi	r24, 0xED	; 237
    24ba:	96 4f       	sbci	r25, 0xF6	; 246
    24bc:	0e 94 6f 04 	call	0x8de	; 0x8de <vListInsertEnd>
    24c0:	e0 91 37 09 	lds	r30, 0x0937
    24c4:	f0 91 38 09 	lds	r31, 0x0938
    24c8:	9e 89       	ldd	r25, Y+22	; 0x16
    24ca:	86 89       	ldd	r24, Z+22	; 0x16
    24cc:	98 17       	cp	r25, r24
    24ce:	10 f0       	brcs	.+4      	; 0x24d4 <xTaskResumeAll+0xa2>
    24d0:	d0 92 e3 08 	sts	0x08E3, r13
    24d4:	f7 01       	movw	r30, r14
    24d6:	80 81       	ld	r24, Z
    24d8:	81 11       	cpse	r24, r1
    24da:	cc cf       	rjmp	.-104    	; 0x2474 <xTaskResumeAll+0x42>
    24dc:	80 91 e4 08 	lds	r24, 0x08E4
    24e0:	88 23       	and	r24, r24
    24e2:	91 f0       	breq	.+36     	; 0x2508 <xTaskResumeAll+0xd6>
    24e4:	80 91 e4 08 	lds	r24, 0x08E4
    24e8:	88 23       	and	r24, r24
    24ea:	71 f0       	breq	.+28     	; 0x2508 <xTaskResumeAll+0xd6>
    24ec:	c1 e0       	ldi	r28, 0x01	; 1
    24ee:	e3 de       	rcall	.-570    	; 0x22b6 <xTaskIncrementTick>
    24f0:	81 11       	cpse	r24, r1
    24f2:	c0 93 e3 08 	sts	0x08E3, r28
    24f6:	80 91 e4 08 	lds	r24, 0x08E4
    24fa:	81 50       	subi	r24, 0x01	; 1
    24fc:	80 93 e4 08 	sts	0x08E4, r24
    2500:	80 91 e4 08 	lds	r24, 0x08E4
    2504:	81 11       	cpse	r24, r1
    2506:	f3 cf       	rjmp	.-26     	; 0x24ee <xTaskResumeAll+0xbc>
    2508:	80 91 e3 08 	lds	r24, 0x08E3
    250c:	81 30       	cpi	r24, 0x01	; 1
    250e:	39 f4       	brne	.+14     	; 0x251e <xTaskResumeAll+0xec>
    2510:	32 d9       	rcall	.-3484   	; 0x1776 <vPortYield>
    2512:	81 e0       	ldi	r24, 0x01	; 1
    2514:	05 c0       	rjmp	.+10     	; 0x2520 <xTaskResumeAll+0xee>
    2516:	80 e0       	ldi	r24, 0x00	; 0
    2518:	03 c0       	rjmp	.+6      	; 0x2520 <xTaskResumeAll+0xee>
    251a:	80 e0       	ldi	r24, 0x00	; 0
    251c:	01 c0       	rjmp	.+2      	; 0x2520 <xTaskResumeAll+0xee>
    251e:	80 e0       	ldi	r24, 0x00	; 0
    2520:	0f 90       	pop	r0
    2522:	0f be       	out	0x3f, r0	; 63
    2524:	df 91       	pop	r29
    2526:	cf 91       	pop	r28
    2528:	1f 91       	pop	r17
    252a:	0f 91       	pop	r16
    252c:	ff 90       	pop	r15
    252e:	ef 90       	pop	r14
    2530:	df 90       	pop	r13
    2532:	08 95       	ret

00002534 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2534:	cf 93       	push	r28
    2536:	df 93       	push	r29
    2538:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    253a:	00 97       	sbiw	r24, 0x00	; 0
    253c:	99 f0       	breq	.+38     	; 0x2564 <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    253e:	b5 de       	rcall	.-662    	; 0x22aa <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2540:	80 91 e7 08 	lds	r24, 0x08E7
    2544:	90 91 e8 08 	lds	r25, 0x08E8
    2548:	c8 0f       	add	r28, r24
    254a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    254c:	80 91 37 09 	lds	r24, 0x0937
    2550:	90 91 38 09 	lds	r25, 0x0938
    2554:	02 96       	adiw	r24, 0x02	; 2
    2556:	0e 94 c1 04 	call	0x982	; 0x982 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    255a:	ce 01       	movw	r24, r28
    255c:	3e dd       	rcall	.-1412   	; 0x1fda <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    255e:	69 df       	rcall	.-302    	; 0x2432 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2560:	81 11       	cpse	r24, r1
    2562:	01 c0       	rjmp	.+2      	; 0x2566 <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    2564:	08 d9       	rcall	.-3568   	; 0x1776 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	08 95       	ret

0000256c <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    256c:	0f 2e       	mov	r0, r31
    256e:	f3 e1       	ldi	r31, 0x13	; 19
    2570:	ef 2e       	mov	r14, r31
    2572:	f9 e0       	ldi	r31, 0x09	; 9
    2574:	ff 2e       	mov	r15, r31
    2576:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2578:	cb ee       	ldi	r28, 0xEB	; 235
    257a:	d8 e0       	ldi	r29, 0x08	; 8
    257c:	26 c0       	rjmp	.+76     	; 0x25ca <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    257e:	95 de       	rcall	.-726    	; 0x22aa <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2580:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    2582:	57 df       	rcall	.-338    	; 0x2432 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2584:	11 23       	and	r17, r17
    2586:	09 f1       	breq	.+66     	; 0x25ca <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    258e:	e0 91 f0 08 	lds	r30, 0x08F0
    2592:	f0 91 f1 08 	lds	r31, 0x08F1
    2596:	06 81       	ldd	r16, Z+6	; 0x06
    2598:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    259a:	c8 01       	movw	r24, r16
    259c:	02 96       	adiw	r24, 0x02	; 2
    259e:	0e 94 c1 04 	call	0x982	; 0x982 <uxListRemove>
					--uxCurrentNumberOfTasks;
    25a2:	80 91 e9 08 	lds	r24, 0x08E9
    25a6:	81 50       	subi	r24, 0x01	; 1
    25a8:	80 93 e9 08 	sts	0x08E9, r24
					--uxTasksDeleted;
    25ac:	80 91 ea 08 	lds	r24, 0x08EA
    25b0:	81 50       	subi	r24, 0x01	; 1
    25b2:	80 93 ea 08 	sts	0x08EA, r24
				}
				taskEXIT_CRITICAL();
    25b6:	0f 90       	pop	r0
    25b8:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    25ba:	f8 01       	movw	r30, r16
    25bc:	87 89       	ldd	r24, Z+23	; 0x17
    25be:	90 8d       	ldd	r25, Z+24	; 0x18
    25c0:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vPortFree>
		vPortFree( pxTCB );
    25c4:	c8 01       	movw	r24, r16
    25c6:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    25ca:	80 91 ea 08 	lds	r24, 0x08EA
    25ce:	81 11       	cpse	r24, r1
    25d0:	d6 cf       	rjmp	.-84     	; 0x257e <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    25d2:	f7 01       	movw	r30, r14
    25d4:	80 81       	ld	r24, Z
    25d6:	82 30       	cpi	r24, 0x02	; 2
    25d8:	c0 f3       	brcs	.-16     	; 0x25ca <prvIdleTask+0x5e>
			{
				taskYIELD();
    25da:	cd d8       	rcall	.-3686   	; 0x1776 <vPortYield>
    25dc:	f6 cf       	rjmp	.-20     	; 0x25ca <prvIdleTask+0x5e>

000025de <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    25de:	80 91 e0 08 	lds	r24, 0x08E0
    25e2:	88 23       	and	r24, r24
    25e4:	21 f0       	breq	.+8      	; 0x25ee <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    25e6:	81 e0       	ldi	r24, 0x01	; 1
    25e8:	80 93 e3 08 	sts	0x08E3, r24
    25ec:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    25ee:	10 92 e3 08 	sts	0x08E3, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    25f2:	80 91 e6 08 	lds	r24, 0x08E6
    25f6:	90 e0       	ldi	r25, 0x00	; 0
    25f8:	fc 01       	movw	r30, r24
    25fa:	ee 0f       	add	r30, r30
    25fc:	ff 1f       	adc	r31, r31
    25fe:	ee 0f       	add	r30, r30
    2600:	ff 1f       	adc	r31, r31
    2602:	ee 0f       	add	r30, r30
    2604:	ff 1f       	adc	r31, r31
    2606:	8e 0f       	add	r24, r30
    2608:	9f 1f       	adc	r25, r31
    260a:	fc 01       	movw	r30, r24
    260c:	ed 5e       	subi	r30, 0xED	; 237
    260e:	f6 4f       	sbci	r31, 0xF6	; 246
    2610:	80 81       	ld	r24, Z
    2612:	81 11       	cpse	r24, r1
    2614:	17 c0       	rjmp	.+46     	; 0x2644 <vTaskSwitchContext+0x66>
    2616:	80 91 e6 08 	lds	r24, 0x08E6
    261a:	81 50       	subi	r24, 0x01	; 1
    261c:	80 93 e6 08 	sts	0x08E6, r24
    2620:	80 91 e6 08 	lds	r24, 0x08E6
    2624:	90 e0       	ldi	r25, 0x00	; 0
    2626:	fc 01       	movw	r30, r24
    2628:	ee 0f       	add	r30, r30
    262a:	ff 1f       	adc	r31, r31
    262c:	ee 0f       	add	r30, r30
    262e:	ff 1f       	adc	r31, r31
    2630:	ee 0f       	add	r30, r30
    2632:	ff 1f       	adc	r31, r31
    2634:	8e 0f       	add	r24, r30
    2636:	9f 1f       	adc	r25, r31
    2638:	fc 01       	movw	r30, r24
    263a:	ed 5e       	subi	r30, 0xED	; 237
    263c:	f6 4f       	sbci	r31, 0xF6	; 246
    263e:	80 81       	ld	r24, Z
    2640:	88 23       	and	r24, r24
    2642:	49 f3       	breq	.-46     	; 0x2616 <vTaskSwitchContext+0x38>
    2644:	e0 91 e6 08 	lds	r30, 0x08E6
    2648:	f0 e0       	ldi	r31, 0x00	; 0
    264a:	cf 01       	movw	r24, r30
    264c:	88 0f       	add	r24, r24
    264e:	99 1f       	adc	r25, r25
    2650:	88 0f       	add	r24, r24
    2652:	99 1f       	adc	r25, r25
    2654:	88 0f       	add	r24, r24
    2656:	99 1f       	adc	r25, r25
    2658:	e8 0f       	add	r30, r24
    265a:	f9 1f       	adc	r31, r25
    265c:	ed 5e       	subi	r30, 0xED	; 237
    265e:	f6 4f       	sbci	r31, 0xF6	; 246
    2660:	a1 81       	ldd	r26, Z+1	; 0x01
    2662:	b2 81       	ldd	r27, Z+2	; 0x02
    2664:	12 96       	adiw	r26, 0x02	; 2
    2666:	0d 90       	ld	r0, X+
    2668:	bc 91       	ld	r27, X
    266a:	a0 2d       	mov	r26, r0
    266c:	b2 83       	std	Z+2, r27	; 0x02
    266e:	a1 83       	std	Z+1, r26	; 0x01
    2670:	cf 01       	movw	r24, r30
    2672:	03 96       	adiw	r24, 0x03	; 3
    2674:	a8 17       	cp	r26, r24
    2676:	b9 07       	cpc	r27, r25
    2678:	31 f4       	brne	.+12     	; 0x2686 <vTaskSwitchContext+0xa8>
    267a:	12 96       	adiw	r26, 0x02	; 2
    267c:	8d 91       	ld	r24, X+
    267e:	9c 91       	ld	r25, X
    2680:	13 97       	sbiw	r26, 0x03	; 3
    2682:	92 83       	std	Z+2, r25	; 0x02
    2684:	81 83       	std	Z+1, r24	; 0x01
    2686:	01 80       	ldd	r0, Z+1	; 0x01
    2688:	f2 81       	ldd	r31, Z+2	; 0x02
    268a:	e0 2d       	mov	r30, r0
    268c:	86 81       	ldd	r24, Z+6	; 0x06
    268e:	97 81       	ldd	r25, Z+7	; 0x07
    2690:	90 93 38 09 	sts	0x0938, r25
    2694:	80 93 37 09 	sts	0x0937, r24
    2698:	08 95       	ret

0000269a <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    269a:	10 92 a6 09 	sts	0x09A6, r1
    269e:	81 e0       	ldi	r24, 0x01	; 1
    26a0:	80 93 a4 09 	sts	0x09A4, r24
    26a4:	10 92 a3 09 	sts	0x09A3, r1
    26a8:	61 e0       	ldi	r22, 0x01	; 1
    26aa:	84 e1       	ldi	r24, 0x14	; 20
    26ac:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <digitalWrite>
    26b0:	61 e0       	ldi	r22, 0x01	; 1
    26b2:	85 e1       	ldi	r24, 0x15	; 21
    26b4:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <digitalWrite>
    26b8:	e9 eb       	ldi	r30, 0xB9	; 185
    26ba:	f0 e0       	ldi	r31, 0x00	; 0
    26bc:	80 81       	ld	r24, Z
    26be:	8e 7f       	andi	r24, 0xFE	; 254
    26c0:	80 83       	st	Z, r24
    26c2:	80 81       	ld	r24, Z
    26c4:	8d 7f       	andi	r24, 0xFD	; 253
    26c6:	80 83       	st	Z, r24
    26c8:	8d ef       	ldi	r24, 0xFD	; 253
    26ca:	80 93 b8 00 	sts	0x00B8, r24
    26ce:	85 e4       	ldi	r24, 0x45	; 69
    26d0:	80 93 bc 00 	sts	0x00BC, r24
    26d4:	08 95       	ret

000026d6 <twi_readFrom>:
    26d6:	41 32       	cpi	r20, 0x21	; 33
    26d8:	08 f0       	brcs	.+2      	; 0x26dc <twi_readFrom+0x6>
    26da:	45 c0       	rjmp	.+138    	; 0x2766 <twi_readFrom+0x90>
    26dc:	90 91 a6 09 	lds	r25, 0x09A6
    26e0:	91 11       	cpse	r25, r1
    26e2:	fc cf       	rjmp	.-8      	; 0x26dc <twi_readFrom+0x6>
    26e4:	91 e0       	ldi	r25, 0x01	; 1
    26e6:	90 93 a6 09 	sts	0x09A6, r25
    26ea:	20 93 a4 09 	sts	0x09A4, r18
    26ee:	2f ef       	ldi	r18, 0xFF	; 255
    26f0:	20 93 39 09 	sts	0x0939, r18
    26f4:	10 92 7e 09 	sts	0x097E, r1
    26f8:	24 0f       	add	r18, r20
    26fa:	20 93 7d 09 	sts	0x097D, r18
    26fe:	90 93 a5 09 	sts	0x09A5, r25
    2702:	90 91 a5 09 	lds	r25, 0x09A5
    2706:	88 0f       	add	r24, r24
    2708:	89 2b       	or	r24, r25
    270a:	80 93 a5 09 	sts	0x09A5, r24
    270e:	80 91 a3 09 	lds	r24, 0x09A3
    2712:	81 30       	cpi	r24, 0x01	; 1
    2714:	51 f4       	brne	.+20     	; 0x272a <twi_readFrom+0x54>
    2716:	10 92 a3 09 	sts	0x09A3, r1
    271a:	80 91 a5 09 	lds	r24, 0x09A5
    271e:	80 93 bb 00 	sts	0x00BB, r24
    2722:	85 ec       	ldi	r24, 0xC5	; 197
    2724:	80 93 bc 00 	sts	0x00BC, r24
    2728:	03 c0       	rjmp	.+6      	; 0x2730 <twi_readFrom+0x5a>
    272a:	85 ee       	ldi	r24, 0xE5	; 229
    272c:	80 93 bc 00 	sts	0x00BC, r24
    2730:	80 91 a6 09 	lds	r24, 0x09A6
    2734:	81 30       	cpi	r24, 0x01	; 1
    2736:	e1 f3       	breq	.-8      	; 0x2730 <twi_readFrom+0x5a>
    2738:	80 91 7e 09 	lds	r24, 0x097E
    273c:	84 17       	cp	r24, r20
    273e:	10 f4       	brcc	.+4      	; 0x2744 <twi_readFrom+0x6e>
    2740:	40 91 7e 09 	lds	r20, 0x097E
    2744:	44 23       	and	r20, r20
    2746:	89 f0       	breq	.+34     	; 0x276a <twi_readFrom+0x94>
    2748:	ef e7       	ldi	r30, 0x7F	; 127
    274a:	f9 e0       	ldi	r31, 0x09	; 9
    274c:	a6 2f       	mov	r26, r22
    274e:	b7 2f       	mov	r27, r23
    2750:	2f ef       	ldi	r18, 0xFF	; 255
    2752:	24 0f       	add	r18, r20
    2754:	30 e0       	ldi	r19, 0x00	; 0
    2756:	20 58       	subi	r18, 0x80	; 128
    2758:	36 4f       	sbci	r19, 0xF6	; 246
    275a:	91 91       	ld	r25, Z+
    275c:	9d 93       	st	X+, r25
    275e:	e2 17       	cp	r30, r18
    2760:	f3 07       	cpc	r31, r19
    2762:	d9 f7       	brne	.-10     	; 0x275a <twi_readFrom+0x84>
    2764:	04 c0       	rjmp	.+8      	; 0x276e <twi_readFrom+0x98>
    2766:	80 e0       	ldi	r24, 0x00	; 0
    2768:	08 95       	ret
    276a:	84 2f       	mov	r24, r20
    276c:	08 95       	ret
    276e:	84 2f       	mov	r24, r20
    2770:	08 95       	ret

00002772 <twi_writeTo>:
    2772:	0f 93       	push	r16
    2774:	41 32       	cpi	r20, 0x21	; 33
    2776:	08 f0       	brcs	.+2      	; 0x277a <twi_writeTo+0x8>
    2778:	50 c0       	rjmp	.+160    	; 0x281a <twi_writeTo+0xa8>
    277a:	90 91 a6 09 	lds	r25, 0x09A6
    277e:	91 11       	cpse	r25, r1
    2780:	fc cf       	rjmp	.-8      	; 0x277a <twi_writeTo+0x8>
    2782:	92 e0       	ldi	r25, 0x02	; 2
    2784:	90 93 a6 09 	sts	0x09A6, r25
    2788:	00 93 a4 09 	sts	0x09A4, r16
    278c:	9f ef       	ldi	r25, 0xFF	; 255
    278e:	90 93 39 09 	sts	0x0939, r25
    2792:	10 92 7e 09 	sts	0x097E, r1
    2796:	40 93 7d 09 	sts	0x097D, r20
    279a:	44 23       	and	r20, r20
    279c:	69 f0       	breq	.+26     	; 0x27b8 <twi_writeTo+0x46>
    279e:	fb 01       	movw	r30, r22
    27a0:	af e7       	ldi	r26, 0x7F	; 127
    27a2:	b9 e0       	ldi	r27, 0x09	; 9
    27a4:	6f 5f       	subi	r22, 0xFF	; 255
    27a6:	7f 4f       	sbci	r23, 0xFF	; 255
    27a8:	41 50       	subi	r20, 0x01	; 1
    27aa:	64 0f       	add	r22, r20
    27ac:	71 1d       	adc	r23, r1
    27ae:	91 91       	ld	r25, Z+
    27b0:	9d 93       	st	X+, r25
    27b2:	e6 17       	cp	r30, r22
    27b4:	f7 07       	cpc	r31, r23
    27b6:	d9 f7       	brne	.-10     	; 0x27ae <twi_writeTo+0x3c>
    27b8:	10 92 a5 09 	sts	0x09A5, r1
    27bc:	90 91 a5 09 	lds	r25, 0x09A5
    27c0:	88 0f       	add	r24, r24
    27c2:	89 2b       	or	r24, r25
    27c4:	80 93 a5 09 	sts	0x09A5, r24
    27c8:	80 91 a3 09 	lds	r24, 0x09A3
    27cc:	81 30       	cpi	r24, 0x01	; 1
    27ce:	51 f4       	brne	.+20     	; 0x27e4 <twi_writeTo+0x72>
    27d0:	10 92 a3 09 	sts	0x09A3, r1
    27d4:	80 91 a5 09 	lds	r24, 0x09A5
    27d8:	80 93 bb 00 	sts	0x00BB, r24
    27dc:	85 ec       	ldi	r24, 0xC5	; 197
    27de:	80 93 bc 00 	sts	0x00BC, r24
    27e2:	03 c0       	rjmp	.+6      	; 0x27ea <twi_writeTo+0x78>
    27e4:	85 ee       	ldi	r24, 0xE5	; 229
    27e6:	80 93 bc 00 	sts	0x00BC, r24
    27ea:	22 23       	and	r18, r18
    27ec:	41 f0       	breq	.+16     	; 0x27fe <twi_writeTo+0x8c>
    27ee:	80 91 a6 09 	lds	r24, 0x09A6
    27f2:	82 30       	cpi	r24, 0x02	; 2
    27f4:	21 f4       	brne	.+8      	; 0x27fe <twi_writeTo+0x8c>
    27f6:	80 91 a6 09 	lds	r24, 0x09A6
    27fa:	82 30       	cpi	r24, 0x02	; 2
    27fc:	e1 f3       	breq	.-8      	; 0x27f6 <twi_writeTo+0x84>
    27fe:	80 91 39 09 	lds	r24, 0x0939
    2802:	8f 3f       	cpi	r24, 0xFF	; 255
    2804:	61 f0       	breq	.+24     	; 0x281e <twi_writeTo+0xac>
    2806:	80 91 39 09 	lds	r24, 0x0939
    280a:	80 32       	cpi	r24, 0x20	; 32
    280c:	51 f0       	breq	.+20     	; 0x2822 <twi_writeTo+0xb0>
    280e:	80 91 39 09 	lds	r24, 0x0939
    2812:	80 33       	cpi	r24, 0x30	; 48
    2814:	41 f4       	brne	.+16     	; 0x2826 <twi_writeTo+0xb4>
    2816:	83 e0       	ldi	r24, 0x03	; 3
    2818:	07 c0       	rjmp	.+14     	; 0x2828 <twi_writeTo+0xb6>
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	05 c0       	rjmp	.+10     	; 0x2828 <twi_writeTo+0xb6>
    281e:	80 e0       	ldi	r24, 0x00	; 0
    2820:	03 c0       	rjmp	.+6      	; 0x2828 <twi_writeTo+0xb6>
    2822:	82 e0       	ldi	r24, 0x02	; 2
    2824:	01 c0       	rjmp	.+2      	; 0x2828 <twi_writeTo+0xb6>
    2826:	84 e0       	ldi	r24, 0x04	; 4
    2828:	0f 91       	pop	r16
    282a:	08 95       	ret

0000282c <twi_transmit>:
    282c:	61 32       	cpi	r22, 0x21	; 33
    282e:	a8 f4       	brcc	.+42     	; 0x285a <twi_transmit+0x2e>
    2830:	20 91 a6 09 	lds	r18, 0x09A6
    2834:	24 30       	cpi	r18, 0x04	; 4
    2836:	99 f4       	brne	.+38     	; 0x285e <twi_transmit+0x32>
    2838:	60 93 5b 09 	sts	0x095B, r22
    283c:	66 23       	and	r22, r22
    283e:	89 f0       	breq	.+34     	; 0x2862 <twi_transmit+0x36>
    2840:	fc 01       	movw	r30, r24
    2842:	ad e5       	ldi	r26, 0x5D	; 93
    2844:	b9 e0       	ldi	r27, 0x09	; 9
    2846:	01 96       	adiw	r24, 0x01	; 1
    2848:	61 50       	subi	r22, 0x01	; 1
    284a:	86 0f       	add	r24, r22
    284c:	91 1d       	adc	r25, r1
    284e:	21 91       	ld	r18, Z+
    2850:	2d 93       	st	X+, r18
    2852:	e8 17       	cp	r30, r24
    2854:	f9 07       	cpc	r31, r25
    2856:	d9 f7       	brne	.-10     	; 0x284e <twi_transmit+0x22>
    2858:	06 c0       	rjmp	.+12     	; 0x2866 <twi_transmit+0x3a>
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	08 95       	ret
    285e:	82 e0       	ldi	r24, 0x02	; 2
    2860:	08 95       	ret
    2862:	80 e0       	ldi	r24, 0x00	; 0
    2864:	08 95       	ret
    2866:	80 e0       	ldi	r24, 0x00	; 0
    2868:	08 95       	ret

0000286a <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    286a:	85 ed       	ldi	r24, 0xD5	; 213
    286c:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    2870:	ec eb       	ldi	r30, 0xBC	; 188
    2872:	f0 e0       	ldi	r31, 0x00	; 0
    2874:	80 81       	ld	r24, Z
    2876:	84 fd       	sbrc	r24, 4
    2878:	fd cf       	rjmp	.-6      	; 0x2874 <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    287a:	10 92 a6 09 	sts	0x09A6, r1
    287e:	08 95       	ret

00002880 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2880:	85 ec       	ldi	r24, 0xC5	; 197
    2882:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2886:	10 92 a6 09 	sts	0x09A6, r1
    288a:	08 95       	ret

0000288c <__vector_39>:
}

ISR(TWI_vect)
{
    288c:	1f 92       	push	r1
    288e:	0f 92       	push	r0
    2890:	0f b6       	in	r0, 0x3f	; 63
    2892:	0f 92       	push	r0
    2894:	11 24       	eor	r1, r1
    2896:	0b b6       	in	r0, 0x3b	; 59
    2898:	0f 92       	push	r0
    289a:	2f 93       	push	r18
    289c:	3f 93       	push	r19
    289e:	4f 93       	push	r20
    28a0:	5f 93       	push	r21
    28a2:	6f 93       	push	r22
    28a4:	7f 93       	push	r23
    28a6:	8f 93       	push	r24
    28a8:	9f 93       	push	r25
    28aa:	af 93       	push	r26
    28ac:	bf 93       	push	r27
    28ae:	ef 93       	push	r30
    28b0:	ff 93       	push	r31
  switch(TW_STATUS){
    28b2:	80 91 b9 00 	lds	r24, 0x00B9
    28b6:	88 7f       	andi	r24, 0xF8	; 248
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	89 3c       	cpi	r24, 0xC9	; 201
    28bc:	91 05       	cpc	r25, r1
    28be:	08 f0       	brcs	.+2      	; 0x28c2 <__vector_39+0x36>
    28c0:	ee c0       	rjmp	.+476    	; 0x2a9e <__vector_39+0x212>
    28c2:	fc 01       	movw	r30, r24
    28c4:	ee 58       	subi	r30, 0x8E	; 142
    28c6:	ff 4f       	sbci	r31, 0xFF	; 255
    28c8:	0c 94 bc 1f 	jmp	0x3f78	; 0x3f78 <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    28cc:	80 91 a5 09 	lds	r24, 0x09A5
    28d0:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    28d4:	85 ec       	ldi	r24, 0xC5	; 197
    28d6:	80 93 bc 00 	sts	0x00BC, r24
    28da:	e1 c0       	rjmp	.+450    	; 0x2a9e <__vector_39+0x212>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    28dc:	90 91 7e 09 	lds	r25, 0x097E
    28e0:	80 91 7d 09 	lds	r24, 0x097D
    28e4:	98 17       	cp	r25, r24
    28e6:	80 f4       	brcc	.+32     	; 0x2908 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    28e8:	e0 91 7e 09 	lds	r30, 0x097E
    28ec:	81 e0       	ldi	r24, 0x01	; 1
    28ee:	8e 0f       	add	r24, r30
    28f0:	80 93 7e 09 	sts	0x097E, r24
    28f4:	f0 e0       	ldi	r31, 0x00	; 0
    28f6:	e1 58       	subi	r30, 0x81	; 129
    28f8:	f6 4f       	sbci	r31, 0xF6	; 246
    28fa:	80 81       	ld	r24, Z
    28fc:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2900:	85 ec       	ldi	r24, 0xC5	; 197
    2902:	80 93 bc 00 	sts	0x00BC, r24
    2906:	cb c0       	rjmp	.+406    	; 0x2a9e <__vector_39+0x212>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    2908:	80 91 a4 09 	lds	r24, 0x09A4
    290c:	88 23       	and	r24, r24
    290e:	11 f0       	breq	.+4      	; 0x2914 <__vector_39+0x88>
          twi_stop();
    2910:	ac df       	rcall	.-168    	; 0x286a <twi_stop>
    2912:	c5 c0       	rjmp	.+394    	; 0x2a9e <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2914:	81 e0       	ldi	r24, 0x01	; 1
    2916:	80 93 a3 09 	sts	0x09A3, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    291a:	84 ea       	ldi	r24, 0xA4	; 164
    291c:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    2920:	10 92 a6 09 	sts	0x09A6, r1
    2924:	bc c0       	rjmp	.+376    	; 0x2a9e <__vector_39+0x212>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    2926:	80 e2       	ldi	r24, 0x20	; 32
    2928:	80 93 39 09 	sts	0x0939, r24
      twi_stop();
    292c:	9e df       	rcall	.-196    	; 0x286a <twi_stop>
      break;
    292e:	b7 c0       	rjmp	.+366    	; 0x2a9e <__vector_39+0x212>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    2930:	80 e3       	ldi	r24, 0x30	; 48
    2932:	80 93 39 09 	sts	0x0939, r24
      twi_stop();
    2936:	99 df       	rcall	.-206    	; 0x286a <twi_stop>
      break;
    2938:	b2 c0       	rjmp	.+356    	; 0x2a9e <__vector_39+0x212>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    293a:	88 e3       	ldi	r24, 0x38	; 56
    293c:	80 93 39 09 	sts	0x0939, r24
      twi_releaseBus();
    2940:	9f df       	rcall	.-194    	; 0x2880 <twi_releaseBus>
      break;
    2942:	ad c0       	rjmp	.+346    	; 0x2a9e <__vector_39+0x212>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2944:	e0 91 7e 09 	lds	r30, 0x097E
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	8e 0f       	add	r24, r30
    294c:	80 93 7e 09 	sts	0x097E, r24
    2950:	80 91 bb 00 	lds	r24, 0x00BB
    2954:	f0 e0       	ldi	r31, 0x00	; 0
    2956:	e1 58       	subi	r30, 0x81	; 129
    2958:	f6 4f       	sbci	r31, 0xF6	; 246
    295a:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    295c:	90 91 7e 09 	lds	r25, 0x097E
    2960:	80 91 7d 09 	lds	r24, 0x097D
    2964:	98 17       	cp	r25, r24
    2966:	20 f4       	brcc	.+8      	; 0x2970 <__vector_39+0xe4>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2968:	85 ec       	ldi	r24, 0xC5	; 197
    296a:	80 93 bc 00 	sts	0x00BC, r24
    296e:	97 c0       	rjmp	.+302    	; 0x2a9e <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2970:	85 e8       	ldi	r24, 0x85	; 133
    2972:	80 93 bc 00 	sts	0x00BC, r24
    2976:	93 c0       	rjmp	.+294    	; 0x2a9e <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    2978:	e0 91 7e 09 	lds	r30, 0x097E
    297c:	81 e0       	ldi	r24, 0x01	; 1
    297e:	8e 0f       	add	r24, r30
    2980:	80 93 7e 09 	sts	0x097E, r24
    2984:	80 91 bb 00 	lds	r24, 0x00BB
    2988:	f0 e0       	ldi	r31, 0x00	; 0
    298a:	e1 58       	subi	r30, 0x81	; 129
    298c:	f6 4f       	sbci	r31, 0xF6	; 246
    298e:	80 83       	st	Z, r24
	if (twi_sendStop)
    2990:	80 91 a4 09 	lds	r24, 0x09A4
    2994:	88 23       	and	r24, r24
    2996:	11 f0       	breq	.+4      	; 0x299c <__vector_39+0x110>
          twi_stop();
    2998:	68 df       	rcall	.-304    	; 0x286a <twi_stop>
    299a:	81 c0       	rjmp	.+258    	; 0x2a9e <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    299c:	81 e0       	ldi	r24, 0x01	; 1
    299e:	80 93 a3 09 	sts	0x09A3, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    29a2:	84 ea       	ldi	r24, 0xA4	; 164
    29a4:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    29a8:	10 92 a6 09 	sts	0x09A6, r1
    29ac:	78 c0       	rjmp	.+240    	; 0x2a9e <__vector_39+0x212>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    29ae:	5d df       	rcall	.-326    	; 0x286a <twi_stop>
      break;
    29b0:	76 c0       	rjmp	.+236    	; 0x2a9e <__vector_39+0x212>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    29b2:	83 e0       	ldi	r24, 0x03	; 3
    29b4:	80 93 a6 09 	sts	0x09A6, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    29b8:	10 92 3a 09 	sts	0x093A, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    29bc:	85 ec       	ldi	r24, 0xC5	; 197
    29be:	80 93 bc 00 	sts	0x00BC, r24
    29c2:	6d c0       	rjmp	.+218    	; 0x2a9e <__vector_39+0x212>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    29c4:	80 91 3a 09 	lds	r24, 0x093A
    29c8:	80 32       	cpi	r24, 0x20	; 32
    29ca:	80 f4       	brcc	.+32     	; 0x29ec <__vector_39+0x160>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    29cc:	e0 91 3a 09 	lds	r30, 0x093A
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	8e 0f       	add	r24, r30
    29d4:	80 93 3a 09 	sts	0x093A, r24
    29d8:	80 91 bb 00 	lds	r24, 0x00BB
    29dc:	f0 e0       	ldi	r31, 0x00	; 0
    29de:	e5 5c       	subi	r30, 0xC5	; 197
    29e0:	f6 4f       	sbci	r31, 0xF6	; 246
    29e2:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    29e4:	85 ec       	ldi	r24, 0xC5	; 197
    29e6:	80 93 bc 00 	sts	0x00BC, r24
    29ea:	59 c0       	rjmp	.+178    	; 0x2a9e <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    29ec:	85 e8       	ldi	r24, 0x85	; 133
    29ee:	80 93 bc 00 	sts	0x00BC, r24
    29f2:	55 c0       	rjmp	.+170    	; 0x2a9e <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    29f4:	80 91 3a 09 	lds	r24, 0x093A
    29f8:	80 32       	cpi	r24, 0x20	; 32
    29fa:	30 f4       	brcc	.+12     	; 0x2a08 <__vector_39+0x17c>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    29fc:	e0 91 3a 09 	lds	r30, 0x093A
    2a00:	f0 e0       	ldi	r31, 0x00	; 0
    2a02:	e5 5c       	subi	r30, 0xC5	; 197
    2a04:	f6 4f       	sbci	r31, 0xF6	; 246
    2a06:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    2a08:	30 df       	rcall	.-416    	; 0x286a <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    2a0a:	60 91 3a 09 	lds	r22, 0x093A
    2a0e:	70 e0       	ldi	r23, 0x00	; 0
    2a10:	e0 91 9f 09 	lds	r30, 0x099F
    2a14:	f0 91 a0 09 	lds	r31, 0x09A0
    2a18:	8b e3       	ldi	r24, 0x3B	; 59
    2a1a:	99 e0       	ldi	r25, 0x09	; 9
    2a1c:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    2a1e:	10 92 3a 09 	sts	0x093A, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    2a22:	2e df       	rcall	.-420    	; 0x2880 <twi_releaseBus>
      break;
    2a24:	3c c0       	rjmp	.+120    	; 0x2a9e <__vector_39+0x212>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2a26:	85 e8       	ldi	r24, 0x85	; 133
    2a28:	80 93 bc 00 	sts	0x00BC, r24
    2a2c:	38 c0       	rjmp	.+112    	; 0x2a9e <__vector_39+0x212>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    2a2e:	84 e0       	ldi	r24, 0x04	; 4
    2a30:	80 93 a6 09 	sts	0x09A6, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    2a34:	10 92 5c 09 	sts	0x095C, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    2a38:	10 92 5b 09 	sts	0x095B, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    2a3c:	e0 91 a1 09 	lds	r30, 0x09A1
    2a40:	f0 91 a2 09 	lds	r31, 0x09A2
    2a44:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    2a46:	80 91 5b 09 	lds	r24, 0x095B
    2a4a:	81 11       	cpse	r24, r1
    2a4c:	05 c0       	rjmp	.+10     	; 0x2a58 <__vector_39+0x1cc>
        twi_txBufferLength = 1;
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	80 93 5b 09 	sts	0x095B, r24
        twi_txBuffer[0] = 0x00;
    2a54:	10 92 5d 09 	sts	0x095D, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    2a58:	e0 91 5c 09 	lds	r30, 0x095C
    2a5c:	81 e0       	ldi	r24, 0x01	; 1
    2a5e:	8e 0f       	add	r24, r30
    2a60:	80 93 5c 09 	sts	0x095C, r24
    2a64:	f0 e0       	ldi	r31, 0x00	; 0
    2a66:	e3 5a       	subi	r30, 0xA3	; 163
    2a68:	f6 4f       	sbci	r31, 0xF6	; 246
    2a6a:	80 81       	ld	r24, Z
    2a6c:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    2a70:	90 91 5c 09 	lds	r25, 0x095C
    2a74:	80 91 5b 09 	lds	r24, 0x095B
    2a78:	98 17       	cp	r25, r24
    2a7a:	20 f4       	brcc	.+8      	; 0x2a84 <__vector_39+0x1f8>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2a7c:	85 ec       	ldi	r24, 0xC5	; 197
    2a7e:	80 93 bc 00 	sts	0x00BC, r24
    2a82:	0d c0       	rjmp	.+26     	; 0x2a9e <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2a84:	85 e8       	ldi	r24, 0x85	; 133
    2a86:	80 93 bc 00 	sts	0x00BC, r24
    2a8a:	09 c0       	rjmp	.+18     	; 0x2a9e <__vector_39+0x212>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2a8c:	85 ec       	ldi	r24, 0xC5	; 197
    2a8e:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    2a92:	10 92 a6 09 	sts	0x09A6, r1
      break;
    2a96:	03 c0       	rjmp	.+6      	; 0x2a9e <__vector_39+0x212>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    2a98:	10 92 39 09 	sts	0x0939, r1
      twi_stop();
    2a9c:	e6 de       	rcall	.-564    	; 0x286a <twi_stop>
      break;
  }
}
    2a9e:	ff 91       	pop	r31
    2aa0:	ef 91       	pop	r30
    2aa2:	bf 91       	pop	r27
    2aa4:	af 91       	pop	r26
    2aa6:	9f 91       	pop	r25
    2aa8:	8f 91       	pop	r24
    2aaa:	7f 91       	pop	r23
    2aac:	6f 91       	pop	r22
    2aae:	5f 91       	pop	r21
    2ab0:	4f 91       	pop	r20
    2ab2:	3f 91       	pop	r19
    2ab4:	2f 91       	pop	r18
    2ab6:	0f 90       	pop	r0
    2ab8:	0b be       	out	0x3b, r0	; 59
    2aba:	0f 90       	pop	r0
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	0f 90       	pop	r0
    2ac0:	1f 90       	pop	r1
    2ac2:	18 95       	reti

00002ac4 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    2ac4:	80 91 d7 09 	lds	r24, 0x09D7
    2ac8:	90 e0       	ldi	r25, 0x00	; 0
    2aca:	20 91 d8 09 	lds	r18, 0x09D8
    2ace:	82 1b       	sub	r24, r18
    2ad0:	91 09       	sbc	r25, r1
    2ad2:	08 95       	ret

00002ad4 <_ZN7TwoWire4readEv>:
    2ad4:	20 91 d8 09 	lds	r18, 0x09D8
    2ad8:	80 91 d7 09 	lds	r24, 0x09D7
    2adc:	28 17       	cp	r18, r24
    2ade:	50 f4       	brcc	.+20     	; 0x2af4 <_ZN7TwoWire4readEv+0x20>
    2ae0:	e2 2f       	mov	r30, r18
    2ae2:	f0 e0       	ldi	r31, 0x00	; 0
    2ae4:	e7 52       	subi	r30, 0x27	; 39
    2ae6:	f6 4f       	sbci	r31, 0xF6	; 246
    2ae8:	80 81       	ld	r24, Z
    2aea:	90 e0       	ldi	r25, 0x00	; 0
    2aec:	2f 5f       	subi	r18, 0xFF	; 255
    2aee:	20 93 d8 09 	sts	0x09D8, r18
    2af2:	08 95       	ret
    2af4:	8f ef       	ldi	r24, 0xFF	; 255
    2af6:	9f ef       	ldi	r25, 0xFF	; 255
    2af8:	08 95       	ret

00002afa <_ZN7TwoWire4peekEv>:
    2afa:	e0 91 d8 09 	lds	r30, 0x09D8
    2afe:	80 91 d7 09 	lds	r24, 0x09D7
    2b02:	e8 17       	cp	r30, r24
    2b04:	30 f4       	brcc	.+12     	; 0x2b12 <_ZN7TwoWire4peekEv+0x18>
    2b06:	f0 e0       	ldi	r31, 0x00	; 0
    2b08:	e7 52       	subi	r30, 0x27	; 39
    2b0a:	f6 4f       	sbci	r31, 0xF6	; 246
    2b0c:	80 81       	ld	r24, Z
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	08 95       	ret
    2b12:	8f ef       	ldi	r24, 0xFF	; 255
    2b14:	9f ef       	ldi	r25, 0xFF	; 255
    2b16:	08 95       	ret

00002b18 <_ZN7TwoWire5flushEv>:
    2b18:	08 95       	ret

00002b1a <_ZN7TwoWire5writeEPKhj>:
    2b1a:	cf 92       	push	r12
    2b1c:	df 92       	push	r13
    2b1e:	ef 92       	push	r14
    2b20:	ff 92       	push	r15
    2b22:	0f 93       	push	r16
    2b24:	1f 93       	push	r17
    2b26:	cf 93       	push	r28
    2b28:	df 93       	push	r29
    2b2a:	8c 01       	movw	r16, r24
    2b2c:	7b 01       	movw	r14, r22
    2b2e:	6a 01       	movw	r12, r20
    2b30:	80 91 b3 09 	lds	r24, 0x09B3
    2b34:	88 23       	and	r24, r24
    2b36:	99 f0       	breq	.+38     	; 0x2b5e <_ZN7TwoWire5writeEPKhj+0x44>
    2b38:	41 15       	cp	r20, r1
    2b3a:	51 05       	cpc	r21, r1
    2b3c:	99 f0       	breq	.+38     	; 0x2b64 <_ZN7TwoWire5writeEPKhj+0x4a>
    2b3e:	eb 01       	movw	r28, r22
    2b40:	e4 0e       	add	r14, r20
    2b42:	f5 1e       	adc	r15, r21
    2b44:	69 91       	ld	r22, Y+
    2b46:	d8 01       	movw	r26, r16
    2b48:	ed 91       	ld	r30, X+
    2b4a:	fc 91       	ld	r31, X
    2b4c:	01 90       	ld	r0, Z+
    2b4e:	f0 81       	ld	r31, Z
    2b50:	e0 2d       	mov	r30, r0
    2b52:	c8 01       	movw	r24, r16
    2b54:	19 95       	eicall
    2b56:	ce 15       	cp	r28, r14
    2b58:	df 05       	cpc	r29, r15
    2b5a:	a1 f7       	brne	.-24     	; 0x2b44 <_ZN7TwoWire5writeEPKhj+0x2a>
    2b5c:	03 c0       	rjmp	.+6      	; 0x2b64 <_ZN7TwoWire5writeEPKhj+0x4a>
    2b5e:	64 2f       	mov	r22, r20
    2b60:	c7 01       	movw	r24, r14
    2b62:	64 de       	rcall	.-824    	; 0x282c <twi_transmit>
    2b64:	c6 01       	movw	r24, r12
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	1f 91       	pop	r17
    2b6c:	0f 91       	pop	r16
    2b6e:	ff 90       	pop	r15
    2b70:	ef 90       	pop	r14
    2b72:	df 90       	pop	r13
    2b74:	cf 90       	pop	r12
    2b76:	08 95       	ret

00002b78 <_ZN7TwoWire5writeEh>:
    2b78:	cf 93       	push	r28
    2b7a:	df 93       	push	r29
    2b7c:	1f 92       	push	r1
    2b7e:	cd b7       	in	r28, 0x3d	; 61
    2b80:	de b7       	in	r29, 0x3e	; 62
    2b82:	69 83       	std	Y+1, r22	; 0x01
    2b84:	20 91 b3 09 	lds	r18, 0x09B3
    2b88:	22 23       	and	r18, r18
    2b8a:	e1 f0       	breq	.+56     	; 0x2bc4 <_ZN7TwoWire5writeEh+0x4c>
    2b8c:	20 91 b4 09 	lds	r18, 0x09B4
    2b90:	20 32       	cpi	r18, 0x20	; 32
    2b92:	40 f0       	brcs	.+16     	; 0x2ba4 <_ZN7TwoWire5writeEh+0x2c>
    2b94:	21 e0       	ldi	r18, 0x01	; 1
    2b96:	30 e0       	ldi	r19, 0x00	; 0
    2b98:	fc 01       	movw	r30, r24
    2b9a:	33 83       	std	Z+3, r19	; 0x03
    2b9c:	22 83       	std	Z+2, r18	; 0x02
    2b9e:	80 e0       	ldi	r24, 0x00	; 0
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	16 c0       	rjmp	.+44     	; 0x2bd0 <_ZN7TwoWire5writeEh+0x58>
    2ba4:	80 91 b5 09 	lds	r24, 0x09B5
    2ba8:	e8 2f       	mov	r30, r24
    2baa:	f0 e0       	ldi	r31, 0x00	; 0
    2bac:	ea 54       	subi	r30, 0x4A	; 74
    2bae:	f6 4f       	sbci	r31, 0xF6	; 246
    2bb0:	99 81       	ldd	r25, Y+1	; 0x01
    2bb2:	90 83       	st	Z, r25
    2bb4:	8f 5f       	subi	r24, 0xFF	; 255
    2bb6:	80 93 b5 09 	sts	0x09B5, r24
    2bba:	80 93 b4 09 	sts	0x09B4, r24
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	06 c0       	rjmp	.+12     	; 0x2bd0 <_ZN7TwoWire5writeEh+0x58>
    2bc4:	61 e0       	ldi	r22, 0x01	; 1
    2bc6:	ce 01       	movw	r24, r28
    2bc8:	01 96       	adiw	r24, 0x01	; 1
    2bca:	30 de       	rcall	.-928    	; 0x282c <twi_transmit>
    2bcc:	81 e0       	ldi	r24, 0x01	; 1
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	0f 90       	pop	r0
    2bd2:	df 91       	pop	r29
    2bd4:	cf 91       	pop	r28
    2bd6:	08 95       	ret

00002bd8 <_ZN7TwoWireC1Ev>:
    2bd8:	fc 01       	movw	r30, r24
    2bda:	13 82       	std	Z+3, r1	; 0x03
    2bdc:	12 82       	std	Z+2, r1	; 0x02
    2bde:	48 ee       	ldi	r20, 0xE8	; 232
    2be0:	53 e0       	ldi	r21, 0x03	; 3
    2be2:	60 e0       	ldi	r22, 0x00	; 0
    2be4:	70 e0       	ldi	r23, 0x00	; 0
    2be6:	44 83       	std	Z+4, r20	; 0x04
    2be8:	55 83       	std	Z+5, r21	; 0x05
    2bea:	66 83       	std	Z+6, r22	; 0x06
    2bec:	77 83       	std	Z+7, r23	; 0x07
    2bee:	8e e7       	ldi	r24, 0x7E	; 126
    2bf0:	92 e0       	ldi	r25, 0x02	; 2
    2bf2:	91 83       	std	Z+1, r25	; 0x01
    2bf4:	80 83       	st	Z, r24
    2bf6:	08 95       	ret

00002bf8 <_ZN7TwoWire5beginEv>:
    2bf8:	10 92 d8 09 	sts	0x09D8, r1
    2bfc:	10 92 d7 09 	sts	0x09D7, r1
    2c00:	10 92 b5 09 	sts	0x09B5, r1
    2c04:	10 92 b4 09 	sts	0x09B4, r1
    2c08:	48 cd       	rjmp	.-1392   	; 0x269a <twi_init>
    2c0a:	08 95       	ret

00002c0c <_ZN7TwoWire11requestFromEhhh>:
    2c0c:	86 2f       	mov	r24, r22
    2c0e:	41 32       	cpi	r20, 0x21	; 33
    2c10:	08 f0       	brcs	.+2      	; 0x2c14 <_ZN7TwoWire11requestFromEhhh+0x8>
    2c12:	40 e2       	ldi	r20, 0x20	; 32
    2c14:	69 ed       	ldi	r22, 0xD9	; 217
    2c16:	79 e0       	ldi	r23, 0x09	; 9
    2c18:	5e dd       	rcall	.-1348   	; 0x26d6 <twi_readFrom>
    2c1a:	10 92 d8 09 	sts	0x09D8, r1
    2c1e:	80 93 d7 09 	sts	0x09D7, r24
    2c22:	08 95       	ret

00002c24 <_ZN7TwoWire11requestFromEhh>:
    2c24:	21 e0       	ldi	r18, 0x01	; 1
    2c26:	f2 cf       	rjmp	.-28     	; 0x2c0c <_ZN7TwoWire11requestFromEhhh>
    2c28:	08 95       	ret

00002c2a <_ZN7TwoWire17beginTransmissionEh>:
    2c2a:	81 e0       	ldi	r24, 0x01	; 1
    2c2c:	80 93 b3 09 	sts	0x09B3, r24
    2c30:	60 93 d6 09 	sts	0x09D6, r22
    2c34:	10 92 b5 09 	sts	0x09B5, r1
    2c38:	10 92 b4 09 	sts	0x09B4, r1
    2c3c:	08 95       	ret

00002c3e <_ZN7TwoWire15endTransmissionEh>:
    2c3e:	0f 93       	push	r16
    2c40:	06 2f       	mov	r16, r22
    2c42:	21 e0       	ldi	r18, 0x01	; 1
    2c44:	40 91 b4 09 	lds	r20, 0x09B4
    2c48:	66 eb       	ldi	r22, 0xB6	; 182
    2c4a:	79 e0       	ldi	r23, 0x09	; 9
    2c4c:	80 91 d6 09 	lds	r24, 0x09D6
    2c50:	90 dd       	rcall	.-1248   	; 0x2772 <twi_writeTo>
    2c52:	10 92 b5 09 	sts	0x09B5, r1
    2c56:	10 92 b4 09 	sts	0x09B4, r1
    2c5a:	10 92 b3 09 	sts	0x09B3, r1
    2c5e:	0f 91       	pop	r16
    2c60:	08 95       	ret

00002c62 <_ZN7TwoWire15endTransmissionEv>:
    2c62:	61 e0       	ldi	r22, 0x01	; 1
    2c64:	ec cf       	rjmp	.-40     	; 0x2c3e <_ZN7TwoWire15endTransmissionEh>
    2c66:	08 95       	ret

00002c68 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2c68:	87 ea       	ldi	r24, 0xA7	; 167
    2c6a:	99 e0       	ldi	r25, 0x09	; 9
    2c6c:	b5 cf       	rjmp	.-150    	; 0x2bd8 <_ZN7TwoWireC1Ev>
    2c6e:	08 95       	ret

00002c70 <__subsf3>:
    2c70:	50 58       	subi	r21, 0x80	; 128

00002c72 <__addsf3>:
    2c72:	bb 27       	eor	r27, r27
    2c74:	aa 27       	eor	r26, r26
    2c76:	0e d0       	rcall	.+28     	; 0x2c94 <__addsf3x>
    2c78:	fc c1       	rjmp	.+1016   	; 0x3072 <__fp_round>
    2c7a:	ed d1       	rcall	.+986    	; 0x3056 <__fp_pscA>
    2c7c:	30 f0       	brcs	.+12     	; 0x2c8a <__addsf3+0x18>
    2c7e:	f2 d1       	rcall	.+996    	; 0x3064 <__fp_pscB>
    2c80:	20 f0       	brcs	.+8      	; 0x2c8a <__addsf3+0x18>
    2c82:	31 f4       	brne	.+12     	; 0x2c90 <__addsf3+0x1e>
    2c84:	9f 3f       	cpi	r25, 0xFF	; 255
    2c86:	11 f4       	brne	.+4      	; 0x2c8c <__addsf3+0x1a>
    2c88:	1e f4       	brtc	.+6      	; 0x2c90 <__addsf3+0x1e>
    2c8a:	bd c1       	rjmp	.+890    	; 0x3006 <__fp_nan>
    2c8c:	0e f4       	brtc	.+2      	; 0x2c90 <__addsf3+0x1e>
    2c8e:	e0 95       	com	r30
    2c90:	e7 fb       	bst	r30, 7
    2c92:	b3 c1       	rjmp	.+870    	; 0x2ffa <__fp_inf>

00002c94 <__addsf3x>:
    2c94:	e9 2f       	mov	r30, r25
    2c96:	fe d1       	rcall	.+1020   	; 0x3094 <__fp_split3>
    2c98:	80 f3       	brcs	.-32     	; 0x2c7a <__addsf3+0x8>
    2c9a:	ba 17       	cp	r27, r26
    2c9c:	62 07       	cpc	r22, r18
    2c9e:	73 07       	cpc	r23, r19
    2ca0:	84 07       	cpc	r24, r20
    2ca2:	95 07       	cpc	r25, r21
    2ca4:	18 f0       	brcs	.+6      	; 0x2cac <__addsf3x+0x18>
    2ca6:	71 f4       	brne	.+28     	; 0x2cc4 <__addsf3x+0x30>
    2ca8:	9e f5       	brtc	.+102    	; 0x2d10 <__addsf3x+0x7c>
    2caa:	16 c2       	rjmp	.+1068   	; 0x30d8 <__fp_zero>
    2cac:	0e f4       	brtc	.+2      	; 0x2cb0 <__addsf3x+0x1c>
    2cae:	e0 95       	com	r30
    2cb0:	0b 2e       	mov	r0, r27
    2cb2:	ba 2f       	mov	r27, r26
    2cb4:	a0 2d       	mov	r26, r0
    2cb6:	0b 01       	movw	r0, r22
    2cb8:	b9 01       	movw	r22, r18
    2cba:	90 01       	movw	r18, r0
    2cbc:	0c 01       	movw	r0, r24
    2cbe:	ca 01       	movw	r24, r20
    2cc0:	a0 01       	movw	r20, r0
    2cc2:	11 24       	eor	r1, r1
    2cc4:	ff 27       	eor	r31, r31
    2cc6:	59 1b       	sub	r21, r25
    2cc8:	99 f0       	breq	.+38     	; 0x2cf0 <__addsf3x+0x5c>
    2cca:	59 3f       	cpi	r21, 0xF9	; 249
    2ccc:	50 f4       	brcc	.+20     	; 0x2ce2 <__addsf3x+0x4e>
    2cce:	50 3e       	cpi	r21, 0xE0	; 224
    2cd0:	68 f1       	brcs	.+90     	; 0x2d2c <__addsf3x+0x98>
    2cd2:	1a 16       	cp	r1, r26
    2cd4:	f0 40       	sbci	r31, 0x00	; 0
    2cd6:	a2 2f       	mov	r26, r18
    2cd8:	23 2f       	mov	r18, r19
    2cda:	34 2f       	mov	r19, r20
    2cdc:	44 27       	eor	r20, r20
    2cde:	58 5f       	subi	r21, 0xF8	; 248
    2ce0:	f3 cf       	rjmp	.-26     	; 0x2cc8 <__addsf3x+0x34>
    2ce2:	46 95       	lsr	r20
    2ce4:	37 95       	ror	r19
    2ce6:	27 95       	ror	r18
    2ce8:	a7 95       	ror	r26
    2cea:	f0 40       	sbci	r31, 0x00	; 0
    2cec:	53 95       	inc	r21
    2cee:	c9 f7       	brne	.-14     	; 0x2ce2 <__addsf3x+0x4e>
    2cf0:	7e f4       	brtc	.+30     	; 0x2d10 <__addsf3x+0x7c>
    2cf2:	1f 16       	cp	r1, r31
    2cf4:	ba 0b       	sbc	r27, r26
    2cf6:	62 0b       	sbc	r22, r18
    2cf8:	73 0b       	sbc	r23, r19
    2cfa:	84 0b       	sbc	r24, r20
    2cfc:	ba f0       	brmi	.+46     	; 0x2d2c <__addsf3x+0x98>
    2cfe:	91 50       	subi	r25, 0x01	; 1
    2d00:	a1 f0       	breq	.+40     	; 0x2d2a <__addsf3x+0x96>
    2d02:	ff 0f       	add	r31, r31
    2d04:	bb 1f       	adc	r27, r27
    2d06:	66 1f       	adc	r22, r22
    2d08:	77 1f       	adc	r23, r23
    2d0a:	88 1f       	adc	r24, r24
    2d0c:	c2 f7       	brpl	.-16     	; 0x2cfe <__addsf3x+0x6a>
    2d0e:	0e c0       	rjmp	.+28     	; 0x2d2c <__addsf3x+0x98>
    2d10:	ba 0f       	add	r27, r26
    2d12:	62 1f       	adc	r22, r18
    2d14:	73 1f       	adc	r23, r19
    2d16:	84 1f       	adc	r24, r20
    2d18:	48 f4       	brcc	.+18     	; 0x2d2c <__addsf3x+0x98>
    2d1a:	87 95       	ror	r24
    2d1c:	77 95       	ror	r23
    2d1e:	67 95       	ror	r22
    2d20:	b7 95       	ror	r27
    2d22:	f7 95       	ror	r31
    2d24:	9e 3f       	cpi	r25, 0xFE	; 254
    2d26:	08 f0       	brcs	.+2      	; 0x2d2a <__addsf3x+0x96>
    2d28:	b3 cf       	rjmp	.-154    	; 0x2c90 <__addsf3+0x1e>
    2d2a:	93 95       	inc	r25
    2d2c:	88 0f       	add	r24, r24
    2d2e:	08 f0       	brcs	.+2      	; 0x2d32 <__addsf3x+0x9e>
    2d30:	99 27       	eor	r25, r25
    2d32:	ee 0f       	add	r30, r30
    2d34:	97 95       	ror	r25
    2d36:	87 95       	ror	r24
    2d38:	08 95       	ret
    2d3a:	8d d1       	rcall	.+794    	; 0x3056 <__fp_pscA>
    2d3c:	58 f0       	brcs	.+22     	; 0x2d54 <__addsf3x+0xc0>
    2d3e:	80 e8       	ldi	r24, 0x80	; 128
    2d40:	91 e0       	ldi	r25, 0x01	; 1
    2d42:	09 f4       	brne	.+2      	; 0x2d46 <__addsf3x+0xb2>
    2d44:	9e ef       	ldi	r25, 0xFE	; 254
    2d46:	8e d1       	rcall	.+796    	; 0x3064 <__fp_pscB>
    2d48:	28 f0       	brcs	.+10     	; 0x2d54 <__addsf3x+0xc0>
    2d4a:	40 e8       	ldi	r20, 0x80	; 128
    2d4c:	51 e0       	ldi	r21, 0x01	; 1
    2d4e:	59 f4       	brne	.+22     	; 0x2d66 <atan2+0xe>
    2d50:	5e ef       	ldi	r21, 0xFE	; 254
    2d52:	09 c0       	rjmp	.+18     	; 0x2d66 <atan2+0xe>
    2d54:	58 c1       	rjmp	.+688    	; 0x3006 <__fp_nan>
    2d56:	c0 c1       	rjmp	.+896    	; 0x30d8 <__fp_zero>

00002d58 <atan2>:
    2d58:	e9 2f       	mov	r30, r25
    2d5a:	e0 78       	andi	r30, 0x80	; 128
    2d5c:	9b d1       	rcall	.+822    	; 0x3094 <__fp_split3>
    2d5e:	68 f3       	brcs	.-38     	; 0x2d3a <__addsf3x+0xa6>
    2d60:	09 2e       	mov	r0, r25
    2d62:	05 2a       	or	r0, r21
    2d64:	c1 f3       	breq	.-16     	; 0x2d56 <__addsf3x+0xc2>
    2d66:	26 17       	cp	r18, r22
    2d68:	37 07       	cpc	r19, r23
    2d6a:	48 07       	cpc	r20, r24
    2d6c:	59 07       	cpc	r21, r25
    2d6e:	38 f0       	brcs	.+14     	; 0x2d7e <atan2+0x26>
    2d70:	0e 2e       	mov	r0, r30
    2d72:	07 f8       	bld	r0, 7
    2d74:	e0 25       	eor	r30, r0
    2d76:	69 f0       	breq	.+26     	; 0x2d92 <atan2+0x3a>
    2d78:	e0 25       	eor	r30, r0
    2d7a:	e0 64       	ori	r30, 0x40	; 64
    2d7c:	0a c0       	rjmp	.+20     	; 0x2d92 <atan2+0x3a>
    2d7e:	ef 63       	ori	r30, 0x3F	; 63
    2d80:	07 f8       	bld	r0, 7
    2d82:	00 94       	com	r0
    2d84:	07 fa       	bst	r0, 7
    2d86:	db 01       	movw	r26, r22
    2d88:	b9 01       	movw	r22, r18
    2d8a:	9d 01       	movw	r18, r26
    2d8c:	dc 01       	movw	r26, r24
    2d8e:	ca 01       	movw	r24, r20
    2d90:	ad 01       	movw	r20, r26
    2d92:	ef 93       	push	r30
    2d94:	47 d0       	rcall	.+142    	; 0x2e24 <__divsf3_pse>
    2d96:	6d d1       	rcall	.+730    	; 0x3072 <__fp_round>
    2d98:	0a d0       	rcall	.+20     	; 0x2dae <atan>
    2d9a:	5f 91       	pop	r21
    2d9c:	55 23       	and	r21, r21
    2d9e:	31 f0       	breq	.+12     	; 0x2dac <atan2+0x54>
    2da0:	2b ed       	ldi	r18, 0xDB	; 219
    2da2:	3f e0       	ldi	r19, 0x0F	; 15
    2da4:	49 e4       	ldi	r20, 0x49	; 73
    2da6:	50 fd       	sbrc	r21, 0
    2da8:	49 ec       	ldi	r20, 0xC9	; 201
    2daa:	63 cf       	rjmp	.-314    	; 0x2c72 <__addsf3>
    2dac:	08 95       	ret

00002dae <atan>:
    2dae:	df 93       	push	r29
    2db0:	dd 27       	eor	r29, r29
    2db2:	b9 2f       	mov	r27, r25
    2db4:	bf 77       	andi	r27, 0x7F	; 127
    2db6:	40 e8       	ldi	r20, 0x80	; 128
    2db8:	5f e3       	ldi	r21, 0x3F	; 63
    2dba:	16 16       	cp	r1, r22
    2dbc:	17 06       	cpc	r1, r23
    2dbe:	48 07       	cpc	r20, r24
    2dc0:	5b 07       	cpc	r21, r27
    2dc2:	10 f4       	brcc	.+4      	; 0x2dc8 <atan+0x1a>
    2dc4:	d9 2f       	mov	r29, r25
    2dc6:	8f d1       	rcall	.+798    	; 0x30e6 <inverse>
    2dc8:	9f 93       	push	r25
    2dca:	8f 93       	push	r24
    2dcc:	7f 93       	push	r23
    2dce:	6f 93       	push	r22
    2dd0:	82 d2       	rcall	.+1284   	; 0x32d6 <square>
    2dd2:	e6 e7       	ldi	r30, 0x76	; 118
    2dd4:	f2 e0       	ldi	r31, 0x02	; 2
    2dd6:	1a d1       	rcall	.+564    	; 0x300c <__fp_powser>
    2dd8:	4c d1       	rcall	.+664    	; 0x3072 <__fp_round>
    2dda:	2f 91       	pop	r18
    2ddc:	3f 91       	pop	r19
    2dde:	4f 91       	pop	r20
    2de0:	5f 91       	pop	r21
    2de2:	94 d1       	rcall	.+808    	; 0x310c <__mulsf3x>
    2de4:	dd 23       	and	r29, r29
    2de6:	49 f0       	breq	.+18     	; 0x2dfa <atan+0x4c>
    2de8:	90 58       	subi	r25, 0x80	; 128
    2dea:	a2 ea       	ldi	r26, 0xA2	; 162
    2dec:	2a ed       	ldi	r18, 0xDA	; 218
    2dee:	3f e0       	ldi	r19, 0x0F	; 15
    2df0:	49 ec       	ldi	r20, 0xC9	; 201
    2df2:	5f e3       	ldi	r21, 0x3F	; 63
    2df4:	d0 78       	andi	r29, 0x80	; 128
    2df6:	5d 27       	eor	r21, r29
    2df8:	4d df       	rcall	.-358    	; 0x2c94 <__addsf3x>
    2dfa:	df 91       	pop	r29
    2dfc:	3a c1       	rjmp	.+628    	; 0x3072 <__fp_round>

00002dfe <__cmpsf2>:
    2dfe:	d9 d0       	rcall	.+434    	; 0x2fb2 <__fp_cmp>
    2e00:	08 f4       	brcc	.+2      	; 0x2e04 <__cmpsf2+0x6>
    2e02:	81 e0       	ldi	r24, 0x01	; 1
    2e04:	08 95       	ret

00002e06 <__divsf3>:
    2e06:	0c d0       	rcall	.+24     	; 0x2e20 <__divsf3x>
    2e08:	34 c1       	rjmp	.+616    	; 0x3072 <__fp_round>
    2e0a:	2c d1       	rcall	.+600    	; 0x3064 <__fp_pscB>
    2e0c:	40 f0       	brcs	.+16     	; 0x2e1e <__divsf3+0x18>
    2e0e:	23 d1       	rcall	.+582    	; 0x3056 <__fp_pscA>
    2e10:	30 f0       	brcs	.+12     	; 0x2e1e <__divsf3+0x18>
    2e12:	21 f4       	brne	.+8      	; 0x2e1c <__divsf3+0x16>
    2e14:	5f 3f       	cpi	r21, 0xFF	; 255
    2e16:	19 f0       	breq	.+6      	; 0x2e1e <__divsf3+0x18>
    2e18:	f0 c0       	rjmp	.+480    	; 0x2ffa <__fp_inf>
    2e1a:	51 11       	cpse	r21, r1
    2e1c:	5e c1       	rjmp	.+700    	; 0x30da <__fp_szero>
    2e1e:	f3 c0       	rjmp	.+486    	; 0x3006 <__fp_nan>

00002e20 <__divsf3x>:
    2e20:	39 d1       	rcall	.+626    	; 0x3094 <__fp_split3>
    2e22:	98 f3       	brcs	.-26     	; 0x2e0a <__divsf3+0x4>

00002e24 <__divsf3_pse>:
    2e24:	99 23       	and	r25, r25
    2e26:	c9 f3       	breq	.-14     	; 0x2e1a <__divsf3+0x14>
    2e28:	55 23       	and	r21, r21
    2e2a:	b1 f3       	breq	.-20     	; 0x2e18 <__divsf3+0x12>
    2e2c:	95 1b       	sub	r25, r21
    2e2e:	55 0b       	sbc	r21, r21
    2e30:	bb 27       	eor	r27, r27
    2e32:	aa 27       	eor	r26, r26
    2e34:	62 17       	cp	r22, r18
    2e36:	73 07       	cpc	r23, r19
    2e38:	84 07       	cpc	r24, r20
    2e3a:	38 f0       	brcs	.+14     	; 0x2e4a <__divsf3_pse+0x26>
    2e3c:	9f 5f       	subi	r25, 0xFF	; 255
    2e3e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e40:	22 0f       	add	r18, r18
    2e42:	33 1f       	adc	r19, r19
    2e44:	44 1f       	adc	r20, r20
    2e46:	aa 1f       	adc	r26, r26
    2e48:	a9 f3       	breq	.-22     	; 0x2e34 <__divsf3_pse+0x10>
    2e4a:	33 d0       	rcall	.+102    	; 0x2eb2 <__divsf3_pse+0x8e>
    2e4c:	0e 2e       	mov	r0, r30
    2e4e:	3a f0       	brmi	.+14     	; 0x2e5e <__divsf3_pse+0x3a>
    2e50:	e0 e8       	ldi	r30, 0x80	; 128
    2e52:	30 d0       	rcall	.+96     	; 0x2eb4 <__divsf3_pse+0x90>
    2e54:	91 50       	subi	r25, 0x01	; 1
    2e56:	50 40       	sbci	r21, 0x00	; 0
    2e58:	e6 95       	lsr	r30
    2e5a:	00 1c       	adc	r0, r0
    2e5c:	ca f7       	brpl	.-14     	; 0x2e50 <__divsf3_pse+0x2c>
    2e5e:	29 d0       	rcall	.+82     	; 0x2eb2 <__divsf3_pse+0x8e>
    2e60:	fe 2f       	mov	r31, r30
    2e62:	27 d0       	rcall	.+78     	; 0x2eb2 <__divsf3_pse+0x8e>
    2e64:	66 0f       	add	r22, r22
    2e66:	77 1f       	adc	r23, r23
    2e68:	88 1f       	adc	r24, r24
    2e6a:	bb 1f       	adc	r27, r27
    2e6c:	26 17       	cp	r18, r22
    2e6e:	37 07       	cpc	r19, r23
    2e70:	48 07       	cpc	r20, r24
    2e72:	ab 07       	cpc	r26, r27
    2e74:	b0 e8       	ldi	r27, 0x80	; 128
    2e76:	09 f0       	breq	.+2      	; 0x2e7a <__divsf3_pse+0x56>
    2e78:	bb 0b       	sbc	r27, r27
    2e7a:	80 2d       	mov	r24, r0
    2e7c:	bf 01       	movw	r22, r30
    2e7e:	ff 27       	eor	r31, r31
    2e80:	93 58       	subi	r25, 0x83	; 131
    2e82:	5f 4f       	sbci	r21, 0xFF	; 255
    2e84:	2a f0       	brmi	.+10     	; 0x2e90 <__divsf3_pse+0x6c>
    2e86:	9e 3f       	cpi	r25, 0xFE	; 254
    2e88:	51 05       	cpc	r21, r1
    2e8a:	68 f0       	brcs	.+26     	; 0x2ea6 <__divsf3_pse+0x82>
    2e8c:	b6 c0       	rjmp	.+364    	; 0x2ffa <__fp_inf>
    2e8e:	25 c1       	rjmp	.+586    	; 0x30da <__fp_szero>
    2e90:	5f 3f       	cpi	r21, 0xFF	; 255
    2e92:	ec f3       	brlt	.-6      	; 0x2e8e <__divsf3_pse+0x6a>
    2e94:	98 3e       	cpi	r25, 0xE8	; 232
    2e96:	dc f3       	brlt	.-10     	; 0x2e8e <__divsf3_pse+0x6a>
    2e98:	86 95       	lsr	r24
    2e9a:	77 95       	ror	r23
    2e9c:	67 95       	ror	r22
    2e9e:	b7 95       	ror	r27
    2ea0:	f7 95       	ror	r31
    2ea2:	9f 5f       	subi	r25, 0xFF	; 255
    2ea4:	c9 f7       	brne	.-14     	; 0x2e98 <__divsf3_pse+0x74>
    2ea6:	88 0f       	add	r24, r24
    2ea8:	91 1d       	adc	r25, r1
    2eaa:	96 95       	lsr	r25
    2eac:	87 95       	ror	r24
    2eae:	97 f9       	bld	r25, 7
    2eb0:	08 95       	ret
    2eb2:	e1 e0       	ldi	r30, 0x01	; 1
    2eb4:	66 0f       	add	r22, r22
    2eb6:	77 1f       	adc	r23, r23
    2eb8:	88 1f       	adc	r24, r24
    2eba:	bb 1f       	adc	r27, r27
    2ebc:	62 17       	cp	r22, r18
    2ebe:	73 07       	cpc	r23, r19
    2ec0:	84 07       	cpc	r24, r20
    2ec2:	ba 07       	cpc	r27, r26
    2ec4:	20 f0       	brcs	.+8      	; 0x2ece <__divsf3_pse+0xaa>
    2ec6:	62 1b       	sub	r22, r18
    2ec8:	73 0b       	sbc	r23, r19
    2eca:	84 0b       	sbc	r24, r20
    2ecc:	ba 0b       	sbc	r27, r26
    2ece:	ee 1f       	adc	r30, r30
    2ed0:	88 f7       	brcc	.-30     	; 0x2eb4 <__divsf3_pse+0x90>
    2ed2:	e0 95       	com	r30
    2ed4:	08 95       	ret

00002ed6 <__fixsfsi>:
    2ed6:	04 d0       	rcall	.+8      	; 0x2ee0 <__fixunssfsi>
    2ed8:	68 94       	set
    2eda:	b1 11       	cpse	r27, r1
    2edc:	fe c0       	rjmp	.+508    	; 0x30da <__fp_szero>
    2ede:	08 95       	ret

00002ee0 <__fixunssfsi>:
    2ee0:	e1 d0       	rcall	.+450    	; 0x30a4 <__fp_splitA>
    2ee2:	88 f0       	brcs	.+34     	; 0x2f06 <__fixunssfsi+0x26>
    2ee4:	9f 57       	subi	r25, 0x7F	; 127
    2ee6:	90 f0       	brcs	.+36     	; 0x2f0c <__fixunssfsi+0x2c>
    2ee8:	b9 2f       	mov	r27, r25
    2eea:	99 27       	eor	r25, r25
    2eec:	b7 51       	subi	r27, 0x17	; 23
    2eee:	a0 f0       	brcs	.+40     	; 0x2f18 <__fixunssfsi+0x38>
    2ef0:	d1 f0       	breq	.+52     	; 0x2f26 <__fixunssfsi+0x46>
    2ef2:	66 0f       	add	r22, r22
    2ef4:	77 1f       	adc	r23, r23
    2ef6:	88 1f       	adc	r24, r24
    2ef8:	99 1f       	adc	r25, r25
    2efa:	1a f0       	brmi	.+6      	; 0x2f02 <__fixunssfsi+0x22>
    2efc:	ba 95       	dec	r27
    2efe:	c9 f7       	brne	.-14     	; 0x2ef2 <__fixunssfsi+0x12>
    2f00:	12 c0       	rjmp	.+36     	; 0x2f26 <__fixunssfsi+0x46>
    2f02:	b1 30       	cpi	r27, 0x01	; 1
    2f04:	81 f0       	breq	.+32     	; 0x2f26 <__fixunssfsi+0x46>
    2f06:	e8 d0       	rcall	.+464    	; 0x30d8 <__fp_zero>
    2f08:	b1 e0       	ldi	r27, 0x01	; 1
    2f0a:	08 95       	ret
    2f0c:	e5 c0       	rjmp	.+458    	; 0x30d8 <__fp_zero>
    2f0e:	67 2f       	mov	r22, r23
    2f10:	78 2f       	mov	r23, r24
    2f12:	88 27       	eor	r24, r24
    2f14:	b8 5f       	subi	r27, 0xF8	; 248
    2f16:	39 f0       	breq	.+14     	; 0x2f26 <__fixunssfsi+0x46>
    2f18:	b9 3f       	cpi	r27, 0xF9	; 249
    2f1a:	cc f3       	brlt	.-14     	; 0x2f0e <__fixunssfsi+0x2e>
    2f1c:	86 95       	lsr	r24
    2f1e:	77 95       	ror	r23
    2f20:	67 95       	ror	r22
    2f22:	b3 95       	inc	r27
    2f24:	d9 f7       	brne	.-10     	; 0x2f1c <__fixunssfsi+0x3c>
    2f26:	3e f4       	brtc	.+14     	; 0x2f36 <__fixunssfsi+0x56>
    2f28:	90 95       	com	r25
    2f2a:	80 95       	com	r24
    2f2c:	70 95       	com	r23
    2f2e:	61 95       	neg	r22
    2f30:	7f 4f       	sbci	r23, 0xFF	; 255
    2f32:	8f 4f       	sbci	r24, 0xFF	; 255
    2f34:	9f 4f       	sbci	r25, 0xFF	; 255
    2f36:	08 95       	ret

00002f38 <__floatunsisf>:
    2f38:	e8 94       	clt
    2f3a:	09 c0       	rjmp	.+18     	; 0x2f4e <__floatsisf+0x12>

00002f3c <__floatsisf>:
    2f3c:	97 fb       	bst	r25, 7
    2f3e:	3e f4       	brtc	.+14     	; 0x2f4e <__floatsisf+0x12>
    2f40:	90 95       	com	r25
    2f42:	80 95       	com	r24
    2f44:	70 95       	com	r23
    2f46:	61 95       	neg	r22
    2f48:	7f 4f       	sbci	r23, 0xFF	; 255
    2f4a:	8f 4f       	sbci	r24, 0xFF	; 255
    2f4c:	9f 4f       	sbci	r25, 0xFF	; 255
    2f4e:	99 23       	and	r25, r25
    2f50:	a9 f0       	breq	.+42     	; 0x2f7c <__floatsisf+0x40>
    2f52:	f9 2f       	mov	r31, r25
    2f54:	96 e9       	ldi	r25, 0x96	; 150
    2f56:	bb 27       	eor	r27, r27
    2f58:	93 95       	inc	r25
    2f5a:	f6 95       	lsr	r31
    2f5c:	87 95       	ror	r24
    2f5e:	77 95       	ror	r23
    2f60:	67 95       	ror	r22
    2f62:	b7 95       	ror	r27
    2f64:	f1 11       	cpse	r31, r1
    2f66:	f8 cf       	rjmp	.-16     	; 0x2f58 <__floatsisf+0x1c>
    2f68:	fa f4       	brpl	.+62     	; 0x2fa8 <__floatsisf+0x6c>
    2f6a:	bb 0f       	add	r27, r27
    2f6c:	11 f4       	brne	.+4      	; 0x2f72 <__floatsisf+0x36>
    2f6e:	60 ff       	sbrs	r22, 0
    2f70:	1b c0       	rjmp	.+54     	; 0x2fa8 <__floatsisf+0x6c>
    2f72:	6f 5f       	subi	r22, 0xFF	; 255
    2f74:	7f 4f       	sbci	r23, 0xFF	; 255
    2f76:	8f 4f       	sbci	r24, 0xFF	; 255
    2f78:	9f 4f       	sbci	r25, 0xFF	; 255
    2f7a:	16 c0       	rjmp	.+44     	; 0x2fa8 <__floatsisf+0x6c>
    2f7c:	88 23       	and	r24, r24
    2f7e:	11 f0       	breq	.+4      	; 0x2f84 <__floatsisf+0x48>
    2f80:	96 e9       	ldi	r25, 0x96	; 150
    2f82:	11 c0       	rjmp	.+34     	; 0x2fa6 <__floatsisf+0x6a>
    2f84:	77 23       	and	r23, r23
    2f86:	21 f0       	breq	.+8      	; 0x2f90 <__floatsisf+0x54>
    2f88:	9e e8       	ldi	r25, 0x8E	; 142
    2f8a:	87 2f       	mov	r24, r23
    2f8c:	76 2f       	mov	r23, r22
    2f8e:	05 c0       	rjmp	.+10     	; 0x2f9a <__floatsisf+0x5e>
    2f90:	66 23       	and	r22, r22
    2f92:	71 f0       	breq	.+28     	; 0x2fb0 <__floatsisf+0x74>
    2f94:	96 e8       	ldi	r25, 0x86	; 134
    2f96:	86 2f       	mov	r24, r22
    2f98:	70 e0       	ldi	r23, 0x00	; 0
    2f9a:	60 e0       	ldi	r22, 0x00	; 0
    2f9c:	2a f0       	brmi	.+10     	; 0x2fa8 <__floatsisf+0x6c>
    2f9e:	9a 95       	dec	r25
    2fa0:	66 0f       	add	r22, r22
    2fa2:	77 1f       	adc	r23, r23
    2fa4:	88 1f       	adc	r24, r24
    2fa6:	da f7       	brpl	.-10     	; 0x2f9e <__floatsisf+0x62>
    2fa8:	88 0f       	add	r24, r24
    2faa:	96 95       	lsr	r25
    2fac:	87 95       	ror	r24
    2fae:	97 f9       	bld	r25, 7
    2fb0:	08 95       	ret

00002fb2 <__fp_cmp>:
    2fb2:	99 0f       	add	r25, r25
    2fb4:	00 08       	sbc	r0, r0
    2fb6:	55 0f       	add	r21, r21
    2fb8:	aa 0b       	sbc	r26, r26
    2fba:	e0 e8       	ldi	r30, 0x80	; 128
    2fbc:	fe ef       	ldi	r31, 0xFE	; 254
    2fbe:	16 16       	cp	r1, r22
    2fc0:	17 06       	cpc	r1, r23
    2fc2:	e8 07       	cpc	r30, r24
    2fc4:	f9 07       	cpc	r31, r25
    2fc6:	c0 f0       	brcs	.+48     	; 0x2ff8 <__fp_cmp+0x46>
    2fc8:	12 16       	cp	r1, r18
    2fca:	13 06       	cpc	r1, r19
    2fcc:	e4 07       	cpc	r30, r20
    2fce:	f5 07       	cpc	r31, r21
    2fd0:	98 f0       	brcs	.+38     	; 0x2ff8 <__fp_cmp+0x46>
    2fd2:	62 1b       	sub	r22, r18
    2fd4:	73 0b       	sbc	r23, r19
    2fd6:	84 0b       	sbc	r24, r20
    2fd8:	95 0b       	sbc	r25, r21
    2fda:	39 f4       	brne	.+14     	; 0x2fea <__fp_cmp+0x38>
    2fdc:	0a 26       	eor	r0, r26
    2fde:	61 f0       	breq	.+24     	; 0x2ff8 <__fp_cmp+0x46>
    2fe0:	23 2b       	or	r18, r19
    2fe2:	24 2b       	or	r18, r20
    2fe4:	25 2b       	or	r18, r21
    2fe6:	21 f4       	brne	.+8      	; 0x2ff0 <__fp_cmp+0x3e>
    2fe8:	08 95       	ret
    2fea:	0a 26       	eor	r0, r26
    2fec:	09 f4       	brne	.+2      	; 0x2ff0 <__fp_cmp+0x3e>
    2fee:	a1 40       	sbci	r26, 0x01	; 1
    2ff0:	a6 95       	lsr	r26
    2ff2:	8f ef       	ldi	r24, 0xFF	; 255
    2ff4:	81 1d       	adc	r24, r1
    2ff6:	81 1d       	adc	r24, r1
    2ff8:	08 95       	ret

00002ffa <__fp_inf>:
    2ffa:	97 f9       	bld	r25, 7
    2ffc:	9f 67       	ori	r25, 0x7F	; 127
    2ffe:	80 e8       	ldi	r24, 0x80	; 128
    3000:	70 e0       	ldi	r23, 0x00	; 0
    3002:	60 e0       	ldi	r22, 0x00	; 0
    3004:	08 95       	ret

00003006 <__fp_nan>:
    3006:	9f ef       	ldi	r25, 0xFF	; 255
    3008:	80 ec       	ldi	r24, 0xC0	; 192
    300a:	08 95       	ret

0000300c <__fp_powser>:
    300c:	df 93       	push	r29
    300e:	cf 93       	push	r28
    3010:	1f 93       	push	r17
    3012:	0f 93       	push	r16
    3014:	ff 92       	push	r15
    3016:	ef 92       	push	r14
    3018:	df 92       	push	r13
    301a:	7b 01       	movw	r14, r22
    301c:	8c 01       	movw	r16, r24
    301e:	68 94       	set
    3020:	05 c0       	rjmp	.+10     	; 0x302c <__fp_powser+0x20>
    3022:	da 2e       	mov	r13, r26
    3024:	ef 01       	movw	r28, r30
    3026:	72 d0       	rcall	.+228    	; 0x310c <__mulsf3x>
    3028:	fe 01       	movw	r30, r28
    302a:	e8 94       	clt
    302c:	a5 91       	lpm	r26, Z+
    302e:	25 91       	lpm	r18, Z+
    3030:	35 91       	lpm	r19, Z+
    3032:	45 91       	lpm	r20, Z+
    3034:	55 91       	lpm	r21, Z+
    3036:	ae f3       	brts	.-22     	; 0x3022 <__fp_powser+0x16>
    3038:	ef 01       	movw	r28, r30
    303a:	2c de       	rcall	.-936    	; 0x2c94 <__addsf3x>
    303c:	fe 01       	movw	r30, r28
    303e:	97 01       	movw	r18, r14
    3040:	a8 01       	movw	r20, r16
    3042:	da 94       	dec	r13
    3044:	79 f7       	brne	.-34     	; 0x3024 <__fp_powser+0x18>
    3046:	df 90       	pop	r13
    3048:	ef 90       	pop	r14
    304a:	ff 90       	pop	r15
    304c:	0f 91       	pop	r16
    304e:	1f 91       	pop	r17
    3050:	cf 91       	pop	r28
    3052:	df 91       	pop	r29
    3054:	08 95       	ret

00003056 <__fp_pscA>:
    3056:	00 24       	eor	r0, r0
    3058:	0a 94       	dec	r0
    305a:	16 16       	cp	r1, r22
    305c:	17 06       	cpc	r1, r23
    305e:	18 06       	cpc	r1, r24
    3060:	09 06       	cpc	r0, r25
    3062:	08 95       	ret

00003064 <__fp_pscB>:
    3064:	00 24       	eor	r0, r0
    3066:	0a 94       	dec	r0
    3068:	12 16       	cp	r1, r18
    306a:	13 06       	cpc	r1, r19
    306c:	14 06       	cpc	r1, r20
    306e:	05 06       	cpc	r0, r21
    3070:	08 95       	ret

00003072 <__fp_round>:
    3072:	09 2e       	mov	r0, r25
    3074:	03 94       	inc	r0
    3076:	00 0c       	add	r0, r0
    3078:	11 f4       	brne	.+4      	; 0x307e <__fp_round+0xc>
    307a:	88 23       	and	r24, r24
    307c:	52 f0       	brmi	.+20     	; 0x3092 <__fp_round+0x20>
    307e:	bb 0f       	add	r27, r27
    3080:	40 f4       	brcc	.+16     	; 0x3092 <__fp_round+0x20>
    3082:	bf 2b       	or	r27, r31
    3084:	11 f4       	brne	.+4      	; 0x308a <__fp_round+0x18>
    3086:	60 ff       	sbrs	r22, 0
    3088:	04 c0       	rjmp	.+8      	; 0x3092 <__fp_round+0x20>
    308a:	6f 5f       	subi	r22, 0xFF	; 255
    308c:	7f 4f       	sbci	r23, 0xFF	; 255
    308e:	8f 4f       	sbci	r24, 0xFF	; 255
    3090:	9f 4f       	sbci	r25, 0xFF	; 255
    3092:	08 95       	ret

00003094 <__fp_split3>:
    3094:	57 fd       	sbrc	r21, 7
    3096:	90 58       	subi	r25, 0x80	; 128
    3098:	44 0f       	add	r20, r20
    309a:	55 1f       	adc	r21, r21
    309c:	59 f0       	breq	.+22     	; 0x30b4 <__fp_splitA+0x10>
    309e:	5f 3f       	cpi	r21, 0xFF	; 255
    30a0:	71 f0       	breq	.+28     	; 0x30be <__fp_splitA+0x1a>
    30a2:	47 95       	ror	r20

000030a4 <__fp_splitA>:
    30a4:	88 0f       	add	r24, r24
    30a6:	97 fb       	bst	r25, 7
    30a8:	99 1f       	adc	r25, r25
    30aa:	61 f0       	breq	.+24     	; 0x30c4 <__fp_splitA+0x20>
    30ac:	9f 3f       	cpi	r25, 0xFF	; 255
    30ae:	79 f0       	breq	.+30     	; 0x30ce <__fp_splitA+0x2a>
    30b0:	87 95       	ror	r24
    30b2:	08 95       	ret
    30b4:	12 16       	cp	r1, r18
    30b6:	13 06       	cpc	r1, r19
    30b8:	14 06       	cpc	r1, r20
    30ba:	55 1f       	adc	r21, r21
    30bc:	f2 cf       	rjmp	.-28     	; 0x30a2 <__fp_split3+0xe>
    30be:	46 95       	lsr	r20
    30c0:	f1 df       	rcall	.-30     	; 0x30a4 <__fp_splitA>
    30c2:	08 c0       	rjmp	.+16     	; 0x30d4 <__fp_splitA+0x30>
    30c4:	16 16       	cp	r1, r22
    30c6:	17 06       	cpc	r1, r23
    30c8:	18 06       	cpc	r1, r24
    30ca:	99 1f       	adc	r25, r25
    30cc:	f1 cf       	rjmp	.-30     	; 0x30b0 <__fp_splitA+0xc>
    30ce:	86 95       	lsr	r24
    30d0:	71 05       	cpc	r23, r1
    30d2:	61 05       	cpc	r22, r1
    30d4:	08 94       	sec
    30d6:	08 95       	ret

000030d8 <__fp_zero>:
    30d8:	e8 94       	clt

000030da <__fp_szero>:
    30da:	bb 27       	eor	r27, r27
    30dc:	66 27       	eor	r22, r22
    30de:	77 27       	eor	r23, r23
    30e0:	cb 01       	movw	r24, r22
    30e2:	97 f9       	bld	r25, 7
    30e4:	08 95       	ret

000030e6 <inverse>:
    30e6:	9b 01       	movw	r18, r22
    30e8:	ac 01       	movw	r20, r24
    30ea:	60 e0       	ldi	r22, 0x00	; 0
    30ec:	70 e0       	ldi	r23, 0x00	; 0
    30ee:	80 e8       	ldi	r24, 0x80	; 128
    30f0:	9f e3       	ldi	r25, 0x3F	; 63
    30f2:	89 ce       	rjmp	.-750    	; 0x2e06 <__divsf3>

000030f4 <__mulsf3>:
    30f4:	0b d0       	rcall	.+22     	; 0x310c <__mulsf3x>
    30f6:	bd cf       	rjmp	.-134    	; 0x3072 <__fp_round>
    30f8:	ae df       	rcall	.-164    	; 0x3056 <__fp_pscA>
    30fa:	28 f0       	brcs	.+10     	; 0x3106 <__mulsf3+0x12>
    30fc:	b3 df       	rcall	.-154    	; 0x3064 <__fp_pscB>
    30fe:	18 f0       	brcs	.+6      	; 0x3106 <__mulsf3+0x12>
    3100:	95 23       	and	r25, r21
    3102:	09 f0       	breq	.+2      	; 0x3106 <__mulsf3+0x12>
    3104:	7a cf       	rjmp	.-268    	; 0x2ffa <__fp_inf>
    3106:	7f cf       	rjmp	.-258    	; 0x3006 <__fp_nan>
    3108:	11 24       	eor	r1, r1
    310a:	e7 cf       	rjmp	.-50     	; 0x30da <__fp_szero>

0000310c <__mulsf3x>:
    310c:	c3 df       	rcall	.-122    	; 0x3094 <__fp_split3>
    310e:	a0 f3       	brcs	.-24     	; 0x30f8 <__mulsf3+0x4>

00003110 <__mulsf3_pse>:
    3110:	95 9f       	mul	r25, r21
    3112:	d1 f3       	breq	.-12     	; 0x3108 <__mulsf3+0x14>
    3114:	95 0f       	add	r25, r21
    3116:	50 e0       	ldi	r21, 0x00	; 0
    3118:	55 1f       	adc	r21, r21
    311a:	62 9f       	mul	r22, r18
    311c:	f0 01       	movw	r30, r0
    311e:	72 9f       	mul	r23, r18
    3120:	bb 27       	eor	r27, r27
    3122:	f0 0d       	add	r31, r0
    3124:	b1 1d       	adc	r27, r1
    3126:	63 9f       	mul	r22, r19
    3128:	aa 27       	eor	r26, r26
    312a:	f0 0d       	add	r31, r0
    312c:	b1 1d       	adc	r27, r1
    312e:	aa 1f       	adc	r26, r26
    3130:	64 9f       	mul	r22, r20
    3132:	66 27       	eor	r22, r22
    3134:	b0 0d       	add	r27, r0
    3136:	a1 1d       	adc	r26, r1
    3138:	66 1f       	adc	r22, r22
    313a:	82 9f       	mul	r24, r18
    313c:	22 27       	eor	r18, r18
    313e:	b0 0d       	add	r27, r0
    3140:	a1 1d       	adc	r26, r1
    3142:	62 1f       	adc	r22, r18
    3144:	73 9f       	mul	r23, r19
    3146:	b0 0d       	add	r27, r0
    3148:	a1 1d       	adc	r26, r1
    314a:	62 1f       	adc	r22, r18
    314c:	83 9f       	mul	r24, r19
    314e:	a0 0d       	add	r26, r0
    3150:	61 1d       	adc	r22, r1
    3152:	22 1f       	adc	r18, r18
    3154:	74 9f       	mul	r23, r20
    3156:	33 27       	eor	r19, r19
    3158:	a0 0d       	add	r26, r0
    315a:	61 1d       	adc	r22, r1
    315c:	23 1f       	adc	r18, r19
    315e:	84 9f       	mul	r24, r20
    3160:	60 0d       	add	r22, r0
    3162:	21 1d       	adc	r18, r1
    3164:	82 2f       	mov	r24, r18
    3166:	76 2f       	mov	r23, r22
    3168:	6a 2f       	mov	r22, r26
    316a:	11 24       	eor	r1, r1
    316c:	9f 57       	subi	r25, 0x7F	; 127
    316e:	50 40       	sbci	r21, 0x00	; 0
    3170:	8a f0       	brmi	.+34     	; 0x3194 <__mulsf3_pse+0x84>
    3172:	e1 f0       	breq	.+56     	; 0x31ac <__mulsf3_pse+0x9c>
    3174:	88 23       	and	r24, r24
    3176:	4a f0       	brmi	.+18     	; 0x318a <__mulsf3_pse+0x7a>
    3178:	ee 0f       	add	r30, r30
    317a:	ff 1f       	adc	r31, r31
    317c:	bb 1f       	adc	r27, r27
    317e:	66 1f       	adc	r22, r22
    3180:	77 1f       	adc	r23, r23
    3182:	88 1f       	adc	r24, r24
    3184:	91 50       	subi	r25, 0x01	; 1
    3186:	50 40       	sbci	r21, 0x00	; 0
    3188:	a9 f7       	brne	.-22     	; 0x3174 <__mulsf3_pse+0x64>
    318a:	9e 3f       	cpi	r25, 0xFE	; 254
    318c:	51 05       	cpc	r21, r1
    318e:	70 f0       	brcs	.+28     	; 0x31ac <__mulsf3_pse+0x9c>
    3190:	34 cf       	rjmp	.-408    	; 0x2ffa <__fp_inf>
    3192:	a3 cf       	rjmp	.-186    	; 0x30da <__fp_szero>
    3194:	5f 3f       	cpi	r21, 0xFF	; 255
    3196:	ec f3       	brlt	.-6      	; 0x3192 <__mulsf3_pse+0x82>
    3198:	98 3e       	cpi	r25, 0xE8	; 232
    319a:	dc f3       	brlt	.-10     	; 0x3192 <__mulsf3_pse+0x82>
    319c:	86 95       	lsr	r24
    319e:	77 95       	ror	r23
    31a0:	67 95       	ror	r22
    31a2:	b7 95       	ror	r27
    31a4:	f7 95       	ror	r31
    31a6:	e7 95       	ror	r30
    31a8:	9f 5f       	subi	r25, 0xFF	; 255
    31aa:	c1 f7       	brne	.-16     	; 0x319c <__mulsf3_pse+0x8c>
    31ac:	fe 2b       	or	r31, r30
    31ae:	88 0f       	add	r24, r24
    31b0:	91 1d       	adc	r25, r1
    31b2:	96 95       	lsr	r25
    31b4:	87 95       	ror	r24
    31b6:	97 f9       	bld	r25, 7
    31b8:	08 95       	ret

000031ba <pow>:
    31ba:	fa 01       	movw	r30, r20
    31bc:	ee 0f       	add	r30, r30
    31be:	ff 1f       	adc	r31, r31
    31c0:	30 96       	adiw	r30, 0x00	; 0
    31c2:	21 05       	cpc	r18, r1
    31c4:	31 05       	cpc	r19, r1
    31c6:	99 f1       	breq	.+102    	; 0x322e <pow+0x74>
    31c8:	61 15       	cp	r22, r1
    31ca:	71 05       	cpc	r23, r1
    31cc:	61 f4       	brne	.+24     	; 0x31e6 <pow+0x2c>
    31ce:	80 38       	cpi	r24, 0x80	; 128
    31d0:	bf e3       	ldi	r27, 0x3F	; 63
    31d2:	9b 07       	cpc	r25, r27
    31d4:	49 f1       	breq	.+82     	; 0x3228 <pow+0x6e>
    31d6:	68 94       	set
    31d8:	90 38       	cpi	r25, 0x80	; 128
    31da:	81 05       	cpc	r24, r1
    31dc:	61 f0       	breq	.+24     	; 0x31f6 <pow+0x3c>
    31de:	80 38       	cpi	r24, 0x80	; 128
    31e0:	bf ef       	ldi	r27, 0xFF	; 255
    31e2:	9b 07       	cpc	r25, r27
    31e4:	41 f0       	breq	.+16     	; 0x31f6 <pow+0x3c>
    31e6:	99 23       	and	r25, r25
    31e8:	42 f5       	brpl	.+80     	; 0x323a <pow+0x80>
    31ea:	ff 3f       	cpi	r31, 0xFF	; 255
    31ec:	e1 05       	cpc	r30, r1
    31ee:	31 05       	cpc	r19, r1
    31f0:	21 05       	cpc	r18, r1
    31f2:	11 f1       	breq	.+68     	; 0x3238 <pow+0x7e>
    31f4:	e8 94       	clt
    31f6:	08 94       	sec
    31f8:	e7 95       	ror	r30
    31fa:	d9 01       	movw	r26, r18
    31fc:	aa 23       	and	r26, r26
    31fe:	29 f4       	brne	.+10     	; 0x320a <pow+0x50>
    3200:	ab 2f       	mov	r26, r27
    3202:	be 2f       	mov	r27, r30
    3204:	f8 5f       	subi	r31, 0xF8	; 248
    3206:	d0 f3       	brcs	.-12     	; 0x31fc <pow+0x42>
    3208:	10 c0       	rjmp	.+32     	; 0x322a <pow+0x70>
    320a:	ff 5f       	subi	r31, 0xFF	; 255
    320c:	70 f4       	brcc	.+28     	; 0x322a <pow+0x70>
    320e:	a6 95       	lsr	r26
    3210:	e0 f7       	brcc	.-8      	; 0x320a <pow+0x50>
    3212:	f7 39       	cpi	r31, 0x97	; 151
    3214:	50 f0       	brcs	.+20     	; 0x322a <pow+0x70>
    3216:	19 f0       	breq	.+6      	; 0x321e <pow+0x64>
    3218:	ff 3a       	cpi	r31, 0xAF	; 175
    321a:	38 f4       	brcc	.+14     	; 0x322a <pow+0x70>
    321c:	9f 77       	andi	r25, 0x7F	; 127
    321e:	9f 93       	push	r25
    3220:	0c d0       	rcall	.+24     	; 0x323a <pow+0x80>
    3222:	0f 90       	pop	r0
    3224:	07 fc       	sbrc	r0, 7
    3226:	90 58       	subi	r25, 0x80	; 128
    3228:	08 95       	ret
    322a:	3e f0       	brts	.+14     	; 0x323a <pow+0x80>
    322c:	ec ce       	rjmp	.-552    	; 0x3006 <__fp_nan>
    322e:	60 e0       	ldi	r22, 0x00	; 0
    3230:	70 e0       	ldi	r23, 0x00	; 0
    3232:	80 e8       	ldi	r24, 0x80	; 128
    3234:	9f e3       	ldi	r25, 0x3F	; 63
    3236:	08 95       	ret
    3238:	4f e7       	ldi	r20, 0x7F	; 127
    323a:	9f 77       	andi	r25, 0x7F	; 127
    323c:	5f 93       	push	r21
    323e:	4f 93       	push	r20
    3240:	3f 93       	push	r19
    3242:	2f 93       	push	r18
    3244:	cc d0       	rcall	.+408    	; 0x33de <log>
    3246:	2f 91       	pop	r18
    3248:	3f 91       	pop	r19
    324a:	4f 91       	pop	r20
    324c:	5f 91       	pop	r21
    324e:	52 df       	rcall	.-348    	; 0x30f4 <__mulsf3>
    3250:	4a c0       	rjmp	.+148    	; 0x32e6 <exp>
    3252:	11 f4       	brne	.+4      	; 0x3258 <pow+0x9e>
    3254:	0e f4       	brtc	.+2      	; 0x3258 <pow+0x9e>
    3256:	d7 ce       	rjmp	.-594    	; 0x3006 <__fp_nan>
    3258:	72 c0       	rjmp	.+228    	; 0x333e <__fp_mpack>

0000325a <sqrt>:
    325a:	24 df       	rcall	.-440    	; 0x30a4 <__fp_splitA>
    325c:	d0 f3       	brcs	.-12     	; 0x3252 <pow+0x98>
    325e:	99 23       	and	r25, r25
    3260:	d9 f3       	breq	.-10     	; 0x3258 <pow+0x9e>
    3262:	ce f3       	brts	.-14     	; 0x3256 <pow+0x9c>
    3264:	9f 57       	subi	r25, 0x7F	; 127
    3266:	55 0b       	sbc	r21, r21
    3268:	87 ff       	sbrs	r24, 7
    326a:	77 d0       	rcall	.+238    	; 0x335a <__fp_norm2>
    326c:	00 24       	eor	r0, r0
    326e:	a0 e6       	ldi	r26, 0x60	; 96
    3270:	40 ea       	ldi	r20, 0xA0	; 160
    3272:	90 01       	movw	r18, r0
    3274:	80 58       	subi	r24, 0x80	; 128
    3276:	56 95       	lsr	r21
    3278:	97 95       	ror	r25
    327a:	28 f4       	brcc	.+10     	; 0x3286 <sqrt+0x2c>
    327c:	80 5c       	subi	r24, 0xC0	; 192
    327e:	66 0f       	add	r22, r22
    3280:	77 1f       	adc	r23, r23
    3282:	88 1f       	adc	r24, r24
    3284:	20 f0       	brcs	.+8      	; 0x328e <sqrt+0x34>
    3286:	26 17       	cp	r18, r22
    3288:	37 07       	cpc	r19, r23
    328a:	48 07       	cpc	r20, r24
    328c:	30 f4       	brcc	.+12     	; 0x329a <sqrt+0x40>
    328e:	62 1b       	sub	r22, r18
    3290:	73 0b       	sbc	r23, r19
    3292:	84 0b       	sbc	r24, r20
    3294:	20 29       	or	r18, r0
    3296:	31 29       	or	r19, r1
    3298:	4a 2b       	or	r20, r26
    329a:	a6 95       	lsr	r26
    329c:	17 94       	ror	r1
    329e:	07 94       	ror	r0
    32a0:	20 25       	eor	r18, r0
    32a2:	31 25       	eor	r19, r1
    32a4:	4a 27       	eor	r20, r26
    32a6:	58 f7       	brcc	.-42     	; 0x327e <sqrt+0x24>
    32a8:	66 0f       	add	r22, r22
    32aa:	77 1f       	adc	r23, r23
    32ac:	88 1f       	adc	r24, r24
    32ae:	20 f0       	brcs	.+8      	; 0x32b8 <sqrt+0x5e>
    32b0:	26 17       	cp	r18, r22
    32b2:	37 07       	cpc	r19, r23
    32b4:	48 07       	cpc	r20, r24
    32b6:	30 f4       	brcc	.+12     	; 0x32c4 <sqrt+0x6a>
    32b8:	62 0b       	sbc	r22, r18
    32ba:	73 0b       	sbc	r23, r19
    32bc:	84 0b       	sbc	r24, r20
    32be:	20 0d       	add	r18, r0
    32c0:	31 1d       	adc	r19, r1
    32c2:	41 1d       	adc	r20, r1
    32c4:	a0 95       	com	r26
    32c6:	81 f7       	brne	.-32     	; 0x32a8 <sqrt+0x4e>
    32c8:	b9 01       	movw	r22, r18
    32ca:	84 2f       	mov	r24, r20
    32cc:	91 58       	subi	r25, 0x81	; 129
    32ce:	88 0f       	add	r24, r24
    32d0:	96 95       	lsr	r25
    32d2:	87 95       	ror	r24
    32d4:	08 95       	ret

000032d6 <square>:
    32d6:	9b 01       	movw	r18, r22
    32d8:	ac 01       	movw	r20, r24
    32da:	0c cf       	rjmp	.-488    	; 0x30f4 <__mulsf3>
    32dc:	19 f4       	brne	.+6      	; 0x32e4 <square+0xe>
    32de:	0e f0       	brts	.+2      	; 0x32e2 <square+0xc>
    32e0:	8c ce       	rjmp	.-744    	; 0x2ffa <__fp_inf>
    32e2:	fa ce       	rjmp	.-524    	; 0x30d8 <__fp_zero>
    32e4:	90 ce       	rjmp	.-736    	; 0x3006 <__fp_nan>

000032e6 <exp>:
    32e6:	de de       	rcall	.-580    	; 0x30a4 <__fp_splitA>
    32e8:	c8 f3       	brcs	.-14     	; 0x32dc <square+0x6>
    32ea:	96 38       	cpi	r25, 0x86	; 134
    32ec:	c0 f7       	brcc	.-16     	; 0x32de <square+0x8>
    32ee:	07 f8       	bld	r0, 7
    32f0:	0f 92       	push	r0
    32f2:	e8 94       	clt
    32f4:	2b e3       	ldi	r18, 0x3B	; 59
    32f6:	3a ea       	ldi	r19, 0xAA	; 170
    32f8:	48 eb       	ldi	r20, 0xB8	; 184
    32fa:	5f e7       	ldi	r21, 0x7F	; 127
    32fc:	09 df       	rcall	.-494    	; 0x3110 <__mulsf3_pse>
    32fe:	0f 92       	push	r0
    3300:	0f 92       	push	r0
    3302:	0f 92       	push	r0
    3304:	4d b7       	in	r20, 0x3d	; 61
    3306:	5e b7       	in	r21, 0x3e	; 62
    3308:	0f 92       	push	r0
    330a:	a9 d0       	rcall	.+338    	; 0x345e <modf>
    330c:	e3 ea       	ldi	r30, 0xA3	; 163
    330e:	f2 e0       	ldi	r31, 0x02	; 2
    3310:	7d de       	rcall	.-774    	; 0x300c <__fp_powser>
    3312:	4f 91       	pop	r20
    3314:	5f 91       	pop	r21
    3316:	ef 91       	pop	r30
    3318:	ff 91       	pop	r31
    331a:	e5 95       	asr	r30
    331c:	ee 1f       	adc	r30, r30
    331e:	ff 1f       	adc	r31, r31
    3320:	49 f0       	breq	.+18     	; 0x3334 <exp+0x4e>
    3322:	fe 57       	subi	r31, 0x7E	; 126
    3324:	e0 68       	ori	r30, 0x80	; 128
    3326:	44 27       	eor	r20, r20
    3328:	ee 0f       	add	r30, r30
    332a:	44 1f       	adc	r20, r20
    332c:	fa 95       	dec	r31
    332e:	e1 f7       	brne	.-8      	; 0x3328 <exp+0x42>
    3330:	41 95       	neg	r20
    3332:	55 0b       	sbc	r21, r21
    3334:	1b d0       	rcall	.+54     	; 0x336c <ldexp>
    3336:	0f 90       	pop	r0
    3338:	07 fe       	sbrs	r0, 7
    333a:	d5 ce       	rjmp	.-598    	; 0x30e6 <inverse>
    333c:	08 95       	ret

0000333e <__fp_mpack>:
    333e:	9f 3f       	cpi	r25, 0xFF	; 255
    3340:	31 f0       	breq	.+12     	; 0x334e <__fp_mpack_finite+0xc>

00003342 <__fp_mpack_finite>:
    3342:	91 50       	subi	r25, 0x01	; 1
    3344:	20 f4       	brcc	.+8      	; 0x334e <__fp_mpack_finite+0xc>
    3346:	87 95       	ror	r24
    3348:	77 95       	ror	r23
    334a:	67 95       	ror	r22
    334c:	b7 95       	ror	r27
    334e:	88 0f       	add	r24, r24
    3350:	91 1d       	adc	r25, r1
    3352:	96 95       	lsr	r25
    3354:	87 95       	ror	r24
    3356:	97 f9       	bld	r25, 7
    3358:	08 95       	ret

0000335a <__fp_norm2>:
    335a:	91 50       	subi	r25, 0x01	; 1
    335c:	50 40       	sbci	r21, 0x00	; 0
    335e:	66 0f       	add	r22, r22
    3360:	77 1f       	adc	r23, r23
    3362:	88 1f       	adc	r24, r24
    3364:	d2 f7       	brpl	.-12     	; 0x335a <__fp_norm2>
    3366:	08 95       	ret
    3368:	48 ce       	rjmp	.-880    	; 0x2ffa <__fp_inf>
    336a:	e9 cf       	rjmp	.-46     	; 0x333e <__fp_mpack>

0000336c <ldexp>:
    336c:	9b de       	rcall	.-714    	; 0x30a4 <__fp_splitA>
    336e:	e8 f3       	brcs	.-6      	; 0x336a <__fp_norm2+0x10>
    3370:	99 23       	and	r25, r25
    3372:	d9 f3       	breq	.-10     	; 0x336a <__fp_norm2+0x10>
    3374:	94 0f       	add	r25, r20
    3376:	51 1d       	adc	r21, r1
    3378:	bb f3       	brvs	.-18     	; 0x3368 <__fp_norm2+0xe>
    337a:	91 50       	subi	r25, 0x01	; 1
    337c:	50 40       	sbci	r21, 0x00	; 0
    337e:	94 f0       	brlt	.+36     	; 0x33a4 <ldexp+0x38>
    3380:	59 f0       	breq	.+22     	; 0x3398 <ldexp+0x2c>
    3382:	88 23       	and	r24, r24
    3384:	32 f0       	brmi	.+12     	; 0x3392 <ldexp+0x26>
    3386:	66 0f       	add	r22, r22
    3388:	77 1f       	adc	r23, r23
    338a:	88 1f       	adc	r24, r24
    338c:	91 50       	subi	r25, 0x01	; 1
    338e:	50 40       	sbci	r21, 0x00	; 0
    3390:	c1 f7       	brne	.-16     	; 0x3382 <ldexp+0x16>
    3392:	9e 3f       	cpi	r25, 0xFE	; 254
    3394:	51 05       	cpc	r21, r1
    3396:	44 f7       	brge	.-48     	; 0x3368 <__fp_norm2+0xe>
    3398:	88 0f       	add	r24, r24
    339a:	91 1d       	adc	r25, r1
    339c:	96 95       	lsr	r25
    339e:	87 95       	ror	r24
    33a0:	97 f9       	bld	r25, 7
    33a2:	08 95       	ret
    33a4:	5f 3f       	cpi	r21, 0xFF	; 255
    33a6:	ac f0       	brlt	.+42     	; 0x33d2 <ldexp+0x66>
    33a8:	98 3e       	cpi	r25, 0xE8	; 232
    33aa:	9c f0       	brlt	.+38     	; 0x33d2 <ldexp+0x66>
    33ac:	bb 27       	eor	r27, r27
    33ae:	86 95       	lsr	r24
    33b0:	77 95       	ror	r23
    33b2:	67 95       	ror	r22
    33b4:	b7 95       	ror	r27
    33b6:	08 f4       	brcc	.+2      	; 0x33ba <ldexp+0x4e>
    33b8:	b1 60       	ori	r27, 0x01	; 1
    33ba:	93 95       	inc	r25
    33bc:	c1 f7       	brne	.-16     	; 0x33ae <ldexp+0x42>
    33be:	bb 0f       	add	r27, r27
    33c0:	58 f7       	brcc	.-42     	; 0x3398 <ldexp+0x2c>
    33c2:	11 f4       	brne	.+4      	; 0x33c8 <ldexp+0x5c>
    33c4:	60 ff       	sbrs	r22, 0
    33c6:	e8 cf       	rjmp	.-48     	; 0x3398 <ldexp+0x2c>
    33c8:	6f 5f       	subi	r22, 0xFF	; 255
    33ca:	7f 4f       	sbci	r23, 0xFF	; 255
    33cc:	8f 4f       	sbci	r24, 0xFF	; 255
    33ce:	9f 4f       	sbci	r25, 0xFF	; 255
    33d0:	e3 cf       	rjmp	.-58     	; 0x3398 <ldexp+0x2c>
    33d2:	83 ce       	rjmp	.-762    	; 0x30da <__fp_szero>
    33d4:	0e f0       	brts	.+2      	; 0x33d8 <ldexp+0x6c>
    33d6:	b3 cf       	rjmp	.-154    	; 0x333e <__fp_mpack>
    33d8:	16 ce       	rjmp	.-980    	; 0x3006 <__fp_nan>
    33da:	68 94       	set
    33dc:	0e ce       	rjmp	.-996    	; 0x2ffa <__fp_inf>

000033de <log>:
    33de:	62 de       	rcall	.-828    	; 0x30a4 <__fp_splitA>
    33e0:	c8 f3       	brcs	.-14     	; 0x33d4 <ldexp+0x68>
    33e2:	99 23       	and	r25, r25
    33e4:	d1 f3       	breq	.-12     	; 0x33da <ldexp+0x6e>
    33e6:	c6 f3       	brts	.-16     	; 0x33d8 <ldexp+0x6c>
    33e8:	df 93       	push	r29
    33ea:	cf 93       	push	r28
    33ec:	1f 93       	push	r17
    33ee:	0f 93       	push	r16
    33f0:	ff 92       	push	r15
    33f2:	c9 2f       	mov	r28, r25
    33f4:	dd 27       	eor	r29, r29
    33f6:	88 23       	and	r24, r24
    33f8:	2a f0       	brmi	.+10     	; 0x3404 <log+0x26>
    33fa:	21 97       	sbiw	r28, 0x01	; 1
    33fc:	66 0f       	add	r22, r22
    33fe:	77 1f       	adc	r23, r23
    3400:	88 1f       	adc	r24, r24
    3402:	da f7       	brpl	.-10     	; 0x33fa <log+0x1c>
    3404:	20 e0       	ldi	r18, 0x00	; 0
    3406:	30 e0       	ldi	r19, 0x00	; 0
    3408:	40 e8       	ldi	r20, 0x80	; 128
    340a:	5f eb       	ldi	r21, 0xBF	; 191
    340c:	9f e3       	ldi	r25, 0x3F	; 63
    340e:	88 39       	cpi	r24, 0x98	; 152
    3410:	20 f0       	brcs	.+8      	; 0x341a <log+0x3c>
    3412:	80 3e       	cpi	r24, 0xE0	; 224
    3414:	30 f0       	brcs	.+12     	; 0x3422 <log+0x44>
    3416:	21 96       	adiw	r28, 0x01	; 1
    3418:	8f 77       	andi	r24, 0x7F	; 127
    341a:	2b dc       	rcall	.-1962   	; 0x2c72 <__addsf3>
    341c:	eb ec       	ldi	r30, 0xCB	; 203
    341e:	f2 e0       	ldi	r31, 0x02	; 2
    3420:	03 c0       	rjmp	.+6      	; 0x3428 <log+0x4a>
    3422:	27 dc       	rcall	.-1970   	; 0x2c72 <__addsf3>
    3424:	e8 ef       	ldi	r30, 0xF8	; 248
    3426:	f2 e0       	ldi	r31, 0x02	; 2
    3428:	f1 dd       	rcall	.-1054   	; 0x300c <__fp_powser>
    342a:	8b 01       	movw	r16, r22
    342c:	be 01       	movw	r22, r28
    342e:	ec 01       	movw	r28, r24
    3430:	fb 2e       	mov	r15, r27
    3432:	6f 57       	subi	r22, 0x7F	; 127
    3434:	71 09       	sbc	r23, r1
    3436:	75 95       	asr	r23
    3438:	77 1f       	adc	r23, r23
    343a:	88 0b       	sbc	r24, r24
    343c:	99 0b       	sbc	r25, r25
    343e:	7e dd       	rcall	.-1284   	; 0x2f3c <__floatsisf>
    3440:	28 e1       	ldi	r18, 0x18	; 24
    3442:	32 e7       	ldi	r19, 0x72	; 114
    3444:	41 e3       	ldi	r20, 0x31	; 49
    3446:	5f e3       	ldi	r21, 0x3F	; 63
    3448:	61 de       	rcall	.-830    	; 0x310c <__mulsf3x>
    344a:	af 2d       	mov	r26, r15
    344c:	98 01       	movw	r18, r16
    344e:	ae 01       	movw	r20, r28
    3450:	ff 90       	pop	r15
    3452:	0f 91       	pop	r16
    3454:	1f 91       	pop	r17
    3456:	cf 91       	pop	r28
    3458:	df 91       	pop	r29
    345a:	1c dc       	rcall	.-1992   	; 0x2c94 <__addsf3x>
    345c:	0a ce       	rjmp	.-1004   	; 0x3072 <__fp_round>

0000345e <modf>:
    345e:	fa 01       	movw	r30, r20
    3460:	dc 01       	movw	r26, r24
    3462:	aa 0f       	add	r26, r26
    3464:	bb 1f       	adc	r27, r27
    3466:	9b 01       	movw	r18, r22
    3468:	ac 01       	movw	r20, r24
    346a:	bf 57       	subi	r27, 0x7F	; 127
    346c:	28 f4       	brcc	.+10     	; 0x3478 <modf+0x1a>
    346e:	22 27       	eor	r18, r18
    3470:	33 27       	eor	r19, r19
    3472:	44 27       	eor	r20, r20
    3474:	50 78       	andi	r21, 0x80	; 128
    3476:	1f c0       	rjmp	.+62     	; 0x34b6 <modf+0x58>
    3478:	b7 51       	subi	r27, 0x17	; 23
    347a:	88 f4       	brcc	.+34     	; 0x349e <modf+0x40>
    347c:	ab 2f       	mov	r26, r27
    347e:	00 24       	eor	r0, r0
    3480:	46 95       	lsr	r20
    3482:	37 95       	ror	r19
    3484:	27 95       	ror	r18
    3486:	01 1c       	adc	r0, r1
    3488:	a3 95       	inc	r26
    348a:	d2 f3       	brmi	.-12     	; 0x3480 <modf+0x22>
    348c:	00 20       	and	r0, r0
    348e:	69 f0       	breq	.+26     	; 0x34aa <modf+0x4c>
    3490:	22 0f       	add	r18, r18
    3492:	33 1f       	adc	r19, r19
    3494:	44 1f       	adc	r20, r20
    3496:	b3 95       	inc	r27
    3498:	da f3       	brmi	.-10     	; 0x3490 <modf+0x32>
    349a:	0d d0       	rcall	.+26     	; 0x34b6 <modf+0x58>
    349c:	e9 cb       	rjmp	.-2094   	; 0x2c70 <__subsf3>
    349e:	61 30       	cpi	r22, 0x01	; 1
    34a0:	71 05       	cpc	r23, r1
    34a2:	a0 e8       	ldi	r26, 0x80	; 128
    34a4:	8a 07       	cpc	r24, r26
    34a6:	b9 46       	sbci	r27, 0x69	; 105
    34a8:	30 f4       	brcc	.+12     	; 0x34b6 <modf+0x58>
    34aa:	9b 01       	movw	r18, r22
    34ac:	ac 01       	movw	r20, r24
    34ae:	66 27       	eor	r22, r22
    34b0:	77 27       	eor	r23, r23
    34b2:	88 27       	eor	r24, r24
    34b4:	90 78       	andi	r25, 0x80	; 128
    34b6:	30 96       	adiw	r30, 0x00	; 0
    34b8:	21 f0       	breq	.+8      	; 0x34c2 <modf+0x64>
    34ba:	20 83       	st	Z, r18
    34bc:	31 83       	std	Z+1, r19	; 0x01
    34be:	42 83       	std	Z+2, r20	; 0x02
    34c0:	53 83       	std	Z+3, r21	; 0x03
    34c2:	08 95       	ret

000034c4 <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    34c4:	fc 01       	movw	r30, r24
    34c6:	81 8d       	ldd	r24, Z+25	; 0x19
    34c8:	22 8d       	ldd	r18, Z+26	; 0x1a
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	80 5c       	subi	r24, 0xC0	; 192
    34ce:	9f 4f       	sbci	r25, 0xFF	; 255
    34d0:	82 1b       	sub	r24, r18
    34d2:	91 09       	sbc	r25, r1
    34d4:	8f 73       	andi	r24, 0x3F	; 63
    34d6:	99 27       	eor	r25, r25
    34d8:	08 95       	ret

000034da <_ZN14HardwareSerial4peekEv>:
    34da:	fc 01       	movw	r30, r24
    34dc:	91 8d       	ldd	r25, Z+25	; 0x19
    34de:	82 8d       	ldd	r24, Z+26	; 0x1a
    34e0:	98 17       	cp	r25, r24
    34e2:	31 f0       	breq	.+12     	; 0x34f0 <_ZN14HardwareSerial4peekEv+0x16>
    34e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    34e6:	e8 0f       	add	r30, r24
    34e8:	f1 1d       	adc	r31, r1
    34ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    34ec:	90 e0       	ldi	r25, 0x00	; 0
    34ee:	08 95       	ret
    34f0:	8f ef       	ldi	r24, 0xFF	; 255
    34f2:	9f ef       	ldi	r25, 0xFF	; 255
    34f4:	08 95       	ret

000034f6 <_ZN14HardwareSerial4readEv>:
    34f6:	fc 01       	movw	r30, r24
    34f8:	91 8d       	ldd	r25, Z+25	; 0x19
    34fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    34fc:	98 17       	cp	r25, r24
    34fe:	61 f0       	breq	.+24     	; 0x3518 <_ZN14HardwareSerial4readEv+0x22>
    3500:	82 8d       	ldd	r24, Z+26	; 0x1a
    3502:	df 01       	movw	r26, r30
    3504:	a8 0f       	add	r26, r24
    3506:	b1 1d       	adc	r27, r1
    3508:	5d 96       	adiw	r26, 0x1d	; 29
    350a:	8c 91       	ld	r24, X
    350c:	92 8d       	ldd	r25, Z+26	; 0x1a
    350e:	9f 5f       	subi	r25, 0xFF	; 255
    3510:	9f 73       	andi	r25, 0x3F	; 63
    3512:	92 8f       	std	Z+26, r25	; 0x1a
    3514:	90 e0       	ldi	r25, 0x00	; 0
    3516:	08 95       	ret
    3518:	8f ef       	ldi	r24, 0xFF	; 255
    351a:	9f ef       	ldi	r25, 0xFF	; 255
    351c:	08 95       	ret

0000351e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    351e:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    3520:	84 8d       	ldd	r24, Z+28	; 0x1c
    3522:	df 01       	movw	r26, r30
    3524:	a8 0f       	add	r26, r24
    3526:	b1 1d       	adc	r27, r1
    3528:	a3 5a       	subi	r26, 0xA3	; 163
    352a:	bf 4f       	sbci	r27, 0xFF	; 255
    352c:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    352e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	01 96       	adiw	r24, 0x01	; 1
    3534:	8f 73       	andi	r24, 0x3F	; 63
    3536:	90 78       	andi	r25, 0x80	; 128
    3538:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    353a:	a6 89       	ldd	r26, Z+22	; 0x16
    353c:	b7 89       	ldd	r27, Z+23	; 0x17
    353e:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    3540:	a0 89       	ldd	r26, Z+16	; 0x10
    3542:	b1 89       	ldd	r27, Z+17	; 0x11
    3544:	8c 91       	ld	r24, X
    3546:	80 64       	ori	r24, 0x40	; 64
    3548:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    354a:	93 8d       	ldd	r25, Z+27	; 0x1b
    354c:	84 8d       	ldd	r24, Z+28	; 0x1c
    354e:	98 13       	cpse	r25, r24
    3550:	06 c0       	rjmp	.+12     	; 0x355e <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    3552:	02 88       	ldd	r0, Z+18	; 0x12
    3554:	f3 89       	ldd	r31, Z+19	; 0x13
    3556:	e0 2d       	mov	r30, r0
    3558:	80 81       	ld	r24, Z
    355a:	8f 7d       	andi	r24, 0xDF	; 223
    355c:	80 83       	st	Z, r24
    355e:	08 95       	ret

00003560 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    3560:	cf 93       	push	r28
    3562:	df 93       	push	r29
    3564:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    3566:	88 8d       	ldd	r24, Y+24	; 0x18
    3568:	81 11       	cpse	r24, r1
    356a:	0a c0       	rjmp	.+20     	; 0x3580 <_ZN14HardwareSerial5flushEv+0x20>
    356c:	1a c0       	rjmp	.+52     	; 0x35a2 <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    356e:	0f b6       	in	r0, 0x3f	; 63
    3570:	07 fc       	sbrc	r0, 7
    3572:	08 c0       	rjmp	.+16     	; 0x3584 <_ZN14HardwareSerial5flushEv+0x24>
    3574:	80 81       	ld	r24, Z
    3576:	85 ff       	sbrs	r24, 5
    3578:	05 c0       	rjmp	.+10     	; 0x3584 <_ZN14HardwareSerial5flushEv+0x24>
    357a:	0d c0       	rjmp	.+26     	; 0x3596 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    357c:	ce 01       	movw	r24, r28
    357e:	cf df       	rcall	.-98     	; 0x351e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    3580:	ea 89       	ldd	r30, Y+18	; 0x12
    3582:	fb 89       	ldd	r31, Y+19	; 0x13
    3584:	80 81       	ld	r24, Z
    3586:	85 fd       	sbrc	r24, 5
    3588:	f2 cf       	rjmp	.-28     	; 0x356e <_ZN14HardwareSerial5flushEv+0xe>
    358a:	a8 89       	ldd	r26, Y+16	; 0x10
    358c:	b9 89       	ldd	r27, Y+17	; 0x11
    358e:	8c 91       	ld	r24, X
    3590:	86 ff       	sbrs	r24, 6
    3592:	ed cf       	rjmp	.-38     	; 0x356e <_ZN14HardwareSerial5flushEv+0xe>
    3594:	06 c0       	rjmp	.+12     	; 0x35a2 <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    3596:	a8 89       	ldd	r26, Y+16	; 0x10
    3598:	b9 89       	ldd	r27, Y+17	; 0x11
    359a:	8c 91       	ld	r24, X
    359c:	85 ff       	sbrs	r24, 5
    359e:	f2 cf       	rjmp	.-28     	; 0x3584 <_ZN14HardwareSerial5flushEv+0x24>
    35a0:	ed cf       	rjmp	.-38     	; 0x357c <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    35a2:	df 91       	pop	r29
    35a4:	cf 91       	pop	r28
    35a6:	08 95       	ret

000035a8 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    35a8:	0f 93       	push	r16
    35aa:	1f 93       	push	r17
    35ac:	cf 93       	push	r28
    35ae:	df 93       	push	r29
    35b0:	ec 01       	movw	r28, r24
    35b2:	16 2f       	mov	r17, r22
  _written = true;
    35b4:	81 e0       	ldi	r24, 0x01	; 1
    35b6:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    35b8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    35ba:	8c 8d       	ldd	r24, Y+28	; 0x1c
    35bc:	98 13       	cpse	r25, r24
    35be:	21 c0       	rjmp	.+66     	; 0x3602 <_ZN14HardwareSerial5writeEh+0x5a>
    35c0:	e8 89       	ldd	r30, Y+16	; 0x10
    35c2:	f9 89       	ldd	r31, Y+17	; 0x11
    35c4:	80 81       	ld	r24, Z
    35c6:	85 fd       	sbrc	r24, 5
    35c8:	23 c0       	rjmp	.+70     	; 0x3610 <_ZN14HardwareSerial5writeEh+0x68>
    35ca:	1b c0       	rjmp	.+54     	; 0x3602 <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	07 fc       	sbrc	r0, 7
    35d0:	07 c0       	rjmp	.+14     	; 0x35e0 <_ZN14HardwareSerial5writeEh+0x38>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    35d2:	e8 89       	ldd	r30, Y+16	; 0x10
    35d4:	f9 89       	ldd	r31, Y+17	; 0x11
    35d6:	80 81       	ld	r24, Z
    35d8:	85 ff       	sbrs	r24, 5
    35da:	02 c0       	rjmp	.+4      	; 0x35e0 <_ZN14HardwareSerial5writeEh+0x38>
	_tx_udr_empty_irq();
    35dc:	ce 01       	movw	r24, r28
    35de:	9f df       	rcall	.-194    	; 0x351e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    35e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    35e2:	09 17       	cp	r16, r25
    35e4:	99 f3       	breq	.-26     	; 0x35cc <_ZN14HardwareSerial5writeEh+0x24>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    35e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    35e8:	fe 01       	movw	r30, r28
    35ea:	e8 0f       	add	r30, r24
    35ec:	f1 1d       	adc	r31, r1
    35ee:	e3 5a       	subi	r30, 0xA3	; 163
    35f0:	ff 4f       	sbci	r31, 0xFF	; 255
    35f2:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    35f4:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    35f6:	ea 89       	ldd	r30, Y+18	; 0x12
    35f8:	fb 89       	ldd	r31, Y+19	; 0x13
    35fa:	80 81       	ld	r24, Z
    35fc:	80 62       	ori	r24, 0x20	; 32
    35fe:	80 83       	st	Z, r24
  
  return 1;
    3600:	0f c0       	rjmp	.+30     	; 0x3620 <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    3602:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	01 96       	adiw	r24, 0x01	; 1
    3608:	8f 73       	andi	r24, 0x3F	; 63
    360a:	90 78       	andi	r25, 0x80	; 128
    360c:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    360e:	e8 cf       	rjmp	.-48     	; 0x35e0 <_ZN14HardwareSerial5writeEh+0x38>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    3610:	ee 89       	ldd	r30, Y+22	; 0x16
    3612:	ff 89       	ldd	r31, Y+23	; 0x17
    3614:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    3616:	e8 89       	ldd	r30, Y+16	; 0x10
    3618:	f9 89       	ldd	r31, Y+17	; 0x11
    361a:	80 81       	ld	r24, Z
    361c:	80 64       	ori	r24, 0x40	; 64
    361e:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
    3620:	81 e0       	ldi	r24, 0x01	; 1
    3622:	90 e0       	ldi	r25, 0x00	; 0
    3624:	df 91       	pop	r29
    3626:	cf 91       	pop	r28
    3628:	1f 91       	pop	r17
    362a:	0f 91       	pop	r16
    362c:	08 95       	ret

0000362e <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    362e:	cf 92       	push	r12
    3630:	df 92       	push	r13
    3632:	ef 92       	push	r14
    3634:	ff 92       	push	r15
    3636:	1f 93       	push	r17
    3638:	cf 93       	push	r28
    363a:	df 93       	push	r29
    363c:	ec 01       	movw	r28, r24
    363e:	6a 01       	movw	r12, r20
    3640:	7b 01       	movw	r14, r22
    3642:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    3644:	e8 89       	ldd	r30, Y+16	; 0x10
    3646:	f9 89       	ldd	r31, Y+17	; 0x11
    3648:	82 e0       	ldi	r24, 0x02	; 2
    364a:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    364c:	41 15       	cp	r20, r1
    364e:	81 ee       	ldi	r24, 0xE1	; 225
    3650:	58 07       	cpc	r21, r24
    3652:	61 05       	cpc	r22, r1
    3654:	71 05       	cpc	r23, r1
    3656:	a9 f0       	breq	.+42     	; 0x3682 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3658:	60 e0       	ldi	r22, 0x00	; 0
    365a:	79 e0       	ldi	r23, 0x09	; 9
    365c:	8d e3       	ldi	r24, 0x3D	; 61
    365e:	90 e0       	ldi	r25, 0x00	; 0
    3660:	a7 01       	movw	r20, r14
    3662:	96 01       	movw	r18, r12
    3664:	4b d4       	rcall	.+2198   	; 0x3efc <__udivmodsi4>
    3666:	ba 01       	movw	r22, r20
    3668:	a9 01       	movw	r20, r18
    366a:	41 50       	subi	r20, 0x01	; 1
    366c:	51 09       	sbc	r21, r1
    366e:	61 09       	sbc	r22, r1
    3670:	71 09       	sbc	r23, r1
    3672:	76 95       	lsr	r23
    3674:	67 95       	ror	r22
    3676:	57 95       	ror	r21
    3678:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    367a:	41 15       	cp	r20, r1
    367c:	80 e1       	ldi	r24, 0x10	; 16
    367e:	58 07       	cpc	r21, r24
    3680:	a0 f0       	brcs	.+40     	; 0x36aa <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    3682:	e8 89       	ldd	r30, Y+16	; 0x10
    3684:	f9 89       	ldd	r31, Y+17	; 0x11
    3686:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3688:	60 e8       	ldi	r22, 0x80	; 128
    368a:	74 e8       	ldi	r23, 0x84	; 132
    368c:	8e e1       	ldi	r24, 0x1E	; 30
    368e:	90 e0       	ldi	r25, 0x00	; 0
    3690:	a7 01       	movw	r20, r14
    3692:	96 01       	movw	r18, r12
    3694:	33 d4       	rcall	.+2150   	; 0x3efc <__udivmodsi4>
    3696:	ba 01       	movw	r22, r20
    3698:	a9 01       	movw	r20, r18
    369a:	41 50       	subi	r20, 0x01	; 1
    369c:	51 09       	sbc	r21, r1
    369e:	61 09       	sbc	r22, r1
    36a0:	71 09       	sbc	r23, r1
    36a2:	76 95       	lsr	r23
    36a4:	67 95       	ror	r22
    36a6:	57 95       	ror	r21
    36a8:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    36aa:	ec 85       	ldd	r30, Y+12	; 0x0c
    36ac:	fd 85       	ldd	r31, Y+13	; 0x0d
    36ae:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    36b0:	ee 85       	ldd	r30, Y+14	; 0x0e
    36b2:	ff 85       	ldd	r31, Y+15	; 0x0f
    36b4:	40 83       	st	Z, r20

  _written = false;
    36b6:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    36b8:	ec 89       	ldd	r30, Y+20	; 0x14
    36ba:	fd 89       	ldd	r31, Y+21	; 0x15
    36bc:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    36be:	ea 89       	ldd	r30, Y+18	; 0x12
    36c0:	fb 89       	ldd	r31, Y+19	; 0x13
    36c2:	80 81       	ld	r24, Z
    36c4:	80 61       	ori	r24, 0x10	; 16
    36c6:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    36c8:	ea 89       	ldd	r30, Y+18	; 0x12
    36ca:	fb 89       	ldd	r31, Y+19	; 0x13
    36cc:	80 81       	ld	r24, Z
    36ce:	88 60       	ori	r24, 0x08	; 8
    36d0:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    36d2:	ea 89       	ldd	r30, Y+18	; 0x12
    36d4:	fb 89       	ldd	r31, Y+19	; 0x13
    36d6:	80 81       	ld	r24, Z
    36d8:	80 68       	ori	r24, 0x80	; 128
    36da:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    36dc:	ea 89       	ldd	r30, Y+18	; 0x12
    36de:	fb 89       	ldd	r31, Y+19	; 0x13
    36e0:	80 81       	ld	r24, Z
    36e2:	8f 7d       	andi	r24, 0xDF	; 223
    36e4:	80 83       	st	Z, r24
}
    36e6:	df 91       	pop	r29
    36e8:	cf 91       	pop	r28
    36ea:	1f 91       	pop	r17
    36ec:	ff 90       	pop	r15
    36ee:	ef 90       	pop	r14
    36f0:	df 90       	pop	r13
    36f2:	cf 90       	pop	r12
    36f4:	08 95       	ret

000036f6 <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    36f6:	1f 92       	push	r1
    36f8:	0f 92       	push	r0
    36fa:	0f b6       	in	r0, 0x3f	; 63
    36fc:	0f 92       	push	r0
    36fe:	11 24       	eor	r1, r1
    3700:	0b b6       	in	r0, 0x3b	; 59
    3702:	0f 92       	push	r0
    3704:	2f 93       	push	r18
    3706:	8f 93       	push	r24
    3708:	9f 93       	push	r25
    370a:	af 93       	push	r26
    370c:	bf 93       	push	r27
    370e:	ef 93       	push	r30
    3710:	ff 93       	push	r31
    3712:	e0 91 09 0a 	lds	r30, 0x0A09
    3716:	f0 91 0a 0a 	lds	r31, 0x0A0A
    371a:	80 81       	ld	r24, Z
    371c:	82 fd       	sbrc	r24, 2
    371e:	17 c0       	rjmp	.+46     	; 0x374e <__vector_25+0x58>
    3720:	e0 91 0f 0a 	lds	r30, 0x0A0F
    3724:	f0 91 10 0a 	lds	r31, 0x0A10
    3728:	20 81       	ld	r18, Z
    372a:	80 91 12 0a 	lds	r24, 0x0A12
    372e:	8f 5f       	subi	r24, 0xFF	; 255
    3730:	8f 73       	andi	r24, 0x3F	; 63
    3732:	90 91 13 0a 	lds	r25, 0x0A13
    3736:	89 17       	cp	r24, r25
    3738:	79 f0       	breq	.+30     	; 0x3758 <__vector_25+0x62>
    373a:	e2 e1       	ldi	r30, 0x12	; 18
    373c:	fa e0       	ldi	r31, 0x0A	; 10
    373e:	a0 81       	ld	r26, Z
    3740:	b0 e0       	ldi	r27, 0x00	; 0
    3742:	a7 50       	subi	r26, 0x07	; 7
    3744:	b6 4f       	sbci	r27, 0xF6	; 246
    3746:	5d 96       	adiw	r26, 0x1d	; 29
    3748:	2c 93       	st	X, r18
    374a:	80 83       	st	Z, r24
    374c:	05 c0       	rjmp	.+10     	; 0x3758 <__vector_25+0x62>
    374e:	e0 91 0f 0a 	lds	r30, 0x0A0F
    3752:	f0 91 10 0a 	lds	r31, 0x0A10
    3756:	80 81       	ld	r24, Z
    3758:	ff 91       	pop	r31
    375a:	ef 91       	pop	r30
    375c:	bf 91       	pop	r27
    375e:	af 91       	pop	r26
    3760:	9f 91       	pop	r25
    3762:	8f 91       	pop	r24
    3764:	2f 91       	pop	r18
    3766:	0f 90       	pop	r0
    3768:	0b be       	out	0x3b, r0	; 59
    376a:	0f 90       	pop	r0
    376c:	0f be       	out	0x3f, r0	; 63
    376e:	0f 90       	pop	r0
    3770:	1f 90       	pop	r1
    3772:	18 95       	reti

00003774 <__vector_26>:
    3774:	1f 92       	push	r1
    3776:	0f 92       	push	r0
    3778:	0f b6       	in	r0, 0x3f	; 63
    377a:	0f 92       	push	r0
    377c:	11 24       	eor	r1, r1
    377e:	0b b6       	in	r0, 0x3b	; 59
    3780:	0f 92       	push	r0
    3782:	2f 93       	push	r18
    3784:	3f 93       	push	r19
    3786:	4f 93       	push	r20
    3788:	5f 93       	push	r21
    378a:	6f 93       	push	r22
    378c:	7f 93       	push	r23
    378e:	8f 93       	push	r24
    3790:	9f 93       	push	r25
    3792:	af 93       	push	r26
    3794:	bf 93       	push	r27
    3796:	ef 93       	push	r30
    3798:	ff 93       	push	r31
    379a:	89 ef       	ldi	r24, 0xF9	; 249
    379c:	99 e0       	ldi	r25, 0x09	; 9
    379e:	bf de       	rcall	.-642    	; 0x351e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    37a0:	ff 91       	pop	r31
    37a2:	ef 91       	pop	r30
    37a4:	bf 91       	pop	r27
    37a6:	af 91       	pop	r26
    37a8:	9f 91       	pop	r25
    37aa:	8f 91       	pop	r24
    37ac:	7f 91       	pop	r23
    37ae:	6f 91       	pop	r22
    37b0:	5f 91       	pop	r21
    37b2:	4f 91       	pop	r20
    37b4:	3f 91       	pop	r19
    37b6:	2f 91       	pop	r18
    37b8:	0f 90       	pop	r0
    37ba:	0b be       	out	0x3b, r0	; 59
    37bc:	0f 90       	pop	r0
    37be:	0f be       	out	0x3f, r0	; 63
    37c0:	0f 90       	pop	r0
    37c2:	1f 90       	pop	r1
    37c4:	18 95       	reti

000037c6 <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    37c6:	10 92 fc 09 	sts	0x09FC, r1
    37ca:	10 92 fb 09 	sts	0x09FB, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    37ce:	88 ee       	ldi	r24, 0xE8	; 232
    37d0:	93 e0       	ldi	r25, 0x03	; 3
    37d2:	a0 e0       	ldi	r26, 0x00	; 0
    37d4:	b0 e0       	ldi	r27, 0x00	; 0
    37d6:	80 93 fd 09 	sts	0x09FD, r24
    37da:	90 93 fe 09 	sts	0x09FE, r25
    37de:	a0 93 ff 09 	sts	0x09FF, r26
    37e2:	b0 93 00 0a 	sts	0x0A00, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    37e6:	8e e8       	ldi	r24, 0x8E	; 142
    37e8:	92 e0       	ldi	r25, 0x02	; 2
    37ea:	90 93 fa 09 	sts	0x09FA, r25
    37ee:	80 93 f9 09 	sts	0x09F9, r24
    37f2:	85 ec       	ldi	r24, 0xC5	; 197
    37f4:	90 e0       	ldi	r25, 0x00	; 0
    37f6:	90 93 06 0a 	sts	0x0A06, r25
    37fa:	80 93 05 0a 	sts	0x0A05, r24
    37fe:	84 ec       	ldi	r24, 0xC4	; 196
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	90 93 08 0a 	sts	0x0A08, r25
    3806:	80 93 07 0a 	sts	0x0A07, r24
    380a:	80 ec       	ldi	r24, 0xC0	; 192
    380c:	90 e0       	ldi	r25, 0x00	; 0
    380e:	90 93 0a 0a 	sts	0x0A0A, r25
    3812:	80 93 09 0a 	sts	0x0A09, r24
    3816:	81 ec       	ldi	r24, 0xC1	; 193
    3818:	90 e0       	ldi	r25, 0x00	; 0
    381a:	90 93 0c 0a 	sts	0x0A0C, r25
    381e:	80 93 0b 0a 	sts	0x0A0B, r24
    3822:	82 ec       	ldi	r24, 0xC2	; 194
    3824:	90 e0       	ldi	r25, 0x00	; 0
    3826:	90 93 0e 0a 	sts	0x0A0E, r25
    382a:	80 93 0d 0a 	sts	0x0A0D, r24
    382e:	86 ec       	ldi	r24, 0xC6	; 198
    3830:	90 e0       	ldi	r25, 0x00	; 0
    3832:	90 93 10 0a 	sts	0x0A10, r25
    3836:	80 93 0f 0a 	sts	0x0A0F, r24
    383a:	10 92 12 0a 	sts	0x0A12, r1
    383e:	10 92 13 0a 	sts	0x0A13, r1
    3842:	10 92 14 0a 	sts	0x0A14, r1
    3846:	10 92 15 0a 	sts	0x0A15, r1
    384a:	08 95       	ret

0000384c <_ZN5Print5writeEPKhj>:
size_t Print::println(long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    384c:	cf 92       	push	r12
    384e:	df 92       	push	r13
    3850:	ef 92       	push	r14
    3852:	ff 92       	push	r15
    3854:	0f 93       	push	r16
    3856:	1f 93       	push	r17
    3858:	cf 93       	push	r28
    385a:	df 93       	push	r29
    385c:	6c 01       	movw	r12, r24
    385e:	41 15       	cp	r20, r1
    3860:	51 05       	cpc	r21, r1
    3862:	b1 f0       	breq	.+44     	; 0x3890 <_ZN5Print5writeEPKhj+0x44>
    3864:	06 2f       	mov	r16, r22
    3866:	17 2f       	mov	r17, r23
    3868:	ea 01       	movw	r28, r20
    386a:	e1 2c       	mov	r14, r1
    386c:	f1 2c       	mov	r15, r1
    386e:	d8 01       	movw	r26, r16
    3870:	6d 91       	ld	r22, X+
    3872:	8d 01       	movw	r16, r26
    3874:	d6 01       	movw	r26, r12
    3876:	ed 91       	ld	r30, X+
    3878:	fc 91       	ld	r31, X
    387a:	01 90       	ld	r0, Z+
    387c:	f0 81       	ld	r31, Z
    387e:	e0 2d       	mov	r30, r0
    3880:	c6 01       	movw	r24, r12
    3882:	19 95       	eicall
    3884:	e8 0e       	add	r14, r24
    3886:	f9 1e       	adc	r15, r25
    3888:	21 97       	sbiw	r28, 0x01	; 1
    388a:	20 97       	sbiw	r28, 0x00	; 0
    388c:	81 f7       	brne	.-32     	; 0x386e <_ZN5Print5writeEPKhj+0x22>
    388e:	02 c0       	rjmp	.+4      	; 0x3894 <_ZN5Print5writeEPKhj+0x48>
    3890:	e1 2c       	mov	r14, r1
    3892:	f1 2c       	mov	r15, r1
    3894:	c7 01       	movw	r24, r14
    3896:	df 91       	pop	r29
    3898:	cf 91       	pop	r28
    389a:	1f 91       	pop	r17
    389c:	0f 91       	pop	r16
    389e:	ff 90       	pop	r15
    38a0:	ef 90       	pop	r14
    38a2:	df 90       	pop	r13
    38a4:	cf 90       	pop	r12
    38a6:	08 95       	ret

000038a8 <_ZN5Print5printEc>:
    38a8:	dc 01       	movw	r26, r24
    38aa:	ed 91       	ld	r30, X+
    38ac:	fc 91       	ld	r31, X
    38ae:	01 90       	ld	r0, Z+
    38b0:	f0 81       	ld	r31, Z
    38b2:	e0 2d       	mov	r30, r0
    38b4:	19 95       	eicall
    38b6:	08 95       	ret

000038b8 <_ZN5Print7printlnEv>:
    38b8:	dc 01       	movw	r26, r24
    38ba:	ed 91       	ld	r30, X+
    38bc:	fc 91       	ld	r31, X
    38be:	02 80       	ldd	r0, Z+2	; 0x02
    38c0:	f3 81       	ldd	r31, Z+3	; 0x03
    38c2:	e0 2d       	mov	r30, r0
    38c4:	42 e0       	ldi	r20, 0x02	; 2
    38c6:	50 e0       	ldi	r21, 0x00	; 0
    38c8:	6a e9       	ldi	r22, 0x9A	; 154
    38ca:	72 e0       	ldi	r23, 0x02	; 2
    38cc:	19 95       	eicall
    38ce:	08 95       	ret

000038d0 <_ZN5Print11printNumberEmh>:
    38d0:	6f 92       	push	r6
    38d2:	7f 92       	push	r7
    38d4:	8f 92       	push	r8
    38d6:	9f 92       	push	r9
    38d8:	af 92       	push	r10
    38da:	bf 92       	push	r11
    38dc:	cf 92       	push	r12
    38de:	df 92       	push	r13
    38e0:	ef 92       	push	r14
    38e2:	ff 92       	push	r15
    38e4:	0f 93       	push	r16
    38e6:	1f 93       	push	r17
    38e8:	cf 93       	push	r28
    38ea:	df 93       	push	r29
    38ec:	cd b7       	in	r28, 0x3d	; 61
    38ee:	de b7       	in	r29, 0x3e	; 62
    38f0:	a1 97       	sbiw	r28, 0x21	; 33
    38f2:	0f b6       	in	r0, 0x3f	; 63
    38f4:	f8 94       	cli
    38f6:	de bf       	out	0x3e, r29	; 62
    38f8:	0f be       	out	0x3f, r0	; 63
    38fa:	cd bf       	out	0x3d, r28	; 61
    38fc:	6c 01       	movw	r12, r24
    38fe:	74 2e       	mov	r7, r20
    3900:	35 2f       	mov	r19, r21
    3902:	86 2f       	mov	r24, r22
    3904:	97 2f       	mov	r25, r23
    3906:	62 2e       	mov	r6, r18
    3908:	19 a2       	std	Y+33, r1	; 0x21
    390a:	21 e0       	ldi	r18, 0x01	; 1
    390c:	26 15       	cp	r18, r6
    390e:	20 f0       	brcs	.+8      	; 0x3918 <_ZN5Print11printNumberEmh+0x48>
    3910:	0f 2e       	mov	r0, r31
    3912:	fa e0       	ldi	r31, 0x0A	; 10
    3914:	6f 2e       	mov	r6, r31
    3916:	f0 2d       	mov	r31, r0
    3918:	7e 01       	movw	r14, r28
    391a:	a1 e2       	ldi	r26, 0x21	; 33
    391c:	ea 0e       	add	r14, r26
    391e:	f1 1c       	adc	r15, r1
    3920:	86 2c       	mov	r8, r6
    3922:	91 2c       	mov	r9, r1
    3924:	a1 2c       	mov	r10, r1
    3926:	b1 2c       	mov	r11, r1
    3928:	67 2d       	mov	r22, r7
    392a:	73 2f       	mov	r23, r19
    392c:	a5 01       	movw	r20, r10
    392e:	94 01       	movw	r18, r8
    3930:	e5 d2       	rcall	.+1482   	; 0x3efc <__udivmodsi4>
    3932:	e2 2f       	mov	r30, r18
    3934:	73 2f       	mov	r23, r19
    3936:	02 2f       	mov	r16, r18
    3938:	13 2f       	mov	r17, r19
    393a:	24 2f       	mov	r18, r20
    393c:	35 2f       	mov	r19, r21
    393e:	f7 2d       	mov	r31, r7
    3940:	6e 9e       	mul	r6, r30
    3942:	f0 19       	sub	r31, r0
    3944:	11 24       	eor	r1, r1
    3946:	b1 e0       	ldi	r27, 0x01	; 1
    3948:	eb 1a       	sub	r14, r27
    394a:	f1 08       	sbc	r15, r1
    394c:	fa 30       	cpi	r31, 0x0A	; 10
    394e:	10 f4       	brcc	.+4      	; 0x3954 <_ZN5Print11printNumberEmh+0x84>
    3950:	f0 5d       	subi	r31, 0xD0	; 208
    3952:	01 c0       	rjmp	.+2      	; 0x3956 <_ZN5Print11printNumberEmh+0x86>
    3954:	f9 5c       	subi	r31, 0xC9	; 201
    3956:	d7 01       	movw	r26, r14
    3958:	fc 93       	st	X, r31
    395a:	01 2b       	or	r16, r17
    395c:	02 2b       	or	r16, r18
    395e:	03 2b       	or	r16, r19
    3960:	29 f0       	breq	.+10     	; 0x396c <_ZN5Print11printNumberEmh+0x9c>
    3962:	7e 2e       	mov	r7, r30
    3964:	37 2f       	mov	r19, r23
    3966:	84 2f       	mov	r24, r20
    3968:	95 2f       	mov	r25, r21
    396a:	de cf       	rjmp	.-68     	; 0x3928 <_ZN5Print11printNumberEmh+0x58>
    396c:	e1 14       	cp	r14, r1
    396e:	f1 04       	cpc	r15, r1
    3970:	91 f0       	breq	.+36     	; 0x3996 <_ZN5Print11printNumberEmh+0xc6>
    3972:	f7 01       	movw	r30, r14
    3974:	01 90       	ld	r0, Z+
    3976:	00 20       	and	r0, r0
    3978:	e9 f7       	brne	.-6      	; 0x3974 <_ZN5Print11printNumberEmh+0xa4>
    397a:	31 97       	sbiw	r30, 0x01	; 1
    397c:	af 01       	movw	r20, r30
    397e:	4e 19       	sub	r20, r14
    3980:	5f 09       	sbc	r21, r15
    3982:	d6 01       	movw	r26, r12
    3984:	ed 91       	ld	r30, X+
    3986:	fc 91       	ld	r31, X
    3988:	02 80       	ldd	r0, Z+2	; 0x02
    398a:	f3 81       	ldd	r31, Z+3	; 0x03
    398c:	e0 2d       	mov	r30, r0
    398e:	b7 01       	movw	r22, r14
    3990:	c6 01       	movw	r24, r12
    3992:	19 95       	eicall
    3994:	02 c0       	rjmp	.+4      	; 0x399a <_ZN5Print11printNumberEmh+0xca>
    3996:	80 e0       	ldi	r24, 0x00	; 0
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	a1 96       	adiw	r28, 0x21	; 33
    399c:	0f b6       	in	r0, 0x3f	; 63
    399e:	f8 94       	cli
    39a0:	de bf       	out	0x3e, r29	; 62
    39a2:	0f be       	out	0x3f, r0	; 63
    39a4:	cd bf       	out	0x3d, r28	; 61
    39a6:	df 91       	pop	r29
    39a8:	cf 91       	pop	r28
    39aa:	1f 91       	pop	r17
    39ac:	0f 91       	pop	r16
    39ae:	ff 90       	pop	r15
    39b0:	ef 90       	pop	r14
    39b2:	df 90       	pop	r13
    39b4:	cf 90       	pop	r12
    39b6:	bf 90       	pop	r11
    39b8:	af 90       	pop	r10
    39ba:	9f 90       	pop	r9
    39bc:	8f 90       	pop	r8
    39be:	7f 90       	pop	r7
    39c0:	6f 90       	pop	r6
    39c2:	08 95       	ret

000039c4 <_ZN5Print5printEli>:
    39c4:	cf 92       	push	r12
    39c6:	df 92       	push	r13
    39c8:	ef 92       	push	r14
    39ca:	ff 92       	push	r15
    39cc:	0f 93       	push	r16
    39ce:	1f 93       	push	r17
    39d0:	cf 93       	push	r28
    39d2:	df 93       	push	r29
    39d4:	ec 01       	movw	r28, r24
    39d6:	6a 01       	movw	r12, r20
    39d8:	7b 01       	movw	r14, r22
    39da:	21 15       	cp	r18, r1
    39dc:	31 05       	cpc	r19, r1
    39de:	41 f4       	brne	.+16     	; 0x39f0 <_ZN5Print5printEli+0x2c>
    39e0:	e8 81       	ld	r30, Y
    39e2:	f9 81       	ldd	r31, Y+1	; 0x01
    39e4:	01 90       	ld	r0, Z+
    39e6:	f0 81       	ld	r31, Z
    39e8:	e0 2d       	mov	r30, r0
    39ea:	64 2f       	mov	r22, r20
    39ec:	19 95       	eicall
    39ee:	19 c0       	rjmp	.+50     	; 0x3a22 <_ZN5Print5printEli+0x5e>
    39f0:	2a 30       	cpi	r18, 0x0A	; 10
    39f2:	31 05       	cpc	r19, r1
    39f4:	a9 f4       	brne	.+42     	; 0x3a20 <_ZN5Print5printEli+0x5c>
    39f6:	77 23       	and	r23, r23
    39f8:	84 f4       	brge	.+32     	; 0x3a1a <_ZN5Print5printEli+0x56>
    39fa:	6d e2       	ldi	r22, 0x2D	; 45
    39fc:	55 df       	rcall	.-342    	; 0x38a8 <_ZN5Print5printEc>
    39fe:	8c 01       	movw	r16, r24
    3a00:	44 27       	eor	r20, r20
    3a02:	55 27       	eor	r21, r21
    3a04:	ba 01       	movw	r22, r20
    3a06:	4c 19       	sub	r20, r12
    3a08:	5d 09       	sbc	r21, r13
    3a0a:	6e 09       	sbc	r22, r14
    3a0c:	7f 09       	sbc	r23, r15
    3a0e:	2a e0       	ldi	r18, 0x0A	; 10
    3a10:	ce 01       	movw	r24, r28
    3a12:	5e df       	rcall	.-324    	; 0x38d0 <_ZN5Print11printNumberEmh>
    3a14:	80 0f       	add	r24, r16
    3a16:	91 1f       	adc	r25, r17
    3a18:	04 c0       	rjmp	.+8      	; 0x3a22 <_ZN5Print5printEli+0x5e>
    3a1a:	2a e0       	ldi	r18, 0x0A	; 10
    3a1c:	59 df       	rcall	.-334    	; 0x38d0 <_ZN5Print11printNumberEmh>
    3a1e:	01 c0       	rjmp	.+2      	; 0x3a22 <_ZN5Print5printEli+0x5e>
    3a20:	57 df       	rcall	.-338    	; 0x38d0 <_ZN5Print11printNumberEmh>
    3a22:	df 91       	pop	r29
    3a24:	cf 91       	pop	r28
    3a26:	1f 91       	pop	r17
    3a28:	0f 91       	pop	r16
    3a2a:	ff 90       	pop	r15
    3a2c:	ef 90       	pop	r14
    3a2e:	df 90       	pop	r13
    3a30:	cf 90       	pop	r12
    3a32:	08 95       	ret

00003a34 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    3a34:	0f 93       	push	r16
    3a36:	1f 93       	push	r17
    3a38:	cf 93       	push	r28
    3a3a:	df 93       	push	r29
    3a3c:	ec 01       	movw	r28, r24
    3a3e:	9a 01       	movw	r18, r20
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
    3a40:	ab 01       	movw	r20, r22
    3a42:	66 27       	eor	r22, r22
    3a44:	57 fd       	sbrc	r21, 7
    3a46:	60 95       	com	r22
    3a48:	76 2f       	mov	r23, r22
    3a4a:	bc df       	rcall	.-136    	; 0x39c4 <_ZN5Print5printEli>
    3a4c:	8c 01       	movw	r16, r24
}

size_t Print::println(int num, int base)
{
  size_t n = print(num, base);
  n += println();
    3a4e:	ce 01       	movw	r24, r28
    3a50:	33 df       	rcall	.-410    	; 0x38b8 <_ZN5Print7printlnEv>
  return n;
}
    3a52:	80 0f       	add	r24, r16
    3a54:	91 1f       	adc	r25, r17
    3a56:	df 91       	pop	r29
    3a58:	cf 91       	pop	r28
    3a5a:	1f 91       	pop	r17
    3a5c:	0f 91       	pop	r16
    3a5e:	08 95       	ret

00003a60 <__vector_23>:
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    3a60:	1f 92       	push	r1
    3a62:	0f 92       	push	r0
    3a64:	0f b6       	in	r0, 0x3f	; 63
    3a66:	0f 92       	push	r0
    3a68:	11 24       	eor	r1, r1
    3a6a:	2f 93       	push	r18
    3a6c:	3f 93       	push	r19
    3a6e:	8f 93       	push	r24
    3a70:	9f 93       	push	r25
    3a72:	af 93       	push	r26
    3a74:	bf 93       	push	r27
    3a76:	80 91 97 0a 	lds	r24, 0x0A97
    3a7a:	90 91 98 0a 	lds	r25, 0x0A98
    3a7e:	a0 91 99 0a 	lds	r26, 0x0A99
    3a82:	b0 91 9a 0a 	lds	r27, 0x0A9A
    3a86:	30 91 96 0a 	lds	r19, 0x0A96
    3a8a:	23 e0       	ldi	r18, 0x03	; 3
    3a8c:	23 0f       	add	r18, r19
    3a8e:	2d 37       	cpi	r18, 0x7D	; 125
    3a90:	20 f4       	brcc	.+8      	; 0x3a9a <__vector_23+0x3a>
    3a92:	01 96       	adiw	r24, 0x01	; 1
    3a94:	a1 1d       	adc	r26, r1
    3a96:	b1 1d       	adc	r27, r1
    3a98:	05 c0       	rjmp	.+10     	; 0x3aa4 <__vector_23+0x44>
    3a9a:	26 e8       	ldi	r18, 0x86	; 134
    3a9c:	23 0f       	add	r18, r19
    3a9e:	02 96       	adiw	r24, 0x02	; 2
    3aa0:	a1 1d       	adc	r26, r1
    3aa2:	b1 1d       	adc	r27, r1
    3aa4:	20 93 96 0a 	sts	0x0A96, r18
    3aa8:	80 93 97 0a 	sts	0x0A97, r24
    3aac:	90 93 98 0a 	sts	0x0A98, r25
    3ab0:	a0 93 99 0a 	sts	0x0A99, r26
    3ab4:	b0 93 9a 0a 	sts	0x0A9A, r27
    3ab8:	80 91 9b 0a 	lds	r24, 0x0A9B
    3abc:	90 91 9c 0a 	lds	r25, 0x0A9C
    3ac0:	a0 91 9d 0a 	lds	r26, 0x0A9D
    3ac4:	b0 91 9e 0a 	lds	r27, 0x0A9E
    3ac8:	01 96       	adiw	r24, 0x01	; 1
    3aca:	a1 1d       	adc	r26, r1
    3acc:	b1 1d       	adc	r27, r1
    3ace:	80 93 9b 0a 	sts	0x0A9B, r24
    3ad2:	90 93 9c 0a 	sts	0x0A9C, r25
    3ad6:	a0 93 9d 0a 	sts	0x0A9D, r26
    3ada:	b0 93 9e 0a 	sts	0x0A9E, r27
    3ade:	bf 91       	pop	r27
    3ae0:	af 91       	pop	r26
    3ae2:	9f 91       	pop	r25
    3ae4:	8f 91       	pop	r24
    3ae6:	3f 91       	pop	r19
    3ae8:	2f 91       	pop	r18
    3aea:	0f 90       	pop	r0
    3aec:	0f be       	out	0x3f, r0	; 63
    3aee:	0f 90       	pop	r0
    3af0:	1f 90       	pop	r1
    3af2:	18 95       	reti

00003af4 <millis>:
    3af4:	2f b7       	in	r18, 0x3f	; 63
    3af6:	f8 94       	cli
    3af8:	60 91 97 0a 	lds	r22, 0x0A97
    3afc:	70 91 98 0a 	lds	r23, 0x0A98
    3b00:	80 91 99 0a 	lds	r24, 0x0A99
    3b04:	90 91 9a 0a 	lds	r25, 0x0A9A
    3b08:	2f bf       	out	0x3f, r18	; 63
    3b0a:	08 95       	ret

00003b0c <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    3b0c:	82 30       	cpi	r24, 0x02	; 2
    3b0e:	91 05       	cpc	r25, r1
    3b10:	38 f0       	brcs	.+14     	; 0x3b20 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    3b12:	88 0f       	add	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	88 0f       	add	r24, r24
    3b18:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    3b1a:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    3b1c:	01 97       	sbiw	r24, 0x01	; 1
    3b1e:	f1 f7       	brne	.-4      	; 0x3b1c <delayMicroseconds+0x10>
    3b20:	08 95       	ret

00003b22 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    3b22:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    3b24:	84 b5       	in	r24, 0x24	; 36
    3b26:	82 60       	ori	r24, 0x02	; 2
    3b28:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    3b2a:	84 b5       	in	r24, 0x24	; 36
    3b2c:	81 60       	ori	r24, 0x01	; 1
    3b2e:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    3b30:	85 b5       	in	r24, 0x25	; 37
    3b32:	82 60       	ori	r24, 0x02	; 2
    3b34:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    3b36:	85 b5       	in	r24, 0x25	; 37
    3b38:	81 60       	ori	r24, 0x01	; 1
    3b3a:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    3b3c:	ee e6       	ldi	r30, 0x6E	; 110
    3b3e:	f0 e0       	ldi	r31, 0x00	; 0
    3b40:	80 81       	ld	r24, Z
    3b42:	81 60       	ori	r24, 0x01	; 1
    3b44:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    3b46:	e1 e8       	ldi	r30, 0x81	; 129
    3b48:	f0 e0       	ldi	r31, 0x00	; 0
    3b4a:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    3b4c:	80 81       	ld	r24, Z
    3b4e:	82 60       	ori	r24, 0x02	; 2
    3b50:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    3b52:	80 81       	ld	r24, Z
    3b54:	81 60       	ori	r24, 0x01	; 1
    3b56:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    3b58:	e0 e8       	ldi	r30, 0x80	; 128
    3b5a:	f0 e0       	ldi	r31, 0x00	; 0
    3b5c:	80 81       	ld	r24, Z
    3b5e:	81 60       	ori	r24, 0x01	; 1
    3b60:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    3b62:	e1 eb       	ldi	r30, 0xB1	; 177
    3b64:	f0 e0       	ldi	r31, 0x00	; 0
    3b66:	80 81       	ld	r24, Z
    3b68:	84 60       	ori	r24, 0x04	; 4
    3b6a:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    3b6c:	e0 eb       	ldi	r30, 0xB0	; 176
    3b6e:	f0 e0       	ldi	r31, 0x00	; 0
    3b70:	80 81       	ld	r24, Z
    3b72:	81 60       	ori	r24, 0x01	; 1
    3b74:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    3b76:	e1 e9       	ldi	r30, 0x91	; 145
    3b78:	f0 e0       	ldi	r31, 0x00	; 0
    3b7a:	80 81       	ld	r24, Z
    3b7c:	82 60       	ori	r24, 0x02	; 2
    3b7e:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    3b80:	80 81       	ld	r24, Z
    3b82:	81 60       	ori	r24, 0x01	; 1
    3b84:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    3b86:	e0 e9       	ldi	r30, 0x90	; 144
    3b88:	f0 e0       	ldi	r31, 0x00	; 0
    3b8a:	80 81       	ld	r24, Z
    3b8c:	81 60       	ori	r24, 0x01	; 1
    3b8e:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    3b90:	e1 ea       	ldi	r30, 0xA1	; 161
    3b92:	f0 e0       	ldi	r31, 0x00	; 0
    3b94:	80 81       	ld	r24, Z
    3b96:	82 60       	ori	r24, 0x02	; 2
    3b98:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    3b9a:	80 81       	ld	r24, Z
    3b9c:	81 60       	ori	r24, 0x01	; 1
    3b9e:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    3ba0:	e0 ea       	ldi	r30, 0xA0	; 160
    3ba2:	f0 e0       	ldi	r31, 0x00	; 0
    3ba4:	80 81       	ld	r24, Z
    3ba6:	81 60       	ori	r24, 0x01	; 1
    3ba8:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    3baa:	e1 e2       	ldi	r30, 0x21	; 33
    3bac:	f1 e0       	ldi	r31, 0x01	; 1
    3bae:	80 81       	ld	r24, Z
    3bb0:	82 60       	ori	r24, 0x02	; 2
    3bb2:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    3bb4:	80 81       	ld	r24, Z
    3bb6:	81 60       	ori	r24, 0x01	; 1
    3bb8:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    3bba:	e0 e2       	ldi	r30, 0x20	; 32
    3bbc:	f1 e0       	ldi	r31, 0x01	; 1
    3bbe:	80 81       	ld	r24, Z
    3bc0:	81 60       	ori	r24, 0x01	; 1
    3bc2:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    3bc4:	ea e7       	ldi	r30, 0x7A	; 122
    3bc6:	f0 e0       	ldi	r31, 0x00	; 0
    3bc8:	80 81       	ld	r24, Z
    3bca:	84 60       	ori	r24, 0x04	; 4
    3bcc:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    3bce:	80 81       	ld	r24, Z
    3bd0:	82 60       	ori	r24, 0x02	; 2
    3bd2:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    3bd4:	80 81       	ld	r24, Z
    3bd6:	81 60       	ori	r24, 0x01	; 1
    3bd8:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    3bda:	80 81       	ld	r24, Z
    3bdc:	80 68       	ori	r24, 0x80	; 128
    3bde:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    3be0:	10 92 c1 00 	sts	0x00C1, r1
    3be4:	08 95       	ret

00003be6 <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
    3be6:	80 93 08 02 	sts	0x0208, r24
    3bea:	08 95       	ret

00003bec <analogRead>:
#if defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#endif
	pin = analogPinToChannel(pin);
#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
    3bec:	86 33       	cpi	r24, 0x36	; 54
    3bee:	08 f0       	brcs	.+2      	; 0x3bf2 <analogRead+0x6>
    3bf0:	86 53       	subi	r24, 0x36	; 54
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
    3bf2:	eb e7       	ldi	r30, 0x7B	; 123
    3bf4:	f0 e0       	ldi	r31, 0x00	; 0
    3bf6:	90 81       	ld	r25, Z
    3bf8:	28 2f       	mov	r18, r24
    3bfa:	28 70       	andi	r18, 0x08	; 8
    3bfc:	97 7f       	andi	r25, 0xF7	; 247
    3bfe:	92 2b       	or	r25, r18
    3c00:	90 83       	st	Z, r25
  
	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
#if defined(ADMUX)
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    3c02:	87 70       	andi	r24, 0x07	; 7
    3c04:	20 91 08 02 	lds	r18, 0x0208
    3c08:	90 e4       	ldi	r25, 0x40	; 64
    3c0a:	29 9f       	mul	r18, r25
    3c0c:	90 01       	movw	r18, r0
    3c0e:	11 24       	eor	r1, r1
    3c10:	28 2b       	or	r18, r24
    3c12:	20 93 7c 00 	sts	0x007C, r18
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    3c16:	ea e7       	ldi	r30, 0x7A	; 122
    3c18:	f0 e0       	ldi	r31, 0x00	; 0
    3c1a:	80 81       	ld	r24, Z
    3c1c:	80 64       	ori	r24, 0x40	; 64
    3c1e:	80 83       	st	Z, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    3c20:	80 81       	ld	r24, Z
    3c22:	86 fd       	sbrc	r24, 6
    3c24:	fd cf       	rjmp	.-6      	; 0x3c20 <analogRead+0x34>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    3c26:	80 91 78 00 	lds	r24, 0x0078
	high = ADCH;
    3c2a:	20 91 79 00 	lds	r18, 0x0079
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    3c2e:	90 e0       	ldi	r25, 0x00	; 0
}
    3c30:	92 2b       	or	r25, r18
    3c32:	08 95       	ret

00003c34 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    3c34:	90 e0       	ldi	r25, 0x00	; 0
    3c36:	fc 01       	movw	r30, r24
    3c38:	31 97       	sbiw	r30, 0x01	; 1
    3c3a:	e2 31       	cpi	r30, 0x12	; 18
    3c3c:	f1 05       	cpc	r31, r1
    3c3e:	08 f0       	brcs	.+2      	; 0x3c42 <turnOffPWM+0xe>
    3c40:	5e c0       	rjmp	.+188    	; 0x3cfe <turnOffPWM+0xca>
    3c42:	ed 56       	subi	r30, 0x6D	; 109
    3c44:	fe 4f       	sbci	r31, 0xFE	; 254
    3c46:	98 c1       	rjmp	.+816    	; 0x3f78 <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    3c48:	e0 e8       	ldi	r30, 0x80	; 128
    3c4a:	f0 e0       	ldi	r31, 0x00	; 0
    3c4c:	80 81       	ld	r24, Z
    3c4e:	8f 77       	andi	r24, 0x7F	; 127
    3c50:	80 83       	st	Z, r24
    3c52:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    3c54:	e0 e8       	ldi	r30, 0x80	; 128
    3c56:	f0 e0       	ldi	r31, 0x00	; 0
    3c58:	80 81       	ld	r24, Z
    3c5a:	8f 7d       	andi	r24, 0xDF	; 223
    3c5c:	80 83       	st	Z, r24
    3c5e:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    3c60:	e0 e8       	ldi	r30, 0x80	; 128
    3c62:	f0 e0       	ldi	r31, 0x00	; 0
    3c64:	80 81       	ld	r24, Z
    3c66:	87 7f       	andi	r24, 0xF7	; 247
    3c68:	80 83       	st	Z, r24
    3c6a:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    3c6c:	84 b5       	in	r24, 0x24	; 36
    3c6e:	8f 77       	andi	r24, 0x7F	; 127
    3c70:	84 bd       	out	0x24, r24	; 36
    3c72:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    3c74:	84 b5       	in	r24, 0x24	; 36
    3c76:	8f 7d       	andi	r24, 0xDF	; 223
    3c78:	84 bd       	out	0x24, r24	; 36
    3c7a:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    3c7c:	e0 eb       	ldi	r30, 0xB0	; 176
    3c7e:	f0 e0       	ldi	r31, 0x00	; 0
    3c80:	80 81       	ld	r24, Z
    3c82:	8f 77       	andi	r24, 0x7F	; 127
    3c84:	80 83       	st	Z, r24
    3c86:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    3c88:	e0 eb       	ldi	r30, 0xB0	; 176
    3c8a:	f0 e0       	ldi	r31, 0x00	; 0
    3c8c:	80 81       	ld	r24, Z
    3c8e:	8f 7d       	andi	r24, 0xDF	; 223
    3c90:	80 83       	st	Z, r24
    3c92:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    3c94:	e0 e9       	ldi	r30, 0x90	; 144
    3c96:	f0 e0       	ldi	r31, 0x00	; 0
    3c98:	80 81       	ld	r24, Z
    3c9a:	8f 77       	andi	r24, 0x7F	; 127
    3c9c:	80 83       	st	Z, r24
    3c9e:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    3ca0:	e0 e9       	ldi	r30, 0x90	; 144
    3ca2:	f0 e0       	ldi	r31, 0x00	; 0
    3ca4:	80 81       	ld	r24, Z
    3ca6:	8f 7d       	andi	r24, 0xDF	; 223
    3ca8:	80 83       	st	Z, r24
    3caa:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    3cac:	e0 e9       	ldi	r30, 0x90	; 144
    3cae:	f0 e0       	ldi	r31, 0x00	; 0
    3cb0:	80 81       	ld	r24, Z
    3cb2:	87 7f       	andi	r24, 0xF7	; 247
    3cb4:	80 83       	st	Z, r24
    3cb6:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    3cb8:	e0 ea       	ldi	r30, 0xA0	; 160
    3cba:	f0 e0       	ldi	r31, 0x00	; 0
    3cbc:	80 81       	ld	r24, Z
    3cbe:	8f 77       	andi	r24, 0x7F	; 127
    3cc0:	80 83       	st	Z, r24
    3cc2:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    3cc4:	e0 ea       	ldi	r30, 0xA0	; 160
    3cc6:	f0 e0       	ldi	r31, 0x00	; 0
    3cc8:	80 81       	ld	r24, Z
    3cca:	8f 7d       	andi	r24, 0xDF	; 223
    3ccc:	80 83       	st	Z, r24
    3cce:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    3cd0:	e0 ea       	ldi	r30, 0xA0	; 160
    3cd2:	f0 e0       	ldi	r31, 0x00	; 0
    3cd4:	80 81       	ld	r24, Z
    3cd6:	87 7f       	andi	r24, 0xF7	; 247
    3cd8:	80 83       	st	Z, r24
    3cda:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    3cdc:	e0 e2       	ldi	r30, 0x20	; 32
    3cde:	f1 e0       	ldi	r31, 0x01	; 1
    3ce0:	80 81       	ld	r24, Z
    3ce2:	8f 77       	andi	r24, 0x7F	; 127
    3ce4:	80 83       	st	Z, r24
    3ce6:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    3ce8:	e0 e2       	ldi	r30, 0x20	; 32
    3cea:	f1 e0       	ldi	r31, 0x01	; 1
    3cec:	80 81       	ld	r24, Z
    3cee:	8f 7d       	andi	r24, 0xDF	; 223
    3cf0:	80 83       	st	Z, r24
    3cf2:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    3cf4:	e0 e2       	ldi	r30, 0x20	; 32
    3cf6:	f1 e0       	ldi	r31, 0x01	; 1
    3cf8:	80 81       	ld	r24, Z
    3cfa:	87 7f       	andi	r24, 0xF7	; 247
    3cfc:	80 83       	st	Z, r24
    3cfe:	08 95       	ret

00003d00 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    3d00:	cf 93       	push	r28
    3d02:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    3d04:	90 e0       	ldi	r25, 0x00	; 0
    3d06:	fc 01       	movw	r30, r24
    3d08:	e0 57       	subi	r30, 0x70	; 112
    3d0a:	fc 4f       	sbci	r31, 0xFC	; 252
    3d0c:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    3d0e:	fc 01       	movw	r30, r24
    3d10:	ea 52       	subi	r30, 0x2A	; 42
    3d12:	fc 4f       	sbci	r31, 0xFC	; 252
    3d14:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    3d16:	88 23       	and	r24, r24
    3d18:	71 f1       	breq	.+92     	; 0x3d76 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
    3d1c:	88 0f       	add	r24, r24
    3d1e:	99 1f       	adc	r25, r25
    3d20:	fc 01       	movw	r30, r24
    3d22:	e0 5b       	subi	r30, 0xB0	; 176
    3d24:	fb 4f       	sbci	r31, 0xFB	; 251
    3d26:	a5 91       	lpm	r26, Z+
    3d28:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    3d2a:	8a 5c       	subi	r24, 0xCA	; 202
    3d2c:	9b 4f       	sbci	r25, 0xFB	; 251
    3d2e:	fc 01       	movw	r30, r24
    3d30:	c5 91       	lpm	r28, Z+
    3d32:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    3d34:	61 11       	cpse	r22, r1
    3d36:	0b c0       	rjmp	.+22     	; 0x3d4e <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    3d38:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3d3a:	f8 94       	cli
		*reg &= ~bit;
    3d3c:	9c 91       	ld	r25, X
    3d3e:	20 95       	com	r18
    3d40:	92 23       	and	r25, r18
    3d42:	9c 93       	st	X, r25
		*out &= ~bit;
    3d44:	e8 81       	ld	r30, Y
    3d46:	2e 23       	and	r18, r30
    3d48:	28 83       	st	Y, r18
		SREG = oldSREG;
    3d4a:	8f bf       	out	0x3f, r24	; 63
    3d4c:	14 c0       	rjmp	.+40     	; 0x3d76 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    3d4e:	62 30       	cpi	r22, 0x02	; 2
    3d50:	61 f4       	brne	.+24     	; 0x3d6a <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    3d52:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3d54:	f8 94       	cli
		*reg &= ~bit;
    3d56:	3c 91       	ld	r19, X
    3d58:	92 2f       	mov	r25, r18
    3d5a:	90 95       	com	r25
    3d5c:	93 23       	and	r25, r19
    3d5e:	9c 93       	st	X, r25
		*out |= bit;
    3d60:	e8 81       	ld	r30, Y
    3d62:	2e 2b       	or	r18, r30
    3d64:	28 83       	st	Y, r18
		SREG = oldSREG;
    3d66:	8f bf       	out	0x3f, r24	; 63
    3d68:	06 c0       	rjmp	.+12     	; 0x3d76 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    3d6a:	8f b7       	in	r24, 0x3f	; 63
                cli();
    3d6c:	f8 94       	cli
		*reg |= bit;
    3d6e:	ec 91       	ld	r30, X
    3d70:	2e 2b       	or	r18, r30
    3d72:	2c 93       	st	X, r18
		SREG = oldSREG;
    3d74:	8f bf       	out	0x3f, r24	; 63
	}
}
    3d76:	df 91       	pop	r29
    3d78:	cf 91       	pop	r28
    3d7a:	08 95       	ret

00003d7c <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    3d7c:	1f 93       	push	r17
    3d7e:	cf 93       	push	r28
    3d80:	df 93       	push	r29
    3d82:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    3d84:	28 2f       	mov	r18, r24
    3d86:	30 e0       	ldi	r19, 0x00	; 0
    3d88:	f9 01       	movw	r30, r18
    3d8a:	e6 5b       	subi	r30, 0xB6	; 182
    3d8c:	fc 4f       	sbci	r31, 0xFC	; 252
    3d8e:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    3d90:	f9 01       	movw	r30, r18
    3d92:	e0 57       	subi	r30, 0x70	; 112
    3d94:	fc 4f       	sbci	r31, 0xFC	; 252
    3d96:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    3d98:	f9 01       	movw	r30, r18
    3d9a:	ea 52       	subi	r30, 0x2A	; 42
    3d9c:	fc 4f       	sbci	r31, 0xFC	; 252
    3d9e:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    3da0:	dd 23       	and	r29, r29
    3da2:	c1 f0       	breq	.+48     	; 0x3dd4 <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    3da4:	81 11       	cpse	r24, r1
    3da6:	46 df       	rcall	.-372    	; 0x3c34 <turnOffPWM>

	out = portOutputRegister(port);
    3da8:	2d 2f       	mov	r18, r29
    3daa:	30 e0       	ldi	r19, 0x00	; 0
    3dac:	f9 01       	movw	r30, r18
    3dae:	ee 0f       	add	r30, r30
    3db0:	ff 1f       	adc	r31, r31
    3db2:	ea 5c       	subi	r30, 0xCA	; 202
    3db4:	fb 4f       	sbci	r31, 0xFB	; 251
    3db6:	a5 91       	lpm	r26, Z+
    3db8:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    3dba:	8f b7       	in	r24, 0x3f	; 63
	cli();
    3dbc:	f8 94       	cli

	if (val == LOW) {
    3dbe:	c1 11       	cpse	r28, r1
    3dc0:	05 c0       	rjmp	.+10     	; 0x3dcc <digitalWrite+0x50>
		*out &= ~bit;
    3dc2:	ec 91       	ld	r30, X
    3dc4:	10 95       	com	r17
    3dc6:	1e 23       	and	r17, r30
    3dc8:	1c 93       	st	X, r17
    3dca:	03 c0       	rjmp	.+6      	; 0x3dd2 <digitalWrite+0x56>
	} else {
		*out |= bit;
    3dcc:	ec 91       	ld	r30, X
    3dce:	1e 2b       	or	r17, r30
    3dd0:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    3dd2:	8f bf       	out	0x3f, r24	; 63
}
    3dd4:	df 91       	pop	r29
    3dd6:	cf 91       	pop	r28
    3dd8:	1f 91       	pop	r17
    3dda:	08 95       	ret

00003ddc <pulseIn>:
 * before the start of the pulse.
 *
 * This function performs better with short pulses in noInterrupt() context
 */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    3ddc:	0f 93       	push	r16
    3dde:	1f 93       	push	r17
    3de0:	76 2f       	mov	r23, r22
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    3de2:	90 e0       	ldi	r25, 0x00	; 0
    3de4:	fc 01       	movw	r30, r24
    3de6:	e0 57       	subi	r30, 0x70	; 112
    3de8:	fc 4f       	sbci	r31, 0xFC	; 252
    3dea:	64 91       	lpm	r22, Z
	uint8_t port = digitalPinToPort(pin);
    3dec:	fc 01       	movw	r30, r24
    3dee:	ea 52       	subi	r30, 0x2A	; 42
    3df0:	fc 4f       	sbci	r31, 0xFC	; 252
    3df2:	e4 91       	lpm	r30, Z
	uint8_t stateMask = (state ? bit : 0);
    3df4:	71 11       	cpse	r23, r1
    3df6:	76 2f       	mov	r23, r22

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3df8:	f0 e0       	ldi	r31, 0x00	; 0
    3dfa:	ee 0f       	add	r30, r30
    3dfc:	ff 1f       	adc	r31, r31
    3dfe:	e4 5e       	subi	r30, 0xE4	; 228
    3e00:	fb 4f       	sbci	r31, 0xFB	; 251
    3e02:	85 91       	lpm	r24, Z+
    3e04:	94 91       	lpm	r25, Z
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);

	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes approximately 16 clock cycles per iteration
	unsigned long maxloops = microsecondsToClockCycles(timeout)/16;
    3e06:	89 01       	movw	r16, r18
    3e08:	9a 01       	movw	r18, r20
    3e0a:	3f 70       	andi	r19, 0x0F	; 15

	unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);
    3e0c:	47 2f       	mov	r20, r23
    3e0e:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <countPulseASM>

	// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
	if (width)
    3e12:	61 15       	cp	r22, r1
    3e14:	71 05       	cpc	r23, r1
    3e16:	81 05       	cpc	r24, r1
    3e18:	91 05       	cpc	r25, r1
    3e1a:	49 f0       	breq	.+18     	; 0x3e2e <pulseIn+0x52>
		return clockCyclesToMicroseconds(width * 16 + 16);
    3e1c:	dc 01       	movw	r26, r24
    3e1e:	cb 01       	movw	r24, r22
    3e20:	01 96       	adiw	r24, 0x01	; 1
    3e22:	a1 1d       	adc	r26, r1
    3e24:	b1 1d       	adc	r27, r1
    3e26:	bc 01       	movw	r22, r24
    3e28:	cd 01       	movw	r24, r26
    3e2a:	9f 70       	andi	r25, 0x0F	; 15
    3e2c:	03 c0       	rjmp	.+6      	; 0x3e34 <pulseIn+0x58>
	else
		return 0;
    3e2e:	60 e0       	ldi	r22, 0x00	; 0
    3e30:	70 e0       	ldi	r23, 0x00	; 0
    3e32:	cb 01       	movw	r24, r22
}
    3e34:	1f 91       	pop	r17
    3e36:	0f 91       	pop	r16
    3e38:	08 95       	ret

00003e3a <_Z3maplllll>:
  long diff = howbig - howsmall;
  return random(diff) + howsmall;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
    3e3a:	4f 92       	push	r4
    3e3c:	5f 92       	push	r5
    3e3e:	6f 92       	push	r6
    3e40:	7f 92       	push	r7
    3e42:	af 92       	push	r10
    3e44:	bf 92       	push	r11
    3e46:	cf 92       	push	r12
    3e48:	df 92       	push	r13
    3e4a:	ef 92       	push	r14
    3e4c:	ff 92       	push	r15
    3e4e:	0f 93       	push	r16
    3e50:	1f 93       	push	r17
    3e52:	cf 93       	push	r28
    3e54:	df 93       	push	r29
    3e56:	cd b7       	in	r28, 0x3d	; 61
    3e58:	de b7       	in	r29, 0x3e	; 62
    3e5a:	29 01       	movw	r4, r18
    3e5c:	3a 01       	movw	r6, r20
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    3e5e:	9b 01       	movw	r18, r22
    3e60:	ac 01       	movw	r20, r24
    3e62:	24 19       	sub	r18, r4
    3e64:	35 09       	sbc	r19, r5
    3e66:	46 09       	sbc	r20, r6
    3e68:	57 09       	sbc	r21, r7
    3e6a:	8a 89       	ldd	r24, Y+18	; 0x12
    3e6c:	9b 89       	ldd	r25, Y+19	; 0x13
    3e6e:	ac 89       	ldd	r26, Y+20	; 0x14
    3e70:	bd 89       	ldd	r27, Y+21	; 0x15
    3e72:	bc 01       	movw	r22, r24
    3e74:	cd 01       	movw	r24, r26
    3e76:	6a 19       	sub	r22, r10
    3e78:	7b 09       	sbc	r23, r11
    3e7a:	8c 09       	sbc	r24, r12
    3e7c:	9d 09       	sbc	r25, r13
    3e7e:	1c d0       	rcall	.+56     	; 0x3eb8 <__mulsi3>
    3e80:	a8 01       	movw	r20, r16
    3e82:	97 01       	movw	r18, r14
    3e84:	24 19       	sub	r18, r4
    3e86:	35 09       	sbc	r19, r5
    3e88:	46 09       	sbc	r20, r6
    3e8a:	57 09       	sbc	r21, r7
    3e8c:	59 d0       	rcall	.+178    	; 0x3f40 <__divmodsi4>
    3e8e:	ca 01       	movw	r24, r20
    3e90:	b9 01       	movw	r22, r18
    3e92:	6a 0d       	add	r22, r10
    3e94:	7b 1d       	adc	r23, r11
    3e96:	8c 1d       	adc	r24, r12
    3e98:	9d 1d       	adc	r25, r13
}
    3e9a:	df 91       	pop	r29
    3e9c:	cf 91       	pop	r28
    3e9e:	1f 91       	pop	r17
    3ea0:	0f 91       	pop	r16
    3ea2:	ff 90       	pop	r15
    3ea4:	ef 90       	pop	r14
    3ea6:	df 90       	pop	r13
    3ea8:	cf 90       	pop	r12
    3eaa:	bf 90       	pop	r11
    3eac:	af 90       	pop	r10
    3eae:	7f 90       	pop	r7
    3eb0:	6f 90       	pop	r6
    3eb2:	5f 90       	pop	r5
    3eb4:	4f 90       	pop	r4
    3eb6:	08 95       	ret

00003eb8 <__mulsi3>:
    3eb8:	db 01       	movw	r26, r22
    3eba:	8f 93       	push	r24
    3ebc:	9f 93       	push	r25
    3ebe:	62 d0       	rcall	.+196    	; 0x3f84 <__muluhisi3>
    3ec0:	bf 91       	pop	r27
    3ec2:	af 91       	pop	r26
    3ec4:	a2 9f       	mul	r26, r18
    3ec6:	80 0d       	add	r24, r0
    3ec8:	91 1d       	adc	r25, r1
    3eca:	a3 9f       	mul	r26, r19
    3ecc:	90 0d       	add	r25, r0
    3ece:	b2 9f       	mul	r27, r18
    3ed0:	90 0d       	add	r25, r0
    3ed2:	11 24       	eor	r1, r1
    3ed4:	08 95       	ret

00003ed6 <__divmodhi4>:
    3ed6:	97 fb       	bst	r25, 7
    3ed8:	07 2e       	mov	r0, r23
    3eda:	16 f4       	brtc	.+4      	; 0x3ee0 <__divmodhi4+0xa>
    3edc:	00 94       	com	r0
    3ede:	06 d0       	rcall	.+12     	; 0x3eec <__divmodhi4_neg1>
    3ee0:	77 fd       	sbrc	r23, 7
    3ee2:	08 d0       	rcall	.+16     	; 0x3ef4 <__divmodhi4_neg2>
    3ee4:	5d d0       	rcall	.+186    	; 0x3fa0 <__udivmodhi4>
    3ee6:	07 fc       	sbrc	r0, 7
    3ee8:	05 d0       	rcall	.+10     	; 0x3ef4 <__divmodhi4_neg2>
    3eea:	3e f4       	brtc	.+14     	; 0x3efa <__divmodhi4_exit>

00003eec <__divmodhi4_neg1>:
    3eec:	90 95       	com	r25
    3eee:	81 95       	neg	r24
    3ef0:	9f 4f       	sbci	r25, 0xFF	; 255
    3ef2:	08 95       	ret

00003ef4 <__divmodhi4_neg2>:
    3ef4:	70 95       	com	r23
    3ef6:	61 95       	neg	r22
    3ef8:	7f 4f       	sbci	r23, 0xFF	; 255

00003efa <__divmodhi4_exit>:
    3efa:	08 95       	ret

00003efc <__udivmodsi4>:
    3efc:	a1 e2       	ldi	r26, 0x21	; 33
    3efe:	1a 2e       	mov	r1, r26
    3f00:	aa 1b       	sub	r26, r26
    3f02:	bb 1b       	sub	r27, r27
    3f04:	fd 01       	movw	r30, r26
    3f06:	0d c0       	rjmp	.+26     	; 0x3f22 <__udivmodsi4_ep>

00003f08 <__udivmodsi4_loop>:
    3f08:	aa 1f       	adc	r26, r26
    3f0a:	bb 1f       	adc	r27, r27
    3f0c:	ee 1f       	adc	r30, r30
    3f0e:	ff 1f       	adc	r31, r31
    3f10:	a2 17       	cp	r26, r18
    3f12:	b3 07       	cpc	r27, r19
    3f14:	e4 07       	cpc	r30, r20
    3f16:	f5 07       	cpc	r31, r21
    3f18:	20 f0       	brcs	.+8      	; 0x3f22 <__udivmodsi4_ep>
    3f1a:	a2 1b       	sub	r26, r18
    3f1c:	b3 0b       	sbc	r27, r19
    3f1e:	e4 0b       	sbc	r30, r20
    3f20:	f5 0b       	sbc	r31, r21

00003f22 <__udivmodsi4_ep>:
    3f22:	66 1f       	adc	r22, r22
    3f24:	77 1f       	adc	r23, r23
    3f26:	88 1f       	adc	r24, r24
    3f28:	99 1f       	adc	r25, r25
    3f2a:	1a 94       	dec	r1
    3f2c:	69 f7       	brne	.-38     	; 0x3f08 <__udivmodsi4_loop>
    3f2e:	60 95       	com	r22
    3f30:	70 95       	com	r23
    3f32:	80 95       	com	r24
    3f34:	90 95       	com	r25
    3f36:	9b 01       	movw	r18, r22
    3f38:	ac 01       	movw	r20, r24
    3f3a:	bd 01       	movw	r22, r26
    3f3c:	cf 01       	movw	r24, r30
    3f3e:	08 95       	ret

00003f40 <__divmodsi4>:
    3f40:	05 2e       	mov	r0, r21
    3f42:	97 fb       	bst	r25, 7
    3f44:	16 f4       	brtc	.+4      	; 0x3f4a <__divmodsi4+0xa>
    3f46:	00 94       	com	r0
    3f48:	0f d0       	rcall	.+30     	; 0x3f68 <__negsi2>
    3f4a:	57 fd       	sbrc	r21, 7
    3f4c:	05 d0       	rcall	.+10     	; 0x3f58 <__divmodsi4_neg2>
    3f4e:	d6 df       	rcall	.-84     	; 0x3efc <__udivmodsi4>
    3f50:	07 fc       	sbrc	r0, 7
    3f52:	02 d0       	rcall	.+4      	; 0x3f58 <__divmodsi4_neg2>
    3f54:	46 f4       	brtc	.+16     	; 0x3f66 <__divmodsi4_exit>
    3f56:	08 c0       	rjmp	.+16     	; 0x3f68 <__negsi2>

00003f58 <__divmodsi4_neg2>:
    3f58:	50 95       	com	r21
    3f5a:	40 95       	com	r20
    3f5c:	30 95       	com	r19
    3f5e:	21 95       	neg	r18
    3f60:	3f 4f       	sbci	r19, 0xFF	; 255
    3f62:	4f 4f       	sbci	r20, 0xFF	; 255
    3f64:	5f 4f       	sbci	r21, 0xFF	; 255

00003f66 <__divmodsi4_exit>:
    3f66:	08 95       	ret

00003f68 <__negsi2>:
    3f68:	90 95       	com	r25
    3f6a:	80 95       	com	r24
    3f6c:	70 95       	com	r23
    3f6e:	61 95       	neg	r22
    3f70:	7f 4f       	sbci	r23, 0xFF	; 255
    3f72:	8f 4f       	sbci	r24, 0xFF	; 255
    3f74:	9f 4f       	sbci	r25, 0xFF	; 255
    3f76:	08 95       	ret

00003f78 <__tablejump2__>:
    3f78:	ee 0f       	add	r30, r30
    3f7a:	ff 1f       	adc	r31, r31

00003f7c <__tablejump__>:
    3f7c:	05 90       	lpm	r0, Z+
    3f7e:	f4 91       	lpm	r31, Z
    3f80:	e0 2d       	mov	r30, r0
    3f82:	19 94       	eijmp

00003f84 <__muluhisi3>:
    3f84:	21 d0       	rcall	.+66     	; 0x3fc8 <__umulhisi3>
    3f86:	a5 9f       	mul	r26, r21
    3f88:	90 0d       	add	r25, r0
    3f8a:	b4 9f       	mul	r27, r20
    3f8c:	90 0d       	add	r25, r0
    3f8e:	a4 9f       	mul	r26, r20
    3f90:	80 0d       	add	r24, r0
    3f92:	91 1d       	adc	r25, r1
    3f94:	11 24       	eor	r1, r1
    3f96:	08 95       	ret

00003f98 <__tablejump_elpm__>:
    3f98:	07 90       	elpm	r0, Z+
    3f9a:	f6 91       	elpm	r31, Z
    3f9c:	e0 2d       	mov	r30, r0
    3f9e:	19 94       	eijmp

00003fa0 <__udivmodhi4>:
    3fa0:	aa 1b       	sub	r26, r26
    3fa2:	bb 1b       	sub	r27, r27
    3fa4:	51 e1       	ldi	r21, 0x11	; 17
    3fa6:	07 c0       	rjmp	.+14     	; 0x3fb6 <__udivmodhi4_ep>

00003fa8 <__udivmodhi4_loop>:
    3fa8:	aa 1f       	adc	r26, r26
    3faa:	bb 1f       	adc	r27, r27
    3fac:	a6 17       	cp	r26, r22
    3fae:	b7 07       	cpc	r27, r23
    3fb0:	10 f0       	brcs	.+4      	; 0x3fb6 <__udivmodhi4_ep>
    3fb2:	a6 1b       	sub	r26, r22
    3fb4:	b7 0b       	sbc	r27, r23

00003fb6 <__udivmodhi4_ep>:
    3fb6:	88 1f       	adc	r24, r24
    3fb8:	99 1f       	adc	r25, r25
    3fba:	5a 95       	dec	r21
    3fbc:	a9 f7       	brne	.-22     	; 0x3fa8 <__udivmodhi4_loop>
    3fbe:	80 95       	com	r24
    3fc0:	90 95       	com	r25
    3fc2:	bc 01       	movw	r22, r24
    3fc4:	cd 01       	movw	r24, r26
    3fc6:	08 95       	ret

00003fc8 <__umulhisi3>:
    3fc8:	a2 9f       	mul	r26, r18
    3fca:	b0 01       	movw	r22, r0
    3fcc:	b3 9f       	mul	r27, r19
    3fce:	c0 01       	movw	r24, r0
    3fd0:	a3 9f       	mul	r26, r19
    3fd2:	70 0d       	add	r23, r0
    3fd4:	81 1d       	adc	r24, r1
    3fd6:	11 24       	eor	r1, r1
    3fd8:	91 1d       	adc	r25, r1
    3fda:	b2 9f       	mul	r27, r18
    3fdc:	70 0d       	add	r23, r0
    3fde:	81 1d       	adc	r24, r1
    3fe0:	11 24       	eor	r1, r1
    3fe2:	91 1d       	adc	r25, r1
    3fe4:	08 95       	ret

00003fe6 <_exit>:
    3fe6:	f8 94       	cli

00003fe8 <__stop_program>:
    3fe8:	ff cf       	rjmp	.-2      	; 0x3fe8 <__stop_program>
